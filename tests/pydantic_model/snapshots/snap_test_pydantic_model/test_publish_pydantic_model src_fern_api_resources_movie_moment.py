# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import datetime as dt
import typing
import uuid

import pydantic
import typing_extensions

from ...core.datetime_utils import serialize_datetime


class Moment(pydantic.BaseModel):
    """
    import datetime
    import uuid

    from fern.api import Moment

    Moment(
        id=uuid.UUID("656f12d6-f592-444c-a1d3-a3cfd46d5b39"),
        date=datetime.date.fromisoformat("1994-01-01"),
        datetime=datetime.datetime.fromisoformat("1994-01-01 01:01:01"),
    )
    """

    id: uuid.UUID
    date: dt.date
    datetime: dt.datetime

    class Partial(typing_extensions.TypedDict):
        id: typing_extensions.NotRequired[uuid.UUID]
        date: typing_extensions.NotRequired[dt.date]
        datetime: typing_extensions.NotRequired[dt.datetime]

    class Validators:
        """
        Use this class to add validators to the Pydantic model.

            @Moment.Validators.root()
            def validate(values: Moment.Partial) -> Moment.Partial:
                ...

            @Moment.Validators.field("id")
            def validate_id(id: uuid.UUID, values: Moment.Partial) -> uuid.UUID:
                ...

            @Moment.Validators.field("date")
            def validate_date(date: dt.date, values: Moment.Partial) -> dt.date:
                ...

            @Moment.Validators.field("datetime")
            def validate_datetime(datetime: dt.datetime, values: Moment.Partial) -> dt.datetime:
                ...
        """

        _pre_validators: typing.ClassVar[typing.List[Moment.Validators._PreRootValidator]] = []
        _post_validators: typing.ClassVar[typing.List[Moment.Validators._RootValidator]] = []
        _id_pre_validators: typing.ClassVar[typing.List[Moment.Validators.PreIdValidator]] = []
        _id_post_validators: typing.ClassVar[typing.List[Moment.Validators.IdValidator]] = []
        _date_pre_validators: typing.ClassVar[typing.List[Moment.Validators.PreDateValidator]] = []
        _date_post_validators: typing.ClassVar[typing.List[Moment.Validators.DateValidator]] = []
        _datetime_pre_validators: typing.ClassVar[typing.List[Moment.Validators.PreDatetimeValidator]] = []
        _datetime_post_validators: typing.ClassVar[typing.List[Moment.Validators.DatetimeValidator]] = []

        @typing.overload
        @classmethod
        def root(
            cls, *, pre: typing_extensions.Literal[False] = False
        ) -> typing.Callable[[Moment.Validators._RootValidator], Moment.Validators._RootValidator]:
            ...

        @typing.overload
        @classmethod
        def root(
            cls, *, pre: typing_extensions.Literal[True]
        ) -> typing.Callable[[Moment.Validators._PreRootValidator], Moment.Validators._PreRootValidator]:
            ...

        @classmethod
        def root(cls, *, pre: bool = False) -> typing.Any:
            def decorator(validator: typing.Any) -> typing.Any:
                if pre:
                    cls._pre_validators.append(validator)
                else:
                    cls._post_validators.append(validator)
                return validator

            return decorator

        @typing.overload
        @classmethod
        def field(
            cls, field_name: typing_extensions.Literal["id"], *, pre: typing_extensions.Literal[True]
        ) -> typing.Callable[[Moment.Validators.PreIdValidator], Moment.Validators.PreIdValidator]:
            ...

        @typing.overload
        @classmethod
        def field(
            cls, field_name: typing_extensions.Literal["id"], *, pre: typing_extensions.Literal[False] = False
        ) -> typing.Callable[[Moment.Validators.IdValidator], Moment.Validators.IdValidator]:
            ...

        @typing.overload
        @classmethod
        def field(
            cls, field_name: typing_extensions.Literal["date"], *, pre: typing_extensions.Literal[True]
        ) -> typing.Callable[[Moment.Validators.PreDateValidator], Moment.Validators.PreDateValidator]:
            ...

        @typing.overload
        @classmethod
        def field(
            cls, field_name: typing_extensions.Literal["date"], *, pre: typing_extensions.Literal[False] = False
        ) -> typing.Callable[[Moment.Validators.DateValidator], Moment.Validators.DateValidator]:
            ...

        @typing.overload
        @classmethod
        def field(
            cls, field_name: typing_extensions.Literal["datetime"], *, pre: typing_extensions.Literal[True]
        ) -> typing.Callable[[Moment.Validators.PreDatetimeValidator], Moment.Validators.PreDatetimeValidator]:
            ...

        @typing.overload
        @classmethod
        def field(
            cls, field_name: typing_extensions.Literal["datetime"], *, pre: typing_extensions.Literal[False] = False
        ) -> typing.Callable[[Moment.Validators.DatetimeValidator], Moment.Validators.DatetimeValidator]:
            ...

        @classmethod
        def field(cls, field_name: str, *, pre: bool = False) -> typing.Any:
            def decorator(validator: typing.Any) -> typing.Any:
                if field_name == "id":
                    if pre:
                        cls._id_pre_validators.append(validator)
                    else:
                        cls._id_post_validators.append(validator)
                if field_name == "date":
                    if pre:
                        cls._date_pre_validators.append(validator)
                    else:
                        cls._date_post_validators.append(validator)
                if field_name == "datetime":
                    if pre:
                        cls._datetime_pre_validators.append(validator)
                    else:
                        cls._datetime_post_validators.append(validator)
                return validator

            return decorator

        class PreIdValidator(typing_extensions.Protocol):
            def __call__(self, __v: typing.Any, __values: Moment.Partial) -> typing.Any:
                ...

        class IdValidator(typing_extensions.Protocol):
            def __call__(self, __v: uuid.UUID, __values: Moment.Partial) -> uuid.UUID:
                ...

        class PreDateValidator(typing_extensions.Protocol):
            def __call__(self, __v: typing.Any, __values: Moment.Partial) -> typing.Any:
                ...

        class DateValidator(typing_extensions.Protocol):
            def __call__(self, __v: dt.date, __values: Moment.Partial) -> dt.date:
                ...

        class PreDatetimeValidator(typing_extensions.Protocol):
            def __call__(self, __v: typing.Any, __values: Moment.Partial) -> typing.Any:
                ...

        class DatetimeValidator(typing_extensions.Protocol):
            def __call__(self, __v: dt.datetime, __values: Moment.Partial) -> dt.datetime:
                ...

        class _PreRootValidator(typing_extensions.Protocol):
            def __call__(self, __values: typing.Any) -> typing.Any:
                ...

        class _RootValidator(typing_extensions.Protocol):
            def __call__(self, __values: Moment.Partial) -> Moment.Partial:
                ...

    @pydantic.root_validator(pre=True)
    def _pre_validate_moment(cls, values: Moment.Partial) -> Moment.Partial:
        for validator in Moment.Validators._pre_validators:
            values = validator(values)
        return values

    @pydantic.root_validator(pre=False)
    def _post_validate_moment(cls, values: Moment.Partial) -> Moment.Partial:
        for validator in Moment.Validators._post_validators:
            values = validator(values)
        return values

    @pydantic.validator("id", pre=True)
    def _pre_validate_id(cls, v: uuid.UUID, values: Moment.Partial) -> uuid.UUID:
        for validator in Moment.Validators._id_pre_validators:
            v = validator(v, values)
        return v

    @pydantic.validator("id", pre=False)
    def _post_validate_id(cls, v: uuid.UUID, values: Moment.Partial) -> uuid.UUID:
        for validator in Moment.Validators._id_post_validators:
            v = validator(v, values)
        return v

    @pydantic.validator("date", pre=True)
    def _pre_validate_date(cls, v: dt.date, values: Moment.Partial) -> dt.date:
        for validator in Moment.Validators._date_pre_validators:
            v = validator(v, values)
        return v

    @pydantic.validator("date", pre=False)
    def _post_validate_date(cls, v: dt.date, values: Moment.Partial) -> dt.date:
        for validator in Moment.Validators._date_post_validators:
            v = validator(v, values)
        return v

    @pydantic.validator("datetime", pre=True)
    def _pre_validate_datetime(cls, v: dt.datetime, values: Moment.Partial) -> dt.datetime:
        for validator in Moment.Validators._datetime_pre_validators:
            v = validator(v, values)
        return v

    @pydantic.validator("datetime", pre=False)
    def _post_validate_datetime(cls, v: dt.datetime, values: Moment.Partial) -> dt.datetime:
        for validator in Moment.Validators._datetime_post_validators:
            v = validator(v, values)
        return v

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().dict(**kwargs_with_defaults)

    class Config:
        json_encoders = {dt.datetime: serialize_datetime}
