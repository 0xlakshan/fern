import { AbsoluteFilePath } from "@fern-api/fs-utils";
import { IntermediateRepresentation } from "@fern-fern/ir-model/ir";
import {
    convertExportedFilePathToFilePath,
    CoreUtilitiesManager,
    DependencyManager,
    ExportedDirectory,
    ExportedFilePath,
    ExportsManager,
    ImportsManager,
    writeProjectToVolume,
} from "@fern-typescript/commons";
import { GeneratorContext } from "@fern-typescript/contexts";
import { ExpressEndpointTypeSchemasGenerator } from "@fern-typescript/express-endpoint-type-schemas-generator";
import { ExpressInlinedRequestBodyGenerator } from "@fern-typescript/express-inlined-request-body-generator";
import { ExpressInlinedRequestBodySchemaGenerator } from "@fern-typescript/express-inlined-request-schema-generator";
import { ExpressRegisterGenerator } from "@fern-typescript/express-register-generator";
import { ExpressServiceGenerator } from "@fern-typescript/express-service-generator";
import { ServiceResolver, TypeResolver } from "@fern-typescript/resolvers";
import { TypeGenerator } from "@fern-typescript/type-generator";
import { TypeReferenceExampleGenerator } from "@fern-typescript/type-reference-example-generator";
import { TypeSchemaGenerator } from "@fern-typescript/type-schema-generator";
import { Volume } from "memfs/lib/volume";
import { Directory, Project, SourceFile } from "ts-morph";
import { ExpressEndpointTypeSchemasContextImpl } from "./contexts/express-endpoint-type-schemas/ExpressEndpointTypeSchemasContextImpl";
import { ExpressInlinedRequestBodySchemaContextImpl } from "./contexts/express-inlined-request-body-schema/ExpressInlinedRequestBodySchemaContextImpl";
import { ExpressInlinedRequestBodyContextImpl } from "./contexts/express-inlined-request-body/ExpressInlinedRequestBodyContextImpl";
import { ExpressRegisterContextImpl } from "./contexts/express-register/ExpressRegisterContextImpl";
import { ExpressServiceContextImpl } from "./contexts/express-service/ExpressServiceContextImpl";
import { TypeSchemaContextImpl } from "./contexts/type-schema/TypeSchemaContextImpl";
import { TypeContextImpl } from "./contexts/type/TypeContextImpl";
import { EndpointDeclarationReferencer } from "./declaration-referencers/EndpointDeclarationReferencer";
import { ExpressInlinedRequestBodyDeclarationReferencer } from "./declaration-referencers/ExpressInlinedRequestBodyDeclarationReferencer";
import { ExpressRegisterDeclarationReferencer } from "./declaration-referencers/ExpressRegisterDeclarationReferencer";
import { ExpressServiceDeclarationReferencer } from "./declaration-referencers/ExpressServiceDeclarationReferencer";
import { TypeDeclarationReferencer } from "./declaration-referencers/TypeDeclarationReferencer";

const FILE_HEADER = `/**
 * This file was auto-generated by Fern from our API Definition.
 */
`;

export declare namespace ExpressGenerator {
    export interface Init {
        namespaceExport: string;
        intermediateRepresentation: IntermediateRepresentation;
        context: GeneratorContext;
        volume: Volume;
        config: Config;
    }

    export interface Config {
        shouldUseBrandedStringAliases: boolean;
    }
}

export class ExpressGenerator {
    private context: GeneratorContext;
    private intermediateRepresentation: IntermediateRepresentation;

    private rootDirectory: Directory;
    private exportsManager: ExportsManager;
    private dependencyManager = new DependencyManager();
    private coreUtilitiesManager: CoreUtilitiesManager;
    private typeResolver: TypeResolver;
    private serviceResolver: ServiceResolver;

    private typeDeclarationReferencer: TypeDeclarationReferencer;
    private typeSchemaDeclarationReferencer: TypeDeclarationReferencer;
    private expressInlinedRequestBodyDeclarationReferencer: ExpressInlinedRequestBodyDeclarationReferencer;
    private expressInlinedRequestBodySchemaDeclarationReferencer: ExpressInlinedRequestBodyDeclarationReferencer;
    private expressEndpointSchemaDeclarationReferencer: EndpointDeclarationReferencer;
    private expressServiceDeclarationReferencer: ExpressServiceDeclarationReferencer;
    private expressRegisterDeclarationReferencer: ExpressRegisterDeclarationReferencer;

    private typeGenerator: TypeGenerator;
    private typeSchemaGenerator: TypeSchemaGenerator;
    private typeReferenceExampleGenerator: TypeReferenceExampleGenerator;
    private expressInlinedRequestBodyGenerator: ExpressInlinedRequestBodyGenerator;
    private expressInlinedRequestBodySchemaGenerator: ExpressInlinedRequestBodySchemaGenerator;
    private expressEndpointTypeSchemasGenerator: ExpressEndpointTypeSchemasGenerator;
    private expressServiceGenerator: ExpressServiceGenerator;
    private expressRegisterGenerator: ExpressRegisterGenerator;

    private generatePackage: () => Promise<void>;

    constructor({ namespaceExport, intermediateRepresentation, context, volume, config }: ExpressGenerator.Init) {
        this.context = context;
        this.intermediateRepresentation = intermediateRepresentation;

        this.exportsManager = new ExportsManager({ aliasOfRoot: undefined });
        this.coreUtilitiesManager = new CoreUtilitiesManager({ aliasOfRoot: undefined });

        const project = new Project({
            useInMemoryFileSystem: true,
        });
        this.rootDirectory = project.createDirectory("/");
        this.typeResolver = new TypeResolver(intermediateRepresentation);
        this.serviceResolver = new ServiceResolver(intermediateRepresentation);

        const apiDirectory: ExportedDirectory[] = [
            {
                nameOnDisk: "api",
                exportDeclaration: { namespaceExport },
            },
        ];

        const schemaDirectory: ExportedDirectory[] = [
            {
                nameOnDisk: "serialization",
            },
        ];

        this.typeDeclarationReferencer = new TypeDeclarationReferencer({
            containingDirectory: apiDirectory,
            namespaceExport,
        });
        this.typeSchemaDeclarationReferencer = new TypeDeclarationReferencer({
            containingDirectory: schemaDirectory,
            namespaceExport,
        });
        this.expressInlinedRequestBodyDeclarationReferencer = new ExpressInlinedRequestBodyDeclarationReferencer({
            containingDirectory: apiDirectory,
            namespaceExport,
        });
        this.expressInlinedRequestBodySchemaDeclarationReferencer = new ExpressInlinedRequestBodyDeclarationReferencer({
            containingDirectory: schemaDirectory,
            namespaceExport,
        });
        this.expressEndpointSchemaDeclarationReferencer = new EndpointDeclarationReferencer({
            containingDirectory: schemaDirectory,
            namespaceExport,
        });
        this.expressServiceDeclarationReferencer = new ExpressServiceDeclarationReferencer({
            containingDirectory: apiDirectory,
            namespaceExport,
        });
        this.expressRegisterDeclarationReferencer = new ExpressRegisterDeclarationReferencer({
            containingDirectory: [],
            namespaceExport,
        });

        this.typeGenerator = new TypeGenerator({ useBrandedStringAliases: config.shouldUseBrandedStringAliases });
        this.typeSchemaGenerator = new TypeSchemaGenerator();
        this.typeReferenceExampleGenerator = new TypeReferenceExampleGenerator();
        this.expressInlinedRequestBodyGenerator = new ExpressInlinedRequestBodyGenerator();
        this.expressInlinedRequestBodySchemaGenerator = new ExpressInlinedRequestBodySchemaGenerator();
        this.expressEndpointTypeSchemasGenerator = new ExpressEndpointTypeSchemasGenerator();
        this.expressServiceGenerator = new ExpressServiceGenerator();
        this.expressRegisterGenerator = new ExpressRegisterGenerator({
            intermediateRepresentation: this.intermediateRepresentation,
            registerFunctionName: this.expressRegisterDeclarationReferencer.getRegisterFunctionName(),
        });

        this.generatePackage = async () => {
            await writeProjectToVolume(project, volume, "/");
        };
    }

    public async generate(): Promise<void> {
        this.generateTypeDeclarations();
        this.generateTypeSchemas();
        this.generateInlinedRequestBodies();
        this.generateInlinedRequestBodySchemas();
        this.generateEndpointTypeSchemas();
        this.generateExpressServices();
        this.generateExpressRegister();

        this.coreUtilitiesManager.finalize(this.exportsManager, this.dependencyManager);
        this.exportsManager.writeExportsToProject(this.rootDirectory);
        await this.generatePackage();
    }

    public async copyCoreUtilities({ pathToSrc }: { pathToSrc: AbsoluteFilePath }): Promise<void> {
        await this.coreUtilitiesManager.copyCoreUtilities({ pathToSrc });
    }

    private generateTypeDeclarations() {
        for (const typeDeclaration of this.intermediateRepresentation.types) {
            this.withSourceFile({
                filepath: this.typeDeclarationReferencer.getExportedFilepath(typeDeclaration.name),
                run: ({ sourceFile, importsManager }) => {
                    const typeContext = new TypeContextImpl({
                        sourceFile,
                        coreUtilitiesManager: this.coreUtilitiesManager,
                        dependencyManager: this.dependencyManager,
                        fernConstants: this.intermediateRepresentation.constants,
                        importsManager,
                        typeResolver: this.typeResolver,
                        typeDeclarationReferencer: this.typeDeclarationReferencer,
                        typeGenerator: this.typeGenerator,
                        typeReferenceExampleGenerator: this.typeReferenceExampleGenerator,
                    });
                    typeContext.type.getGeneratedType(typeDeclaration.name).writeToFile(typeContext);
                },
            });
        }
    }

    private generateTypeSchemas() {
        for (const typeDeclaration of this.intermediateRepresentation.types) {
            this.withSourceFile({
                filepath: this.typeSchemaDeclarationReferencer.getExportedFilepath(typeDeclaration.name),
                run: ({ sourceFile, importsManager }) => {
                    const typeSchemaContext = new TypeSchemaContextImpl({
                        sourceFile,
                        coreUtilitiesManager: this.coreUtilitiesManager,
                        dependencyManager: this.dependencyManager,
                        fernConstants: this.intermediateRepresentation.constants,
                        importsManager,
                        typeResolver: this.typeResolver,
                        typeDeclarationReferencer: this.typeDeclarationReferencer,
                        typeSchemaDeclarationReferencer: this.typeSchemaDeclarationReferencer,
                        typeGenerator: this.typeGenerator,
                        typeSchemaGenerator: this.typeSchemaGenerator,
                        typeReferenceExampleGenerator: this.typeReferenceExampleGenerator,
                    });
                    typeSchemaContext.typeSchema
                        .getGeneratedTypeSchema(typeDeclaration.name)
                        .writeToFile(typeSchemaContext);
                },
            });
        }
    }

    private generateInlinedRequestBodies() {
        for (const service of this.intermediateRepresentation.services) {
            for (const endpoint of service.endpoints) {
                if (endpoint.requestBody?.type === "inlinedRequestBody") {
                    this.withSourceFile({
                        filepath: this.expressInlinedRequestBodyDeclarationReferencer.getExportedFilepath({
                            service: service.name.fernFilepath,
                            endpoint,
                        }),
                        run: ({ sourceFile, importsManager }) => {
                            const context = new ExpressInlinedRequestBodyContextImpl({
                                sourceFile,
                                coreUtilitiesManager: this.coreUtilitiesManager,
                                dependencyManager: this.dependencyManager,
                                fernConstants: this.intermediateRepresentation.constants,
                                importsManager,
                                typeResolver: this.typeResolver,
                                typeDeclarationReferencer: this.typeDeclarationReferencer,
                                typeReferenceExampleGenerator: this.typeReferenceExampleGenerator,
                                typeGenerator: this.typeGenerator,
                                expressInlinedRequestBodyDeclarationReferencer:
                                    this.expressInlinedRequestBodyDeclarationReferencer,
                                expressInlinedRequestBodyGenerator: this.expressInlinedRequestBodyGenerator,
                                serviceResolver: this.serviceResolver,
                            });
                            context.expressInlinedRequestBody
                                .getGeneratedInlinedRequestBody(service.name.fernFilepath, endpoint.name)
                                .writeToFile(context);
                        },
                    });
                }
            }
        }
    }

    private generateInlinedRequestBodySchemas() {
        for (const service of this.intermediateRepresentation.services) {
            for (const endpoint of service.endpoints) {
                if (endpoint.requestBody?.type === "inlinedRequestBody") {
                    this.withSourceFile({
                        filepath: this.expressInlinedRequestBodySchemaDeclarationReferencer.getExportedFilepath({
                            service: service.name.fernFilepath,
                            endpoint,
                        }),
                        run: ({ sourceFile, importsManager }) => {
                            const context = new ExpressInlinedRequestBodySchemaContextImpl({
                                sourceFile,
                                coreUtilitiesManager: this.coreUtilitiesManager,
                                dependencyManager: this.dependencyManager,
                                fernConstants: this.intermediateRepresentation.constants,
                                importsManager,
                                typeResolver: this.typeResolver,
                                typeDeclarationReferencer: this.typeDeclarationReferencer,
                                typeReferenceExampleGenerator: this.typeReferenceExampleGenerator,
                                typeGenerator: this.typeGenerator,
                                serviceResolver: this.serviceResolver,
                                expressInlinedRequestBodyDeclarationReferencer:
                                    this.expressInlinedRequestBodyDeclarationReferencer,
                                expressInlinedRequestBodyGenerator: this.expressInlinedRequestBodyGenerator,
                                expressInlinedRequestBodySchemaGenerator: this.expressInlinedRequestBodySchemaGenerator,
                                expressInlinedRequestBodySchemaDeclarationReferencer:
                                    this.expressInlinedRequestBodySchemaDeclarationReferencer,
                                typeSchemaGenerator: this.typeSchemaGenerator,
                                typeSchemaDeclarationReferencer: this.typeSchemaDeclarationReferencer,
                            });
                            context.expressInlinedRequestBodySchema
                                .getGeneratedInlinedRequestBodySchema(service.name.fernFilepath, endpoint.name)
                                .writeToFile(context);
                        },
                    });
                }
            }
        }
    }

    private generateEndpointTypeSchemas() {
        for (const service of this.intermediateRepresentation.services) {
            for (const endpoint of service.endpoints) {
                this.withSourceFile({
                    filepath: this.expressEndpointSchemaDeclarationReferencer.getExportedFilepath({
                        service: service.name.fernFilepath,
                        endpoint,
                    }),
                    run: ({ sourceFile, importsManager }) => {
                        const endpointTypeSchemasContext = new ExpressEndpointTypeSchemasContextImpl({
                            sourceFile,
                            coreUtilitiesManager: this.coreUtilitiesManager,
                            dependencyManager: this.dependencyManager,
                            fernConstants: this.intermediateRepresentation.constants,
                            importsManager,
                            typeResolver: this.typeResolver,
                            typeDeclarationReferencer: this.typeDeclarationReferencer,
                            typeSchemaDeclarationReferencer: this.typeSchemaDeclarationReferencer,
                            typeReferenceExampleGenerator: this.typeReferenceExampleGenerator,
                            expressEndpointSchemaDeclarationReferencer: this.expressEndpointSchemaDeclarationReferencer,
                            typeGenerator: this.typeGenerator,
                            serviceResolver: this.serviceResolver,
                            expressEndpointTypeSchemasGenerator: this.expressEndpointTypeSchemasGenerator,
                            typeSchemaGenerator: this.typeSchemaGenerator,
                        });
                        endpointTypeSchemasContext.expressEndpointTypeSchemas
                            .getGeneratedEndpointTypeSchemas(service.name.fernFilepath, endpoint.name)
                            .writeToFile(endpointTypeSchemasContext);
                    },
                });
            }
        }
    }

    private generateExpressServices() {
        for (const service of this.intermediateRepresentation.services) {
            this.withSourceFile({
                filepath: this.expressServiceDeclarationReferencer.getExportedFilepath(service.name),
                run: ({ sourceFile, importsManager }) => {
                    const expressServiceContext = new ExpressServiceContextImpl({
                        sourceFile,
                        coreUtilitiesManager: this.coreUtilitiesManager,
                        dependencyManager: this.dependencyManager,
                        fernConstants: this.intermediateRepresentation.constants,
                        importsManager,
                        typeResolver: this.typeResolver,
                        typeDeclarationReferencer: this.typeDeclarationReferencer,
                        typeSchemaDeclarationReferencer: this.typeSchemaDeclarationReferencer,
                        typeReferenceExampleGenerator: this.typeReferenceExampleGenerator,
                        expressEndpointSchemaDeclarationReferencer: this.expressEndpointSchemaDeclarationReferencer,
                        typeGenerator: this.typeGenerator,
                        serviceResolver: this.serviceResolver,
                        expressEndpointTypeSchemasGenerator: this.expressEndpointTypeSchemasGenerator,
                        typeSchemaGenerator: this.typeSchemaGenerator,
                        expressInlinedRequestBodyDeclarationReferencer:
                            this.expressInlinedRequestBodyDeclarationReferencer,
                        expressInlinedRequestBodyGenerator: this.expressInlinedRequestBodyGenerator,
                        expressInlinedRequestBodySchemaDeclarationReferencer:
                            this.expressInlinedRequestBodySchemaDeclarationReferencer,
                        expressInlinedRequestBodySchemaGenerator: this.expressInlinedRequestBodySchemaGenerator,
                        expressServiceDeclarationReferencer: this.expressServiceDeclarationReferencer,
                        expressServiceGenerator: this.expressServiceGenerator,
                    });
                    expressServiceContext.expressService
                        .getGeneratedExpressService(service.name.fernFilepath)
                        .writeToFile(expressServiceContext);
                },
            });
        }
    }

    private generateExpressRegister() {
        this.withSourceFile({
            filepath: this.expressRegisterDeclarationReferencer.getExportedFilepath(),
            run: ({ sourceFile, importsManager }) => {
                const expressRegisterContext = new ExpressRegisterContextImpl({
                    sourceFile,
                    coreUtilitiesManager: this.coreUtilitiesManager,
                    dependencyManager: this.dependencyManager,
                    fernConstants: this.intermediateRepresentation.constants,
                    importsManager,
                    typeResolver: this.typeResolver,
                    typeDeclarationReferencer: this.typeDeclarationReferencer,
                    typeSchemaDeclarationReferencer: this.typeSchemaDeclarationReferencer,
                    typeReferenceExampleGenerator: this.typeReferenceExampleGenerator,
                    expressEndpointSchemaDeclarationReferencer: this.expressEndpointSchemaDeclarationReferencer,
                    typeGenerator: this.typeGenerator,
                    serviceResolver: this.serviceResolver,
                    expressEndpointTypeSchemasGenerator: this.expressEndpointTypeSchemasGenerator,
                    typeSchemaGenerator: this.typeSchemaGenerator,
                    expressInlinedRequestBodyDeclarationReferencer: this.expressInlinedRequestBodyDeclarationReferencer,
                    expressInlinedRequestBodyGenerator: this.expressInlinedRequestBodyGenerator,
                    expressInlinedRequestBodySchemaDeclarationReferencer:
                        this.expressInlinedRequestBodySchemaDeclarationReferencer,
                    expressInlinedRequestBodySchemaGenerator: this.expressInlinedRequestBodySchemaGenerator,
                    expressServiceDeclarationReferencer: this.expressServiceDeclarationReferencer,
                    expressServiceGenerator: this.expressServiceGenerator,
                    expressRegisterGenerator: this.expressRegisterGenerator,
                });
                expressRegisterContext.expressRegister
                    .getGeneratedExpressRegister()
                    .writeToFile(expressRegisterContext);
            },
        });
    }

    private withSourceFile({
        run,
        filepath,
    }: {
        run: (args: { sourceFile: SourceFile; importsManager: ImportsManager }) => void;
        filepath: ExportedFilePath;
    }) {
        const filepathStr = convertExportedFilePathToFilePath(filepath);
        this.context.logger.debug(`Generating ${filepathStr}`);

        const sourceFile = this.rootDirectory.createSourceFile(filepathStr);
        const importsManager = new ImportsManager();

        run({ sourceFile, importsManager });

        if (sourceFile.getStatements().length === 0) {
            sourceFile.delete();
            this.context.logger.debug(`Skipping ${filepathStr} (no content)`);
        } else {
            importsManager.writeImportsToSourceFile(sourceFile);
            this.exportsManager.addExportsForFilepath(filepath);

            // this needs to be last.
            // https://github.com/dsherret/ts-morph/issues/189#issuecomment-414174283
            sourceFile.insertText(0, (writer) => {
                writer.writeLine(FILE_HEADER);
            });

            this.context.logger.debug(`Generated ${filepathStr}`);
        }
    }
}
