// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`runGenerator mercoa 1`] = `
Array [
  Object {
    "contents": Array [
      Object {
        "contents": "export * from \\"./resources\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface Address {
    addressLine1: string;
    addressLine2?: string;
    city: string;
    stateOrProvince: string;
    postalCode: string;
    country?: string;
}
",
                    "name": "Address.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface BirthDate {
    day?: number;
    month?: number;
    year?: number;
}
",
                    "name": "BirthDate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface FullName {
    firstName: string;
    middleName?: string;
    lastName: string;
    suffix?: string;
}
",
                    "name": "FullName.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface PhoneNumber {
    countryCode: string;
    number: string;
}
",
                    "name": "PhoneNumber.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./FullName\\";
export * from \\"./BirthDate\\";
export * from \\"./Address\\";
export * from \\"./PhoneNumber\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "commons",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./service\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import express from \\"express\\";
import * as serializers from \\"../../../../serialization\\";
import { MercoaApi } from \\"../../../..\\";

export abstract class AbstractCounterpartyService {
    private router = express.Router().use(express.json());

    public abstract find(request: express.Request<{
        entityId: serializers.EntityId.Raw;
    }, MercoaApi.Entity[], never, {
        \\"query\\": string;
        \\"paymentMethods\\"?: boolean | null;
    }, never>): Promise<MercoaApi.Entity[]>;

    public addMiddleware(handler: express.RequestHandler): this {
        this.router.use(handler);
        return this;
    }

    public toRouter(): express.Router {
        this.router.get(\\"\\", async (req, res, next) => {
            try {
                const response = await this.find(req as any);
                res.send(await serializers.counterparty.find.Response.json(response));
            }
            catch (error) {
                console.error(error);
                res.status(500).send(\\"Internal Server Error\\");
            }
            next();
        });
        return this.router;
    }
}
",
                    "name": "AbstractCounterpartyService.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { AbstractCounterpartyService } from \\"./AbstractCounterpartyService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "service",
                "type": "directory",
              },
            ],
            "name": "counterparty",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./service\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import express from \\"express\\";
import { MercoaApi } from \\"../../../..\\";
import * as serializers from \\"../../../../serialization\\";

export abstract class AbstractEntityService {
    private router = express.Router().use(express.json());

    public abstract getAll(request: express.Request<never, MercoaApi.Entity[], never, never, never>): Promise<MercoaApi.Entity[]>;

    public abstract create(request: express.Request<never, MercoaApi.Entity, MercoaApi.Entity, never, never>): Promise<MercoaApi.Entity>;

    public abstract get(request: express.Request<{
        entityId: serializers.EntityId.Raw;
    }, MercoaApi.Entity, never, never, never>): Promise<MercoaApi.Entity>;

    public abstract update(request: express.Request<{
        entityId: serializers.EntityId.Raw;
    }, MercoaApi.Entity, MercoaApi.Entity, never, never>): Promise<MercoaApi.Entity>;

    public abstract delete(request: express.Request<{
        entityId: serializers.EntityId.Raw;
    }, never, never, never, never>): Promise<void>;

    public abstract acceptTermsOfService(request: express.Request<{
        entityId: serializers.EntityId.Raw;
    }, never, never, never, never>): Promise<void>;

    public addMiddleware(handler: express.RequestHandler): this {
        this.router.use(handler);
        return this;
    }

    public toRouter(): express.Router {
        this.router.get(\\"/entities\\", async (req, res, next) => {
            try {
                const response = await this.getAll(req as any);
                res.send(await serializers.entity.getAll.Response.json(response));
            }
            catch (error) {
                console.error(error);
                res.status(500).send(\\"Internal Server Error\\");
            }
            next();
        });
        this.router.post(\\"/entity\\", async (req, res, next) => {
            try {
                req.body = await serializers.Entity.parse(req.body);
                const response = await this.create(req as any);
                res.send(await serializers.Entity.json(response));
            }
            catch (error) {
                console.error(error);
                res.status(500).send(\\"Internal Server Error\\");
            }
            next();
        });
        this.router.get(\\"/entity/:entityId\\", async (req, res, next) => {
            try {
                const response = await this.get(req as any);
                res.send(await serializers.Entity.json(response));
            }
            catch (error) {
                console.error(error);
                res.status(500).send(\\"Internal Server Error\\");
            }
            next();
        });
        this.router.post(\\"/entity/:entityId\\", async (req, res, next) => {
            try {
                req.body = await serializers.Entity.parse(req.body);
                const response = await this.update(req as any);
                res.send(await serializers.Entity.json(response));
            }
            catch (error) {
                console.error(error);
                res.status(500).send(\\"Internal Server Error\\");
            }
            next();
        });
        this.router.delete(\\"/entity/:entityId\\", async (req, res, next) => {
            try {
                await this.delete(req as any);
                res.sendStatus(204);
            }
            catch (error) {
                console.error(error);
                res.status(500).send(\\"Internal Server Error\\");
            }
            next();
        });
        this.router.post(\\"/entity/:entityId/accept-tos\\", async (req, res, next) => {
            try {
                await this.acceptTermsOfService(req as any);
                res.sendStatus(204);
            }
            catch (error) {
                console.error(error);
                res.status(500).send(\\"Internal Server Error\\");
            }
            next();
        });
        return this.router;
    }
}
",
                    "name": "AbstractEntityService.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { AbstractEntityService } from \\"./AbstractEntityService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "service",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { MercoaApi } from \\"../../../..\\";

export interface BusinessProfile {
    email: string;
    phone: MercoaApi.PhoneNumber;
    businessType: string;
    legalBusinessName: string;
    doingBusinessAs: string;
    website: string;
    ownersProvided: boolean;
    taxId: MercoaApi.TaxId;
    address: MercoaApi.Address;
}
",
                    "name": "BusinessProfile.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { MercoaApi } from \\"../../../..\\";

export interface Entity {
    id?: MercoaApi.EntityId;
    accountType: string;
    name?: string;
    email?: string;
    profile: MercoaApi.Profile;
    moovStatus?: string;
    ownersProvided?: boolean;
    accpetedMoovTos?: boolean;
    createdAt?: string;
    updatedAt?: string;
}
",
                    "name": "Entity.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type EntityId = string;
",
                    "name": "EntityId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { MercoaApi } from \\"../../../..\\";

export interface IndividualProfile {
    email: string;
    phone: MercoaApi.PhoneNumber;
    name: MercoaApi.FullName;
    birthdate: MercoaApi.BirthDate;
    address: MercoaApi.Address;
}
",
                    "name": "IndividualProfile.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { MercoaApi } from \\"../../../..\\";

export interface Profile {
    business?: MercoaApi.BusinessProfile;
    individual?: MercoaApi.IndividualProfile;
}
",
                    "name": "Profile.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface TaxId {
    ein: string;
}
",
                    "name": "TaxId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./Entity\\";
export * from \\"./EntityId\\";
export * from \\"./Profile\\";
export * from \\"./BusinessProfile\\";
export * from \\"./IndividualProfile\\";
export * from \\"./TaxId\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "entity",
            "type": "directory",
          },
          Object {
            "contents": "export * as commons from \\"./commons\\";
export * from \\"./commons/types\\";
export * as entity from \\"./entity\\";
export * from \\"./entity/types\\";
export * as invoice from \\"./invoice\\";
export * from \\"./invoice/types\\";
export * as paymentMethod from \\"./paymentMethod\\";
export * from \\"./paymentMethod/types\\";
export * as representative from \\"./representative\\";
export * from \\"./representative/types\\";
export * from \\"./paymentMethod/service/requests\\";
export * as counterparty from \\"./counterparty\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./service\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import express from \\"express\\";
import * as serializers from \\"../../../../serialization\\";
import { MercoaApi } from \\"../../../..\\";

export abstract class AbstractInvoiceService {
    private router = express.Router().use(express.json());

    public abstract getInvoices(request: express.Request<{
        entityId: serializers.EntityId.Raw;
    }, MercoaApi.Invoice[], never, never, never>): Promise<MercoaApi.Invoice[]>;

    public abstract getToken(request: express.Request<{
        entityId: serializers.EntityId.Raw;
    }, never, never, never, never>): Promise<void>;

    public abstract create(request: express.Request<never, MercoaApi.Invoice, MercoaApi.Invoice, never, never>): Promise<MercoaApi.Invoice>;

    public abstract get(request: express.Request<{
        invoiceId: serializers.InvoiceId.Raw;
    }, MercoaApi.Invoice, never, never, never>): Promise<MercoaApi.Invoice>;

    public abstract update(request: express.Request<{
        invoiceId: serializers.InvoiceId.Raw;
    }, MercoaApi.Invoice, MercoaApi.Invoice, never, never>): Promise<MercoaApi.Invoice>;

    public abstract delete(request: express.Request<{
        invoiceId: serializers.InvoiceId.Raw;
    }, never, never, never, never>): Promise<void>;

    public abstract getVendorLink(request: express.Request<{
        invoiceId: serializers.InvoiceId.Raw;
    }, never, never, never, never>): Promise<void>;

    public addMiddleware(handler: express.RequestHandler): this {
        this.router.use(handler);
        return this;
    }

    public toRouter(): express.Router {
        this.router.get(\\"/entity/:entityId/invoices\\", async (req, res, next) => {
            try {
                const response = await this.getInvoices(req as any);
                res.send(await serializers.invoice.getInvoices.Response.json(response));
            }
            catch (error) {
                console.error(error);
                res.status(500).send(\\"Internal Server Error\\");
            }
            next();
        });
        this.router.get(\\"/entity/:entityId/token\\", async (req, res, next) => {
            try {
                await this.getToken(req as any);
                res.sendStatus(204);
            }
            catch (error) {
                console.error(error);
                res.status(500).send(\\"Internal Server Error\\");
            }
            next();
        });
        this.router.post(\\"/invoice\\", async (req, res, next) => {
            try {
                req.body = await serializers.Invoice.parse(req.body);
                const response = await this.create(req as any);
                res.send(await serializers.Invoice.json(response));
            }
            catch (error) {
                console.error(error);
                res.status(500).send(\\"Internal Server Error\\");
            }
            next();
        });
        this.router.get(\\"/invoice/:invoiceId\\", async (req, res, next) => {
            try {
                const response = await this.get(req as any);
                res.send(await serializers.Invoice.json(response));
            }
            catch (error) {
                console.error(error);
                res.status(500).send(\\"Internal Server Error\\");
            }
            next();
        });
        this.router.post(\\"/invoice/:invoiceId\\", async (req, res, next) => {
            try {
                req.body = await serializers.Invoice.parse(req.body);
                const response = await this.update(req as any);
                res.send(await serializers.Invoice.json(response));
            }
            catch (error) {
                console.error(error);
                res.status(500).send(\\"Internal Server Error\\");
            }
            next();
        });
        this.router.delete(\\"/invoice/:invoiceId\\", async (req, res, next) => {
            try {
                await this.delete(req as any);
                res.sendStatus(204);
            }
            catch (error) {
                console.error(error);
                res.status(500).send(\\"Internal Server Error\\");
            }
            next();
        });
        this.router.get(\\"/invoice/:invoiceId/vendorlink\\", async (req, res, next) => {
            try {
                await this.getVendorLink(req as any);
                res.sendStatus(204);
            }
            catch (error) {
                console.error(error);
                res.status(500).send(\\"Internal Server Error\\");
            }
            next();
        });
        return this.router;
    }
}
",
                    "name": "AbstractInvoiceService.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { AbstractInvoiceService } from \\"./AbstractInvoiceService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "service",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { MercoaApi } from \\"../../../..\\";

export interface Invoice {
    id?: MercoaApi.InvoiceId;
    status?: string;
    amount?: number;
    currency?: string;
    dueDate?: string;
    invoiceNumber?: string;
    noteToSelf?: string;
    createdAt?: string;
    updatedAt?: string;
    vendorId?: string;
    vendor?: MercoaApi.Entity;
    payerId?: string;
    payer?: MercoaApi.Entity;
    paymentSource?: MercoaApi.PaymentMethod;
    paymentSourceId?: string;
    paymentDestination?: MercoaApi.PaymentMethod;
    paymentDestinationId?: string;
}
",
                    "name": "Invoice.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type InvoiceId = string;
",
                    "name": "InvoiceId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./Invoice\\";
export * from \\"./InvoiceId\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "invoice",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./service\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import express from \\"express\\";
import * as serializers from \\"../../../../serialization\\";
import { MercoaApi } from \\"../../../..\\";

export abstract class AbstractPaymentMethodService {
    private router = express.Router().use(express.json());

    public abstract getAll(request: express.Request<{
        entityId: serializers.EntityId.Raw;
    }, MercoaApi.PaymentMethod[], never, {
        \\"type\\": string;
    }, never>): Promise<MercoaApi.PaymentMethod[]>;

    public abstract create(request: express.Request<{
        entityId: serializers.EntityId.Raw;
    }, MercoaApi.PaymentMethod, MercoaApi.PaymentMethod, never, never>): Promise<MercoaApi.PaymentMethod>;

    public abstract get(request: express.Request<{
        entityId: serializers.EntityId.Raw;
        paymentMethodId: serializers.PaymentMethodId.Raw;
    }, MercoaApi.PaymentMethod, never, never, never>): Promise<MercoaApi.PaymentMethod>;

    public abstract delete(request: express.Request<{
        entityId: serializers.EntityId.Raw;
        paymentMethodId: serializers.PaymentMethodId.Raw;
    }, never, never, never, never>): Promise<void>;

    public abstract initiateMicroDeposits(request: express.Request<{
        entityId: serializers.EntityId.Raw;
        paymentMethodId: serializers.PaymentMethodId.Raw;
    }, never, never, never, never>): Promise<void>;

    public abstract completeMicroDeposits(request: express.Request<{
        entityId: serializers.EntityId.Raw;
        paymentMethodId: serializers.PaymentMethodId.Raw;
    }, never, MercoaApi.CompleteMicroDepositsRequest, never, never>): Promise<void>;

    public addMiddleware(handler: express.RequestHandler): this {
        this.router.use(handler);
        return this;
    }

    public toRouter(): express.Router {
        this.router.get(\\"/paymentMethods\\", async (req, res, next) => {
            try {
                const response = await this.getAll(req as any);
                res.send(await serializers.paymentMethod.getAll.Response.json(response));
            }
            catch (error) {
                console.error(error);
                res.status(500).send(\\"Internal Server Error\\");
            }
            next();
        });
        this.router.post(\\"/paymentMethod\\", async (req, res, next) => {
            try {
                req.body = await serializers.PaymentMethod.parse(req.body);
                const response = await this.create(req as any);
                res.send(await serializers.PaymentMethod.json(response));
            }
            catch (error) {
                console.error(error);
                res.status(500).send(\\"Internal Server Error\\");
            }
            next();
        });
        this.router.get(\\"/paymentMethod/:paymentMethodId\\", async (req, res, next) => {
            try {
                const response = await this.get(req as any);
                res.send(await serializers.PaymentMethod.json(response));
            }
            catch (error) {
                console.error(error);
                res.status(500).send(\\"Internal Server Error\\");
            }
            next();
        });
        this.router.delete(\\"/paymentMethod/:paymentMethodId\\", async (req, res, next) => {
            try {
                await this.delete(req as any);
                res.sendStatus(204);
            }
            catch (error) {
                console.error(error);
                res.status(500).send(\\"Internal Server Error\\");
            }
            next();
        });
        this.router.post(\\"/paymentMethod/:paymentMethodId/micro-deposits\\", async (req, res, next) => {
            try {
                await this.initiateMicroDeposits(req as any);
                res.sendStatus(204);
            }
            catch (error) {
                console.error(error);
                res.status(500).send(\\"Internal Server Error\\");
            }
            next();
        });
        this.router.put(\\"/paymentMethod/:paymentMethodId/micro-deposits\\", async (req, res, next) => {
            try {
                req.body = await serializers.CompleteMicroDepositsRequest.parse(req.body);
                await this.completeMicroDeposits(req as any);
                res.sendStatus(204);
            }
            catch (error) {
                console.error(error);
                res.status(500).send(\\"Internal Server Error\\");
            }
            next();
        });
        return this.router;
    }
}
",
                    "name": "AbstractPaymentMethodService.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./requests\\";
export { AbstractPaymentMethodService } from \\"./AbstractPaymentMethodService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface CompleteMicroDepositsRequest {
    amounts?: number[];
}
",
                        "name": "CompleteMicroDepositsRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { CompleteMicroDepositsRequest } from \\"./CompleteMicroDepositsRequest\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "requests",
                    "type": "directory",
                  },
                ],
                "name": "service",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface BankAccount {
    id?: string;
    bankName: string;
    accountName?: string;
    routingNumber: string;
    accountNumber: string;
    accountType: string;
    moovStatus: string;
}
",
                    "name": "BankAccount.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface Check {
    id?: string;
    payToTheOrderOf: string;
    addressLine1: string;
    addressLine2?: string;
    city: string;
    stateOrProvince: string;
    postalCode: string;
    country: string;
}
",
                    "name": "Check.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { MercoaApi } from \\"../../../..\\";

export interface PaymentMethod {
    id?: MercoaApi.PaymentMethodId;
    type?: string;
    bankAccount?: MercoaApi.BankAccount;
    check?: MercoaApi.Check;
}
",
                    "name": "PaymentMethod.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type PaymentMethodId = string;
",
                    "name": "PaymentMethodId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./PaymentMethod\\";
export * from \\"./PaymentMethodId\\";
export * from \\"./BankAccount\\";
export * from \\"./Check\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "paymentMethod",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./service\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import express from \\"express\\";
import * as serializers from \\"../../../../serialization\\";
import { MercoaApi } from \\"../../../..\\";

export abstract class AbstractRepresentativeService {
    private router = express.Router().use(express.json());

    public abstract getAll(request: express.Request<{
        entityId: serializers.EntityId.Raw;
    }, MercoaApi.Representative[], never, never, never>): Promise<MercoaApi.Representative[]>;

    public abstract create(request: express.Request<{
        entityId: serializers.EntityId.Raw;
    }, MercoaApi.Representative, MercoaApi.Representative, never, never>): Promise<MercoaApi.Representative>;

    public abstract get(request: express.Request<{
        entityId: serializers.EntityId.Raw;
        representativeId: serializers.RepresentativeId.Raw;
    }, MercoaApi.Representative, never, never, never>): Promise<MercoaApi.Representative>;

    public abstract delete(request: express.Request<{
        entityId: serializers.EntityId.Raw;
        representativeId: serializers.RepresentativeId.Raw;
    }, never, never, never, never>): Promise<void>;

    public addMiddleware(handler: express.RequestHandler): this {
        this.router.use(handler);
        return this;
    }

    public toRouter(): express.Router {
        this.router.get(\\"/representatives\\", async (req, res, next) => {
            try {
                const response = await this.getAll(req as any);
                res.send(await serializers.representative.getAll.Response.json(response));
            }
            catch (error) {
                console.error(error);
                res.status(500).send(\\"Internal Server Error\\");
            }
            next();
        });
        this.router.post(\\"/representative\\", async (req, res, next) => {
            try {
                req.body = await serializers.Representative.parse(req.body);
                const response = await this.create(req as any);
                res.send(await serializers.Representative.json(response));
            }
            catch (error) {
                console.error(error);
                res.status(500).send(\\"Internal Server Error\\");
            }
            next();
        });
        this.router.get(\\"/representative/:representativeId\\", async (req, res, next) => {
            try {
                const response = await this.get(req as any);
                res.send(await serializers.Representative.json(response));
            }
            catch (error) {
                console.error(error);
                res.status(500).send(\\"Internal Server Error\\");
            }
            next();
        });
        this.router.delete(\\"/representative/:representativeId\\", async (req, res, next) => {
            try {
                await this.delete(req as any);
                res.sendStatus(204);
            }
            catch (error) {
                console.error(error);
                res.status(500).send(\\"Internal Server Error\\");
            }
            next();
        });
        return this.router;
    }
}
",
                    "name": "AbstractRepresentativeService.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { AbstractRepresentativeService } from \\"./AbstractRepresentativeService\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "service",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { MercoaApi } from \\"../../../..\\";

export interface IndividualGovernmentId {
    ssn: MercoaApi.SocialSecurityNumber;
    itin: MercoaApi.Itin;
}
",
                    "name": "IndividualGovernmentId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface Itin {
    full: string;
    lastFour: string;
}
",
                    "name": "Itin.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { MercoaApi } from \\"../../../..\\";

export interface Representative {
    id?: MercoaApi.RepresentativeId;
    name: MercoaApi.FullName;
    phone: MercoaApi.PhoneNumber;
    email: string;
    address: MercoaApi.Address;
    birthDateProvided?: boolean;
    governmentIdProvided?: boolean;
    birthDate?: MercoaApi.BirthDate;
    governmentId?: MercoaApi.IndividualGovernmentId;
    responsibilities?: MercoaApi.Responsibilities;
    createdOn?: string;
    updatedOn?: string;
    disabledOn?: string;
}
",
                    "name": "Representative.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type RepresentativeId = string;
",
                    "name": "RepresentativeId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface Responsibilities {
    jobTitle?: string;
    isController?: boolean;
    isOwner?: boolean;
    ownershipPercentage?: number;
}
",
                    "name": "Responsibilities.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface SocialSecurityNumber {
    full: string;
    lastFour: string;
}
",
                    "name": "SocialSecurityNumber.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./Representative\\";
export * from \\"./RepresentativeId\\";
export * from \\"./Responsibilities\\";
export * from \\"./IndividualGovernmentId\\";
export * from \\"./SocialSecurityNumber\\";
export * from \\"./Itin\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "representative",
            "type": "directory",
          },
        ],
        "name": "resources",
        "type": "directory",
      },
    ],
    "name": "api",
    "type": "directory",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "export * as serialization from \\"./schemas\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "import { SchemaUtils } from \\"./builders\\";

export type Schema<Raw = unknown, Parsed = unknown> = BaseSchema<Raw, Parsed> & SchemaUtils<Raw, Parsed>;

export type inferRaw<S extends Schema> = S extends Schema<infer Raw, any> ? Raw : never;
export type inferParsed<S extends Schema> = S extends Schema<any, infer Parsed> ? Parsed : never;

export interface BaseSchema<Raw, Parsed> {
    parse: (raw: Raw, opts?: SchemaOptions) => Parsed | Promise<Parsed>;
    json: (parsed: Parsed, opts?: SchemaOptions) => Raw | Promise<Raw>;
}

export interface SchemaOptions {
    /**
     * @default false
     */
    skipUnknownKeysOnParse?: boolean;

    /**
     * @default false
     */
    includeUnknownKeysOnJson?: boolean;
}
",
            "name": "Schema.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function date(): Schema<string, Date> {
    const baseSchema: BaseSchema<string, Date> = {
        parse: (raw) => new Date(raw),
        json: (date) => date.toISOString(),
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}
",
                    "name": "date.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { date } from \\"./date\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "date",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function enum_<U extends string, E extends Readonly<[U, ...U[]]>>(_values: E): Schema<E[number], E[number]> {
    return createIdentitySchemaCreator<E[number]>()();
}
",
                    "name": "enum.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { enum_ } from \\"./enum\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "enum",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
import { identity } from \\"./identity\\";

export function createIdentitySchemaCreator<T>(): () => Schema<T, T> {
    return <T>() => identity<T>();
}
",
                    "name": "createIdentitySchemaCreator.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function identity<T>(): Schema<T, T> {
    const baseSchema: BaseSchema<T, T> = {
        parse: (raw) => raw,
        json: (parsed) => parsed,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}
",
                    "name": "identity.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { createIdentitySchemaCreator } from \\"./createIdentitySchemaCreator\\";
export { identity } from \\"./identity\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "identity",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./date\\";
export * from \\"./enum\\";
export * from \\"./identity\\";
export * from \\"./lazy\\";
export * from \\"./list\\";
export * from \\"./literals\\";
export * from \\"./object\\";
export * from \\"./object-like\\";
export * from \\"./primitives\\";
export * from \\"./record\\";
export * from \\"./schema-utils\\";
export * from \\"./set\\";
export * from \\"./union\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { lazy, type SchemaGetter } from \\"./lazy\\";
export { lazyObject } from \\"./lazyObject\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export type SchemaGetter<SchemaType extends Schema<any, any>> = () => SchemaType | Promise<SchemaType>;

export function lazy<Raw, Parsed>(getter: SchemaGetter<Schema<Raw, Parsed>>): Schema<Raw, Parsed> {
    const baseSchema = constructLazyBaseSchema(getter);
    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}

export function constructLazyBaseSchema<Raw, Parsed>(
    getter: SchemaGetter<Schema<Raw, Parsed>>
): BaseSchema<Raw, Parsed> {
    return {
        parse: async (raw) => (await getMemoizedSchema(getter)).parse(raw),
        json: async (parsed) => (await getMemoizedSchema(getter)).json(parsed),
    };
}

type MemoizedGetter<SchemaType extends Schema<any, any>> = SchemaGetter<SchemaType> & { __zurg_memoized?: SchemaType };

export async function getMemoizedSchema<SchemaType extends Schema<any, any>>(
    getter: SchemaGetter<SchemaType>
): Promise<SchemaType> {
    const castedGetter = getter as MemoizedGetter<SchemaType>;
    if (castedGetter.__zurg_memoized == null) {
        castedGetter.__zurg_memoized = await getter();
    }
    return castedGetter.__zurg_memoized;
}
",
                    "name": "lazy.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { getObjectUtils } from \\"../object\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { BaseObjectSchema, ObjectSchema } from \\"../object/types\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { constructLazyBaseSchema, getMemoizedSchema, SchemaGetter } from \\"./lazy\\";

export function lazyObject<Raw, Parsed>(getter: SchemaGetter<ObjectSchema<Raw, Parsed>>): ObjectSchema<Raw, Parsed> {
    const baseSchema: BaseObjectSchema<Raw, Parsed> = {
        ...OBJECT_LIKE_BRAND,
        ...constructLazyBaseSchema(getter),
        _getRawProperties: async () => (await getMemoizedSchema(getter))._getRawProperties(),
        _getParsedProperties: async () => (await getMemoizedSchema(getter))._getParsedProperties(),
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
    };
}
",
                    "name": "lazyObject.ts",
                    "type": "file",
                  },
                ],
                "name": "lazy",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { list } from \\"./list\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function list<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Parsed[]> {
    const baseSchema: BaseSchema<Raw[], Parsed[]> = {
        parse: (raw, opts) => Promise.all(raw.map((item) => schema.parse(item, opts))),
        json: (parsed, opts) => Promise.all(parsed.map((item) => schema.json(item, opts))),
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}
",
                    "name": "list.ts",
                    "type": "file",
                  },
                ],
                "name": "list",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { stringLiteral } from \\"./stringLiteral\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function stringLiteral<V extends string>(_value: V): Schema<V, V> {
    return createIdentitySchemaCreator<V>()();
}
",
                    "name": "stringLiteral.ts",
                    "type": "file",
                  },
                ],
                "name": "literals",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { getObjectUtils, object } from \\"./object\\";
export { isProperty, property, type Property } from \\"./property\\";
export {
    type BaseObjectSchema,
    type inferObjectSchemaFromPropertySchemas,
    type inferParsedObject,
    type inferParsedObjectFromPropertySchemas,
    type inferParsedPropertySchema,
    type inferRawKey,
    type inferRawObject,
    type inferRawObjectFromPropertySchemas,
    type inferRawPropertySchema,
    type ObjectSchema,
    type ObjectUtils,
    type PropertySchemas,
} from \\"./types\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { filterObject } from \\"../../utils/filterObject\\";
import { keys } from \\"../../utils/keys\\";
import { partition } from \\"../../utils/partition\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { isProperty } from \\"./property\\";
import {
    BaseObjectSchema,
    inferObjectSchemaFromPropertySchemas,
    inferParsedObjectFromPropertySchemas,
    inferRawObjectFromPropertySchemas,
    ObjectSchema,
    ObjectUtils,
    PropertySchemas,
} from \\"./types\\";

interface ObjectPropertyWithRawKey {
    rawKey: string;
    parsedKey: string | number | symbol;
    valueSchema: Schema<any, any>;
}

export function object<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(
    schemas: T
): inferObjectSchemaFromPropertySchemas<T> {
    const baseSchema: BaseObjectSchema<
        inferRawObjectFromPropertySchemas<T>,
        inferParsedObjectFromPropertySchemas<T>
    > = {
        ...OBJECT_LIKE_BRAND,
        _getRawProperties: () =>
            Promise.resolve(
                Object.entries(schemas).map(([parsedKey, propertySchema]) =>
                    isProperty(propertySchema) ? propertySchema.rawKey : parsedKey
                ) as unknown as (keyof inferRawObjectFromPropertySchemas<T>)[]
            ),
        _getParsedProperties: () =>
            Promise.resolve(keys(schemas) as unknown as (keyof inferParsedObjectFromPropertySchemas<T>)[]),

        parse: async (raw, { skipUnknownKeysOnParse = false } = {}) => {
            const rawKeyToProperty: Record<string, ObjectPropertyWithRawKey> = {};

            for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
                const rawKey = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;

                const property: ObjectPropertyWithRawKey = {
                    rawKey,
                    parsedKey,
                    valueSchema: isProperty(schemaOrObjectProperty)
                        ? schemaOrObjectProperty.valueSchema
                        : schemaOrObjectProperty,
                };

                rawKeyToProperty[rawKey] = property;
            }

            const parsed: Record<string | number | symbol, any> = {};

            for (const [rawKey, rawPropertyValue] of Object.entries(raw)) {
                const property = rawKeyToProperty[rawKey];

                if (property != null) {
                    const value = await property.valueSchema.parse(rawPropertyValue);
                    parsed[property.parsedKey] = value;
                } else if (!skipUnknownKeysOnParse) {
                    parsed[rawKey] = rawPropertyValue;
                }
            }

            return parsed as inferParsedObjectFromPropertySchemas<T>;
        },

        json: async (parsed, { includeUnknownKeysOnJson = false } = {}) => {
            const raw: Record<string | number | symbol, any> = {};

            for (const [parsedKey, parsedPropertyValue] of entries(parsed)) {
                const schemaOrObjectProperty = schemas[parsedKey as keyof T];
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                if (schemaOrObjectProperty != null) {
                    if (isProperty(schemaOrObjectProperty)) {
                        const value = await schemaOrObjectProperty.valueSchema.json(parsedPropertyValue);
                        raw[schemaOrObjectProperty.rawKey] = value;
                    } else {
                        const value = await schemaOrObjectProperty.json(parsedPropertyValue);
                        raw[parsedKey] = value;
                    }
                } else if (includeUnknownKeysOnJson) {
                    raw[parsedKey] = parsedPropertyValue;
                }
            }

            return raw as inferRawObjectFromPropertySchemas<T>;
        },
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
    };
}

export function getObjectUtils<Raw, Parsed>(schema: BaseObjectSchema<Raw, Parsed>): ObjectUtils<Raw, Parsed> {
    return {
        extend: <RawExtension, ParsedExtension>(extension: ObjectSchema<RawExtension, ParsedExtension>) => {
            const baseSchema: BaseObjectSchema<Raw & RawExtension, Parsed & ParsedExtension> = {
                ...OBJECT_LIKE_BRAND,
                _getParsedProperties: async () => [
                    ...(await schema._getParsedProperties()),
                    ...(await extension._getParsedProperties()),
                ],
                _getRawProperties: async () => [
                    ...(await schema._getRawProperties()),
                    ...(await extension._getRawProperties()),
                ],
                parse: async (raw, opts) => {
                    const rawExtensionPropertiesSet = new Set(await extension._getRawProperties());
                    const [extensionProperties, otherProperties] = partition(keys(raw), (key) =>
                        rawExtensionPropertiesSet.has(key as keyof RawExtension)
                    );
                    return {
                        ...(await schema.parse(filterObject(raw, otherProperties), opts)),
                        ...(await extension.parse(filterObject(raw, extensionProperties), opts)),
                    };
                },
                json: async (parsed, opts) => {
                    const parsedExtensionPropertiesSet = new Set(await extension._getParsedProperties());
                    const [extensionProperties, otherProperties] = partition(keys(parsed), (key) =>
                        parsedExtensionPropertiesSet.has(key as keyof ParsedExtension)
                    );
                    return {
                        ...(await schema.json(filterObject(parsed, otherProperties), opts)),
                        ...(await extension.json(filterObject(parsed, extensionProperties), opts)),
                    };
                },
            };

            return {
                ...baseSchema,
                ...getSchemaUtils(baseSchema),
                ...getObjectLikeUtils(baseSchema),
                ...getObjectUtils(baseSchema),
            };
        },
    };
}
",
                    "name": "object.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";

export function property<RawKey extends string, RawValue, ParsedValue>(
    rawKey: RawKey,
    valueSchema: Schema<RawValue, ParsedValue>
): Property<RawKey, RawValue, ParsedValue> {
    return {
        rawKey,
        valueSchema,
        isProperty: true,
    };
}

export interface Property<RawKey extends string, RawValue, ParsedValue> {
    rawKey: RawKey;
    valueSchema: Schema<RawValue, ParsedValue>;
    isProperty: true;
}

export function isProperty<O extends Property<any, any, any>>(maybeProperty: unknown): maybeProperty is O {
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    return (maybeProperty as O).isProperty;
}
",
                    "name": "property.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { inferParsed, inferRaw, Schema } from \\"../../Schema\\";
import { addQuestionMarksToNullableProperties } from \\"../../utils/addQuestionMarksToNullableProperties\\";
import { BaseObjectLikeSchema, ObjectLikeSchema } from \\"../object-like\\";
import { Property } from \\"./property\\";

export type ObjectSchema<Raw, Parsed> = BaseObjectSchema<Raw, Parsed> &
    ObjectLikeSchema<Raw, Parsed> &
    ObjectUtils<Raw, Parsed>;

export interface BaseObjectSchema<Raw, Parsed> extends BaseObjectLikeSchema<Raw, Parsed> {
    _getRawProperties: () => Promise<(keyof Raw)[]>;
    _getParsedProperties: () => Promise<(keyof Parsed)[]>;
}

export interface ObjectUtils<Raw, Parsed> {
    extend: <RawExtension, ParsedExtension>(
        schemas: ObjectSchema<RawExtension, ParsedExtension>
    ) => ObjectSchema<Raw & RawExtension, Parsed & ParsedExtension>;
}

export type inferRawObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<infer Raw, any> ? Raw : never;

export type inferParsedObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<any, infer Parsed>
    ? Parsed
    : never;

export type inferObjectSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> = ObjectSchema<
    inferRawObjectFromPropertySchemas<T>,
    inferParsedObjectFromPropertySchemas<T>
>;

export type inferRawObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
    addQuestionMarksToNullableProperties<{
        [ParsedKey in keyof T as inferRawKey<ParsedKey, T[ParsedKey]>]: inferRawPropertySchema<T[ParsedKey]>;
    }>;

export type inferParsedObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
    addQuestionMarksToNullableProperties<{
        [K in keyof T]: inferParsedPropertySchema<T[K]>;
    }>;

export type PropertySchemas<ParsedKeys extends string | number | symbol> = Record<
    ParsedKeys,
    Property<any, any, any> | Schema<any, any>
>;

export type inferRawPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
    any,
    infer Raw,
    any
>
    ? Raw
    : P extends Schema<any, any>
    ? inferRaw<P>
    : never;

export type inferParsedPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
    any,
    any,
    infer Parsed
>
    ? Parsed
    : P extends Schema<any, any>
    ? inferParsed<P>
    : never;

export type inferRawKey<
    ParsedKey extends string | number | symbol,
    P extends Property<any, any, any> | Schema<any, any>
> = P extends Property<infer Raw, any, any> ? Raw : ParsedKey;
",
                    "name": "types.ts",
                    "type": "file",
                  },
                ],
                "name": "object",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { getSchemaUtils } from \\"../schema-utils\\";
import { BaseObjectLikeSchema, ObjectLikeSchema, ObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"./types\\";

export function getObjectLikeUtils<Raw, Parsed>(
    schema: BaseObjectLikeSchema<Raw, Parsed>
): ObjectLikeUtils<Raw, Parsed> {
    return {
        withProperties: (properties) => withProperties(schema, properties),
    };
}

/**
 * object-like utils are defined in one file to resolve issues with circular imports
 */

export function withProperties<RawObjectShape, ParsedObjectShape, Properties>(
    objectLike: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape>,
    properties: { [K in keyof Properties]: Properties[K] | ((parsed: ParsedObjectShape) => Properties[K]) }
): ObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> {
    const objectSchema: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> = {
        ...OBJECT_LIKE_BRAND,
        parse: async (raw, opts) => {
            const parsedObject = await objectLike.parse(raw, opts);
            const additionalProperties = Object.entries(properties).reduce<Record<string, any>>(
                (processed, [key, value]) => {
                    return {
                        ...processed,
                        [key]: typeof value === \\"function\\" ? value(parsedObject) : value,
                    };
                },
                {}
            );

            return {
                ...parsedObject,
                ...(additionalProperties as Properties),
            };
        },
        json: (parsed, opts) => {
            // strip out added properties
            const addedPropertyKeys = new Set(Object.keys(properties));
            const parsedWithoutAddedProperties = Object.entries(parsed).reduce<Record<string, any>>(
                (filtered, [key, value]) => {
                    if (!addedPropertyKeys.has(key)) {
                        filtered[key] = value;
                    }
                    return filtered;
                },
                {}
            );

            return objectLike.json(parsedWithoutAddedProperties as ParsedObjectShape, opts);
        },
    };

    return {
        ...objectSchema,
        ...getSchemaUtils(objectSchema),
        ...getObjectLikeUtils(objectSchema),
    };
}
",
                    "name": "getObjectLikeUtils.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { getObjectLikeUtils, withProperties } from \\"./getObjectLikeUtils\\";
export { OBJECT_LIKE_BRAND, type BaseObjectLikeSchema, type ObjectLikeSchema, type ObjectLikeUtils } from \\"./types\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";

export type ObjectLikeSchema<Raw, Parsed> = Schema<Raw, Parsed> &
    BaseObjectLikeSchema<Raw, Parsed> &
    ObjectLikeUtils<Raw, Parsed>;

export type BaseObjectLikeSchema<Raw, Parsed> = BaseSchema<Raw, Parsed> & {
    _objectLike: void;
};

export interface ObjectLikeUtils<Raw, Parsed> {
    withProperties: <T extends Record<string, any>>(properties: {
        [K in keyof T]: T[K] | ((parsed: Parsed) => T[K]);
    }) => ObjectLikeSchema<Raw, Parsed & T>;
}

export const OBJECT_LIKE_BRAND = undefined as unknown as { _objectLike: void };
",
                    "name": "types.ts",
                    "type": "file",
                  },
                ],
                "name": "object-like",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const any = createIdentitySchemaCreator<any>();
",
                    "name": "any.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const boolean = createIdentitySchemaCreator<boolean>();
",
                    "name": "boolean.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { any } from \\"./any\\";
export { boolean } from \\"./boolean\\";
export { number } from \\"./number\\";
export { string } from \\"./string\\";
export { unknown } from \\"./unknown\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const number = createIdentitySchemaCreator<number>();
",
                    "name": "number.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const string = createIdentitySchemaCreator<string>();
",
                    "name": "string.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const unknown = createIdentitySchemaCreator<unknown>();
",
                    "name": "unknown.ts",
                    "type": "file",
                  },
                ],
                "name": "primitives",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { record } from \\"./record\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function record<RawKey extends string | number, ParsedKey extends string | number, RawValue, ParsedValue>(
    keySchema: Schema<RawKey, ParsedKey>,
    valueSchema: Schema<RawValue, ParsedValue>
): Schema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> {
    const baseSchema: BaseSchema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> = {
        parse: (raw, opts) => {
            return entries(raw).reduce(async (parsedPromise, [key, value]) => {
                const parsed: Record<ParsedKey, ParsedValue> = await parsedPromise;
                const parsedKey = await keySchema.parse(key, opts);
                parsed[parsedKey] = await valueSchema.parse(value, opts);
                return parsedPromise;
            }, Promise.resolve({} as Record<ParsedKey, ParsedValue>));
        },
        json: (parsed, opts) => {
            return entries(parsed).reduce(async (rawPromise, [key, value]) => {
                const raw: Record<RawKey, RawValue> = await rawPromise;
                const rawKey = await keySchema.json(key, opts);
                raw[rawKey] = await valueSchema.json(value, opts);
                return rawPromise;
            }, Promise.resolve({} as Record<RawKey, RawValue>));
        },
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}
",
                    "name": "record.ts",
                    "type": "file",
                  },
                ],
                "name": "record",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { OptionalSchema, OPTIONAL_BRAND } from \\"./types\\";

export interface SchemaUtils<Raw, Parsed> {
    optional: () => OptionalSchema<Raw, Parsed>;
    transform: <PostTransform>(transformer: BaseSchema<Parsed, PostTransform>) => Schema<Raw, PostTransform>;
}

export function getSchemaUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): SchemaUtils<Raw, Parsed> {
    return {
        optional: () => optional(schema),
        transform: (transformer) => transform(schema, transformer),
    };
}

/**
 * schema utils are defined in one file to resolve issues with circular imports
 */

export function optional<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): OptionalSchema<Raw, Parsed> {
    const baseSchema: BaseSchema<Raw | null | undefined, Parsed | undefined> = {
        parse: (raw, opts) => (raw != null ? schema.parse(raw, opts) : undefined),
        json: (parsed, opts) => (parsed != null ? schema.json(parsed, opts) : null),
    };

    return {
        ...OPTIONAL_BRAND,
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}

export function transform<PreTransformRaw, PreTransformParsed, PostTransform>(
    schema: BaseSchema<PreTransformRaw, PreTransformParsed>,
    transformer: BaseSchema<PreTransformParsed, PostTransform>
): Schema<PreTransformRaw, PostTransform> {
    const baseSchema: BaseSchema<PreTransformRaw, PostTransform> = {
        parse: async (raw, opts) => {
            const postTransformParsed = await schema.parse(raw, opts);
            return transformer.parse(postTransformParsed, opts);
        },
        json: async (parsed, opts) => {
            const preTransformParsed = await transformer.json(parsed, opts);
            return schema.json(preTransformParsed, opts);
        },
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}
",
                    "name": "getSchemaUtils.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { getSchemaUtils, optional, transform, type SchemaUtils } from \\"./getSchemaUtils\\";
export { OPTIONAL_BRAND, type OptionalSchema } from \\"./types\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";

export const OPTIONAL_BRAND = undefined as unknown as { _isOptional: void };

export type OptionalSchema<Raw, Parsed> = Schema<Raw | null | undefined, Parsed | undefined> & {
    _isOptional: void;
};
",
                    "name": "types.ts",
                    "type": "file",
                  },
                ],
                "name": "schema-utils",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { set } from \\"./set\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function set<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Set<Parsed>> {
    const baseSchema: BaseSchema<Raw[], Set<Parsed>> = {
        parse: async (raw, opts) => new Set(await Promise.all(raw.map((item) => schema.parse(item, opts)))),
        json: (parsed, opts) => Promise.all([...parsed].map((item) => schema.json(item, opts))),
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}
",
                    "name": "set.ts",
                    "type": "file",
                  },
                ],
                "name": "set",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export function discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string>(
    parsedDiscriminant: ParsedDiscriminant,
    rawDiscriminant: RawDiscriminant
): Discriminant<RawDiscriminant, ParsedDiscriminant> {
    return {
        parsedDiscriminant,
        rawDiscriminant,
    };
}

export interface Discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string> {
    parsedDiscriminant: ParsedDiscriminant;
    rawDiscriminant: RawDiscriminant;
}
",
                    "name": "discriminant.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { discriminant, type Discriminant } from \\"./discriminant\\";
export {
    type inferParsedDiscriminant,
    type inferParsedUnion,
    type inferRawDiscriminant,
    type inferRawUnion,
    type UnionSubtypes,
} from \\"./types\\";
export { union } from \\"./union\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { inferParsedObject, inferRawObject, ObjectSchema } from \\"../object\\";
import { Discriminant } from \\"./discriminant\\";

export type UnionSubtypes<DiscriminantValues extends string | number | symbol> = {
    [K in DiscriminantValues]: ObjectSchema<any, any>;
};

export type inferRawUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
    [K in keyof U]: Record<inferRawDiscriminant<D>, K> & inferRawObject<U[K]>;
}[keyof U];

export type inferParsedUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
    [K in keyof U]: Record<inferParsedDiscriminant<D>, K> & inferParsedObject<U[K]>;
}[keyof U];

export type inferRawDiscriminant<D extends string | Discriminant<any, any>> = D extends string
    ? D
    : D extends Discriminant<infer Raw, any>
    ? Raw
    : never;

export type inferParsedDiscriminant<D extends string | Discriminant<any, any>> = D extends string
    ? D
    : D extends Discriminant<any, infer Parsed>
    ? Parsed
    : never;
",
                    "name": "types.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseObjectLikeSchema, getObjectLikeUtils, ObjectLikeSchema, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { Discriminant } from \\"./discriminant\\";
import { inferParsedDiscriminant, inferParsedUnion, inferRawDiscriminant, inferRawUnion, UnionSubtypes } from \\"./types\\";

export function union<D extends string | Discriminant<any, any>, U extends UnionSubtypes<any>>(
    discriminant: D,
    union: U
): ObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> {
    const rawDiscriminant =
        typeof discriminant === \\"string\\" ? discriminant : (discriminant.rawDiscriminant as inferRawDiscriminant<D>);
    const parsedDiscriminant =
        typeof discriminant === \\"string\\"
            ? discriminant
            : (discriminant.parsedDiscriminant as inferParsedDiscriminant<D>);

    const baseSchema: BaseObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> = {
        ...OBJECT_LIKE_BRAND,

        parse: async (raw, opts) => {
            const { [rawDiscriminant]: discriminantValue, ...additionalProperties } = raw;
            const additionalPropertySchemas = union[discriminantValue];

            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            if (additionalPropertySchemas == null) {
                return {
                    ...additionalProperties,
                    [parsedDiscriminant]: discriminantValue,
                } as inferParsedUnion<D, U>;
            }

            return {
                ...(await additionalPropertySchemas.parse(additionalProperties, opts)),
                [parsedDiscriminant]: discriminantValue,
            } as inferParsedUnion<D, U>;
        },

        json: async (parsed, opts) => {
            const { [parsedDiscriminant]: discriminantValue, ...additionalProperties } = parsed;
            const additionalPropertySchemas = union[discriminantValue];

            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            if (additionalPropertySchemas == null) {
                return {
                    ...additionalProperties,
                    [rawDiscriminant]: discriminantValue,
                } as unknown as inferRawUnion<D, U>;
            }

            return {
                ...(await additionalPropertySchemas.json(additionalProperties, opts)),
                [rawDiscriminant]: discriminantValue,
            } as inferRawUnion<D, U>;
        },
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
    };
}
",
                    "name": "union.ts",
                    "type": "file",
                  },
                ],
                "name": "union",
                "type": "directory",
              },
            ],
            "name": "builders",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./builders\\";
export { type inferParsed, type inferRaw, type Schema, type SchemaOptions } from \\"./Schema\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export type addQuestionMarksToNullableProperties<T> = {
    [K in OptionalKeys<T>]?: T[K];
} & Pick<T, RequiredKeys<T>>;

export type OptionalKeys<T> = {
    [K in keyof T]: undefined extends T[K] ? K : null extends T[K] ? K : never;
}[keyof T];

export type RequiredKeys<T> = {
    [K in keyof T]: undefined extends T[K] ? never : null extends T[K] ? never : K;
}[keyof T];
",
                "name": "addQuestionMarksToNullableProperties.ts",
                "type": "file",
              },
              Object {
                "contents": "export function entries<T>(object: T): [keyof T, T[keyof T]][] {
    return Object.entries(object) as [keyof T, T[keyof T]][];
}
",
                "name": "entries.ts",
                "type": "file",
              },
              Object {
                "contents": "export function filterObject<T, K extends keyof T>(obj: T, keysToInclude: K[]): Pick<T, K> {
    const keysToIncludeSet = new Set(keysToInclude);
    return Object.entries(obj).reduce((acc, [key, value]) => {
        if (keysToIncludeSet.has(key as K)) {
            acc[key as K] = value;
        }
        return acc;
        // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
    }, {} as Pick<T, K>);
}
",
                "name": "filterObject.ts",
                "type": "file",
              },
              Object {
                "contents": "export function keys<T>(object: T): (keyof T)[] {
    return Object.keys(object) as (keyof T)[];
}
",
                "name": "keys.ts",
                "type": "file",
              },
              Object {
                "contents": "export function partition<T>(items: readonly T[], predicate: (item: T) => boolean): [T[], T[]] {
    const trueItems: T[] = [],
        falseItems: T[] = [];
    for (const item of items) {
        if (predicate(item)) {
            trueItems.push(item);
        } else {
            falseItems.push(item);
        }
    }
    return [trueItems, falseItems];
}
",
                "name": "partition.ts",
                "type": "file",
              },
            ],
            "name": "utils",
            "type": "directory",
          },
        ],
        "name": "schemas",
        "type": "directory",
      },
    ],
    "name": "core",
    "type": "directory",
  },
  Object {
    "contents": "export * as MercoaApi from \\"./api\\";
export { register } from \\"./register\\";
",
    "name": "index.ts",
    "type": "file",
  },
  Object {
    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import express from \\"express\\";
import { AbstractCounterpartyService } from \\"./api/resources/counterparty/service/AbstractCounterpartyService\\";
import { AbstractEntityService } from \\"./api/resources/entity/service/AbstractEntityService\\";
import { AbstractInvoiceService } from \\"./api/resources/invoice/service/AbstractInvoiceService\\";
import { AbstractPaymentMethodService } from \\"./api/resources/paymentMethod/service/AbstractPaymentMethodService\\";
import { AbstractRepresentativeService } from \\"./api/resources/representative/service/AbstractRepresentativeService\\";

export function register(expressApp: express.Express, services: {
    counterparty: AbstractCounterpartyService;
    entity: AbstractEntityService;
    invoice: AbstractInvoiceService;
    paymentMethod: AbstractPaymentMethodService;
    representative: AbstractRepresentativeService;
}): void {
    expressApp.use(\\"/entity/:entityId/counterparties\\", services.counterparty.toRouter());
    expressApp.use(\\"/\\", services.entity.toRouter());
    expressApp.use(\\"/\\", services.invoice.toRouter());
    expressApp.use(\\"/entity/:entityId\\", services.paymentMethod.toRouter());
    expressApp.use(\\"/api/entity/:entityId\\", services.representative.toRouter());
}
",
    "name": "register.ts",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "export * from \\"./resources\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { MercoaApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const Address: core.serialization.ObjectSchema<serializers.Address.Raw, MercoaApi.Address> = core.serialization.object({
    addressLine1: core.serialization.string(),
    addressLine2: core.serialization.string().optional(),
    city: core.serialization.string(),
    stateOrProvince: core.serialization.string(),
    postalCode: core.serialization.string(),
    country: core.serialization.string().optional()
});

export declare namespace Address {
    interface Raw {
        \\"addressLine1\\": string;
        \\"addressLine2\\"?: string | null;
        \\"city\\": string;
        \\"stateOrProvince\\": string;
        \\"postalCode\\": string;
        \\"country\\"?: string | null;
    }
}
",
                    "name": "Address.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { MercoaApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const BirthDate: core.serialization.ObjectSchema<serializers.BirthDate.Raw, MercoaApi.BirthDate> = core.serialization.object({
    day: core.serialization.number().optional(),
    month: core.serialization.number().optional(),
    year: core.serialization.number().optional()
});

export declare namespace BirthDate {
    interface Raw {
        \\"day\\"?: number | null;
        \\"month\\"?: number | null;
        \\"year\\"?: number | null;
    }
}
",
                    "name": "BirthDate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { MercoaApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const FullName: core.serialization.ObjectSchema<serializers.FullName.Raw, MercoaApi.FullName> = core.serialization.object({
    firstName: core.serialization.string(),
    middleName: core.serialization.string().optional(),
    lastName: core.serialization.string(),
    suffix: core.serialization.string().optional()
});

export declare namespace FullName {
    interface Raw {
        \\"firstName\\": string;
        \\"middleName\\"?: string | null;
        \\"lastName\\": string;
        \\"suffix\\"?: string | null;
    }
}
",
                    "name": "FullName.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { MercoaApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const PhoneNumber: core.serialization.ObjectSchema<serializers.PhoneNumber.Raw, MercoaApi.PhoneNumber> = core.serialization.object({
    countryCode: core.serialization.string(),
    number: core.serialization.string()
});

export declare namespace PhoneNumber {
    interface Raw {
        \\"countryCode\\": string;
        \\"number\\": string;
    }
}
",
                    "name": "PhoneNumber.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./FullName\\";
export * from \\"./BirthDate\\";
export * from \\"./Address\\";
export * from \\"./PhoneNumber\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "commons",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./service\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { MercoaApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const Response: core.serialization.Schema<serializers.counterparty.find.Response.Raw, MercoaApi.Entity[]> = core.serialization.list(core.serialization.lazyObject(async () => (await import(\\"../../..\\")).Entity));

export declare namespace Response {
    type Raw = serializers.Entity.Raw[];
}
",
                    "name": "find.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as find from \\"./find\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "service",
                "type": "directory",
              },
            ],
            "name": "counterparty",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./service\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { MercoaApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const Response: core.serialization.Schema<serializers.entity.getAll.Response.Raw, MercoaApi.Entity[]> = core.serialization.list(core.serialization.lazyObject(async () => (await import(\\"../../..\\")).Entity));

export declare namespace Response {
    type Raw = serializers.Entity.Raw[];
}
",
                    "name": "getAll.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getAll from \\"./getAll\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "service",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { MercoaApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const BusinessProfile: core.serialization.ObjectSchema<serializers.BusinessProfile.Raw, MercoaApi.BusinessProfile> = core.serialization.object({
    email: core.serialization.string(),
    phone: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).PhoneNumber),
    businessType: core.serialization.string(),
    legalBusinessName: core.serialization.string(),
    doingBusinessAs: core.serialization.string(),
    website: core.serialization.string(),
    ownersProvided: core.serialization.boolean(),
    taxId: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).TaxId),
    address: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).Address)
});

export declare namespace BusinessProfile {
    interface Raw {
        \\"email\\": string;
        \\"phone\\": serializers.PhoneNumber.Raw;
        \\"businessType\\": string;
        \\"legalBusinessName\\": string;
        \\"doingBusinessAs\\": string;
        \\"website\\": string;
        \\"ownersProvided\\": boolean;
        \\"taxId\\": serializers.TaxId.Raw;
        \\"address\\": serializers.Address.Raw;
    }
}
",
                    "name": "BusinessProfile.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { MercoaApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const Entity: core.serialization.ObjectSchema<serializers.Entity.Raw, MercoaApi.Entity> = core.serialization.object({
    id: core.serialization.lazy(async () => (await import(\\"../../..\\")).EntityId).optional(),
    accountType: core.serialization.string(),
    name: core.serialization.string().optional(),
    email: core.serialization.string().optional(),
    profile: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).Profile),
    moovStatus: core.serialization.string().optional(),
    ownersProvided: core.serialization.boolean().optional(),
    accpetedMoovTos: core.serialization.boolean().optional(),
    createdAt: core.serialization.string().optional(),
    updatedAt: core.serialization.string().optional()
});

export declare namespace Entity {
    interface Raw {
        \\"id\\"?: serializers.EntityId.Raw | null;
        \\"accountType\\": string;
        \\"name\\"?: string | null;
        \\"email\\"?: string | null;
        \\"profile\\": serializers.Profile.Raw;
        \\"moovStatus\\"?: string | null;
        \\"ownersProvided\\"?: boolean | null;
        \\"accpetedMoovTos\\"?: boolean | null;
        \\"createdAt\\"?: string | null;
        \\"updatedAt\\"?: string | null;
    }
}
",
                    "name": "Entity.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { MercoaApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const EntityId: core.serialization.Schema<serializers.EntityId.Raw, MercoaApi.EntityId> = core.serialization.string();

export declare namespace EntityId {
    type Raw = string;
}
",
                    "name": "EntityId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { MercoaApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const IndividualProfile: core.serialization.ObjectSchema<serializers.IndividualProfile.Raw, MercoaApi.IndividualProfile> = core.serialization.object({
    email: core.serialization.string(),
    phone: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).PhoneNumber),
    name: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).FullName),
    birthdate: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).BirthDate),
    address: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).Address)
});

export declare namespace IndividualProfile {
    interface Raw {
        \\"email\\": string;
        \\"phone\\": serializers.PhoneNumber.Raw;
        \\"name\\": serializers.FullName.Raw;
        \\"birthdate\\": serializers.BirthDate.Raw;
        \\"address\\": serializers.Address.Raw;
    }
}
",
                    "name": "IndividualProfile.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { MercoaApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const Profile: core.serialization.ObjectSchema<serializers.Profile.Raw, MercoaApi.Profile> = core.serialization.object({
    business: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).BusinessProfile).optional(),
    individual: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).IndividualProfile).optional()
});

export declare namespace Profile {
    interface Raw {
        \\"business\\"?: serializers.BusinessProfile.Raw | null;
        \\"individual\\"?: serializers.IndividualProfile.Raw | null;
    }
}
",
                    "name": "Profile.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { MercoaApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const TaxId: core.serialization.ObjectSchema<serializers.TaxId.Raw, MercoaApi.TaxId> = core.serialization.object({
    ein: core.serialization.string()
});

export declare namespace TaxId {
    interface Raw {
        \\"ein\\": string;
    }
}
",
                    "name": "TaxId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./Entity\\";
export * from \\"./EntityId\\";
export * from \\"./Profile\\";
export * from \\"./BusinessProfile\\";
export * from \\"./IndividualProfile\\";
export * from \\"./TaxId\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "entity",
            "type": "directory",
          },
          Object {
            "contents": "export * as commons from \\"./commons\\";
export * from \\"./commons/types\\";
export * as entity from \\"./entity\\";
export * from \\"./entity/types\\";
export * as invoice from \\"./invoice\\";
export * from \\"./invoice/types\\";
export * as paymentMethod from \\"./paymentMethod\\";
export * from \\"./paymentMethod/types\\";
export * as representative from \\"./representative\\";
export * from \\"./representative/types\\";
export * from \\"./paymentMethod/service/requests\\";
export * as counterparty from \\"./counterparty\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./service\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { MercoaApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const Response: core.serialization.Schema<serializers.invoice.getInvoices.Response.Raw, MercoaApi.Invoice[]> = core.serialization.list(core.serialization.lazyObject(async () => (await import(\\"../../..\\")).Invoice));

export declare namespace Response {
    type Raw = serializers.Invoice.Raw[];
}
",
                    "name": "getInvoices.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getInvoices from \\"./getInvoices\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "service",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { MercoaApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const Invoice: core.serialization.ObjectSchema<serializers.Invoice.Raw, MercoaApi.Invoice> = core.serialization.object({
    id: core.serialization.lazy(async () => (await import(\\"../../..\\")).InvoiceId).optional(),
    status: core.serialization.string().optional(),
    amount: core.serialization.number().optional(),
    currency: core.serialization.string().optional(),
    dueDate: core.serialization.string().optional(),
    invoiceNumber: core.serialization.string().optional(),
    noteToSelf: core.serialization.string().optional(),
    createdAt: core.serialization.string().optional(),
    updatedAt: core.serialization.string().optional(),
    vendorId: core.serialization.string().optional(),
    vendor: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).Entity).optional(),
    payerId: core.serialization.string().optional(),
    payer: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).Entity).optional(),
    paymentSource: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).PaymentMethod).optional(),
    paymentSourceId: core.serialization.string().optional(),
    paymentDestination: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).PaymentMethod).optional(),
    paymentDestinationId: core.serialization.string().optional()
});

export declare namespace Invoice {
    interface Raw {
        \\"id\\"?: serializers.InvoiceId.Raw | null;
        \\"status\\"?: string | null;
        \\"amount\\"?: number | null;
        \\"currency\\"?: string | null;
        \\"dueDate\\"?: string | null;
        \\"invoiceNumber\\"?: string | null;
        \\"noteToSelf\\"?: string | null;
        \\"createdAt\\"?: string | null;
        \\"updatedAt\\"?: string | null;
        \\"vendorId\\"?: string | null;
        \\"vendor\\"?: serializers.Entity.Raw | null;
        \\"payerId\\"?: string | null;
        \\"payer\\"?: serializers.Entity.Raw | null;
        \\"paymentSource\\"?: serializers.PaymentMethod.Raw | null;
        \\"paymentSourceId\\"?: string | null;
        \\"paymentDestination\\"?: serializers.PaymentMethod.Raw | null;
        \\"paymentDestinationId\\"?: string | null;
    }
}
",
                    "name": "Invoice.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { MercoaApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const InvoiceId: core.serialization.Schema<serializers.InvoiceId.Raw, MercoaApi.InvoiceId> = core.serialization.string();

export declare namespace InvoiceId {
    type Raw = string;
}
",
                    "name": "InvoiceId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./Invoice\\";
export * from \\"./InvoiceId\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "invoice",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./service\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { MercoaApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const Response: core.serialization.Schema<serializers.paymentMethod.getAll.Response.Raw, MercoaApi.PaymentMethod[]> = core.serialization.list(core.serialization.lazyObject(async () => (await import(\\"../../..\\")).PaymentMethod));

export declare namespace Response {
    type Raw = serializers.PaymentMethod.Raw[];
}
",
                    "name": "getAll.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./requests\\";
export * as getAll from \\"./getAll\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { MercoaApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const CompleteMicroDepositsRequest: core.serialization.Schema<serializers.CompleteMicroDepositsRequest.Raw, MercoaApi.CompleteMicroDepositsRequest> = core.serialization.object({
    amounts: core.serialization.list(core.serialization.number()).optional()
});

export declare namespace CompleteMicroDepositsRequest {
    interface Raw {
        \\"amounts\\"?: number[] | null;
    }
}
",
                        "name": "CompleteMicroDepositsRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { CompleteMicroDepositsRequest } from \\"./CompleteMicroDepositsRequest\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "requests",
                    "type": "directory",
                  },
                ],
                "name": "service",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { MercoaApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const BankAccount: core.serialization.ObjectSchema<serializers.BankAccount.Raw, MercoaApi.BankAccount> = core.serialization.object({
    id: core.serialization.string().optional(),
    bankName: core.serialization.string(),
    accountName: core.serialization.string().optional(),
    routingNumber: core.serialization.string(),
    accountNumber: core.serialization.string(),
    accountType: core.serialization.string(),
    moovStatus: core.serialization.string()
});

export declare namespace BankAccount {
    interface Raw {
        \\"id\\"?: string | null;
        \\"bankName\\": string;
        \\"accountName\\"?: string | null;
        \\"routingNumber\\": string;
        \\"accountNumber\\": string;
        \\"accountType\\": string;
        \\"moovStatus\\": string;
    }
}
",
                    "name": "BankAccount.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { MercoaApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const Check: core.serialization.ObjectSchema<serializers.Check.Raw, MercoaApi.Check> = core.serialization.object({
    id: core.serialization.string().optional(),
    payToTheOrderOf: core.serialization.string(),
    addressLine1: core.serialization.string(),
    addressLine2: core.serialization.string().optional(),
    city: core.serialization.string(),
    stateOrProvince: core.serialization.string(),
    postalCode: core.serialization.string(),
    country: core.serialization.string()
});

export declare namespace Check {
    interface Raw {
        \\"id\\"?: string | null;
        \\"payToTheOrderOf\\": string;
        \\"addressLine1\\": string;
        \\"addressLine2\\"?: string | null;
        \\"city\\": string;
        \\"stateOrProvince\\": string;
        \\"postalCode\\": string;
        \\"country\\": string;
    }
}
",
                    "name": "Check.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { MercoaApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const PaymentMethod: core.serialization.ObjectSchema<serializers.PaymentMethod.Raw, MercoaApi.PaymentMethod> = core.serialization.object({
    id: core.serialization.lazy(async () => (await import(\\"../../..\\")).PaymentMethodId).optional(),
    type: core.serialization.string().optional(),
    bankAccount: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).BankAccount).optional(),
    check: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).Check).optional()
});

export declare namespace PaymentMethod {
    interface Raw {
        \\"id\\"?: serializers.PaymentMethodId.Raw | null;
        \\"type\\"?: string | null;
        \\"bankAccount\\"?: serializers.BankAccount.Raw | null;
        \\"check\\"?: serializers.Check.Raw | null;
    }
}
",
                    "name": "PaymentMethod.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { MercoaApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const PaymentMethodId: core.serialization.Schema<serializers.PaymentMethodId.Raw, MercoaApi.PaymentMethodId> = core.serialization.string();

export declare namespace PaymentMethodId {
    type Raw = string;
}
",
                    "name": "PaymentMethodId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./PaymentMethod\\";
export * from \\"./PaymentMethodId\\";
export * from \\"./BankAccount\\";
export * from \\"./Check\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "paymentMethod",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./service\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { MercoaApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const Response: core.serialization.Schema<serializers.representative.getAll.Response.Raw, MercoaApi.Representative[]> = core.serialization.list(core.serialization.lazyObject(async () => (await import(\\"../../..\\")).Representative));

export declare namespace Response {
    type Raw = serializers.Representative.Raw[];
}
",
                    "name": "getAll.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getAll from \\"./getAll\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "service",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { MercoaApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const IndividualGovernmentId: core.serialization.ObjectSchema<serializers.IndividualGovernmentId.Raw, MercoaApi.IndividualGovernmentId> = core.serialization.object({
    ssn: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).SocialSecurityNumber),
    itin: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).Itin)
});

export declare namespace IndividualGovernmentId {
    interface Raw {
        \\"ssn\\": serializers.SocialSecurityNumber.Raw;
        \\"itin\\": serializers.Itin.Raw;
    }
}
",
                    "name": "IndividualGovernmentId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { MercoaApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const Itin: core.serialization.ObjectSchema<serializers.Itin.Raw, MercoaApi.Itin> = core.serialization.object({
    full: core.serialization.string(),
    lastFour: core.serialization.string()
});

export declare namespace Itin {
    interface Raw {
        \\"full\\": string;
        \\"lastFour\\": string;
    }
}
",
                    "name": "Itin.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { MercoaApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const Representative: core.serialization.ObjectSchema<serializers.Representative.Raw, MercoaApi.Representative> = core.serialization.object({
    id: core.serialization.lazy(async () => (await import(\\"../../..\\")).RepresentativeId).optional(),
    name: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).FullName),
    phone: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).PhoneNumber),
    email: core.serialization.string(),
    address: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).Address),
    birthDateProvided: core.serialization.boolean().optional(),
    governmentIdProvided: core.serialization.property(\\"governmentIDProvided\\", core.serialization.boolean().optional()),
    birthDate: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).BirthDate).optional(),
    governmentId: core.serialization.property(\\"governmentID\\", core.serialization.lazyObject(async () => (await import(\\"../../..\\")).IndividualGovernmentId).optional()),
    responsibilities: core.serialization.lazyObject(async () => (await import(\\"../../..\\")).Responsibilities).optional(),
    createdOn: core.serialization.string().optional(),
    updatedOn: core.serialization.string().optional(),
    disabledOn: core.serialization.string().optional()
});

export declare namespace Representative {
    interface Raw {
        \\"id\\"?: serializers.RepresentativeId.Raw | null;
        \\"name\\": serializers.FullName.Raw;
        \\"phone\\": serializers.PhoneNumber.Raw;
        \\"email\\": string;
        \\"address\\": serializers.Address.Raw;
        \\"birthDateProvided\\"?: boolean | null;
        \\"governmentIDProvided\\"?: boolean | null;
        \\"birthDate\\"?: serializers.BirthDate.Raw | null;
        \\"governmentID\\"?: serializers.IndividualGovernmentId.Raw | null;
        \\"responsibilities\\"?: serializers.Responsibilities.Raw | null;
        \\"createdOn\\"?: string | null;
        \\"updatedOn\\"?: string | null;
        \\"disabledOn\\"?: string | null;
    }
}
",
                    "name": "Representative.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { MercoaApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const RepresentativeId: core.serialization.Schema<serializers.RepresentativeId.Raw, MercoaApi.RepresentativeId> = core.serialization.string();

export declare namespace RepresentativeId {
    type Raw = string;
}
",
                    "name": "RepresentativeId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { MercoaApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const Responsibilities: core.serialization.ObjectSchema<serializers.Responsibilities.Raw, MercoaApi.Responsibilities> = core.serialization.object({
    jobTitle: core.serialization.string().optional(),
    isController: core.serialization.boolean().optional(),
    isOwner: core.serialization.boolean().optional(),
    ownershipPercentage: core.serialization.number().optional()
});

export declare namespace Responsibilities {
    interface Raw {
        \\"jobTitle\\"?: string | null;
        \\"isController\\"?: boolean | null;
        \\"isOwner\\"?: boolean | null;
        \\"ownershipPercentage\\"?: number | null;
    }
}
",
                    "name": "Responsibilities.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../..\\";
import { MercoaApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const SocialSecurityNumber: core.serialization.ObjectSchema<serializers.SocialSecurityNumber.Raw, MercoaApi.SocialSecurityNumber> = core.serialization.object({
    full: core.serialization.string(),
    lastFour: core.serialization.string()
});

export declare namespace SocialSecurityNumber {
    interface Raw {
        \\"full\\": string;
        \\"lastFour\\": string;
    }
}
",
                    "name": "SocialSecurityNumber.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./Representative\\";
export * from \\"./RepresentativeId\\";
export * from \\"./Responsibilities\\";
export * from \\"./IndividualGovernmentId\\";
export * from \\"./SocialSecurityNumber\\";
export * from \\"./Itin\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "representative",
            "type": "directory",
          },
        ],
        "name": "resources",
        "type": "directory",
      },
    ],
    "name": "serialization",
    "type": "directory",
  },
]
`;
