// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`runGenerator trace 1`] = `
Array [
  Object {
    "contents": ".pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions
node_modules
.DS_Store
types
*.js
*.js.map",
    "name": ".gitignore",
    "type": "file",
  },
  Object {
    "contents": ".yarn
node_modules
.npmignore
.pnp.cjs
*.js
*.d.ts",
    "name": ".prettierignore",
    "type": "file",
  },
  Object {
    "contents": "nodeLinker: pnp

yarnPath: .yarn/releases/yarn-3.2.3.cjs
",
    "name": ".yarnrc.yml",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../core\\";
import { Client as AdminServiceClient } from \\"./admin/client/Client\\";
import { Client as HomepageProblemServiceClient } from \\"./homepage/client/Client\\";
import { Client as MigrationInfoServiceClient } from \\"./migration/client/Client\\";
import { Client as PlaylistCrudServiceClient } from \\"./playlist/client/Client\\";
import { Client as ProblemCrudServiceClient } from \\"./problem/client/Client\\";
import { Client as ExecutionSesssionManagementServiceClient } from \\"./submission/client/Client\\";
import { Client as SysPropCrudServiceClient } from \\"./sysprop/client/Client\\";
import { Wrapper as V2Wrapper } from \\"./v2/Wrapper\\";

export namespace Client {
  export interface Options {
    _origin: string;
    _token?: core.BearerToken;
    _credentials?: core.BasicAuth;
    xApiKey?: string;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  #admin: AdminServiceClient | undefined;

  public get admin(): AdminServiceClient {
    return (this.#admin ??= new AdminServiceClient({
      _origin: this.options._origin,
      _token: this.options._token,
      _credentials: this.options._credentials,
      xApiKey: this.options.xApiKey,
    }));
  }

  #homepage: HomepageProblemServiceClient | undefined;

  public get homepage(): HomepageProblemServiceClient {
    return (this.#homepage ??= new HomepageProblemServiceClient({
      _origin: this.options._origin,
      _token: this.options._token,
      _credentials: this.options._credentials,
      xApiKey: this.options.xApiKey,
    }));
  }

  #migration: MigrationInfoServiceClient | undefined;

  public get migration(): MigrationInfoServiceClient {
    return (this.#migration ??= new MigrationInfoServiceClient({
      _origin: this.options._origin,
      _token: this.options._token,
      _credentials: this.options._credentials,
      xApiKey: this.options.xApiKey,
    }));
  }

  #playlist: PlaylistCrudServiceClient | undefined;

  public get playlist(): PlaylistCrudServiceClient {
    return (this.#playlist ??= new PlaylistCrudServiceClient({
      _origin: this.options._origin,
      _token: this.options._token,
      _credentials: this.options._credentials,
      xApiKey: this.options.xApiKey,
    }));
  }

  #problem: ProblemCrudServiceClient | undefined;

  public get problem(): ProblemCrudServiceClient {
    return (this.#problem ??= new ProblemCrudServiceClient({
      _origin: this.options._origin,
      _token: this.options._token,
      _credentials: this.options._credentials,
      xApiKey: this.options.xApiKey,
    }));
  }

  #submission: ExecutionSesssionManagementServiceClient | undefined;

  public get submission(): ExecutionSesssionManagementServiceClient {
    return (this.#submission ??= new ExecutionSesssionManagementServiceClient({
      _origin: this.options._origin,
      _token: this.options._token,
      _credentials: this.options._credentials,
      xApiKey: this.options.xApiKey,
    }));
  }

  #sysprop: SysPropCrudServiceClient | undefined;

  public get sysprop(): SysPropCrudServiceClient {
    return (this.#sysprop ??= new SysPropCrudServiceClient({
      _origin: this.options._origin,
      _token: this.options._token,
      _credentials: this.options._credentials,
      xApiKey: this.options.xApiKey,
    }));
  }

  #v2: V2Wrapper | undefined;

  public get v2(): V2Wrapper {
    return (this.#v2 ??= new V2Wrapper(this.options));
  }
}
",
        "name": "Client.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";

export interface Client {
  updateTestSubmissionStatus(
    request: MyApi.admin.updateTestSubmissionStatus.Request
  ): Promise<MyApi.admin.updateTestSubmissionStatus.Response>;
  sendTestSubmissionUpdate(
    request: MyApi.admin.sendTestSubmissionUpdate.Request
  ): Promise<MyApi.admin.sendTestSubmissionUpdate.Response>;
  updateWorkspaceSubmissionStatus(
    request: MyApi.admin.updateWorkspaceSubmissionStatus.Request
  ): Promise<MyApi.admin.updateWorkspaceSubmissionStatus.Response>;
  sendWorkspaceSubmissionUpdate(
    request: MyApi.admin.sendWorkspaceSubmissionUpdate.Request
  ): Promise<MyApi.admin.sendWorkspaceSubmissionUpdate.Response>;
  storeTracedTestCase(
    request: MyApi.admin.storeTracedTestCase.Request
  ): Promise<MyApi.admin.storeTracedTestCase.Response>;
  storeTracedTestCaseV2(
    request: MyApi.admin.storeTracedTestCaseV2.Request
  ): Promise<MyApi.admin.storeTracedTestCaseV2.Response>;
  storeTracedWorkspace(
    request: MyApi.admin.storeTracedWorkspace.Request
  ): Promise<MyApi.admin.storeTracedWorkspace.Response>;
  storeTracedWorkspaceV2(
    request: MyApi.admin.storeTracedWorkspaceV2.Request
  ): Promise<MyApi.admin.storeTracedWorkspaceV2.Response>;
}

export declare namespace Client {
  interface Options {
    _origin: string;
    _token?: core.BearerToken;
    _credentials?: core.BasicAuth;
    xApiKey?: string;
  }
}

export class Client implements Client {
  constructor(private readonly options: Client.Options) {}

  public async updateTestSubmissionStatus(
    request: MyApi.admin.updateTestSubmissionStatus.Request
  ): Promise<MyApi.admin.updateTestSubmissionStatus.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/admin/store-test-submission-status/\${request.submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
      body: request._body,
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async sendTestSubmissionUpdate(
    request: MyApi.admin.sendTestSubmissionUpdate.Request
  ): Promise<MyApi.admin.sendTestSubmissionUpdate.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/admin/store-test-submission-status-v2/\${request.submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
      body: request._body,
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async updateWorkspaceSubmissionStatus(
    request: MyApi.admin.updateWorkspaceSubmissionStatus.Request
  ): Promise<MyApi.admin.updateWorkspaceSubmissionStatus.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/admin/store-workspace-submission-status/\${request.submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
      body: request._body,
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async sendWorkspaceSubmissionUpdate(
    request: MyApi.admin.sendWorkspaceSubmissionUpdate.Request
  ): Promise<MyApi.admin.sendWorkspaceSubmissionUpdate.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/admin/store-workspace-submission-status-v2/\${request.submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
      body: request._body,
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async storeTracedTestCase(
    request: MyApi.admin.storeTracedTestCase.Request
  ): Promise<MyApi.admin.storeTracedTestCase.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/admin/store-test-trace/submission/\${request.submissionId}/testCase/\${request.testCaseId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
      body: request._body,
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async storeTracedTestCaseV2(
    request: MyApi.admin.storeTracedTestCaseV2.Request
  ): Promise<MyApi.admin.storeTracedTestCaseV2.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/admin/store-test-trace-v2/submission/\${request.submissionId}/testCase/\${request.testCaseId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
      body: request._body,
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async storeTracedWorkspace(
    request: MyApi.admin.storeTracedWorkspace.Request
  ): Promise<MyApi.admin.storeTracedWorkspace.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/admin/store-workspace-trace/submission/\${request.submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
      body: request._body,
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async storeTracedWorkspaceV2(
    request: MyApi.admin.storeTracedWorkspaceV2.Request
  ): Promise<MyApi.admin.storeTracedWorkspaceV2.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/admin/store-workspace-trace-v2/submission/\${request.submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
      body: request._body,
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                "name": "Client.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as updateTestSubmissionStatus from \\"./updateTestSubmissionStatus\\";
export * as sendTestSubmissionUpdate from \\"./sendTestSubmissionUpdate\\";
export * as updateWorkspaceSubmissionStatus from \\"./updateWorkspaceSubmissionStatus\\";
export * as sendWorkspaceSubmissionUpdate from \\"./sendWorkspaceSubmissionUpdate\\";
export * as storeTracedTestCase from \\"./storeTracedTestCase\\";
export * as storeTracedTestCaseV2 from \\"./storeTracedTestCaseV2\\";
export * as storeTracedWorkspace from \\"./storeTracedWorkspace\\";
export * as storeTracedWorkspaceV2 from \\"./storeTracedWorkspaceV2\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  submissionId: MyApi.submission.SubmissionId;
  _body: MyApi.submission.TestSubmissionUpdate;
}

export type Response = core.APIResponse<
  void,
  MyApi.admin.sendTestSubmissionUpdate.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "sendTestSubmissionUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  submissionId: MyApi.submission.SubmissionId;
  _body: MyApi.submission.WorkspaceSubmissionUpdate;
}

export type Response = core.APIResponse<
  void,
  MyApi.admin.sendWorkspaceSubmissionUpdate.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "sendWorkspaceSubmissionUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  submissionId: MyApi.submission.SubmissionId;
  testCaseId: string;
  _body: MyApi.admin.StoreTracedTestCaseRequest;
}

export type Response = core.APIResponse<
  void,
  MyApi.admin.storeTracedTestCase.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "storeTracedTestCase.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  submissionId: MyApi.submission.SubmissionId;
  testCaseId: MyApi.v2.problem.TestCaseId;
  _body: MyApi.submission.TraceResponseV2[];
}

export type Response = core.APIResponse<
  void,
  MyApi.admin.storeTracedTestCaseV2.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "storeTracedTestCaseV2.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  submissionId: MyApi.submission.SubmissionId;
  _body: MyApi.admin.StoreTracedWorkspaceRequest;
}

export type Response = core.APIResponse<
  void,
  MyApi.admin.storeTracedWorkspace.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "storeTracedWorkspace.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  submissionId: MyApi.submission.SubmissionId;
  _body: MyApi.submission.TraceResponseV2[];
}

export type Response = core.APIResponse<
  void,
  MyApi.admin.storeTracedWorkspaceV2.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "storeTracedWorkspaceV2.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  submissionId: MyApi.submission.SubmissionId;
  _body: MyApi.submission.TestSubmissionStatus;
}

export type Response = core.APIResponse<
  void,
  MyApi.admin.updateTestSubmissionStatus.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "updateTestSubmissionStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  submissionId: MyApi.submission.SubmissionId;
  _body: MyApi.submission.WorkspaceSubmissionStatus;
}

export type Response = core.APIResponse<
  void,
  MyApi.admin.updateWorkspaceSubmissionStatus.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "updateWorkspaceSubmissionStatus.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "admin",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./types\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "commons",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as schemas from \\"../../../schemas\\";

export interface Client {
  getHomepageProblems(): Promise<MyApi.homepage.getHomepageProblems.Response>;
  setHomepageProblems(
    request: MyApi.commons.ProblemId[]
  ): Promise<MyApi.homepage.setHomepageProblems.Response>;
}

export declare namespace Client {
  interface Options {
    _origin: string;
    _token?: core.BearerToken;
    _credentials?: core.BasicAuth;
    xApiKey?: string;
  }
}

export class Client implements Client {
  constructor(private readonly options: Client.Options) {}

  public async getHomepageProblems(): Promise<MyApi.homepage.getHomepageProblems.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/homepage-problems/\\"),
      method: \\"GET\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.homepage.getHomepageProblems.Response.parse(
          response.body as schemas.commons.ProblemId.Raw[]
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async setHomepageProblems(
    request: MyApi.commons.ProblemId[]
  ): Promise<MyApi.homepage.setHomepageProblems.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/homepage-problems/\\"),
      method: \\"POST\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
      body: schemas.homepage.setHomepageProblems.Request.json(request),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                "name": "Client.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  MyApi.commons.ProblemId[],
  MyApi.homepage.getHomepageProblems.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "getHomepageProblems.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as getHomepageProblems from \\"./getHomepageProblems\\";
export * as setHomepageProblems from \\"./setHomepageProblems\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  void,
  MyApi.homepage.setHomepageProblems.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "setHomepageProblems.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "homepage",
        "type": "directory",
      },
      Object {
        "contents": "export * as admin from \\"./admin\\";
export * from \\"./admin/types\\";
export * as commons from \\"./commons\\";
export * from \\"./commons/types\\";
export * as langServer from \\"./lang-server\\";
export * from \\"./lang-server/types\\";
export * as migration from \\"./migration\\";
export * from \\"./migration/types\\";
export * as playlist from \\"./playlist\\";
export * from \\"./playlist/types\\";
export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as submission from \\"./submission\\";
export * from \\"./submission/types\\";
export * as v2 from \\"./v2\\";
export * from \\"./playlist/errors\\";
export * as homepage from \\"./homepage\\";
export * as sysprop from \\"./sysprop\\";
export * from \\"./Client\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./types\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "lang-server",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as schemas from \\"../../../schemas\\";

export interface Client {
  getAttemptedMigrations(): Promise<MyApi.migration.getAttemptedMigrations.Response>;
}

export declare namespace Client {
  interface Options {
    _origin: string;
    _token?: core.BearerToken;
    _credentials?: core.BasicAuth;
    xApiKey?: string;
  }
}

export class Client implements Client {
  constructor(private readonly options: Client.Options) {}

  public async getAttemptedMigrations(): Promise<MyApi.migration.getAttemptedMigrations.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/migration-info/all\\"),
      method: \\"GET\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.migration.getAttemptedMigrations.Response.parse(
          response.body as schemas.migration.Migration.Raw[]
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                "name": "Client.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  MyApi.migration.Migration[],
  MyApi.migration.getAttemptedMigrations.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "getAttemptedMigrations.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as getAttemptedMigrations from \\"./getAttemptedMigrations\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "migration",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as schemas from \\"../../../schemas\\";

export interface Client {
  createPlaylist(
    request: MyApi.playlist.createPlaylist.Request
  ): Promise<MyApi.playlist.createPlaylist.Response>;
  getPlaylists(
    request: MyApi.playlist.getPlaylists.Request
  ): Promise<MyApi.playlist.getPlaylists.Response>;
  getPlaylist(
    request: MyApi.playlist.getPlaylist.Request
  ): Promise<MyApi.playlist.getPlaylist.Response>;
  updatePlaylist(
    request: MyApi.playlist.updatePlaylist.Request
  ): Promise<MyApi.playlist.updatePlaylist.Response>;
  deletePlaylist(
    request: MyApi.playlist.deletePlaylist.Request
  ): Promise<MyApi.playlist.deletePlaylist.Response>;
}

export declare namespace Client {
  interface Options {
    _origin: string;
    _token?: core.BearerToken;
    _credentials?: core.BasicAuth;
    xApiKey?: string;
  }
}

export class Client implements Client {
  constructor(private readonly options: Client.Options) {}

  public async createPlaylist(
    request: MyApi.playlist.createPlaylist.Request
  ): Promise<MyApi.playlist.createPlaylist.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/v2/playlist/\${request.serviceParam}create\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
      body: request._body,
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.playlist.Playlist.parse(
          response.body as schemas.playlist.Playlist.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getPlaylists(
    request: MyApi.playlist.getPlaylists.Request
  ): Promise<MyApi.playlist.getPlaylists.Response> {
    const queryParameters = new URLSearchParams();
    if (request.limit != null) {
      queryParameters.append(\\"limit\\", request.limit.toString());
    }

    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/v2/playlist/\${request.serviceParam}all\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
      queryParameters: queryParameters,
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.playlist.getPlaylists.Response.parse(
          response.body as schemas.playlist.Playlist.Raw[]
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getPlaylist(
    request: MyApi.playlist.getPlaylist.Request
  ): Promise<MyApi.playlist.getPlaylist.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/v2/playlist/\${request.serviceParam}\${request.playlistId}\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.playlist.Playlist.parse(
          response.body as schemas.playlist.Playlist.Raw
        ),
      };
    }

    if (response.error.reason === \\"status-code\\") {
      switch (
        (response.error.body as schemas.playlist.getPlaylist.Error.Raw)
          ?.errorName
      ) {
        case \\"PlaylistIdNotFoundError\\":
        case \\"UnauthorizedError\\":
          return {
            ok: false,
            error: schemas.playlist.getPlaylist.Error.parse(
              response.error.body as schemas.playlist.getPlaylist.Error.Raw
            ),
          };
      }
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async updatePlaylist(
    request: MyApi.playlist.updatePlaylist.Request
  ): Promise<MyApi.playlist.updatePlaylist.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/v2/playlist/\${request.serviceParam}\${request.playlistId}\`
      ),
      method: \\"PUT\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
      body: request._body,
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.playlist.updatePlaylist.Response.parse(
          response.body as schemas.playlist.Playlist.Raw | null | undefined
        ),
      };
    }

    if (response.error.reason === \\"status-code\\") {
      switch (
        (response.error.body as schemas.playlist.updatePlaylist.Error.Raw)
          ?.errorName
      ) {
        case \\"PlaylistIdNotFoundError\\":
          return {
            ok: false,
            error: schemas.playlist.updatePlaylist.Error.parse(
              response.error.body as schemas.playlist.updatePlaylist.Error.Raw
            ),
          };
      }
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async deletePlaylist(
    request: MyApi.playlist.deletePlaylist.Request
  ): Promise<MyApi.playlist.deletePlaylist.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/v2/playlist/\${request.serviceParam}\${request.playlistId}\`
      ),
      method: \\"DELETE\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                "name": "Client.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  serviceParam: number;
  _body: MyApi.playlist.PlaylistCreateRequest;
}

export type Response = core.APIResponse<
  MyApi.playlist.Playlist,
  MyApi.playlist.createPlaylist.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "createPlaylist.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  serviceParam: number;
  playlistId: MyApi.playlist.PlaylistId;
}

export type Response = core.APIResponse<
  void,
  MyApi.playlist.deletePlaylist.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "deletePlaylist.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  serviceParam: number;
  playlistId: MyApi.playlist.PlaylistId;
}

export type Response = core.APIResponse<
  MyApi.playlist.Playlist,
  MyApi.playlist.getPlaylist.Error
>;
export type Error =
  | Error.PlaylistIdNotFoundError
  | Error.UnauthorizedError
  | Error._Unknown;

export declare namespace Error {
  interface PlaylistIdNotFoundError extends _Utils {
    errorName: \\"PlaylistIdNotFoundError\\";
    content: MyApi.playlist.PlaylistIdNotFoundError;
  }

  interface UnauthorizedError extends _Utils {
    errorName: \\"UnauthorizedError\\";
  }

  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    playlistIdNotFoundError: (
      value: MyApi.playlist.PlaylistIdNotFoundError
    ) => Result;
    unauthorizedError: () => Result;
    _other: (value: core.Fetcher.Error) => Result;
  }
}

export const Error = {
  playlistIdNotFoundError: (
    value: MyApi.playlist.PlaylistIdNotFoundError
  ): Error.PlaylistIdNotFoundError => ({
    content: value,
    errorName: \\"PlaylistIdNotFoundError\\",
    _visit: (visitor) => visitor.playlistIdNotFoundError(value),
  }),

  unauthorizedError: (): Error.UnauthorizedError => ({
    errorName: \\"UnauthorizedError\\",
    _visit: (visitor) => visitor.unauthorizedError(),
  }),
} as const;
",
                "name": "getPlaylist.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  limit?: number;
  serviceParam: number;
}

export type Response = core.APIResponse<
  MyApi.playlist.Playlist[],
  MyApi.playlist.getPlaylists.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "getPlaylists.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as createPlaylist from \\"./createPlaylist\\";
export * as getPlaylists from \\"./getPlaylists\\";
export * as getPlaylist from \\"./getPlaylist\\";
export * as updatePlaylist from \\"./updatePlaylist\\";
export * as deletePlaylist from \\"./deletePlaylist\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  serviceParam: number;
  playlistId: MyApi.playlist.PlaylistId;
  _body?: MyApi.playlist.UpdatePlaylistRequest;
}

export type Response = core.APIResponse<
  MyApi.playlist.Playlist | undefined,
  MyApi.playlist.updatePlaylist.Error
>;
export type Error = Error.PlaylistIdNotFoundError | Error._Unknown;

export declare namespace Error {
  interface PlaylistIdNotFoundError extends _Utils {
    errorName: \\"PlaylistIdNotFoundError\\";
    content: MyApi.playlist.PlaylistIdNotFoundError;
  }

  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    playlistIdNotFoundError: (
      value: MyApi.playlist.PlaylistIdNotFoundError
    ) => Result;
    _other: (value: core.Fetcher.Error) => Result;
  }
}

export const Error = {
  playlistIdNotFoundError: (
    value: MyApi.playlist.PlaylistIdNotFoundError
  ): Error.PlaylistIdNotFoundError => ({
    content: value,
    errorName: \\"PlaylistIdNotFoundError\\",
    _visit: (visitor) => visitor.playlistIdNotFoundError(value),
  }),
} as const;
",
                "name": "updatePlaylist.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { MyApi } from \\"../../..\\";

export type PlaylistIdNotFoundError =
  | PlaylistIdNotFoundError.PlaylistId
  | PlaylistIdNotFoundError._Unknown;

export declare namespace PlaylistIdNotFoundError {
  interface PlaylistId extends _Utils {
    type: \\"playlistId\\";
    value: MyApi.playlist.PlaylistId;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(
      visitor: PlaylistIdNotFoundError._Visitor<Result>
    ) => Result;
  }

  interface _Visitor<Result> {
    playlistId: (value: MyApi.playlist.PlaylistId) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const PlaylistIdNotFoundError = {
  playlistId: (
    value: MyApi.playlist.PlaylistId
  ): PlaylistIdNotFoundError.PlaylistId => ({
    value: value,
    type: \\"playlistId\\",
    _visit: (visitor) => visitor.playlistId(value),
  }),
} as const;
",
                "name": "PlaylistIdNotFoundError.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./PlaylistIdNotFoundError\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "errors",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./errors\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "playlist",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as schemas from \\"../../../schemas\\";

export interface Client {
  createProblem(
    request: MyApi.problem.CreateProblemRequest
  ): Promise<MyApi.problem.createProblem.Response>;
  updateProblem(
    request: MyApi.problem.updateProblem.Request
  ): Promise<MyApi.problem.updateProblem.Response>;
  deleteProblem(
    request: MyApi.problem.deleteProblem.Request
  ): Promise<MyApi.problem.deleteProblem.Response>;
  getDefaultStarterFiles(
    request: MyApi.problem.GetDefaultStarterFilesRequest
  ): Promise<MyApi.problem.getDefaultStarterFiles.Response>;
}

export declare namespace Client {
  interface Options {
    _origin: string;
    _token?: core.BearerToken;
    _credentials?: core.BasicAuth;
    xApiKey?: string;
  }
}

export class Client implements Client {
  constructor(private readonly options: Client.Options) {}

  public async createProblem(
    request: MyApi.problem.CreateProblemRequest
  ): Promise<MyApi.problem.createProblem.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/problem-crud/create\\"),
      method: \\"POST\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
      body: schemas.problem.CreateProblemRequest.json(request),
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.problem.CreateProblemResponse.parse(
          response.body as schemas.problem.CreateProblemResponse.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async updateProblem(
    request: MyApi.problem.updateProblem.Request
  ): Promise<MyApi.problem.updateProblem.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/problem-crud/update/\${request.problemId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
      body: request._body,
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.problem.UpdateProblemResponse.parse(
          response.body as schemas.problem.UpdateProblemResponse.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async deleteProblem(
    request: MyApi.problem.deleteProblem.Request
  ): Promise<MyApi.problem.deleteProblem.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/problem-crud/delete/\${request.problemId}\`
      ),
      method: \\"DELETE\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getDefaultStarterFiles(
    request: MyApi.problem.GetDefaultStarterFilesRequest
  ): Promise<MyApi.problem.getDefaultStarterFiles.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/problem-crud/default-starter-files\\"),
      method: \\"POST\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
      body: schemas.problem.GetDefaultStarterFilesRequest.json(request),
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.problem.GetDefaultStarterFilesResponse.parse(
          response.body as schemas.problem.GetDefaultStarterFilesResponse.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                "name": "Client.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  MyApi.problem.CreateProblemResponse,
  MyApi.problem.createProblem.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "createProblem.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  problemId: MyApi.commons.ProblemId;
}

export type Response = core.APIResponse<
  void,
  MyApi.problem.deleteProblem.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "deleteProblem.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  MyApi.problem.GetDefaultStarterFilesResponse,
  MyApi.problem.getDefaultStarterFiles.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "getDefaultStarterFiles.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as createProblem from \\"./createProblem\\";
export * as updateProblem from \\"./updateProblem\\";
export * as deleteProblem from \\"./deleteProblem\\";
export * as getDefaultStarterFiles from \\"./getDefaultStarterFiles\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  problemId: MyApi.commons.ProblemId;
  _body: MyApi.problem.CreateProblemRequest;
}

export type Response = core.APIResponse<
  MyApi.problem.UpdateProblemResponse,
  MyApi.problem.updateProblem.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "updateProblem.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "problem",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as schemas from \\"../../../schemas\\";

export interface Client {
  createExecutionSession(
    request: MyApi.submission.createExecutionSession.Request
  ): Promise<MyApi.submission.createExecutionSession.Response>;
  getExecutionSession(
    request: MyApi.submission.getExecutionSession.Request
  ): Promise<MyApi.submission.getExecutionSession.Response>;
  stopExecutionSession(
    request: MyApi.submission.stopExecutionSession.Request
  ): Promise<MyApi.submission.stopExecutionSession.Response>;
  getExecutionSessionsState(): Promise<MyApi.submission.getExecutionSessionsState.Response>;
}

export declare namespace Client {
  interface Options {
    _origin: string;
    _token?: core.BearerToken;
    _credentials?: core.BasicAuth;
    xApiKey?: string;
  }
}

/**
 * Responsible for spinning up and spinning down execution.
 */
export class Client implements Client {
  constructor(private readonly options: Client.Options) {}

  public async createExecutionSession(
    request: MyApi.submission.createExecutionSession.Request
  ): Promise<MyApi.submission.createExecutionSession.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/sessions/create-session/\${request.language}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.submission.ExecutionSessionResponse.parse(
          response.body as schemas.submission.ExecutionSessionResponse.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getExecutionSession(
    request: MyApi.submission.getExecutionSession.Request
  ): Promise<MyApi.submission.getExecutionSession.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \`/sessions/\${request.sessionId}\`),
      method: \\"GET\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.submission.getExecutionSession.Response.parse(
          response.body as
            | schemas.submission.ExecutionSessionResponse.Raw
            | null
            | undefined
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async stopExecutionSession(
    request: MyApi.submission.stopExecutionSession.Request
  ): Promise<MyApi.submission.stopExecutionSession.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \`/sessions/stop/\${request.sessionId}\`),
      method: \\"DELETE\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getExecutionSessionsState(): Promise<MyApi.submission.getExecutionSessionsState.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/sessions/execution-sessions-state\\"),
      method: \\"GET\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.submission.GetExecutionSessionStateResponse.parse(
          response.body as schemas.submission.GetExecutionSessionStateResponse.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                "name": "Client.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  language: MyApi.commons.Language;
}

export type Response = core.APIResponse<
  MyApi.submission.ExecutionSessionResponse,
  MyApi.submission.createExecutionSession.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "createExecutionSession.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  sessionId: string;
}

export type Response = core.APIResponse<
  MyApi.submission.ExecutionSessionResponse | undefined,
  MyApi.submission.getExecutionSession.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "getExecutionSession.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  MyApi.submission.GetExecutionSessionStateResponse,
  MyApi.submission.getExecutionSessionsState.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "getExecutionSessionsState.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as createExecutionSession from \\"./createExecutionSession\\";
export * as getExecutionSession from \\"./getExecutionSession\\";
export * as stopExecutionSession from \\"./stopExecutionSession\\";
export * as getExecutionSessionsState from \\"./getExecutionSessionsState\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  sessionId: string;
}

export type Response = core.APIResponse<
  void,
  MyApi.submission.stopExecutionSession.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "stopExecutionSession.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "submission",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as schemas from \\"../../../schemas\\";

export interface Client {
  setNumWarmInstances(
    request: MyApi.sysprop.setNumWarmInstances.Request
  ): Promise<MyApi.sysprop.setNumWarmInstances.Response>;
  getNumWarmInstances(): Promise<MyApi.sysprop.getNumWarmInstances.Response>;
}

export declare namespace Client {
  interface Options {
    _origin: string;
    _token?: core.BearerToken;
    _credentials?: core.BasicAuth;
    xApiKey?: string;
  }
}

export class Client implements Client {
  constructor(private readonly options: Client.Options) {}

  public async setNumWarmInstances(
    request: MyApi.sysprop.setNumWarmInstances.Request
  ): Promise<MyApi.sysprop.setNumWarmInstances.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/sysprop/num-warm-instances/\${request.language}/\${request.numWarmInstances}\`
      ),
      method: \\"PUT\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getNumWarmInstances(): Promise<MyApi.sysprop.getNumWarmInstances.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/sysprop/num-warm-instances\\"),
      method: \\"GET\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.sysprop.getNumWarmInstances.Response.parse(
          response.body as Record<schemas.commons.Language.Raw, number>
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                "name": "Client.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  Record<MyApi.commons.Language.RawValue, number>,
  MyApi.sysprop.getNumWarmInstances.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "getNumWarmInstances.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as setNumWarmInstances from \\"./setNumWarmInstances\\";
export * as getNumWarmInstances from \\"./getNumWarmInstances\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  language: MyApi.commons.Language;
  numWarmInstances: number;
}

export type Response = core.APIResponse<
  void,
  MyApi.sysprop.setNumWarmInstances.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "setNumWarmInstances.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "sysprop",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../core\\";
import { Client as ProblemInfoServicV2Client } from \\"./problem/client/Client\\";
import { Wrapper as V3Wrapper } from \\"./v3/Wrapper\\";

export namespace Wrapper {
  export interface Options {
    _origin: string;
    _token?: core.BearerToken;
    _credentials?: core.BasicAuth;
    xApiKey?: string;
  }
}

export class Wrapper {
  constructor(private readonly options: Wrapper.Options) {}

  #problem: ProblemInfoServicV2Client | undefined;

  public get problem(): ProblemInfoServicV2Client {
    return (this.#problem ??= new ProblemInfoServicV2Client({
      _origin: this.options._origin,
      _token: this.options._token,
      _credentials: this.options._credentials,
      xApiKey: this.options.xApiKey,
    }));
  }

  #v3: V3Wrapper | undefined;

  public get v3(): V3Wrapper {
    return (this.#v3 ??= new V3Wrapper(this.options));
  }
}
",
            "name": "Wrapper.ts",
            "type": "file",
          },
          Object {
            "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as v3 from \\"./v3\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";
import urlJoin from \\"url-join\\";
import * as schemas from \\"../../../../schemas\\";

export interface Client {
  getLightweightProblems(): Promise<MyApi.v2.problem.getLightweightProblems.Response>;
  getProblems(): Promise<MyApi.v2.problem.getProblems.Response>;
  getLatestProblem(
    request: MyApi.v2.problem.getLatestProblem.Request
  ): Promise<MyApi.v2.problem.getLatestProblem.Response>;
  getProblemVersion(
    request: MyApi.v2.problem.getProblemVersion.Request
  ): Promise<MyApi.v2.problem.getProblemVersion.Response>;
}

export declare namespace Client {
  interface Options {
    _origin: string;
    _token?: core.BearerToken;
    _credentials?: core.BasicAuth;
    xApiKey?: string;
  }
}

export class Client implements Client {
  constructor(private readonly options: Client.Options) {}

  public async getLightweightProblems(): Promise<MyApi.v2.problem.getLightweightProblems.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \\"/problems-v2/lightweight-problem-info\\"
      ),
      method: \\"GET\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.v2.problem.getLightweightProblems.Response.parse(
          response.body as schemas.v2.problem.LightweightProblemInfoV2.Raw[]
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getProblems(): Promise<MyApi.v2.problem.getProblems.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/problems-v2/problem-info\\"),
      method: \\"GET\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.v2.problem.getProblems.Response.parse(
          response.body as schemas.v2.problem.ProblemInfoV2.Raw[]
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getLatestProblem(
    request: MyApi.v2.problem.getLatestProblem.Request
  ): Promise<MyApi.v2.problem.getLatestProblem.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/problems-v2/problem-info/\${request.problemId}\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.v2.problem.ProblemInfoV2.parse(
          response.body as schemas.v2.problem.ProblemInfoV2.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getProblemVersion(
    request: MyApi.v2.problem.getProblemVersion.Request
  ): Promise<MyApi.v2.problem.getProblemVersion.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/problems-v2/problem-info/\${request.problemId}/version/\${request.problemVersion}\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.v2.problem.ProblemInfoV2.parse(
          response.body as schemas.v2.problem.ProblemInfoV2.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  problemId: MyApi.commons.ProblemId;
}

export type Response = core.APIResponse<
  MyApi.v2.problem.ProblemInfoV2,
  MyApi.v2.problem.getLatestProblem.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "getLatestProblem.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export type Response = core.APIResponse<
  MyApi.v2.problem.LightweightProblemInfoV2[],
  MyApi.v2.problem.getLightweightProblems.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "getLightweightProblems.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  problemId: MyApi.commons.ProblemId;
  problemVersion: number;
}

export type Response = core.APIResponse<
  MyApi.v2.problem.ProblemInfoV2,
  MyApi.v2.problem.getProblemVersion.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "getProblemVersion.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export type Response = core.APIResponse<
  MyApi.v2.problem.ProblemInfoV2[],
  MyApi.v2.problem.getProblems.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "getProblems.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
export * as getLatestProblem from \\"./getLatestProblem\\";
export * as getProblemVersion from \\"./getProblemVersion\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "problem",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../core\\";
import { Client as ProblemInfoServicV2Client } from \\"./problem/client/Client\\";

export namespace Wrapper {
  export interface Options {
    _origin: string;
    _token?: core.BearerToken;
    _credentials?: core.BasicAuth;
    xApiKey?: string;
  }
}

export class Wrapper {
  constructor(private readonly options: Wrapper.Options) {}

  #problem: ProblemInfoServicV2Client | undefined;

  public get problem(): ProblemInfoServicV2Client {
    return (this.#problem ??= new ProblemInfoServicV2Client({
      _origin: this.options._origin,
      _token: this.options._token,
      _credentials: this.options._credentials,
      xApiKey: this.options.xApiKey,
    }));
  }
}
",
                "name": "Wrapper.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";
import urlJoin from \\"url-join\\";
import * as schemas from \\"../../../../../schemas\\";

export interface Client {
  getLightweightProblems(): Promise<MyApi.v2.v3.problem.getLightweightProblems.Response>;
  getProblems(): Promise<MyApi.v2.v3.problem.getProblems.Response>;
  getLatestProblem(
    request: MyApi.v2.v3.problem.getLatestProblem.Request
  ): Promise<MyApi.v2.v3.problem.getLatestProblem.Response>;
  getProblemVersion(
    request: MyApi.v2.v3.problem.getProblemVersion.Request
  ): Promise<MyApi.v2.v3.problem.getProblemVersion.Response>;
}

export declare namespace Client {
  interface Options {
    _origin: string;
    _token?: core.BearerToken;
    _credentials?: core.BasicAuth;
    xApiKey?: string;
  }
}

export class Client implements Client {
  constructor(private readonly options: Client.Options) {}

  public async getLightweightProblems(): Promise<MyApi.v2.v3.problem.getLightweightProblems.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \\"/problems-v2/lightweight-problem-info\\"
      ),
      method: \\"GET\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.v2.v3.problem.getLightweightProblems.Response.parse(
          response.body as schemas.v2.v3.problem.LightweightProblemInfoV2.Raw[]
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getProblems(): Promise<MyApi.v2.v3.problem.getProblems.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/problems-v2/problem-info\\"),
      method: \\"GET\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.v2.v3.problem.getProblems.Response.parse(
          response.body as schemas.v2.v3.problem.ProblemInfoV2.Raw[]
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getLatestProblem(
    request: MyApi.v2.v3.problem.getLatestProblem.Request
  ): Promise<MyApi.v2.v3.problem.getLatestProblem.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/problems-v2/problem-info/\${request.problemId}\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.v2.v3.problem.ProblemInfoV2.parse(
          response.body as schemas.v2.v3.problem.ProblemInfoV2.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getProblemVersion(
    request: MyApi.v2.v3.problem.getProblemVersion.Request
  ): Promise<MyApi.v2.v3.problem.getProblemVersion.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/problems-v2/problem-info/\${request.problemId}/version/\${request.problemVersion}\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.v2.v3.problem.ProblemInfoV2.parse(
          response.body as schemas.v2.v3.problem.ProblemInfoV2.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                        "name": "Client.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  problemId: MyApi.commons.ProblemId;
}

export type Response = core.APIResponse<
  MyApi.v2.v3.problem.ProblemInfoV2,
  MyApi.v2.v3.problem.getLatestProblem.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                        "name": "getLatestProblem.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export type Response = core.APIResponse<
  MyApi.v2.v3.problem.LightweightProblemInfoV2[],
  MyApi.v2.v3.problem.getLightweightProblems.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                        "name": "getLightweightProblems.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  problemId: MyApi.commons.ProblemId;
  problemVersion: number;
}

export type Response = core.APIResponse<
  MyApi.v2.v3.problem.ProblemInfoV2,
  MyApi.v2.v3.problem.getProblemVersion.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                        "name": "getProblemVersion.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export type Response = core.APIResponse<
  MyApi.v2.v3.problem.ProblemInfoV2[],
  MyApi.v2.v3.problem.getProblems.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                        "name": "getProblems.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
export * as getLatestProblem from \\"./getLatestProblem\\";
export * as getProblemVersion from \\"./getProblemVersion\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "problem",
                "type": "directory",
              },
            ],
            "name": "v3",
            "type": "directory",
          },
        ],
        "name": "v2",
        "type": "directory",
      },
    ],
    "name": "api",
    "type": "directory",
  },
  Object {
    "contents": Array [
      Object {
        "contents": Array [
          Object {
            "contents": "import { parse } from \\"basic-auth\\";
import { Base64 } from \\"js-base64\\";

export interface BasicAuth {
  username: string;
  password: string;
}

export const BasicAuth = {
  toAuthorizationHeader: (basicAuth: BasicAuth): string => {
    const token = Base64.encode(\`\${basicAuth.username}:\${basicAuth.password}\`);
    return \`Basic \${token}\`;
  },
  fromAuthorizationHeader: (header: string): BasicAuth => {
    const parsed = parse(header);
    if (parsed == null) {
      throw new Error(\\"Invalid basic auth\\");
    }
    return {
      username: parsed.name,
      password: parsed.pass,
    };
  },
};
",
            "name": "BasicAuth.ts",
            "type": "file",
          },
          Object {
            "contents": "export type BearerToken = string;

const BEARER_AUTH_HEADER_PREFIX = /^Bearer /i;

export const BearerToken = {
  toAuthorizationHeader: (token: BearerToken): string => {
    return \`Bearer \${token}\`;
  },
  fromAuthorizationHeader: (header: string): BearerToken => {
    return header.replace(BEARER_AUTH_HEADER_PREFIX, \\"\\").trim() as BearerToken;
  },
};
",
            "name": "BearerToken.ts",
            "type": "file",
          },
          Object {
            "contents": "export { BasicAuth } from \\"./BasicAuth\\";
export { BearerToken } from \\"./BearerToken\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "auth",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export type APIResponse<Success, Failure> =
  | SuccessfulResponse<Success>
  | FailedResponse<Failure>;

export interface SuccessfulResponse<T> {
  ok: true;
  body: T;
}

export interface FailedResponse<T> {
  ok: false;
  error: T;
}
",
            "name": "APIResponse.ts",
            "type": "file",
          },
          Object {
            "contents": "import axios, { AxiosError } from \\"axios\\";
import { APIResponse } from \\"./APIResponse\\";

export interface Fetcher {
  fetch: FetchFunction;
}

export type FetchFunction = (
  args: Fetcher.Args
) => Promise<APIResponse<unknown, Fetcher.Error>>;

export declare namespace Fetcher {
  export interface Args {
    url: string;
    method: string;
    headers?: Record<string, string | undefined>;
    queryParameters?: URLSearchParams;
    body?: unknown;
    timeoutMs?: number;
  }

  export type Error =
    | FailedStatusCodeError
    | NonJsonError
    | TimeoutError
    | UnknownError;

  export interface FailedStatusCodeError {
    reason: \\"status-code\\";
    statusCode: number;
    body: unknown;
  }

  export interface NonJsonError {
    reason: \\"non-json\\";
    statusCode: number;
    rawBody: string;
  }

  export interface TimeoutError {
    reason: \\"timeout\\";
  }

  export interface UnknownError {
    reason: \\"unknown\\";
    errorMessage: string;
  }
}

export const fetcher: FetchFunction = async (args) => {
  const headers: Record<string, string> = {
    \\"Content-Type\\": \\"application/json\\",
  };

  if (args.headers != null) {
    for (const [key, value] of Object.entries(args.headers)) {
      if (value != null) {
        headers[key] = value;
      }
    }
  }

  try {
    const response = await axios({
      url: args.url,
      params: args.queryParameters,
      method: args.method,
      headers,
      data: args.body,
      validateStatus: () => true,
      transformResponse: (response) => response,
      timeout: args.timeoutMs ?? 60_000,
      transitional: {
        clarifyTimeoutError: true,
      },
    });

    let body: unknown;
    if (response.data != null) {
      try {
        body = JSON.parse(response.data) ?? undefined;
      } catch {
        return {
          ok: false,
          error: {
            reason: \\"non-json\\",
            statusCode: response.status,
            rawBody: response.data,
          },
        };
      }
    }

    if (response.status >= 200 && response.status < 300) {
      return {
        ok: true,
        body,
      };
    } else {
      return {
        ok: false,
        error: {
          reason: \\"status-code\\",
          statusCode: response.status,
          body,
        },
      };
    }
  } catch (error) {
    if ((error as AxiosError).code === \\"ETIMEDOUT\\") {
      return {
        ok: false,
        error: {
          reason: \\"timeout\\",
        },
      };
    }

    return {
      ok: false,
      error: {
        reason: \\"unknown\\",
        errorMessage: (error as AxiosError).message,
      },
    };
  }
};
",
            "name": "Fetcher.ts",
            "type": "file",
          },
          Object {
            "contents": "export { type APIResponse } from \\"./APIResponse\\";
export { fetcher, type Fetcher, type FetchFunction } from \\"./Fetcher\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "fetcher",
        "type": "directory",
      },
      Object {
        "contents": "export * as schemas from \\"./schemas\\";
export * from \\"./auth\\";
export * from \\"./fetcher\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "import { SchemaUtils } from \\"./builders\\";

export type Schema<Raw = unknown, Parsed = unknown> = BaseSchema<Raw, Parsed> &
  SchemaUtils<Raw, Parsed>;

export type inferRaw<S extends Schema> = S extends Schema<infer Raw, any>
  ? Raw
  : never;
export type inferParsed<S extends Schema> = S extends Schema<any, infer Parsed>
  ? Parsed
  : never;

export interface BaseSchema<Raw, Parsed> {
  parse: (raw: Raw, opts?: SchemaOptions) => Parsed;
  json: (parsed: Parsed, opts?: SchemaOptions) => Raw;
}

export interface SchemaOptions {
  /**
   * @default false
   */
  skipUnknownKeysOnParse?: boolean;

  /**
   * @default false
   */
  includeUnknownKeysOnJson?: boolean;
}
",
            "name": "Schema.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function date(): Schema<string, Date> {
  const baseSchema: BaseSchema<string, Date> = {
    parse: (raw) => new Date(raw),
    json: (date) => date.toISOString(),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                    "name": "date.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { date } from \\"./date\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "date",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function enum_<U extends string, E extends Readonly<[U, ...U[]]>>(
  _values: E
): Schema<E[number], E[number]> {
  return createIdentitySchemaCreator<E[number]>()();
}
",
                    "name": "enum.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { enum_ } from \\"./enum\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "enum",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
import { identity } from \\"./identity\\";

export function createIdentitySchemaCreator<T>(): () => Schema<T, T> {
  return <T>() => identity<T>();
}
",
                    "name": "createIdentitySchemaCreator.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function identity<T>(): Schema<T, T> {
  const baseSchema: BaseSchema<T, T> = {
    parse: (raw) => raw,
    json: (parsed) => parsed,
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                    "name": "identity.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { createIdentitySchemaCreator } from \\"./createIdentitySchemaCreator\\";
export { identity } from \\"./identity\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "identity",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./date\\";
export * from \\"./enum\\";
export * from \\"./identity\\";
export * from \\"./lazy\\";
export * from \\"./list\\";
export * from \\"./literals\\";
export * from \\"./object\\";
export * from \\"./object-like\\";
export * from \\"./primitives\\";
export * from \\"./record\\";
export * from \\"./schema-utils\\";
export * from \\"./set\\";
export * from \\"./union\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { lazy } from \\"./lazy\\";
export { lazyObject } from \\"./lazyObject\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

type Getter<Raw, Parsed> = () => Schema<Raw, Parsed>;
type MemoizedGetter<Raw, Parsed> = Getter<Raw, Parsed> & {
  __zurg_memoized?: Schema<Raw, Parsed>;
};

export function lazy<Raw, Parsed>(
  getter: Getter<Raw, Parsed>
): Schema<Raw, Parsed> {
  const baseSchema = constructLazyBaseSchema(getter);
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function constructLazyBaseSchema<Raw, Parsed>(
  getter: Getter<Raw, Parsed>
): BaseSchema<Raw, Parsed> {
  const getSchema = () => {
    const castedGetter = getter as MemoizedGetter<Raw, Parsed>;
    if (castedGetter.__zurg_memoized == null) {
      castedGetter.__zurg_memoized = getter();
    }
    return castedGetter.__zurg_memoized;
  };

  return {
    parse: (raw) => getSchema().parse(raw),
    json: (parsed) => getSchema().json(parsed),
  };
}
",
                    "name": "lazy.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { getObjectUtils } from \\"../object\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { ObjectSchema } from \\"../object/types\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { constructLazyBaseSchema } from \\"./lazy\\";

export function lazyObject<Raw, Parsed>(
  getter: () => ObjectSchema<Raw, Parsed>
): ObjectSchema<Raw, Parsed> {
  const baseSchema = {
    ...OBJECT_LIKE_BRAND,
    ...constructLazyBaseSchema(getter),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}
",
                    "name": "lazyObject.ts",
                    "type": "file",
                  },
                ],
                "name": "lazy",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { list } from \\"./list\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function list<Raw, Parsed>(
  schema: Schema<Raw, Parsed>
): Schema<Raw[], Parsed[]> {
  const baseSchema: BaseSchema<Raw[], Parsed[]> = {
    parse: (raw, opts) => raw.map((item) => schema.parse(item, opts)),
    json: (parsed, opts) => parsed.map((item) => schema.json(item, opts)),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                    "name": "list.ts",
                    "type": "file",
                  },
                ],
                "name": "list",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { stringLiteral } from \\"./stringLiteral\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function stringLiteral<V extends string>(_value: V): Schema<V, V> {
  return createIdentitySchemaCreator<V>()();
}
",
                    "name": "stringLiteral.ts",
                    "type": "file",
                  },
                ],
                "name": "literals",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { getObjectUtils, object } from \\"./object\\";
export { isProperty, property, type Property } from \\"./property\\";
export {
  type BaseObjectSchema,
  type inferObjectSchemaFromPropertySchemas,
  type inferParsedObject,
  type inferParsedObjectFromPropertySchemas,
  type inferParsedPropertySchema,
  type inferRawKey,
  type inferRawObject,
  type inferRawObjectFromPropertySchemas,
  type inferRawPropertySchema,
  type ObjectSchema,
  type ObjectUtils,
  type PropertySchemas,
} from \\"./types\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { isProperty } from \\"./property\\";
import {
  BaseObjectSchema,
  inferObjectSchemaFromPropertySchemas,
  inferParsedObjectFromPropertySchemas,
  inferRawObjectFromPropertySchemas,
  ObjectSchema,
  ObjectUtils,
  PropertySchemas,
} from \\"./types\\";

interface ObjectPropertyWithRawKey {
  rawKey: string;
  parsedKey: string | number | symbol;
  valueSchema: Schema<any, any>;
}

export function object<
  ParsedKeys extends string,
  T extends PropertySchemas<ParsedKeys>
>(schemas: T): inferObjectSchemaFromPropertySchemas<T> {
  const baseSchema: BaseObjectSchema<
    inferRawObjectFromPropertySchemas<T>,
    inferParsedObjectFromPropertySchemas<T>
  > = {
    ...OBJECT_LIKE_BRAND,

    parse: (raw, { skipUnknownKeysOnParse = false } = {}) => {
      const rawKeyToProperty: Record<string, ObjectPropertyWithRawKey> = {};

      for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
        const rawKey = isProperty(schemaOrObjectProperty)
          ? schemaOrObjectProperty.rawKey
          : parsedKey;

        const property: ObjectPropertyWithRawKey = {
          rawKey,
          parsedKey,
          valueSchema: isProperty(schemaOrObjectProperty)
            ? schemaOrObjectProperty.valueSchema
            : schemaOrObjectProperty,
        };

        rawKeyToProperty[rawKey] = property;
      }

      const parsed: Record<string | number | symbol, any> = {};

      for (const [rawKey, rawPropertyValue] of Object.entries(raw)) {
        const property = rawKeyToProperty[rawKey];

        if (property != null) {
          const value = property.valueSchema.parse(rawPropertyValue);
          if (value != null) {
            parsed[property.parsedKey] = value;
          }
        } else if (!skipUnknownKeysOnParse && rawPropertyValue != null) {
          parsed[rawKey] = rawPropertyValue;
        }
      }

      return parsed as inferParsedObjectFromPropertySchemas<T>;
    },

    json: (parsed, { includeUnknownKeysOnJson = false } = {}) => {
      const raw: Record<string | number | symbol, any> = {};

      for (const [parsedKey, parsedPropertyValue] of entries(parsed)) {
        const schemaOrObjectProperty = schemas[parsedKey as keyof T];
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (schemaOrObjectProperty != null) {
          if (isProperty(schemaOrObjectProperty)) {
            const value =
              schemaOrObjectProperty.valueSchema.json(parsedPropertyValue);
            if (value != null) {
              raw[schemaOrObjectProperty.rawKey] = value;
            }
          } else {
            const value = schemaOrObjectProperty.json(parsedPropertyValue);
            if (value != null) {
              raw[parsedKey] = value;
            }
          }
        } else if (includeUnknownKeysOnJson && parsedPropertyValue != null) {
          raw[parsedKey] = parsedPropertyValue;
        }
      }

      return raw as inferRawObjectFromPropertySchemas<T>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}

export function getObjectUtils<Raw, Parsed>(
  schema: BaseObjectSchema<Raw, Parsed>
): ObjectUtils<Raw, Parsed> {
  return {
    extend: <RawExtension, ParsedExtension>(
      extension: ObjectSchema<RawExtension, ParsedExtension>
    ) => {
      const baseSchema: BaseObjectSchema<
        Raw & RawExtension,
        Parsed & ParsedExtension
      > = {
        ...OBJECT_LIKE_BRAND,
        parse: (raw, opts) => ({
          ...schema.parse(raw, opts),
          ...extension.parse(raw, opts),
        }),
        json: (parsed, opts) => ({
          ...schema.json(parsed, opts),
          ...extension.json(parsed, opts),
        }),
      };

      return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
      };
    },
  };
}
",
                    "name": "object.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";

export function property<RawKey extends string, RawValue, ParsedValue>(
  rawKey: RawKey,
  valueSchema: Schema<RawValue, ParsedValue>
): Property<RawKey, RawValue, ParsedValue> {
  return {
    rawKey,
    valueSchema,
    isProperty: true,
  };
}

export interface Property<RawKey extends string, RawValue, ParsedValue> {
  rawKey: RawKey;
  valueSchema: Schema<RawValue, ParsedValue>;
  isProperty: true;
}

export function isProperty<O extends Property<any, any, any>>(
  maybeProperty: unknown
): maybeProperty is O {
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return (maybeProperty as O).isProperty;
}
",
                    "name": "property.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { inferParsed, inferRaw, Schema } from \\"../../Schema\\";
import { addQuestionMarksToNullableProperties } from \\"../../utils/addQuestionMarksToNullableProperties\\";
import { BaseObjectLikeSchema, ObjectLikeSchema } from \\"../object-like\\";
import { Property } from \\"./property\\";

export type ObjectSchema<Raw, Parsed> = BaseObjectSchema<Raw, Parsed> &
  ObjectLikeSchema<Raw, Parsed> &
  ObjectUtils<Raw, Parsed>;

export type BaseObjectSchema<Raw, Parsed> = BaseObjectLikeSchema<Raw, Parsed>;

export interface ObjectUtils<Raw, Parsed> {
  extend: <RawExtension, ParsedExtension>(
    schemas: ObjectSchema<RawExtension, ParsedExtension>
  ) => ObjectSchema<Raw & RawExtension, Parsed & ParsedExtension>;
}

export type inferRawObject<O extends ObjectSchema<any, any>> =
  O extends ObjectSchema<infer Raw, any> ? Raw : never;

export type inferParsedObject<O extends ObjectSchema<any, any>> =
  O extends ObjectSchema<any, infer Parsed> ? Parsed : never;

export type inferObjectSchemaFromPropertySchemas<
  T extends PropertySchemas<keyof T>
> = ObjectSchema<
  inferRawObjectFromPropertySchemas<T>,
  inferParsedObjectFromPropertySchemas<T>
>;

export type inferRawObjectFromPropertySchemas<
  T extends PropertySchemas<keyof T>
> = addQuestionMarksToNullableProperties<{
  [ParsedKey in keyof T as inferRawKey<
    ParsedKey,
    T[ParsedKey]
  >]: inferRawPropertySchema<T[ParsedKey]>;
}>;

export type inferParsedObjectFromPropertySchemas<
  T extends PropertySchemas<keyof T>
> = addQuestionMarksToNullableProperties<{
  [K in keyof T]: inferParsedPropertySchema<T[K]>;
}>;

export type PropertySchemas<ParsedKeys extends string | number | symbol> =
  Record<ParsedKeys, Property<any, any, any> | Schema<any, any>>;

export type inferRawPropertySchema<
  P extends Property<any, any, any> | Schema<any, any>
> = P extends Property<any, infer Raw, any>
  ? Raw
  : P extends Schema<any, any>
  ? inferRaw<P>
  : never;

export type inferParsedPropertySchema<
  P extends Property<any, any, any> | Schema<any, any>
> = P extends Property<any, any, infer Parsed>
  ? Parsed
  : P extends Schema<any, any>
  ? inferParsed<P>
  : never;

export type inferRawKey<
  ParsedKey extends string | number | symbol,
  P extends Property<any, any, any> | Schema<any, any>
> = P extends Property<infer Raw, any, any> ? Raw : ParsedKey;
",
                    "name": "types.ts",
                    "type": "file",
                  },
                ],
                "name": "object",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { BaseObjectLikeSchema, ObjectLikeUtils } from \\"./types\\";
import { withProperties } from \\"./withProperties\\";

export function getObjectLikeUtils<Raw, Parsed>(
  schema: BaseObjectLikeSchema<Raw, Parsed>
): ObjectLikeUtils<Raw, Parsed> {
  return {
    withProperties: (properties) => withProperties(schema, properties),
  };
}
",
                    "name": "getObjectLikeUtils.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { getObjectLikeUtils } from \\"./getObjectLikeUtils\\";
export {
  OBJECT_LIKE_BRAND,
  type BaseObjectLikeSchema,
  type ObjectLikeSchema,
  type ObjectLikeUtils,
} from \\"./types\\";
export { withProperties } from \\"./withProperties\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";

export type ObjectLikeSchema<Raw, Parsed> = Schema<Raw, Parsed> &
  BaseObjectLikeSchema<Raw, Parsed> &
  ObjectLikeUtils<Raw, Parsed>;

export type BaseObjectLikeSchema<Raw, Parsed> = BaseSchema<Raw, Parsed> & {
  _objectLike: void;
};

export interface ObjectLikeUtils<Raw, Parsed> {
  withProperties: <T extends Record<string, any>>(properties: {
    [K in keyof T]: T[K] | ((parsed: Parsed) => T[K]);
  }) => ObjectLikeSchema<Raw, Parsed & T>;
}

export const OBJECT_LIKE_BRAND = undefined as unknown as { _objectLike: void };
",
                    "name": "types.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { getSchemaUtils } from \\"../schema-utils\\";
import { getObjectLikeUtils } from \\"./getObjectLikeUtils\\";
import {
  BaseObjectLikeSchema,
  ObjectLikeSchema,
  OBJECT_LIKE_BRAND,
} from \\"./types\\";

export function withProperties<RawObjectShape, ParsedObjectShape, Properties>(
  objectLike: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape>,
  properties: {
    [K in keyof Properties]:
      | Properties[K]
      | ((parsed: ParsedObjectShape) => Properties[K]);
  }
): ObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> {
  const objectSchema: BaseObjectLikeSchema<
    RawObjectShape,
    ParsedObjectShape & Properties
  > = {
    ...OBJECT_LIKE_BRAND,
    parse: (raw, opts) => {
      const parsedObject = objectLike.parse(raw, opts);
      const additionalProperties = Object.entries(properties).reduce<
        Record<string, any>
      >((processed, [key, value]) => {
        return {
          ...processed,
          [key]: typeof value === \\"function\\" ? value(parsedObject) : value,
        };
      }, {});

      return {
        ...parsedObject,
        ...(additionalProperties as Properties),
      };
    },
    json: (parsed, opts) => {
      // strip out added properties
      const addedPropertyKeys = new Set(Object.keys(properties));
      const parsedWithoutAddedProperties = Object.entries(parsed).reduce<
        Record<string, any>
      >((filtered, [key, value]) => {
        if (!addedPropertyKeys.has(key)) {
          filtered[key] = value;
        }
        return filtered;
      }, {});

      return objectLike.json(
        parsedWithoutAddedProperties as ParsedObjectShape,
        opts
      );
    },
  };

  return {
    ...objectSchema,
    ...getSchemaUtils(objectSchema),
    ...getObjectLikeUtils(objectSchema),
  };
}
",
                    "name": "withProperties.ts",
                    "type": "file",
                  },
                ],
                "name": "object-like",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const any = createIdentitySchemaCreator<any>();
",
                    "name": "any.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const boolean = createIdentitySchemaCreator<boolean>();
",
                    "name": "boolean.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { any } from \\"./any\\";
export { boolean } from \\"./boolean\\";
export { number } from \\"./number\\";
export { string } from \\"./string\\";
export { unknown } from \\"./unknown\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const number = createIdentitySchemaCreator<number>();
",
                    "name": "number.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const string = createIdentitySchemaCreator<string>();
",
                    "name": "string.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const unknown = createIdentitySchemaCreator<unknown>();
",
                    "name": "unknown.ts",
                    "type": "file",
                  },
                ],
                "name": "primitives",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { record } from \\"./record\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function record<
  RawKey extends string | number,
  ParsedKey extends string | number,
  RawValue,
  ParsedValue
>(
  keySchema: Schema<RawKey, ParsedKey>,
  valueSchema: Schema<RawValue, ParsedValue>
): Schema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> {
  const baseSchema: BaseSchema<
    Record<RawKey, RawValue>,
    Record<ParsedKey, ParsedValue>
  > = {
    parse: (raw, opts) => {
      return entries(raw).reduce(
        (parsed, [key, value]) => {
          parsed[keySchema.parse(key, opts)] = valueSchema.parse(value, opts);
          return parsed;
        },
        // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
        {} as Record<ParsedKey, ParsedValue>
      );
    },
    json: (parsed, opts) => {
      return entries(parsed).reduce(
        (raw, [key, value]) => {
          raw[keySchema.json(key, opts)] = valueSchema.json(value, opts);
          return raw;
        },
        // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
        {} as Record<RawKey, RawValue>
      );
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                    "name": "record.ts",
                    "type": "file",
                  },
                ],
                "name": "record",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { OptionalSchema, OPTIONAL_BRAND } from \\"./types\\";

export interface SchemaUtils<Raw, Parsed> {
  optional: () => OptionalSchema<Raw, Parsed>;
  transform: <PostTransform>(
    transformer: BaseSchema<Parsed, PostTransform>
  ) => Schema<Raw, PostTransform>;
}

export function getSchemaUtils<Raw, Parsed>(
  schema: BaseSchema<Raw, Parsed>
): SchemaUtils<Raw, Parsed> {
  return {
    optional: () => optional(schema),
    transform: (transformer) => transform(schema, transformer),
  };
}

/**
 * schema utils are defined in one file to resolve issues with circular imports
 */

export function optional<Raw, Parsed>(
  schema: BaseSchema<Raw, Parsed>
): OptionalSchema<Raw, Parsed> {
  const baseSchema: BaseSchema<Raw | null | undefined, Parsed | undefined> = {
    parse: (raw, opts) => (raw != null ? schema.parse(raw, opts) : undefined),
    json: (parsed, opts) =>
      parsed != null ? schema.json(parsed, opts) : undefined,
  };

  return {
    ...OPTIONAL_BRAND,
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function transform<PreTransformRaw, PreTransformParsed, PostTransform>(
  schema: BaseSchema<PreTransformRaw, PreTransformParsed>,
  transformer: BaseSchema<PreTransformParsed, PostTransform>
): Schema<PreTransformRaw, PostTransform> {
  const baseSchema: BaseSchema<PreTransformRaw, PostTransform> = {
    parse: (raw, opts) => {
      const postTransformParsed = schema.parse(raw, opts);
      return transformer.parse(postTransformParsed, opts);
    },
    json: (parsed, opts) => {
      const preTransformParsed = transformer.json(parsed, opts);
      return schema.json(preTransformParsed, opts);
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                    "name": "getSchemaUtils.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export {
  getSchemaUtils,
  optional,
  transform,
  type SchemaUtils,
} from \\"./getSchemaUtils\\";
export { OPTIONAL_BRAND, type OptionalSchema } from \\"./types\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";

export const OPTIONAL_BRAND = undefined as unknown as { _isOptional: void };

export type OptionalSchema<Raw, Parsed> = Schema<
  Raw | null | undefined,
  Parsed | undefined
> & {
  _isOptional: void;
};
",
                    "name": "types.ts",
                    "type": "file",
                  },
                ],
                "name": "schema-utils",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { set } from \\"./set\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function set<Raw, Parsed>(
  schema: Schema<Raw, Parsed>
): Schema<Raw[], Set<Parsed>> {
  const baseSchema: BaseSchema<Raw[], Set<Parsed>> = {
    parse: (raw, opts) => new Set(raw.map((item) => schema.parse(item, opts))),
    json: (parsed, opts) => [...parsed].map((item) => schema.json(item, opts)),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                    "name": "set.ts",
                    "type": "file",
                  },
                ],
                "name": "set",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export function discriminant<
  RawDiscriminant extends string,
  ParsedDiscriminant extends string
>(
  parsedDiscriminant: ParsedDiscriminant,
  rawDiscriminant: RawDiscriminant
): Discriminant<RawDiscriminant, ParsedDiscriminant> {
  return {
    parsedDiscriminant,
    rawDiscriminant,
  };
}

export interface Discriminant<
  RawDiscriminant extends string,
  ParsedDiscriminant extends string
> {
  parsedDiscriminant: ParsedDiscriminant;
  rawDiscriminant: RawDiscriminant;
}
",
                    "name": "discriminant.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { discriminant, type Discriminant } from \\"./discriminant\\";
export {
  type inferParsedDiscriminant,
  type inferParsedUnion,
  type inferRawDiscriminant,
  type inferRawUnion,
  type UnionSubtypes,
} from \\"./types\\";
export { union } from \\"./union\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { inferParsedObject, inferRawObject, ObjectSchema } from \\"../object\\";
import { Discriminant } from \\"./discriminant\\";

export type UnionSubtypes<DiscriminantValues extends string | number | symbol> =
  {
    [K in DiscriminantValues]: ObjectSchema<any, any>;
  };

export type inferRawUnion<
  D extends string | Discriminant<any, any>,
  U extends UnionSubtypes<keyof U>
> = {
  [K in keyof U]: Record<inferRawDiscriminant<D>, K> & inferRawObject<U[K]>;
}[keyof U];

export type inferParsedUnion<
  D extends string | Discriminant<any, any>,
  U extends UnionSubtypes<keyof U>
> = {
  [K in keyof U]: Record<inferParsedDiscriminant<D>, K> &
    inferParsedObject<U[K]>;
}[keyof U];

export type inferRawDiscriminant<D extends string | Discriminant<any, any>> =
  D extends string ? D : D extends Discriminant<infer Raw, any> ? Raw : never;

export type inferParsedDiscriminant<D extends string | Discriminant<any, any>> =
  D extends string
    ? D
    : D extends Discriminant<any, infer Parsed>
    ? Parsed
    : never;
",
                    "name": "types.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import {
  BaseObjectLikeSchema,
  getObjectLikeUtils,
  ObjectLikeSchema,
  OBJECT_LIKE_BRAND,
} from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { Discriminant } from \\"./discriminant\\";
import {
  inferParsedDiscriminant,
  inferParsedUnion,
  inferRawDiscriminant,
  inferRawUnion,
  UnionSubtypes,
} from \\"./types\\";

export function union<
  D extends string | Discriminant<any, any>,
  U extends UnionSubtypes<any>
>(
  discriminant: D,
  union: U
): ObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> {
  const rawDiscriminant =
    typeof discriminant === \\"string\\"
      ? discriminant
      : (discriminant.rawDiscriminant as inferRawDiscriminant<D>);
  const parsedDiscriminant =
    typeof discriminant === \\"string\\"
      ? discriminant
      : (discriminant.parsedDiscriminant as inferParsedDiscriminant<D>);

  const baseSchema: BaseObjectLikeSchema<
    inferRawUnion<D, U>,
    inferParsedUnion<D, U>
  > = {
    ...OBJECT_LIKE_BRAND,

    parse: (raw, opts) => {
      const { [rawDiscriminant]: discriminantValue, ...additionalProperties } =
        raw;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [parsedDiscriminant]: discriminantValue,
        } as inferParsedUnion<D, U>;
      }

      return {
        ...additionalPropertySchemas.parse(additionalProperties, opts),
        [parsedDiscriminant]: discriminantValue,
      } as inferParsedUnion<D, U>;
    },

    json: (parsed, opts) => {
      const {
        [parsedDiscriminant]: discriminantValue,
        ...additionalProperties
      } = parsed;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [rawDiscriminant]: discriminantValue,
        } as unknown as inferRawUnion<D, U>;
      }

      return {
        ...additionalPropertySchemas.json(additionalProperties, opts),
        [rawDiscriminant]: discriminantValue,
      } as inferRawUnion<D, U>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
  };
}
",
                    "name": "union.ts",
                    "type": "file",
                  },
                ],
                "name": "union",
                "type": "directory",
              },
            ],
            "name": "builders",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./builders\\";
export {
  type inferParsed,
  type inferRaw,
  type Schema,
  type SchemaOptions,
} from \\"./Schema\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export type addQuestionMarksToNullableProperties<T> = {
  [K in OptionalKeys<T>]?: undefined extends T[K] ? T[K] : never;
} & Pick<T, RequiredKeys<T>>;

export type OptionalKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? K : never;
}[keyof T];

export type RequiredKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? never : K;
}[keyof T];
",
                "name": "addQuestionMarksToNullableProperties.ts",
                "type": "file",
              },
              Object {
                "contents": "export function entries<T>(object: T): [keyof T, T[keyof T]][] {
  return Object.entries(object) as [keyof T, T[keyof T]][];
}
",
                "name": "entries.ts",
                "type": "file",
              },
              Object {
                "contents": "export function keys<T>(object: T): (keyof T)[] {
  return Object.keys(object) as (keyof T)[];
}
",
                "name": "keys.ts",
                "type": "file",
              },
            ],
            "name": "utils",
            "type": "directory",
          },
        ],
        "name": "schemas",
        "type": "directory",
      },
    ],
    "name": "core",
    "type": "directory",
  },
  Object {
    "contents": "export * as MyApi from \\"./api\\";
",
    "name": "index.ts",
    "type": "file",
  },
  Object {
    "contents": "{
    \\"name\\": \\"@fern-api/my-api-client\\",
    \\"main\\": \\"./index.js\\",
    \\"types\\": \\"./types/index.d.ts\\",
    \\"files\\": [
        \\"/api\\",
        \\"/schemas\\",
        \\"/core\\",
        \\"/index.*\\",
        \\"!*.ts\\",
        \\"/types\\"
    ],
    \\"scripts\\": {
        \\"format\\": \\"prettier --write '**/*.ts'\\",
        \\"build\\": \\"esbuild $(find . -name '*.ts' -not -path './node_modules/*') --format=cjs --sourcemap --outdir=. && tsc\\"
    },
    \\"dependencies\\": {
        \\"@types/basic-auth\\": \\"^1.1.3\\",
        \\"@types/url-join\\": \\"4.0.1\\",
        \\"axios\\": \\"^0.27.2\\",
        \\"basic-auth\\": \\"^2.0.1\\",
        \\"js-base64\\": \\"^3.7.2\\",
        \\"url-join\\": \\"4.0.1\\"
    },
    \\"peerDependencies\\": {
        \\"axios\\": \\"*\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"esbuild\\": \\"0.14.47\\",
        \\"prettier\\": \\"2.7.1\\",
        \\"typescript\\": \\"4.6.4\\"
    },
    \\"packageManager\\": \\"yarn@3.2.3\\"
}
",
    "name": "package.json",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "export * as storeTracedTestCaseV2 from \\"./storeTracedTestCaseV2\\";
export * as storeTracedWorkspaceV2 from \\"./storeTracedWorkspaceV2\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  schemas.submission.TraceResponseV2.Raw[],
  MyApi.submission.TraceResponseV2[]
> = core.schemas.list(
  core.schemas.lazyObject(() => schemas.submission.TraceResponseV2)
);
",
                "name": "storeTracedTestCaseV2.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  schemas.submission.TraceResponseV2.Raw[],
  MyApi.submission.TraceResponseV2[]
> = core.schemas.list(
  core.schemas.lazyObject(() => schemas.submission.TraceResponseV2)
);
",
                "name": "storeTracedWorkspaceV2.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "admin",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./types\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "commons",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  schemas.commons.ProblemId.Raw[],
  MyApi.commons.ProblemId[]
> = core.schemas.list(core.schemas.lazy(() => schemas.commons.ProblemId));
",
                "name": "getHomepageProblems.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as getHomepageProblems from \\"./getHomepageProblems\\";
export * as setHomepageProblems from \\"./setHomepageProblems\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  schemas.commons.ProblemId.Raw[],
  MyApi.commons.ProblemId[]
> = core.schemas.list(core.schemas.lazy(() => schemas.commons.ProblemId));
",
                "name": "setHomepageProblems.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "homepage",
        "type": "directory",
      },
      Object {
        "contents": "export * as admin from \\"./admin\\";
export * from \\"./admin/types\\";
export * as commons from \\"./commons\\";
export * from \\"./commons/types\\";
export * as langServer from \\"./lang-server\\";
export * from \\"./lang-server/types\\";
export * as migration from \\"./migration\\";
export * from \\"./migration/types\\";
export * as playlist from \\"./playlist\\";
export * from \\"./playlist/types\\";
export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as submission from \\"./submission\\";
export * from \\"./submission/types\\";
export * as v2 from \\"./v2\\";
export * from \\"./playlist/errors\\";
export * as homepage from \\"./homepage\\";
export * as sysprop from \\"./sysprop\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./types\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "lang-server",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  schemas.migration.Migration.Raw[],
  MyApi.migration.Migration[]
> = core.schemas.list(
  core.schemas.lazyObject(() => schemas.migration.Migration)
);
",
                "name": "getAttemptedMigrations.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as getAttemptedMigrations from \\"./getAttemptedMigrations\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "migration",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const Error: core.schemas.Schema<
  Error.Raw,
  MyApi.playlist.getPlaylist.Error
> = core.schemas
  .union(\\"errorName\\", {
    PlaylistIdNotFoundError: core.schemas.object({
      content: core.schemas.lazy(
        () => schemas.playlist.PlaylistIdNotFoundError
      ),
    }),
    UnauthorizedError: core.schemas.object({}),
  })
  .transform<MyApi.playlist.getPlaylist.Error>({
    parse: (value) => {
      switch (value.errorName) {
        case \\"PlaylistIdNotFoundError\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.playlistIdNotFoundError(value.content),
          };
        }
        case \\"UnauthorizedError\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.unauthorizedError(),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace Error {
  type Raw = Error.PlaylistIdNotFoundError | Error.UnauthorizedError;

  interface PlaylistIdNotFoundError {
    errorName: \\"PlaylistIdNotFoundError\\";
    content: schemas.playlist.PlaylistIdNotFoundError.Raw;
  }

  interface UnauthorizedError {
    errorName: \\"UnauthorizedError\\";
  }
}
",
                "name": "getPlaylist.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  schemas.playlist.Playlist.Raw[],
  MyApi.playlist.Playlist[]
> = core.schemas.list(core.schemas.lazyObject(() => schemas.playlist.Playlist));
",
                "name": "getPlaylists.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as getPlaylists from \\"./getPlaylists\\";
export * as getPlaylist from \\"./getPlaylist\\";
export * as updatePlaylist from \\"./updatePlaylist\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  schemas.playlist.UpdatePlaylistRequest.Raw | null | undefined,
  MyApi.playlist.UpdatePlaylistRequest | undefined
> = core.schemas
  .lazyObject(() => schemas.playlist.UpdatePlaylistRequest)
  .optional();
export const Response: core.schemas.Schema<
  schemas.playlist.Playlist.Raw | null | undefined,
  MyApi.playlist.Playlist | undefined
> = core.schemas.lazyObject(() => schemas.playlist.Playlist).optional();
export const Error: core.schemas.Schema<
  Error.Raw,
  MyApi.playlist.updatePlaylist.Error
> = core.schemas
  .union(\\"errorName\\", {
    PlaylistIdNotFoundError: core.schemas.object({
      content: core.schemas.lazy(
        () => schemas.playlist.PlaylistIdNotFoundError
      ),
    }),
  })
  .transform<MyApi.playlist.updatePlaylist.Error>({
    parse: (value) => {
      switch (value.errorName) {
        case \\"PlaylistIdNotFoundError\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.playlistIdNotFoundError(value.content),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace Error {
  type Raw = Error.PlaylistIdNotFoundError;

  interface PlaylistIdNotFoundError {
    errorName: \\"PlaylistIdNotFoundError\\";
    content: schemas.playlist.PlaylistIdNotFoundError.Raw;
  }
}
",
                "name": "updatePlaylist.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const PlaylistIdNotFoundError: core.schemas.Schema<
  PlaylistIdNotFoundError.Raw,
  MyApi.playlist.PlaylistIdNotFoundError
> = core.schemas
  .union(\\"type\\", {
    playlistId: core.schemas.object({
      value: core.schemas.lazy(() => schemas.playlist.PlaylistId),
    }),
  })
  .transform<MyApi.playlist.PlaylistIdNotFoundError>({
    parse: (value) => {
      switch (value.type) {
        case \\"playlistId\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.playlistId(value.value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace PlaylistIdNotFoundError {
  type Raw = PlaylistIdNotFoundError.PlaylistId;

  interface PlaylistId {
    type: \\"playlistId\\";
    value: schemas.playlist.PlaylistId.Raw;
  }
}
",
                "name": "PlaylistIdNotFoundError.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./PlaylistIdNotFoundError\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "errors",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./errors\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "playlist",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./types\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "problem",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  schemas.submission.ExecutionSessionResponse.Raw | null | undefined,
  MyApi.submission.ExecutionSessionResponse | undefined
> = core.schemas
  .lazyObject(() => schemas.submission.ExecutionSessionResponse)
  .optional();
",
                "name": "getExecutionSession.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as getExecutionSession from \\"./getExecutionSession\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "submission",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  Record<schemas.commons.Language.Raw, number>,
  Record<MyApi.commons.Language.RawValue, number>
> = core.schemas.record(core.schemas.string(), core.schemas.number());
",
                "name": "getNumWarmInstances.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as getNumWarmInstances from \\"./getNumWarmInstances\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "sysprop",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as v3 from \\"./v3\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as schemas from \\"../../..\\";
import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const Response: core.schemas.Schema<
  schemas.v2.problem.LightweightProblemInfoV2.Raw[],
  MyApi.v2.problem.LightweightProblemInfoV2[]
> = core.schemas.list(
  core.schemas.lazyObject(() => schemas.v2.problem.LightweightProblemInfoV2)
);
",
                    "name": "getLightweightProblems.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as schemas from \\"../../..\\";
import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const Response: core.schemas.Schema<
  schemas.v2.problem.ProblemInfoV2.Raw[],
  MyApi.v2.problem.ProblemInfoV2[]
> = core.schemas.list(
  core.schemas.lazyObject(() => schemas.v2.problem.ProblemInfoV2)
);
",
                    "name": "getProblems.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "problem",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as schemas from \\"../../../..\\";
import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const Response: core.schemas.Schema<
  schemas.v2.v3.problem.LightweightProblemInfoV2.Raw[],
  MyApi.v2.v3.problem.LightweightProblemInfoV2[]
> = core.schemas.list(
  core.schemas.lazyObject(() => schemas.v2.v3.problem.LightweightProblemInfoV2)
);
",
                        "name": "getLightweightProblems.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as schemas from \\"../../../..\\";
import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const Response: core.schemas.Schema<
  schemas.v2.v3.problem.ProblemInfoV2.Raw[],
  MyApi.v2.v3.problem.ProblemInfoV2[]
> = core.schemas.list(
  core.schemas.lazyObject(() => schemas.v2.v3.problem.ProblemInfoV2)
);
",
                        "name": "getProblems.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "problem",
                "type": "directory",
              },
            ],
            "name": "v3",
            "type": "directory",
          },
        ],
        "name": "v2",
        "type": "directory",
      },
    ],
    "name": "schemas",
    "type": "directory",
  },
  Object {
    "contents": "{
    \\"compilerOptions\\": {
        \\"strict\\": true,
        \\"target\\": \\"esnext\\",
        \\"moduleResolution\\": \\"node\\",
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"sourceMap\\": true,
        \\"emitDeclarationOnly\\": true,
        \\"esModuleInterop\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true,
        \\"outDir\\": \\"types\\"
    }
}",
    "name": "tsconfig.json",
    "type": "file",
  },
]
`;
