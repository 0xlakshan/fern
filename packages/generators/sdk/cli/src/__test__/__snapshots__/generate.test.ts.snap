// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`runGenerator nursery 1`] = `
Array [
  Object {
    "contents": Array [
      Object {
        "contents": Array [
          Object {
            "contents": "name: ci

on: [push]

jobs:
  compile:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Set up node
        uses: actions/setup-node@v3

      - name: Compile
        run: yarn && yarn build
  
  publish:
    needs: [ compile ]
    if: github.event_name == 'push' && contains(github.ref, 'refs/tags/')
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Set up node
        uses: actions/setup-node@v3

      - name: Install dependencies
        run: yarn install

      - name: Build
        run: yarn build

      - name: Publish to npm
        run: |
          npm config set //registry.npmjs.org/:_authToken \${NPM_TOKEN}
          npm publish --ignore-scripts --access public
        env:
          NPM_TOKEN: \${{ secrets.NPM_TOKEN }}",
            "name": "ci.yml",
            "type": "file",
          },
        ],
        "name": "workflows",
        "type": "directory",
      },
    ],
    "name": ".github",
    "type": "directory",
  },
  Object {
    "contents": "node_modules
.DS_Store
*.d.ts
*.js
*.js.map

# yarn berry
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions

# these are needed to override '*.js' above
!.yarn/patches/**
!.yarn/plugins/**
!.yarn/releases/**
!.yarn/sdks/**
!.yarn/versions/**",
    "name": ".gitignore",
    "type": "file",
  },
  Object {
    "contents": ".yarn
node_modules
.npmignore
.pnp.cjs
*.js
*.d.ts",
    "name": ".prettierignore",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "{
  \\"recommendations\\": [
    \\"arcanis.vscode-zipfs\\",
    \\"esbenp.prettier-vscode\\"
  ]
}
",
        "name": "extensions.json",
        "type": "file",
      },
      Object {
        "contents": "{
  \\"search.exclude\\": {
    \\"**/.yarn\\": true,
    \\"**/.pnp.*\\": true
  },
  \\"prettier.prettierPath\\": \\".yarn/sdks/prettier/index.js\\",
  \\"typescript.tsdk\\": \\".yarn/sdks/typescript/lib\\",
  \\"typescript.enablePromptUseWorkspaceTsdk\\": true
}
",
        "name": "settings.json",
        "type": "file",
      },
    ],
    "name": ".vscode",
    "type": "directory",
  },
  Object {
    "contents": "nodeLinker: pnp

yarnPath: .yarn/releases/yarn-3.2.4.cjs
",
    "name": ".yarnrc.yml",
    "type": "file",
  },
  Object {
    "contents": "{
    \\"name\\": \\"@fern/nursery-api\\",
    \\"version\\": \\"0.0.1\\",
    \\"repository\\": \\"https://github.com/fern/nursery-api}\\",
    \\"files\\": [
        \\"core\\",
        \\"resources\\",
        \\"serialization\\",
        \\"client\\",
        \\"*.{js,js.map,d.ts}\\"
    ],
    \\"main\\": \\"./index.js\\",
    \\"types\\": \\"./index.d.ts\\",
    \\"scripts\\": {
        \\"format\\": \\"prettier --write --print-width 120 'src/**/*.ts'\\",
        \\"build\\": \\"esbuild $(find src -name '*.ts') --format=cjs --sourcemap --outdir=. && tsc\\"
    },
    \\"dependencies\\": {
        \\"@types/url-join\\": \\"4.0.1\\",
        \\"axios\\": \\"^0.27.2\\",
        \\"url-join\\": \\"4.0.1\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"esbuild\\": \\"0.14.47\\",
        \\"prettier\\": \\"2.7.1\\",
        \\"typescript\\": \\"4.6.4\\"
    },
    \\"packageManager\\": \\"yarn@3.2.4\\"
}
",
    "name": "package.json",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { Client as OwnerClient } from \\"./resources/owner/client/Client\\";
import { Client as TokenClient } from \\"./resources/token/client/Client\\";

export declare namespace FernNurseryApiClient {
  interface Options {
    environment: string;
  }
}

export class FernNurseryApiClient {
  constructor(private readonly options: FernNurseryApiClient.Options) {}

  #owner: OwnerClient | undefined;

  public get owner(): OwnerClient {
    return (this.#owner ??= new OwnerClient(this.options));
  }

  #token: TokenClient | undefined;

  public get token(): TokenClient {
    return (this.#token ??= new TokenClient(this.options));
  }
}
",
        "name": "Client.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "export type APIResponse<Success, Failure> = SuccessfulResponse<Success> | FailedResponse<Failure>;

export interface SuccessfulResponse<T> {
  ok: true;
  body: T;
}

export interface FailedResponse<T> {
  ok: false;
  error: T;
}
",
                "name": "APIResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import axios, { AxiosError } from \\"axios\\";
import { APIResponse } from \\"./APIResponse\\";

export interface Fetcher {
  fetch: FetchFunction;
}

export type FetchFunction = (args: Fetcher.Args) => Promise<APIResponse<unknown, Fetcher.Error>>;

export declare namespace Fetcher {
  export interface Args {
    url: string;
    method: string;
    headers?: Record<string, string | undefined>;
    queryParameters?: URLSearchParams;
    body?: unknown;
    timeoutMs?: number;
  }

  export type Error = FailedStatusCodeError | NonJsonError | TimeoutError | UnknownError;

  export interface FailedStatusCodeError {
    reason: \\"status-code\\";
    statusCode: number;
    body: unknown;
  }

  export interface NonJsonError {
    reason: \\"non-json\\";
    statusCode: number;
    rawBody: string;
  }

  export interface TimeoutError {
    reason: \\"timeout\\";
  }

  export interface UnknownError {
    reason: \\"unknown\\";
    errorMessage: string;
  }
}

export const fetcher: FetchFunction = async (args) => {
  const headers: Record<string, string> = {
    \\"Content-Type\\": \\"application/json\\",
  };

  if (args.headers != null) {
    for (const [key, value] of Object.entries(args.headers)) {
      if (value != null) {
        headers[key] = value;
      }
    }
  }

  try {
    const response = await axios({
      url: args.url,
      params: args.queryParameters,
      method: args.method,
      headers,
      data: args.body,
      validateStatus: () => true,
      transformResponse: (response) => response,
      timeout: args.timeoutMs ?? 60_000,
      transitional: {
        clarifyTimeoutError: true,
      },
    });

    let body: unknown;
    if (response.data != null) {
      try {
        body = JSON.parse(response.data) ?? undefined;
      } catch {
        return {
          ok: false,
          error: {
            reason: \\"non-json\\",
            statusCode: response.status,
            rawBody: response.data,
          },
        };
      }
    }

    if (response.status >= 200 && response.status < 300) {
      return {
        ok: true,
        body,
      };
    } else {
      return {
        ok: false,
        error: {
          reason: \\"status-code\\",
          statusCode: response.status,
          body,
        },
      };
    }
  } catch (error) {
    if ((error as AxiosError).code === \\"ETIMEDOUT\\") {
      return {
        ok: false,
        error: {
          reason: \\"timeout\\",
        },
      };
    }

    return {
      ok: false,
      error: {
        reason: \\"unknown\\",
        errorMessage: (error as AxiosError).message,
      },
    };
  }
};
",
                "name": "Fetcher.ts",
                "type": "file",
              },
              Object {
                "contents": "export type Supplier<T> = T | Promise<T> | (() => T | Promise<T>);

export const Supplier = {
  get: async <T>(supplier: Supplier<T>): Promise<T> => {
    if (typeof supplier === \\"function\\") {
      return (supplier as () => T)();
    } else {
      return supplier;
    }
  },
};
",
                "name": "Supplier.ts",
                "type": "file",
              },
              Object {
                "contents": "export { type APIResponse } from \\"./APIResponse\\";
export { fetcher, type Fetcher, type FetchFunction } from \\"./Fetcher\\";
export { Supplier } from \\"./Supplier\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "fetcher",
            "type": "directory",
          },
          Object {
            "contents": "export * as schemas from \\"./schemas\\";
export * from \\"./fetcher\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { SchemaUtils } from \\"./builders\\";

export type Schema<Raw = unknown, Parsed = unknown> = BaseSchema<Raw, Parsed> & SchemaUtils<Raw, Parsed>;

export type inferRaw<S extends Schema> = S extends Schema<infer Raw, any> ? Raw : never;
export type inferParsed<S extends Schema> = S extends Schema<any, infer Parsed> ? Parsed : never;

export interface BaseSchema<Raw, Parsed> {
  parse: (raw: Raw, opts?: SchemaOptions) => Parsed;
  json: (parsed: Parsed, opts?: SchemaOptions) => Raw;
}

export interface SchemaOptions {
  /**
   * @default false
   */
  skipUnknownKeysOnParse?: boolean;

  /**
   * @default false
   */
  includeUnknownKeysOnJson?: boolean;
}
",
                "name": "Schema.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function date(): Schema<string, Date> {
  const baseSchema: BaseSchema<string, Date> = {
    parse: (raw) => new Date(raw),
    json: (date) => date.toISOString(),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "date.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { date } from \\"./date\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "date",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function enum_<U extends string, E extends Readonly<[U, ...U[]]>>(_values: E): Schema<E[number], E[number]> {
  return createIdentitySchemaCreator<E[number]>()();
}
",
                        "name": "enum.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { enum_ } from \\"./enum\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "enum",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { identity } from \\"./identity\\";

export function createIdentitySchemaCreator<T>(): () => Schema<T, T> {
  return <T>() => identity<T>();
}
",
                        "name": "createIdentitySchemaCreator.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function identity<T>(): Schema<T, T> {
  const baseSchema: BaseSchema<T, T> = {
    parse: (raw) => raw,
    json: (parsed) => parsed,
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "identity.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { createIdentitySchemaCreator } from \\"./createIdentitySchemaCreator\\";
export { identity } from \\"./identity\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "identity",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./date\\";
export * from \\"./enum\\";
export * from \\"./identity\\";
export * from \\"./lazy\\";
export * from \\"./list\\";
export * from \\"./literals\\";
export * from \\"./object\\";
export * from \\"./object-like\\";
export * from \\"./primitives\\";
export * from \\"./record\\";
export * from \\"./schema-utils\\";
export * from \\"./set\\";
export * from \\"./union\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { lazy } from \\"./lazy\\";
export { lazyObject } from \\"./lazyObject\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

type Getter<Raw, Parsed> = () => Schema<Raw, Parsed>;
type MemoizedGetter<Raw, Parsed> = Getter<Raw, Parsed> & { __zurg_memoized?: Schema<Raw, Parsed> };

export function lazy<Raw, Parsed>(getter: Getter<Raw, Parsed>): Schema<Raw, Parsed> {
  const baseSchema = constructLazyBaseSchema(getter);
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function constructLazyBaseSchema<Raw, Parsed>(getter: Getter<Raw, Parsed>): BaseSchema<Raw, Parsed> {
  const getSchema = () => {
    const castedGetter = getter as MemoizedGetter<Raw, Parsed>;
    if (castedGetter.__zurg_memoized == null) {
      castedGetter.__zurg_memoized = getter();
    }
    return castedGetter.__zurg_memoized;
  };

  return {
    parse: (raw) => getSchema().parse(raw),
    json: (parsed) => getSchema().json(parsed),
  };
}
",
                        "name": "lazy.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { getObjectUtils } from \\"../object\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { ObjectSchema } from \\"../object/types\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { constructLazyBaseSchema } from \\"./lazy\\";

export function lazyObject<Raw, Parsed>(getter: () => ObjectSchema<Raw, Parsed>): ObjectSchema<Raw, Parsed> {
  const baseSchema = {
    ...OBJECT_LIKE_BRAND,
    ...constructLazyBaseSchema(getter),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}
",
                        "name": "lazyObject.ts",
                        "type": "file",
                      },
                    ],
                    "name": "lazy",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { list } from \\"./list\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function list<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Parsed[]> {
  const baseSchema: BaseSchema<Raw[], Parsed[]> = {
    parse: (raw, opts) => raw.map((item) => schema.parse(item, opts)),
    json: (parsed, opts) => parsed.map((item) => schema.json(item, opts)),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "list.ts",
                        "type": "file",
                      },
                    ],
                    "name": "list",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { stringLiteral } from \\"./stringLiteral\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function stringLiteral<V extends string>(_value: V): Schema<V, V> {
  return createIdentitySchemaCreator<V>()();
}
",
                        "name": "stringLiteral.ts",
                        "type": "file",
                      },
                    ],
                    "name": "literals",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { getObjectUtils, object } from \\"./object\\";
export { isProperty, property, type Property } from \\"./property\\";
export {
  type BaseObjectSchema,
  type inferObjectSchemaFromPropertySchemas,
  type inferParsedObject,
  type inferParsedObjectFromPropertySchemas,
  type inferParsedPropertySchema,
  type inferRawKey,
  type inferRawObject,
  type inferRawObjectFromPropertySchemas,
  type inferRawPropertySchema,
  type ObjectSchema,
  type ObjectUtils,
  type PropertySchemas,
} from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { isProperty } from \\"./property\\";
import {
  BaseObjectSchema,
  inferObjectSchemaFromPropertySchemas,
  inferParsedObjectFromPropertySchemas,
  inferRawObjectFromPropertySchemas,
  ObjectSchema,
  ObjectUtils,
  PropertySchemas,
} from \\"./types\\";

interface ObjectPropertyWithRawKey {
  rawKey: string;
  parsedKey: string | number | symbol;
  valueSchema: Schema<any, any>;
}

export function object<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(
  schemas: T
): inferObjectSchemaFromPropertySchemas<T> {
  const baseSchema: BaseObjectSchema<inferRawObjectFromPropertySchemas<T>, inferParsedObjectFromPropertySchemas<T>> = {
    ...OBJECT_LIKE_BRAND,

    parse: (raw, { skipUnknownKeysOnParse = false } = {}) => {
      const rawKeyToProperty: Record<string, ObjectPropertyWithRawKey> = {};

      for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
        const rawKey = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;

        const property: ObjectPropertyWithRawKey = {
          rawKey,
          parsedKey,
          valueSchema: isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.valueSchema : schemaOrObjectProperty,
        };

        rawKeyToProperty[rawKey] = property;
      }

      const parsed: Record<string | number | symbol, any> = {};

      for (const [rawKey, rawPropertyValue] of Object.entries(raw)) {
        const property = rawKeyToProperty[rawKey];

        if (property != null) {
          const value = property.valueSchema.parse(rawPropertyValue);
          parsed[property.parsedKey] = value;
        } else if (!skipUnknownKeysOnParse && rawPropertyValue != null) {
          parsed[rawKey] = rawPropertyValue;
        }
      }

      return parsed as inferParsedObjectFromPropertySchemas<T>;
    },

    json: (parsed, { includeUnknownKeysOnJson = false } = {}) => {
      const raw: Record<string | number | symbol, any> = {};

      for (const [parsedKey, parsedPropertyValue] of entries(parsed)) {
        const schemaOrObjectProperty = schemas[parsedKey as keyof T];
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (schemaOrObjectProperty != null) {
          if (isProperty(schemaOrObjectProperty)) {
            const value = schemaOrObjectProperty.valueSchema.json(parsedPropertyValue);
            raw[schemaOrObjectProperty.rawKey] = value;
          } else {
            const value = schemaOrObjectProperty.json(parsedPropertyValue);
            raw[parsedKey] = value;
          }
        } else if (includeUnknownKeysOnJson && parsedPropertyValue != null) {
          raw[parsedKey] = parsedPropertyValue;
        }
      }

      return raw as inferRawObjectFromPropertySchemas<T>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}

export function getObjectUtils<Raw, Parsed>(schema: BaseObjectSchema<Raw, Parsed>): ObjectUtils<Raw, Parsed> {
  return {
    extend: <RawExtension, ParsedExtension>(extension: ObjectSchema<RawExtension, ParsedExtension>) => {
      const baseSchema: BaseObjectSchema<Raw & RawExtension, Parsed & ParsedExtension> = {
        ...OBJECT_LIKE_BRAND,
        parse: (raw, opts) => ({
          ...schema.parse(raw, opts),
          ...extension.parse(raw, opts),
        }),
        json: (parsed, opts) => ({
          ...schema.json(parsed, opts),
          ...extension.json(parsed, opts),
        }),
      };

      return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
      };
    },
  };
}
",
                        "name": "object.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export function property<RawKey extends string, RawValue, ParsedValue>(
  rawKey: RawKey,
  valueSchema: Schema<RawValue, ParsedValue>
): Property<RawKey, RawValue, ParsedValue> {
  return {
    rawKey,
    valueSchema,
    isProperty: true,
  };
}

export interface Property<RawKey extends string, RawValue, ParsedValue> {
  rawKey: RawKey;
  valueSchema: Schema<RawValue, ParsedValue>;
  isProperty: true;
}

export function isProperty<O extends Property<any, any, any>>(maybeProperty: unknown): maybeProperty is O {
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return (maybeProperty as O).isProperty;
}
",
                        "name": "property.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsed, inferRaw, Schema } from \\"../../Schema\\";
import { addQuestionMarksToNullableProperties } from \\"../../utils/addQuestionMarksToNullableProperties\\";
import { BaseObjectLikeSchema, ObjectLikeSchema } from \\"../object-like\\";
import { Property } from \\"./property\\";

export type ObjectSchema<Raw, Parsed> = BaseObjectSchema<Raw, Parsed> &
  ObjectLikeSchema<Raw, Parsed> &
  ObjectUtils<Raw, Parsed>;

export type BaseObjectSchema<Raw, Parsed> = BaseObjectLikeSchema<Raw, Parsed>;

export interface ObjectUtils<Raw, Parsed> {
  extend: <RawExtension, ParsedExtension>(
    schemas: ObjectSchema<RawExtension, ParsedExtension>
  ) => ObjectSchema<Raw & RawExtension, Parsed & ParsedExtension>;
}

export type inferRawObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<infer Raw, any> ? Raw : never;

export type inferParsedObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<any, infer Parsed>
  ? Parsed
  : never;

export type inferObjectSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> = ObjectSchema<
  inferRawObjectFromPropertySchemas<T>,
  inferParsedObjectFromPropertySchemas<T>
>;

export type inferRawObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
  addQuestionMarksToNullableProperties<{
    [ParsedKey in keyof T as inferRawKey<ParsedKey, T[ParsedKey]>]: inferRawPropertySchema<T[ParsedKey]>;
  }>;

export type inferParsedObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
  addQuestionMarksToNullableProperties<{
    [K in keyof T]: inferParsedPropertySchema<T[K]>;
  }>;

export type PropertySchemas<ParsedKeys extends string | number | symbol> = Record<
  ParsedKeys,
  Property<any, any, any> | Schema<any, any>
>;

export type inferRawPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
  any,
  infer Raw,
  any
>
  ? Raw
  : P extends Schema<any, any>
  ? inferRaw<P>
  : never;

export type inferParsedPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
  any,
  any,
  infer Parsed
>
  ? Parsed
  : P extends Schema<any, any>
  ? inferParsed<P>
  : never;

export type inferRawKey<
  ParsedKey extends string | number | symbol,
  P extends Property<any, any, any> | Schema<any, any>
> = P extends Property<infer Raw, any, any> ? Raw : ParsedKey;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseObjectLikeSchema, ObjectLikeUtils } from \\"./types\\";
import { withProperties } from \\"./withProperties\\";

export function getObjectLikeUtils<Raw, Parsed>(
  schema: BaseObjectLikeSchema<Raw, Parsed>
): ObjectLikeUtils<Raw, Parsed> {
  return {
    withProperties: (properties) => withProperties(schema, properties),
  };
}
",
                        "name": "getObjectLikeUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getObjectLikeUtils } from \\"./getObjectLikeUtils\\";
export { OBJECT_LIKE_BRAND, type BaseObjectLikeSchema, type ObjectLikeSchema, type ObjectLikeUtils } from \\"./types\\";
export { withProperties } from \\"./withProperties\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";

export type ObjectLikeSchema<Raw, Parsed> = Schema<Raw, Parsed> &
  BaseObjectLikeSchema<Raw, Parsed> &
  ObjectLikeUtils<Raw, Parsed>;

export type BaseObjectLikeSchema<Raw, Parsed> = BaseSchema<Raw, Parsed> & {
  _objectLike: void;
};

export interface ObjectLikeUtils<Raw, Parsed> {
  withProperties: <T extends Record<string, any>>(properties: {
    [K in keyof T]: T[K] | ((parsed: Parsed) => T[K]);
  }) => ObjectLikeSchema<Raw, Parsed & T>;
}

export const OBJECT_LIKE_BRAND = undefined as unknown as { _objectLike: void };
",
                        "name": "types.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { getSchemaUtils } from \\"../schema-utils\\";
import { getObjectLikeUtils } from \\"./getObjectLikeUtils\\";
import { BaseObjectLikeSchema, ObjectLikeSchema, OBJECT_LIKE_BRAND } from \\"./types\\";

export function withProperties<RawObjectShape, ParsedObjectShape, Properties>(
  objectLike: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape>,
  properties: { [K in keyof Properties]: Properties[K] | ((parsed: ParsedObjectShape) => Properties[K]) }
): ObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> {
  const objectSchema: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> = {
    ...OBJECT_LIKE_BRAND,
    parse: (raw, opts) => {
      const parsedObject = objectLike.parse(raw, opts);
      const additionalProperties = Object.entries(properties).reduce<Record<string, any>>((processed, [key, value]) => {
        return {
          ...processed,
          [key]: typeof value === \\"function\\" ? value(parsedObject) : value,
        };
      }, {});

      return {
        ...parsedObject,
        ...(additionalProperties as Properties),
      };
    },
    json: (parsed, opts) => {
      // strip out added properties
      const addedPropertyKeys = new Set(Object.keys(properties));
      const parsedWithoutAddedProperties = Object.entries(parsed).reduce<Record<string, any>>(
        (filtered, [key, value]) => {
          if (!addedPropertyKeys.has(key)) {
            filtered[key] = value;
          }
          return filtered;
        },
        {}
      );

      return objectLike.json(parsedWithoutAddedProperties as ParsedObjectShape, opts);
    },
  };

  return {
    ...objectSchema,
    ...getSchemaUtils(objectSchema),
    ...getObjectLikeUtils(objectSchema),
  };
}
",
                        "name": "withProperties.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object-like",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const any = createIdentitySchemaCreator<any>();
",
                        "name": "any.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const boolean = createIdentitySchemaCreator<boolean>();
",
                        "name": "boolean.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { any } from \\"./any\\";
export { boolean } from \\"./boolean\\";
export { number } from \\"./number\\";
export { string } from \\"./string\\";
export { unknown } from \\"./unknown\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const number = createIdentitySchemaCreator<number>();
",
                        "name": "number.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const string = createIdentitySchemaCreator<string>();
",
                        "name": "string.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const unknown = createIdentitySchemaCreator<unknown>();
",
                        "name": "unknown.ts",
                        "type": "file",
                      },
                    ],
                    "name": "primitives",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { record } from \\"./record\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function record<RawKey extends string | number, ParsedKey extends string | number, RawValue, ParsedValue>(
  keySchema: Schema<RawKey, ParsedKey>,
  valueSchema: Schema<RawValue, ParsedValue>
): Schema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> {
  const baseSchema: BaseSchema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> = {
    parse: (raw, opts) => {
      return entries(raw).reduce(
        (parsed, [key, value]) => {
          parsed[keySchema.parse(key, opts)] = valueSchema.parse(value, opts);
          return parsed;
        },
        // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
        {} as Record<ParsedKey, ParsedValue>
      );
    },
    json: (parsed, opts) => {
      return entries(parsed).reduce(
        (raw, [key, value]) => {
          raw[keySchema.json(key, opts)] = valueSchema.json(value, opts);
          return raw;
        },
        // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
        {} as Record<RawKey, RawValue>
      );
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "record.ts",
                        "type": "file",
                      },
                    ],
                    "name": "record",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { OptionalSchema, OPTIONAL_BRAND } from \\"./types\\";

export interface SchemaUtils<Raw, Parsed> {
  optional: () => OptionalSchema<Raw, Parsed>;
  transform: <PostTransform>(transformer: BaseSchema<Parsed, PostTransform>) => Schema<Raw, PostTransform>;
}

export function getSchemaUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): SchemaUtils<Raw, Parsed> {
  return {
    optional: () => optional(schema),
    transform: (transformer) => transform(schema, transformer),
  };
}

/**
 * schema utils are defined in one file to resolve issues with circular imports
 */

export function optional<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): OptionalSchema<Raw, Parsed> {
  const baseSchema: BaseSchema<Raw | null | undefined, Parsed | undefined> = {
    parse: (raw, opts) => (raw != null ? schema.parse(raw, opts) : undefined),
    json: (parsed, opts) => (parsed != null ? schema.json(parsed, opts) : undefined),
  };

  return {
    ...OPTIONAL_BRAND,
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function transform<PreTransformRaw, PreTransformParsed, PostTransform>(
  schema: BaseSchema<PreTransformRaw, PreTransformParsed>,
  transformer: BaseSchema<PreTransformParsed, PostTransform>
): Schema<PreTransformRaw, PostTransform> {
  const baseSchema: BaseSchema<PreTransformRaw, PostTransform> = {
    parse: (raw, opts) => {
      const postTransformParsed = schema.parse(raw, opts);
      return transformer.parse(postTransformParsed, opts);
    },
    json: (parsed, opts) => {
      const preTransformParsed = transformer.json(parsed, opts);
      return schema.json(preTransformParsed, opts);
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "getSchemaUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getSchemaUtils, optional, transform, type SchemaUtils } from \\"./getSchemaUtils\\";
export { OPTIONAL_BRAND, type OptionalSchema } from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export const OPTIONAL_BRAND = undefined as unknown as { _isOptional: void };

export type OptionalSchema<Raw, Parsed> = Schema<Raw | null | undefined, Parsed | undefined> & {
  _isOptional: void;
};
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "schema-utils",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { set } from \\"./set\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function set<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Set<Parsed>> {
  const baseSchema: BaseSchema<Raw[], Set<Parsed>> = {
    parse: (raw, opts) => new Set(raw.map((item) => schema.parse(item, opts))),
    json: (parsed, opts) => [...parsed].map((item) => schema.json(item, opts)),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "set.ts",
                        "type": "file",
                      },
                    ],
                    "name": "set",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export function discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string>(
  parsedDiscriminant: ParsedDiscriminant,
  rawDiscriminant: RawDiscriminant
): Discriminant<RawDiscriminant, ParsedDiscriminant> {
  return {
    parsedDiscriminant,
    rawDiscriminant,
  };
}

export interface Discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string> {
  parsedDiscriminant: ParsedDiscriminant;
  rawDiscriminant: RawDiscriminant;
}
",
                        "name": "discriminant.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { discriminant, type Discriminant } from \\"./discriminant\\";
export {
  type inferParsedDiscriminant,
  type inferParsedUnion,
  type inferRawDiscriminant,
  type inferRawUnion,
  type UnionSubtypes,
} from \\"./types\\";
export { union } from \\"./union\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsedObject, inferRawObject, ObjectSchema } from \\"../object\\";
import { Discriminant } from \\"./discriminant\\";

export type UnionSubtypes<DiscriminantValues extends string | number | symbol> = {
  [K in DiscriminantValues]: ObjectSchema<any, any>;
};

export type inferRawUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
  [K in keyof U]: Record<inferRawDiscriminant<D>, K> & inferRawObject<U[K]>;
}[keyof U];

export type inferParsedUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
  [K in keyof U]: Record<inferParsedDiscriminant<D>, K> & inferParsedObject<U[K]>;
}[keyof U];

export type inferRawDiscriminant<D extends string | Discriminant<any, any>> = D extends string
  ? D
  : D extends Discriminant<infer Raw, any>
  ? Raw
  : never;

export type inferParsedDiscriminant<D extends string | Discriminant<any, any>> = D extends string
  ? D
  : D extends Discriminant<any, infer Parsed>
  ? Parsed
  : never;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseObjectLikeSchema, getObjectLikeUtils, ObjectLikeSchema, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { Discriminant } from \\"./discriminant\\";
import { inferParsedDiscriminant, inferParsedUnion, inferRawDiscriminant, inferRawUnion, UnionSubtypes } from \\"./types\\";

export function union<D extends string | Discriminant<any, any>, U extends UnionSubtypes<any>>(
  discriminant: D,
  union: U
): ObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> {
  const rawDiscriminant =
    typeof discriminant === \\"string\\" ? discriminant : (discriminant.rawDiscriminant as inferRawDiscriminant<D>);
  const parsedDiscriminant =
    typeof discriminant === \\"string\\" ? discriminant : (discriminant.parsedDiscriminant as inferParsedDiscriminant<D>);

  const baseSchema: BaseObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> = {
    ...OBJECT_LIKE_BRAND,

    parse: (raw, opts) => {
      const { [rawDiscriminant]: discriminantValue, ...additionalProperties } = raw;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [parsedDiscriminant]: discriminantValue,
        } as inferParsedUnion<D, U>;
      }

      return {
        ...additionalPropertySchemas.parse(additionalProperties, opts),
        [parsedDiscriminant]: discriminantValue,
      } as inferParsedUnion<D, U>;
    },

    json: (parsed, opts) => {
      const { [parsedDiscriminant]: discriminantValue, ...additionalProperties } = parsed;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [rawDiscriminant]: discriminantValue,
        } as unknown as inferRawUnion<D, U>;
      }

      return {
        ...additionalPropertySchemas.json(additionalProperties, opts),
        [rawDiscriminant]: discriminantValue,
      } as inferRawUnion<D, U>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
  };
}
",
                        "name": "union.ts",
                        "type": "file",
                      },
                    ],
                    "name": "union",
                    "type": "directory",
                  },
                ],
                "name": "builders",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./builders\\";
export { type inferParsed, type inferRaw, type Schema, type SchemaOptions } from \\"./Schema\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export type addQuestionMarksToNullableProperties<T> = {
  [K in OptionalKeys<T>]?: undefined extends T[K] ? T[K] : never;
} & Pick<T, RequiredKeys<T>>;

export type OptionalKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? K : never;
}[keyof T];

export type RequiredKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? never : K;
}[keyof T];
",
                    "name": "addQuestionMarksToNullableProperties.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function entries<T>(object: T): [keyof T, T[keyof T]][] {
  return Object.entries(object) as [keyof T, T[keyof T]][];
}
",
                    "name": "entries.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function keys<T>(object: T): (keyof T)[] {
  return Object.keys(object) as (keyof T)[];
}
",
                    "name": "keys.ts",
                    "type": "file",
                  },
                ],
                "name": "utils",
                "type": "directory",
              },
            ],
            "name": "schemas",
            "type": "directory",
          },
        ],
        "name": "core",
        "type": "directory",
      },
      Object {
        "contents": "export * as FernNurseryApi from \\"./resources\\";
export { FernNurseryApiClient } from \\"./Client\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * as owner from \\"./owner\\";
export * from \\"./owner/types\\";
export * as token from \\"./token\\";
export * from \\"./token/types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernNurseryApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";
import * as core from \\"../../../core\\";

export declare namespace Client {
  interface Options {
    environment: string;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async create(request: FernNurseryApi.owner.CreateOwnerRequest): Promise<FernNurseryApi.owner.create.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment, \\"/owner/\\"),
      method: \\"POST\\",
      body: serializers.owner.CreateOwnerRequest.json(request),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    if (response.error.reason === \\"status-code\\") {
      switch ((response.error.body as serializers.owner.create.Error.Raw)?.errorName) {
        case \\"OwnerAlreadyExistsError\\":
          return {
            ok: false,
            error: serializers.owner.create.Error.parse(response.error.body as serializers.owner.create.Error.Raw),
          };
      }
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async get(request: FernNurseryApi.owner.get.Request): Promise<FernNurseryApi.owner.get.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment, \`/owner/\${request.ownerId}\`),
      method: \\"GET\\",
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.owner.Owner.parse(response.body as serializers.owner.Owner.Raw),
      };
    }

    if (response.error.reason === \\"status-code\\") {
      switch ((response.error.body as serializers.owner.get.Error.Raw)?.errorName) {
        case \\"OwnerNotFoundError\\":
          return {
            ok: false,
            error: serializers.owner.get.Error.parse(response.error.body as serializers.owner.get.Error.Raw),
          };
      }
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async update(request: FernNurseryApi.owner.update.Request): Promise<FernNurseryApi.owner.update.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment, \`/owner/\${request.ownerId}\`),
      method: \\"PUT\\",
      body: serializers.owner.UpdateOwnerRequest.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.owner.Owner.parse(response.body as serializers.owner.Owner.Raw),
      };
    }

    if (response.error.reason === \\"status-code\\") {
      switch ((response.error.body as serializers.owner.update.Error.Raw)?.errorName) {
        case \\"OwnerNotFoundError\\":
          return {
            ok: false,
            error: serializers.owner.update.Error.parse(response.error.body as serializers.owner.update.Error.Raw),
          };
      }
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernNurseryApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, FernNurseryApi.owner.create.Error>;
export type Error = Error.OwnerAlreadyExistsError | Error._Unknown;

export declare namespace Error {
  interface OwnerAlreadyExistsError extends _Utils {
    errorName: \\"OwnerAlreadyExistsError\\";
  }

  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    ownerAlreadyExistsError: () => Result;
    _other: (value: core.Fetcher.Error) => Result;
  }
}

export const Error = {
  ownerAlreadyExistsError: (): Error.OwnerAlreadyExistsError => {
    const valueWithoutVisit: Omit<Error.OwnerAlreadyExistsError, \\"_visit\\"> = {
      errorName: \\"OwnerAlreadyExistsError\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as Error.OwnerAlreadyExistsError;
    castedValue._visit = (visitor) => visitor.ownerAlreadyExistsError();
    return castedValue;
  },
} as const;
",
                    "name": "create.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernNurseryApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  ownerId: FernNurseryApi.owner.OwnerId;
}

export type Response = core.APIResponse<FernNurseryApi.owner.Owner, FernNurseryApi.owner.get.Error>;
export type Error = Error.OwnerNotFoundError | Error._Unknown;

export declare namespace Error {
  interface OwnerNotFoundError extends _Utils {
    errorName: \\"OwnerNotFoundError\\";
  }

  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    ownerNotFoundError: () => Result;
    _other: (value: core.Fetcher.Error) => Result;
  }
}

export const Error = {
  ownerNotFoundError: (): Error.OwnerNotFoundError => {
    const valueWithoutVisit: Omit<Error.OwnerNotFoundError, \\"_visit\\"> = {
      errorName: \\"OwnerNotFoundError\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as Error.OwnerNotFoundError;
    castedValue._visit = (visitor) => visitor.ownerNotFoundError();
    return castedValue;
  },
} as const;
",
                    "name": "get.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as create from \\"./create\\";
export * as get from \\"./get\\";
export * as update from \\"./update\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernNurseryApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  ownerId: FernNurseryApi.owner.OwnerId;
  _body: FernNurseryApi.owner.UpdateOwnerRequest;
}

export type Response = core.APIResponse<FernNurseryApi.owner.Owner, FernNurseryApi.owner.update.Error>;
export type Error = Error.OwnerNotFoundError | Error._Unknown;

export declare namespace Error {
  interface OwnerNotFoundError extends _Utils {
    errorName: \\"OwnerNotFoundError\\";
  }

  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    ownerNotFoundError: () => Result;
    _other: (value: core.Fetcher.Error) => Result;
  }
}

export const Error = {
  ownerNotFoundError: (): Error.OwnerNotFoundError => {
    const valueWithoutVisit: Omit<Error.OwnerNotFoundError, \\"_visit\\"> = {
      errorName: \\"OwnerNotFoundError\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as Error.OwnerNotFoundError;
    castedValue._visit = (visitor) => visitor.ownerNotFoundError();
    return castedValue;
  },
} as const;
",
                    "name": "update.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernNurseryApi } from \\"../../..\\";

export interface CreateOwnerRequest {
  ownerId: FernNurseryApi.owner.OwnerId;
  data?: unknown;
}
",
                    "name": "CreateOwnerRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernNurseryApi } from \\"../../..\\";

export interface Owner {
  ownerId: FernNurseryApi.owner.OwnerId;
  data?: unknown;
}
",
                    "name": "Owner.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

/**
 * Unique id for an owner.
 */
export type OwnerId = string;
",
                    "name": "OwnerId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface UpdateOwnerRequest {
  data?: unknown;
}
",
                    "name": "UpdateOwnerRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./OwnerId\\";
export * from \\"./CreateOwnerRequest\\";
export * from \\"./UpdateOwnerRequest\\";
export * from \\"./Owner\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "owner",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernNurseryApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";
import * as core from \\"../../../core\\";

export declare namespace Client {
  interface Options {
    environment: string;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async create(request: FernNurseryApi.token.CreateTokenRequest): Promise<FernNurseryApi.token.create.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment, \\"/tokens/create\\"),
      method: \\"POST\\",
      body: serializers.token.CreateTokenRequest.json(request),
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.token.CreateTokenResponse.parse(response.body as serializers.token.CreateTokenResponse.Raw),
      };
    }

    if (response.error.reason === \\"status-code\\") {
      switch ((response.error.body as serializers.token.create.Error.Raw)?.errorName) {
        case \\"OwnerNotFoundError\\":
          return {
            ok: false,
            error: serializers.token.create.Error.parse(response.error.body as serializers.token.create.Error.Raw),
          };
      }
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getTokenMetadata(
    request: FernNurseryApi.token.GetTokenMetadataRequest
  ): Promise<FernNurseryApi.token.getTokenMetadata.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment, \\"/tokens/metadata\\"),
      method: \\"POST\\",
      body: serializers.token.GetTokenMetadataRequest.json(request),
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.token.TokenMetadata.parse(response.body as serializers.token.TokenMetadata.Raw),
      };
    }

    if (response.error.reason === \\"status-code\\") {
      switch ((response.error.body as serializers.token.getTokenMetadata.Error.Raw)?.errorName) {
        case \\"TokenNotFoundError\\":
          return {
            ok: false,
            error: serializers.token.getTokenMetadata.Error.parse(
              response.error.body as serializers.token.getTokenMetadata.Error.Raw
            ),
          };
      }
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getTokensForOwner(
    request: FernNurseryApi.token.getTokensForOwner.Request
  ): Promise<FernNurseryApi.token.getTokensForOwner.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment, \`/tokens/owner/\${request.ownerId}\`),
      method: \\"GET\\",
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.token.getTokensForOwner.Response.parse(
          response.body as serializers.token.TokenMetadata.Raw[]
        ),
      };
    }

    if (response.error.reason === \\"status-code\\") {
      switch ((response.error.body as serializers.token.getTokensForOwner.Error.Raw)?.errorName) {
        case \\"OwnerNotFoundError\\":
          return {
            ok: false,
            error: serializers.token.getTokensForOwner.Error.parse(
              response.error.body as serializers.token.getTokensForOwner.Error.Raw
            ),
          };
      }
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernNurseryApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<FernNurseryApi.token.CreateTokenResponse, FernNurseryApi.token.create.Error>;
export type Error = Error.OwnerNotFoundError | Error._Unknown;

export declare namespace Error {
  interface OwnerNotFoundError extends _Utils {
    errorName: \\"OwnerNotFoundError\\";
  }

  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    ownerNotFoundError: () => Result;
    _other: (value: core.Fetcher.Error) => Result;
  }
}

export const Error = {
  ownerNotFoundError: (): Error.OwnerNotFoundError => {
    const valueWithoutVisit: Omit<Error.OwnerNotFoundError, \\"_visit\\"> = {
      errorName: \\"OwnerNotFoundError\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as Error.OwnerNotFoundError;
    castedValue._visit = (visitor) => visitor.ownerNotFoundError();
    return castedValue;
  },
} as const;
",
                    "name": "create.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernNurseryApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  FernNurseryApi.token.TokenMetadata,
  FernNurseryApi.token.getTokenMetadata.Error
>;
export type Error = Error.TokenNotFoundError | Error._Unknown;

export declare namespace Error {
  interface TokenNotFoundError extends _Utils {
    errorName: \\"TokenNotFoundError\\";
  }

  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    tokenNotFoundError: () => Result;
    _other: (value: core.Fetcher.Error) => Result;
  }
}

export const Error = {
  tokenNotFoundError: (): Error.TokenNotFoundError => {
    const valueWithoutVisit: Omit<Error.TokenNotFoundError, \\"_visit\\"> = {
      errorName: \\"TokenNotFoundError\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as Error.TokenNotFoundError;
    castedValue._visit = (visitor) => visitor.tokenNotFoundError();
    return castedValue;
  },
} as const;
",
                    "name": "getTokenMetadata.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernNurseryApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  ownerId: FernNurseryApi.owner.OwnerId;
}

export type Response = core.APIResponse<
  FernNurseryApi.token.TokenMetadata[],
  FernNurseryApi.token.getTokensForOwner.Error
>;
export type Error = Error.OwnerNotFoundError | Error._Unknown;

export declare namespace Error {
  interface OwnerNotFoundError extends _Utils {
    errorName: \\"OwnerNotFoundError\\";
  }

  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    ownerNotFoundError: () => Result;
    _other: (value: core.Fetcher.Error) => Result;
  }
}

export const Error = {
  ownerNotFoundError: (): Error.OwnerNotFoundError => {
    const valueWithoutVisit: Omit<Error.OwnerNotFoundError, \\"_visit\\"> = {
      errorName: \\"OwnerNotFoundError\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as Error.OwnerNotFoundError;
    castedValue._visit = (visitor) => visitor.ownerNotFoundError();
    return castedValue;
  },
} as const;
",
                    "name": "getTokensForOwner.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as create from \\"./create\\";
export * as getTokenMetadata from \\"./getTokenMetadata\\";
export * as getTokensForOwner from \\"./getTokensForOwner\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernNurseryApi } from \\"../../..\\";

export interface CreateTokenRequest {
  ownerId: FernNurseryApi.owner.OwnerId;
  description?: string;
}
",
                    "name": "CreateTokenRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernNurseryApi } from \\"../../..\\";

export interface CreateTokenResponse {
  token: string;
  tokenId: FernNurseryApi.token.TokenId;
}
",
                    "name": "CreateTokenResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface GetTokenMetadataRequest {
  token: string;
}
",
                    "name": "GetTokenMetadataRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export type TokenId = string;
",
                    "name": "TokenId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernNurseryApi } from \\"../../..\\";

export interface TokenMetadata {
  tokenId: FernNurseryApi.token.TokenId;
  ownerId: FernNurseryApi.owner.OwnerId;
  description?: string;
  createdTime: Date;
  status: FernNurseryApi.token.TokenStatus;
}
",
                    "name": "TokenMetadata.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export type TokenStatus = TokenStatus.Active | TokenStatus.Expired | TokenStatus.Revoked | TokenStatus._Unknown;

export declare namespace TokenStatus {
  interface Active extends _Utils {
    type: \\"active\\";
  }

  interface Expired extends _Utils {
    type: \\"expired\\";
  }

  interface Revoked extends _Utils {
    type: \\"revoked\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: TokenStatus._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    active: () => Result;
    expired: () => Result;
    revoked: () => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const TokenStatus = {
  active: (): TokenStatus.Active => {
    const valueWithoutVisit: Omit<TokenStatus.Active, \\"_visit\\"> = {
      type: \\"active\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TokenStatus.Active;
    castedValue._visit = (visitor) => visitor.active();
    return castedValue;
  },

  expired: (): TokenStatus.Expired => {
    const valueWithoutVisit: Omit<TokenStatus.Expired, \\"_visit\\"> = {
      type: \\"expired\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TokenStatus.Expired;
    castedValue._visit = (visitor) => visitor.expired();
    return castedValue;
  },

  revoked: (): TokenStatus.Revoked => {
    const valueWithoutVisit: Omit<TokenStatus.Revoked, \\"_visit\\"> = {
      type: \\"revoked\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TokenStatus.Revoked;
    castedValue._visit = (visitor) => visitor.revoked();
    return castedValue;
  },
} as const;
",
                    "name": "TokenStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./TokenId\\";
export * from \\"./CreateTokenRequest\\";
export * from \\"./CreateTokenResponse\\";
export * from \\"./GetTokenMetadataRequest\\";
export * from \\"./TokenMetadata\\";
export * from \\"./TokenStatus\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "token",
            "type": "directory",
          },
        ],
        "name": "resources",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * as owner from \\"./owner\\";
export * from \\"./owner/types\\";
export * as token from \\"./token\\";
export * from \\"./token/types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernNurseryApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Error: core.schemas.Schema<Error.Raw, FernNurseryApi.owner.create.Error> = core.schemas
  .union(\\"errorName\\", {
    OwnerAlreadyExistsError: core.schemas.object({}),
  })
  .transform<FernNurseryApi.owner.create.Error>({
    parse: (value) => {
      switch (value.errorName) {
        case \\"OwnerAlreadyExistsError\\": {
          return FernNurseryApi.owner.create.Error.ownerAlreadyExistsError();
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace Error {
  type Raw = Error.OwnerAlreadyExistsError;

  interface OwnerAlreadyExistsError {
    errorName: \\"OwnerAlreadyExistsError\\";
  }
}
",
                    "name": "create.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernNurseryApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Error: core.schemas.Schema<Error.Raw, FernNurseryApi.owner.get.Error> = core.schemas
  .union(\\"errorName\\", {
    OwnerNotFoundError: core.schemas.object({}),
  })
  .transform<FernNurseryApi.owner.get.Error>({
    parse: (value) => {
      switch (value.errorName) {
        case \\"OwnerNotFoundError\\": {
          return FernNurseryApi.owner.get.Error.ownerNotFoundError();
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace Error {
  type Raw = Error.OwnerNotFoundError;

  interface OwnerNotFoundError {
    errorName: \\"OwnerNotFoundError\\";
  }
}
",
                    "name": "get.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as create from \\"./create\\";
export * as get from \\"./get\\";
export * as update from \\"./update\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernNurseryApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Error: core.schemas.Schema<Error.Raw, FernNurseryApi.owner.update.Error> = core.schemas
  .union(\\"errorName\\", {
    OwnerNotFoundError: core.schemas.object({}),
  })
  .transform<FernNurseryApi.owner.update.Error>({
    parse: (value) => {
      switch (value.errorName) {
        case \\"OwnerNotFoundError\\": {
          return FernNurseryApi.owner.update.Error.ownerNotFoundError();
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace Error {
  type Raw = Error.OwnerNotFoundError;

  interface OwnerNotFoundError {
    errorName: \\"OwnerNotFoundError\\";
  }
}
",
                    "name": "update.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernNurseryApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const CreateOwnerRequest: core.schemas.ObjectSchema<
  CreateOwnerRequest.Raw,
  FernNurseryApi.owner.CreateOwnerRequest
> = core.schemas.object({
  ownerId: core.schemas.lazy(() => serializers.owner.OwnerId),
  data: core.schemas.unknown(),
});

export declare namespace CreateOwnerRequest {
  interface Raw {
    ownerId: serializers.owner.OwnerId.Raw;
    data?: unknown;
  }
}
",
                    "name": "CreateOwnerRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernNurseryApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const Owner: core.schemas.ObjectSchema<Owner.Raw, FernNurseryApi.owner.Owner> = core.schemas.object({
  ownerId: core.schemas.lazy(() => serializers.owner.OwnerId),
  data: core.schemas.unknown(),
});

export declare namespace Owner {
  interface Raw {
    ownerId: serializers.owner.OwnerId.Raw;
    data?: unknown;
  }
}
",
                    "name": "Owner.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernNurseryApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const OwnerId: core.schemas.Schema<OwnerId.Raw, FernNurseryApi.owner.OwnerId> = core.schemas.string();

export declare namespace OwnerId {
  type Raw = string;
}
",
                    "name": "OwnerId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernNurseryApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const UpdateOwnerRequest: core.schemas.ObjectSchema<
  UpdateOwnerRequest.Raw,
  FernNurseryApi.owner.UpdateOwnerRequest
> = core.schemas.object({
  data: core.schemas.unknown(),
});

export declare namespace UpdateOwnerRequest {
  interface Raw {
    data?: unknown;
  }
}
",
                    "name": "UpdateOwnerRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./OwnerId\\";
export * from \\"./CreateOwnerRequest\\";
export * from \\"./UpdateOwnerRequest\\";
export * from \\"./Owner\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "owner",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernNurseryApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Error: core.schemas.Schema<Error.Raw, FernNurseryApi.token.create.Error> = core.schemas
  .union(\\"errorName\\", {
    OwnerNotFoundError: core.schemas.object({}),
  })
  .transform<FernNurseryApi.token.create.Error>({
    parse: (value) => {
      switch (value.errorName) {
        case \\"OwnerNotFoundError\\": {
          return FernNurseryApi.token.create.Error.ownerNotFoundError();
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace Error {
  type Raw = Error.OwnerNotFoundError;

  interface OwnerNotFoundError {
    errorName: \\"OwnerNotFoundError\\";
  }
}
",
                    "name": "create.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernNurseryApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Error: core.schemas.Schema<Error.Raw, FernNurseryApi.token.getTokenMetadata.Error> = core.schemas
  .union(\\"errorName\\", {
    TokenNotFoundError: core.schemas.object({}),
  })
  .transform<FernNurseryApi.token.getTokenMetadata.Error>({
    parse: (value) => {
      switch (value.errorName) {
        case \\"TokenNotFoundError\\": {
          return FernNurseryApi.token.getTokenMetadata.Error.tokenNotFoundError();
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace Error {
  type Raw = Error.TokenNotFoundError;

  interface TokenNotFoundError {
    errorName: \\"TokenNotFoundError\\";
  }
}
",
                    "name": "getTokenMetadata.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernNurseryApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  serializers.token.TokenMetadata.Raw[],
  FernNurseryApi.token.TokenMetadata[]
> = core.schemas.list(core.schemas.lazyObject(() => serializers.token.TokenMetadata));
export const Error: core.schemas.Schema<Error.Raw, FernNurseryApi.token.getTokensForOwner.Error> = core.schemas
  .union(\\"errorName\\", {
    OwnerNotFoundError: core.schemas.object({}),
  })
  .transform<FernNurseryApi.token.getTokensForOwner.Error>({
    parse: (value) => {
      switch (value.errorName) {
        case \\"OwnerNotFoundError\\": {
          return FernNurseryApi.token.getTokensForOwner.Error.ownerNotFoundError();
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace Error {
  type Raw = Error.OwnerNotFoundError;

  interface OwnerNotFoundError {
    errorName: \\"OwnerNotFoundError\\";
  }
}
",
                    "name": "getTokensForOwner.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as create from \\"./create\\";
export * as getTokenMetadata from \\"./getTokenMetadata\\";
export * as getTokensForOwner from \\"./getTokensForOwner\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernNurseryApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const CreateTokenRequest: core.schemas.ObjectSchema<
  CreateTokenRequest.Raw,
  FernNurseryApi.token.CreateTokenRequest
> = core.schemas.object({
  ownerId: core.schemas.lazy(() => serializers.owner.OwnerId),
  description: core.schemas.string().optional(),
});

export declare namespace CreateTokenRequest {
  interface Raw {
    ownerId: serializers.owner.OwnerId.Raw;
    description?: string | null;
  }
}
",
                    "name": "CreateTokenRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernNurseryApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const CreateTokenResponse: core.schemas.ObjectSchema<
  CreateTokenResponse.Raw,
  FernNurseryApi.token.CreateTokenResponse
> = core.schemas.object({
  token: core.schemas.string(),
  tokenId: core.schemas.lazy(() => serializers.token.TokenId),
});

export declare namespace CreateTokenResponse {
  interface Raw {
    token: string;
    tokenId: serializers.token.TokenId.Raw;
  }
}
",
                    "name": "CreateTokenResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernNurseryApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const GetTokenMetadataRequest: core.schemas.ObjectSchema<
  GetTokenMetadataRequest.Raw,
  FernNurseryApi.token.GetTokenMetadataRequest
> = core.schemas.object({
  token: core.schemas.string(),
});

export declare namespace GetTokenMetadataRequest {
  interface Raw {
    token: string;
  }
}
",
                    "name": "GetTokenMetadataRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernNurseryApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const TokenId: core.schemas.Schema<TokenId.Raw, FernNurseryApi.token.TokenId> = core.schemas.string();

export declare namespace TokenId {
  type Raw = string;
}
",
                    "name": "TokenId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernNurseryApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TokenMetadata: core.schemas.ObjectSchema<TokenMetadata.Raw, FernNurseryApi.token.TokenMetadata> =
  core.schemas.object({
    tokenId: core.schemas.lazy(() => serializers.token.TokenId),
    ownerId: core.schemas.lazy(() => serializers.owner.OwnerId),
    description: core.schemas.string().optional(),
    createdTime: core.schemas.date(),
    status: core.schemas.lazy(() => serializers.token.TokenStatus),
  });

export declare namespace TokenMetadata {
  interface Raw {
    tokenId: serializers.token.TokenId.Raw;
    ownerId: serializers.owner.OwnerId.Raw;
    description?: string | null;
    createdTime: string;
    status: serializers.token.TokenStatus.Raw;
  }
}
",
                    "name": "TokenMetadata.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernNurseryApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const TokenStatus: core.schemas.Schema<TokenStatus.Raw, FernNurseryApi.token.TokenStatus> = core.schemas
  .union(\\"type\\", {
    active: core.schemas.object({}),
    expired: core.schemas.object({}),
    revoked: core.schemas.object({}),
  })
  .transform<FernNurseryApi.token.TokenStatus>({
    parse: (value) => {
      switch (value.type) {
        case \\"active\\": {
          return FernNurseryApi.token.TokenStatus.active();
        }
        case \\"expired\\": {
          return FernNurseryApi.token.TokenStatus.expired();
        }
        case \\"revoked\\": {
          return FernNurseryApi.token.TokenStatus.revoked();
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace TokenStatus {
  type Raw = TokenStatus.Active | TokenStatus.Expired | TokenStatus.Revoked;

  interface Active {
    type: \\"active\\";
  }

  interface Expired {
    type: \\"expired\\";
  }

  interface Revoked {
    type: \\"revoked\\";
  }
}
",
                    "name": "TokenStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./TokenId\\";
export * from \\"./CreateTokenRequest\\";
export * from \\"./CreateTokenResponse\\";
export * from \\"./GetTokenMetadataRequest\\";
export * from \\"./TokenMetadata\\";
export * from \\"./TokenStatus\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "token",
            "type": "directory",
          },
        ],
        "name": "serialization",
        "type": "directory",
      },
    ],
    "name": "src",
    "type": "directory",
  },
  Object {
    "contents": "{
    \\"compilerOptions\\": {
        \\"strict\\": true,
        \\"target\\": \\"esnext\\",
        \\"moduleResolution\\": \\"node\\",
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"sourceMap\\": true,
        \\"emitDeclarationOnly\\": true,
        \\"esModuleInterop\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true,
        \\"declarationDir\\": \\".\\",
        \\"rootDir\\": \\"src\\"
    },
    \\"include\\": [
        \\"src\\"
    ],
    \\"exclude\\": []
}",
    "name": "tsconfig.json",
    "type": "file",
  },
]
`;

exports[`runGenerator reserved-keywords 1`] = `
Array [
  Object {
    "contents": "node_modules
.DS_Store
*.d.ts
*.js
*.js.map

# yarn berry
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions

# these are needed to override '*.js' above
!.yarn/patches/**
!.yarn/plugins/**
!.yarn/releases/**
!.yarn/sdks/**
!.yarn/versions/**",
    "name": ".gitignore",
    "type": "file",
  },
  Object {
    "contents": "registry=https://registry.npmjs.org/
",
    "name": ".npmrc",
    "type": "file",
  },
  Object {
    "contents": ".yarn
node_modules
.npmignore
.pnp.cjs
*.js
*.d.ts",
    "name": ".prettierignore",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "{
  \\"recommendations\\": [
    \\"arcanis.vscode-zipfs\\",
    \\"esbenp.prettier-vscode\\"
  ]
}
",
        "name": "extensions.json",
        "type": "file",
      },
      Object {
        "contents": "{
  \\"search.exclude\\": {
    \\"**/.yarn\\": true,
    \\"**/.pnp.*\\": true
  },
  \\"prettier.prettierPath\\": \\".yarn/sdks/prettier/index.js\\",
  \\"typescript.tsdk\\": \\".yarn/sdks/typescript/lib\\",
  \\"typescript.enablePromptUseWorkspaceTsdk\\": true
}
",
        "name": "settings.json",
        "type": "file",
      },
    ],
    "name": ".vscode",
    "type": "directory",
  },
  Object {
    "contents": "nodeLinker: pnp

yarnPath: .yarn/releases/yarn-3.2.4.cjs
",
    "name": ".yarnrc.yml",
    "type": "file",
  },
  Object {
    "contents": "{
    \\"name\\": \\"@fern-fern/nursery-api-sdk\\",
    \\"version\\": \\"\\",
    \\"files\\": [
        \\"core\\",
        \\"resources\\",
        \\"serialization\\",
        \\"client\\",
        \\"*.{js,js.map,d.ts}\\"
    ],
    \\"main\\": \\"./index.js\\",
    \\"types\\": \\"./index.d.ts\\",
    \\"scripts\\": {
        \\"format\\": \\"prettier --write --print-width 120 'src/**/*.ts'\\",
        \\"build\\": \\"esbuild $(find src -name '*.ts') --format=cjs --sourcemap --outdir=. && tsc\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"esbuild\\": \\"0.14.47\\",
        \\"prettier\\": \\"2.7.1\\",
        \\"typescript\\": \\"4.6.4\\"
    },
    \\"packageManager\\": \\"yarn@3.2.4\\"
}
",
    "name": "package.json",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": Array [
          Object {
            "contents": "export * as schemas from \\"./schemas\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { SchemaUtils } from \\"./builders\\";

export type Schema<Raw = unknown, Parsed = unknown> = BaseSchema<Raw, Parsed> & SchemaUtils<Raw, Parsed>;

export type inferRaw<S extends Schema> = S extends Schema<infer Raw, any> ? Raw : never;
export type inferParsed<S extends Schema> = S extends Schema<any, infer Parsed> ? Parsed : never;

export interface BaseSchema<Raw, Parsed> {
  parse: (raw: Raw, opts?: SchemaOptions) => Parsed;
  json: (parsed: Parsed, opts?: SchemaOptions) => Raw;
}

export interface SchemaOptions {
  /**
   * @default false
   */
  skipUnknownKeysOnParse?: boolean;

  /**
   * @default false
   */
  includeUnknownKeysOnJson?: boolean;
}
",
                "name": "Schema.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function date(): Schema<string, Date> {
  const baseSchema: BaseSchema<string, Date> = {
    parse: (raw) => new Date(raw),
    json: (date) => date.toISOString(),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "date.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { date } from \\"./date\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "date",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function enum_<U extends string, E extends Readonly<[U, ...U[]]>>(_values: E): Schema<E[number], E[number]> {
  return createIdentitySchemaCreator<E[number]>()();
}
",
                        "name": "enum.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { enum_ } from \\"./enum\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "enum",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { identity } from \\"./identity\\";

export function createIdentitySchemaCreator<T>(): () => Schema<T, T> {
  return <T>() => identity<T>();
}
",
                        "name": "createIdentitySchemaCreator.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function identity<T>(): Schema<T, T> {
  const baseSchema: BaseSchema<T, T> = {
    parse: (raw) => raw,
    json: (parsed) => parsed,
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "identity.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { createIdentitySchemaCreator } from \\"./createIdentitySchemaCreator\\";
export { identity } from \\"./identity\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "identity",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./date\\";
export * from \\"./enum\\";
export * from \\"./identity\\";
export * from \\"./lazy\\";
export * from \\"./list\\";
export * from \\"./literals\\";
export * from \\"./object\\";
export * from \\"./object-like\\";
export * from \\"./primitives\\";
export * from \\"./record\\";
export * from \\"./schema-utils\\";
export * from \\"./set\\";
export * from \\"./union\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { lazy } from \\"./lazy\\";
export { lazyObject } from \\"./lazyObject\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

type Getter<Raw, Parsed> = () => Schema<Raw, Parsed>;
type MemoizedGetter<Raw, Parsed> = Getter<Raw, Parsed> & { __zurg_memoized?: Schema<Raw, Parsed> };

export function lazy<Raw, Parsed>(getter: Getter<Raw, Parsed>): Schema<Raw, Parsed> {
  const baseSchema = constructLazyBaseSchema(getter);
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function constructLazyBaseSchema<Raw, Parsed>(getter: Getter<Raw, Parsed>): BaseSchema<Raw, Parsed> {
  const getSchema = () => {
    const castedGetter = getter as MemoizedGetter<Raw, Parsed>;
    if (castedGetter.__zurg_memoized == null) {
      castedGetter.__zurg_memoized = getter();
    }
    return castedGetter.__zurg_memoized;
  };

  return {
    parse: (raw) => getSchema().parse(raw),
    json: (parsed) => getSchema().json(parsed),
  };
}
",
                        "name": "lazy.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { getObjectUtils } from \\"../object\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { ObjectSchema } from \\"../object/types\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { constructLazyBaseSchema } from \\"./lazy\\";

export function lazyObject<Raw, Parsed>(getter: () => ObjectSchema<Raw, Parsed>): ObjectSchema<Raw, Parsed> {
  const baseSchema = {
    ...OBJECT_LIKE_BRAND,
    ...constructLazyBaseSchema(getter),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}
",
                        "name": "lazyObject.ts",
                        "type": "file",
                      },
                    ],
                    "name": "lazy",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { list } from \\"./list\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function list<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Parsed[]> {
  const baseSchema: BaseSchema<Raw[], Parsed[]> = {
    parse: (raw, opts) => raw.map((item) => schema.parse(item, opts)),
    json: (parsed, opts) => parsed.map((item) => schema.json(item, opts)),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "list.ts",
                        "type": "file",
                      },
                    ],
                    "name": "list",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { stringLiteral } from \\"./stringLiteral\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function stringLiteral<V extends string>(_value: V): Schema<V, V> {
  return createIdentitySchemaCreator<V>()();
}
",
                        "name": "stringLiteral.ts",
                        "type": "file",
                      },
                    ],
                    "name": "literals",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { getObjectUtils, object } from \\"./object\\";
export { isProperty, property, type Property } from \\"./property\\";
export {
  type BaseObjectSchema,
  type inferObjectSchemaFromPropertySchemas,
  type inferParsedObject,
  type inferParsedObjectFromPropertySchemas,
  type inferParsedPropertySchema,
  type inferRawKey,
  type inferRawObject,
  type inferRawObjectFromPropertySchemas,
  type inferRawPropertySchema,
  type ObjectSchema,
  type ObjectUtils,
  type PropertySchemas,
} from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { isProperty } from \\"./property\\";
import {
  BaseObjectSchema,
  inferObjectSchemaFromPropertySchemas,
  inferParsedObjectFromPropertySchemas,
  inferRawObjectFromPropertySchemas,
  ObjectSchema,
  ObjectUtils,
  PropertySchemas,
} from \\"./types\\";

interface ObjectPropertyWithRawKey {
  rawKey: string;
  parsedKey: string | number | symbol;
  valueSchema: Schema<any, any>;
}

export function object<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(
  schemas: T
): inferObjectSchemaFromPropertySchemas<T> {
  const baseSchema: BaseObjectSchema<inferRawObjectFromPropertySchemas<T>, inferParsedObjectFromPropertySchemas<T>> = {
    ...OBJECT_LIKE_BRAND,

    parse: (raw, { skipUnknownKeysOnParse = false } = {}) => {
      const rawKeyToProperty: Record<string, ObjectPropertyWithRawKey> = {};

      for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
        const rawKey = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;

        const property: ObjectPropertyWithRawKey = {
          rawKey,
          parsedKey,
          valueSchema: isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.valueSchema : schemaOrObjectProperty,
        };

        rawKeyToProperty[rawKey] = property;
      }

      const parsed: Record<string | number | symbol, any> = {};

      for (const [rawKey, rawPropertyValue] of Object.entries(raw)) {
        const property = rawKeyToProperty[rawKey];

        if (property != null) {
          const value = property.valueSchema.parse(rawPropertyValue);
          parsed[property.parsedKey] = value;
        } else if (!skipUnknownKeysOnParse && rawPropertyValue != null) {
          parsed[rawKey] = rawPropertyValue;
        }
      }

      return parsed as inferParsedObjectFromPropertySchemas<T>;
    },

    json: (parsed, { includeUnknownKeysOnJson = false } = {}) => {
      const raw: Record<string | number | symbol, any> = {};

      for (const [parsedKey, parsedPropertyValue] of entries(parsed)) {
        const schemaOrObjectProperty = schemas[parsedKey as keyof T];
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (schemaOrObjectProperty != null) {
          if (isProperty(schemaOrObjectProperty)) {
            const value = schemaOrObjectProperty.valueSchema.json(parsedPropertyValue);
            raw[schemaOrObjectProperty.rawKey] = value;
          } else {
            const value = schemaOrObjectProperty.json(parsedPropertyValue);
            raw[parsedKey] = value;
          }
        } else if (includeUnknownKeysOnJson && parsedPropertyValue != null) {
          raw[parsedKey] = parsedPropertyValue;
        }
      }

      return raw as inferRawObjectFromPropertySchemas<T>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}

export function getObjectUtils<Raw, Parsed>(schema: BaseObjectSchema<Raw, Parsed>): ObjectUtils<Raw, Parsed> {
  return {
    extend: <RawExtension, ParsedExtension>(extension: ObjectSchema<RawExtension, ParsedExtension>) => {
      const baseSchema: BaseObjectSchema<Raw & RawExtension, Parsed & ParsedExtension> = {
        ...OBJECT_LIKE_BRAND,
        parse: (raw, opts) => ({
          ...schema.parse(raw, opts),
          ...extension.parse(raw, opts),
        }),
        json: (parsed, opts) => ({
          ...schema.json(parsed, opts),
          ...extension.json(parsed, opts),
        }),
      };

      return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
      };
    },
  };
}
",
                        "name": "object.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export function property<RawKey extends string, RawValue, ParsedValue>(
  rawKey: RawKey,
  valueSchema: Schema<RawValue, ParsedValue>
): Property<RawKey, RawValue, ParsedValue> {
  return {
    rawKey,
    valueSchema,
    isProperty: true,
  };
}

export interface Property<RawKey extends string, RawValue, ParsedValue> {
  rawKey: RawKey;
  valueSchema: Schema<RawValue, ParsedValue>;
  isProperty: true;
}

export function isProperty<O extends Property<any, any, any>>(maybeProperty: unknown): maybeProperty is O {
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return (maybeProperty as O).isProperty;
}
",
                        "name": "property.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsed, inferRaw, Schema } from \\"../../Schema\\";
import { addQuestionMarksToNullableProperties } from \\"../../utils/addQuestionMarksToNullableProperties\\";
import { BaseObjectLikeSchema, ObjectLikeSchema } from \\"../object-like\\";
import { Property } from \\"./property\\";

export type ObjectSchema<Raw, Parsed> = BaseObjectSchema<Raw, Parsed> &
  ObjectLikeSchema<Raw, Parsed> &
  ObjectUtils<Raw, Parsed>;

export type BaseObjectSchema<Raw, Parsed> = BaseObjectLikeSchema<Raw, Parsed>;

export interface ObjectUtils<Raw, Parsed> {
  extend: <RawExtension, ParsedExtension>(
    schemas: ObjectSchema<RawExtension, ParsedExtension>
  ) => ObjectSchema<Raw & RawExtension, Parsed & ParsedExtension>;
}

export type inferRawObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<infer Raw, any> ? Raw : never;

export type inferParsedObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<any, infer Parsed>
  ? Parsed
  : never;

export type inferObjectSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> = ObjectSchema<
  inferRawObjectFromPropertySchemas<T>,
  inferParsedObjectFromPropertySchemas<T>
>;

export type inferRawObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
  addQuestionMarksToNullableProperties<{
    [ParsedKey in keyof T as inferRawKey<ParsedKey, T[ParsedKey]>]: inferRawPropertySchema<T[ParsedKey]>;
  }>;

export type inferParsedObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
  addQuestionMarksToNullableProperties<{
    [K in keyof T]: inferParsedPropertySchema<T[K]>;
  }>;

export type PropertySchemas<ParsedKeys extends string | number | symbol> = Record<
  ParsedKeys,
  Property<any, any, any> | Schema<any, any>
>;

export type inferRawPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
  any,
  infer Raw,
  any
>
  ? Raw
  : P extends Schema<any, any>
  ? inferRaw<P>
  : never;

export type inferParsedPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
  any,
  any,
  infer Parsed
>
  ? Parsed
  : P extends Schema<any, any>
  ? inferParsed<P>
  : never;

export type inferRawKey<
  ParsedKey extends string | number | symbol,
  P extends Property<any, any, any> | Schema<any, any>
> = P extends Property<infer Raw, any, any> ? Raw : ParsedKey;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseObjectLikeSchema, ObjectLikeUtils } from \\"./types\\";
import { withProperties } from \\"./withProperties\\";

export function getObjectLikeUtils<Raw, Parsed>(
  schema: BaseObjectLikeSchema<Raw, Parsed>
): ObjectLikeUtils<Raw, Parsed> {
  return {
    withProperties: (properties) => withProperties(schema, properties),
  };
}
",
                        "name": "getObjectLikeUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getObjectLikeUtils } from \\"./getObjectLikeUtils\\";
export { OBJECT_LIKE_BRAND, type BaseObjectLikeSchema, type ObjectLikeSchema, type ObjectLikeUtils } from \\"./types\\";
export { withProperties } from \\"./withProperties\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";

export type ObjectLikeSchema<Raw, Parsed> = Schema<Raw, Parsed> &
  BaseObjectLikeSchema<Raw, Parsed> &
  ObjectLikeUtils<Raw, Parsed>;

export type BaseObjectLikeSchema<Raw, Parsed> = BaseSchema<Raw, Parsed> & {
  _objectLike: void;
};

export interface ObjectLikeUtils<Raw, Parsed> {
  withProperties: <T extends Record<string, any>>(properties: {
    [K in keyof T]: T[K] | ((parsed: Parsed) => T[K]);
  }) => ObjectLikeSchema<Raw, Parsed & T>;
}

export const OBJECT_LIKE_BRAND = undefined as unknown as { _objectLike: void };
",
                        "name": "types.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { getSchemaUtils } from \\"../schema-utils\\";
import { getObjectLikeUtils } from \\"./getObjectLikeUtils\\";
import { BaseObjectLikeSchema, ObjectLikeSchema, OBJECT_LIKE_BRAND } from \\"./types\\";

export function withProperties<RawObjectShape, ParsedObjectShape, Properties>(
  objectLike: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape>,
  properties: { [K in keyof Properties]: Properties[K] | ((parsed: ParsedObjectShape) => Properties[K]) }
): ObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> {
  const objectSchema: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> = {
    ...OBJECT_LIKE_BRAND,
    parse: (raw, opts) => {
      const parsedObject = objectLike.parse(raw, opts);
      const additionalProperties = Object.entries(properties).reduce<Record<string, any>>((processed, [key, value]) => {
        return {
          ...processed,
          [key]: typeof value === \\"function\\" ? value(parsedObject) : value,
        };
      }, {});

      return {
        ...parsedObject,
        ...(additionalProperties as Properties),
      };
    },
    json: (parsed, opts) => {
      // strip out added properties
      const addedPropertyKeys = new Set(Object.keys(properties));
      const parsedWithoutAddedProperties = Object.entries(parsed).reduce<Record<string, any>>(
        (filtered, [key, value]) => {
          if (!addedPropertyKeys.has(key)) {
            filtered[key] = value;
          }
          return filtered;
        },
        {}
      );

      return objectLike.json(parsedWithoutAddedProperties as ParsedObjectShape, opts);
    },
  };

  return {
    ...objectSchema,
    ...getSchemaUtils(objectSchema),
    ...getObjectLikeUtils(objectSchema),
  };
}
",
                        "name": "withProperties.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object-like",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const any = createIdentitySchemaCreator<any>();
",
                        "name": "any.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const boolean = createIdentitySchemaCreator<boolean>();
",
                        "name": "boolean.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { any } from \\"./any\\";
export { boolean } from \\"./boolean\\";
export { number } from \\"./number\\";
export { string } from \\"./string\\";
export { unknown } from \\"./unknown\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const number = createIdentitySchemaCreator<number>();
",
                        "name": "number.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const string = createIdentitySchemaCreator<string>();
",
                        "name": "string.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const unknown = createIdentitySchemaCreator<unknown>();
",
                        "name": "unknown.ts",
                        "type": "file",
                      },
                    ],
                    "name": "primitives",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { record } from \\"./record\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function record<RawKey extends string | number, ParsedKey extends string | number, RawValue, ParsedValue>(
  keySchema: Schema<RawKey, ParsedKey>,
  valueSchema: Schema<RawValue, ParsedValue>
): Schema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> {
  const baseSchema: BaseSchema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> = {
    parse: (raw, opts) => {
      return entries(raw).reduce(
        (parsed, [key, value]) => {
          parsed[keySchema.parse(key, opts)] = valueSchema.parse(value, opts);
          return parsed;
        },
        // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
        {} as Record<ParsedKey, ParsedValue>
      );
    },
    json: (parsed, opts) => {
      return entries(parsed).reduce(
        (raw, [key, value]) => {
          raw[keySchema.json(key, opts)] = valueSchema.json(value, opts);
          return raw;
        },
        // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
        {} as Record<RawKey, RawValue>
      );
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "record.ts",
                        "type": "file",
                      },
                    ],
                    "name": "record",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { OptionalSchema, OPTIONAL_BRAND } from \\"./types\\";

export interface SchemaUtils<Raw, Parsed> {
  optional: () => OptionalSchema<Raw, Parsed>;
  transform: <PostTransform>(transformer: BaseSchema<Parsed, PostTransform>) => Schema<Raw, PostTransform>;
}

export function getSchemaUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): SchemaUtils<Raw, Parsed> {
  return {
    optional: () => optional(schema),
    transform: (transformer) => transform(schema, transformer),
  };
}

/**
 * schema utils are defined in one file to resolve issues with circular imports
 */

export function optional<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): OptionalSchema<Raw, Parsed> {
  const baseSchema: BaseSchema<Raw | null | undefined, Parsed | undefined> = {
    parse: (raw, opts) => (raw != null ? schema.parse(raw, opts) : undefined),
    json: (parsed, opts) => (parsed != null ? schema.json(parsed, opts) : undefined),
  };

  return {
    ...OPTIONAL_BRAND,
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function transform<PreTransformRaw, PreTransformParsed, PostTransform>(
  schema: BaseSchema<PreTransformRaw, PreTransformParsed>,
  transformer: BaseSchema<PreTransformParsed, PostTransform>
): Schema<PreTransformRaw, PostTransform> {
  const baseSchema: BaseSchema<PreTransformRaw, PostTransform> = {
    parse: (raw, opts) => {
      const postTransformParsed = schema.parse(raw, opts);
      return transformer.parse(postTransformParsed, opts);
    },
    json: (parsed, opts) => {
      const preTransformParsed = transformer.json(parsed, opts);
      return schema.json(preTransformParsed, opts);
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "getSchemaUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getSchemaUtils, optional, transform, type SchemaUtils } from \\"./getSchemaUtils\\";
export { OPTIONAL_BRAND, type OptionalSchema } from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export const OPTIONAL_BRAND = undefined as unknown as { _isOptional: void };

export type OptionalSchema<Raw, Parsed> = Schema<Raw | null | undefined, Parsed | undefined> & {
  _isOptional: void;
};
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "schema-utils",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { set } from \\"./set\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function set<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Set<Parsed>> {
  const baseSchema: BaseSchema<Raw[], Set<Parsed>> = {
    parse: (raw, opts) => new Set(raw.map((item) => schema.parse(item, opts))),
    json: (parsed, opts) => [...parsed].map((item) => schema.json(item, opts)),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "set.ts",
                        "type": "file",
                      },
                    ],
                    "name": "set",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export function discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string>(
  parsedDiscriminant: ParsedDiscriminant,
  rawDiscriminant: RawDiscriminant
): Discriminant<RawDiscriminant, ParsedDiscriminant> {
  return {
    parsedDiscriminant,
    rawDiscriminant,
  };
}

export interface Discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string> {
  parsedDiscriminant: ParsedDiscriminant;
  rawDiscriminant: RawDiscriminant;
}
",
                        "name": "discriminant.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { discriminant, type Discriminant } from \\"./discriminant\\";
export {
  type inferParsedDiscriminant,
  type inferParsedUnion,
  type inferRawDiscriminant,
  type inferRawUnion,
  type UnionSubtypes,
} from \\"./types\\";
export { union } from \\"./union\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsedObject, inferRawObject, ObjectSchema } from \\"../object\\";
import { Discriminant } from \\"./discriminant\\";

export type UnionSubtypes<DiscriminantValues extends string | number | symbol> = {
  [K in DiscriminantValues]: ObjectSchema<any, any>;
};

export type inferRawUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
  [K in keyof U]: Record<inferRawDiscriminant<D>, K> & inferRawObject<U[K]>;
}[keyof U];

export type inferParsedUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
  [K in keyof U]: Record<inferParsedDiscriminant<D>, K> & inferParsedObject<U[K]>;
}[keyof U];

export type inferRawDiscriminant<D extends string | Discriminant<any, any>> = D extends string
  ? D
  : D extends Discriminant<infer Raw, any>
  ? Raw
  : never;

export type inferParsedDiscriminant<D extends string | Discriminant<any, any>> = D extends string
  ? D
  : D extends Discriminant<any, infer Parsed>
  ? Parsed
  : never;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseObjectLikeSchema, getObjectLikeUtils, ObjectLikeSchema, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { Discriminant } from \\"./discriminant\\";
import { inferParsedDiscriminant, inferParsedUnion, inferRawDiscriminant, inferRawUnion, UnionSubtypes } from \\"./types\\";

export function union<D extends string | Discriminant<any, any>, U extends UnionSubtypes<any>>(
  discriminant: D,
  union: U
): ObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> {
  const rawDiscriminant =
    typeof discriminant === \\"string\\" ? discriminant : (discriminant.rawDiscriminant as inferRawDiscriminant<D>);
  const parsedDiscriminant =
    typeof discriminant === \\"string\\" ? discriminant : (discriminant.parsedDiscriminant as inferParsedDiscriminant<D>);

  const baseSchema: BaseObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> = {
    ...OBJECT_LIKE_BRAND,

    parse: (raw, opts) => {
      const { [rawDiscriminant]: discriminantValue, ...additionalProperties } = raw;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [parsedDiscriminant]: discriminantValue,
        } as inferParsedUnion<D, U>;
      }

      return {
        ...additionalPropertySchemas.parse(additionalProperties, opts),
        [parsedDiscriminant]: discriminantValue,
      } as inferParsedUnion<D, U>;
    },

    json: (parsed, opts) => {
      const { [parsedDiscriminant]: discriminantValue, ...additionalProperties } = parsed;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [rawDiscriminant]: discriminantValue,
        } as unknown as inferRawUnion<D, U>;
      }

      return {
        ...additionalPropertySchemas.json(additionalProperties, opts),
        [rawDiscriminant]: discriminantValue,
      } as inferRawUnion<D, U>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
  };
}
",
                        "name": "union.ts",
                        "type": "file",
                      },
                    ],
                    "name": "union",
                    "type": "directory",
                  },
                ],
                "name": "builders",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./builders\\";
export { type inferParsed, type inferRaw, type Schema, type SchemaOptions } from \\"./Schema\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export type addQuestionMarksToNullableProperties<T> = {
  [K in OptionalKeys<T>]?: undefined extends T[K] ? T[K] : never;
} & Pick<T, RequiredKeys<T>>;

export type OptionalKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? K : never;
}[keyof T];

export type RequiredKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? never : K;
}[keyof T];
",
                    "name": "addQuestionMarksToNullableProperties.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function entries<T>(object: T): [keyof T, T[keyof T]][] {
  return Object.entries(object) as [keyof T, T[keyof T]][];
}
",
                    "name": "entries.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function keys<T>(object: T): (keyof T)[] {
  return Object.keys(object) as (keyof T)[];
}
",
                    "name": "keys.ts",
                    "type": "file",
                  },
                ],
                "name": "utils",
                "type": "directory",
              },
            ],
            "name": "schemas",
            "type": "directory",
          },
        ],
        "name": "core",
        "type": "directory",
      },
      Object {
        "contents": "export * as FernNurseryApi from \\"./resources\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * as package_ from \\"./package\\";
export * from \\"./package/types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface Package {
  name: string;
}
",
                    "name": "Package.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./Package\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "package",
            "type": "directory",
          },
        ],
        "name": "resources",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * as package_ from \\"./package\\";
export * from \\"./package/types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernNurseryApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Package: core.schemas.ObjectSchema<Package.Raw, FernNurseryApi.package_.Package> = core.schemas.object({
  name: core.schemas.string(),
});

export declare namespace Package {
  interface Raw {
    name: string;
  }
}
",
                    "name": "Package.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./Package\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "package",
            "type": "directory",
          },
        ],
        "name": "serialization",
        "type": "directory",
      },
    ],
    "name": "src",
    "type": "directory",
  },
  Object {
    "contents": "{
    \\"compilerOptions\\": {
        \\"strict\\": true,
        \\"target\\": \\"esnext\\",
        \\"moduleResolution\\": \\"node\\",
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"sourceMap\\": true,
        \\"emitDeclarationOnly\\": true,
        \\"esModuleInterop\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true,
        \\"declarationDir\\": \\".\\",
        \\"rootDir\\": \\"src\\"
    },
    \\"include\\": [
        \\"src\\"
    ],
    \\"exclude\\": []
}",
    "name": "tsconfig.json",
    "type": "file",
  },
]
`;

exports[`runGenerator trace 1`] = `
Array [
  Object {
    "contents": "node_modules
.DS_Store
*.d.ts
*.js
*.js.map

# yarn berry
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions

# these are needed to override '*.js' above
!.yarn/patches/**
!.yarn/plugins/**
!.yarn/releases/**
!.yarn/sdks/**
!.yarn/versions/**",
    "name": ".gitignore",
    "type": "file",
  },
  Object {
    "contents": "registry=https://registry.npmjs.org/
",
    "name": ".npmrc",
    "type": "file",
  },
  Object {
    "contents": ".yarn
node_modules
.npmignore
.pnp.cjs
*.js
*.d.ts",
    "name": ".prettierignore",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "{
  \\"recommendations\\": [
    \\"arcanis.vscode-zipfs\\",
    \\"esbenp.prettier-vscode\\"
  ]
}
",
        "name": "extensions.json",
        "type": "file",
      },
      Object {
        "contents": "{
  \\"search.exclude\\": {
    \\"**/.yarn\\": true,
    \\"**/.pnp.*\\": true
  },
  \\"prettier.prettierPath\\": \\".yarn/sdks/prettier/index.js\\",
  \\"typescript.tsdk\\": \\".yarn/sdks/typescript/lib\\",
  \\"typescript.enablePromptUseWorkspaceTsdk\\": true
}
",
        "name": "settings.json",
        "type": "file",
      },
    ],
    "name": ".vscode",
    "type": "directory",
  },
  Object {
    "contents": "nodeLinker: pnp

yarnPath: .yarn/releases/yarn-3.2.4.cjs
",
    "name": ".yarnrc.yml",
    "type": "file",
  },
  Object {
    "contents": "{
    \\"name\\": \\"@fern-trace/my-api-sdk\\",
    \\"version\\": \\"\\",
    \\"files\\": [
        \\"core\\",
        \\"resources\\",
        \\"serialization\\",
        \\"client\\",
        \\"*.{js,js.map,d.ts}\\"
    ],
    \\"main\\": \\"./index.js\\",
    \\"types\\": \\"./index.d.ts\\",
    \\"scripts\\": {
        \\"format\\": \\"prettier --write --print-width 120 'src/**/*.ts'\\",
        \\"build\\": \\"esbuild $(find src -name '*.ts') --format=cjs --sourcemap --outdir=. && tsc\\"
    },
    \\"dependencies\\": {
        \\"@types/basic-auth\\": \\"^1.1.3\\",
        \\"@types/url-join\\": \\"4.0.1\\",
        \\"axios\\": \\"^0.27.2\\",
        \\"basic-auth\\": \\"^2.0.1\\",
        \\"js-base64\\": \\"^3.7.2\\",
        \\"url-join\\": \\"4.0.1\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"esbuild\\": \\"0.14.47\\",
        \\"prettier\\": \\"2.7.1\\",
        \\"typescript\\": \\"4.6.4\\"
    },
    \\"packageManager\\": \\"yarn@3.2.4\\"
}
",
    "name": "package.json",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as environments from \\"./environments\\";
import * as core from \\"./core\\";
import { Client as AdminClient } from \\"./resources/admin/client/Client\\";
import { Client as HomepageClient } from \\"./resources/homepage/client/Client\\";
import { Client as MigrationClient } from \\"./resources/migration/client/Client\\";
import { Client as PlaylistClient } from \\"./resources/playlist/client/Client\\";
import { Client as ProblemClient } from \\"./resources/problem/client/Client\\";
import { Client as SubmissionClient } from \\"./resources/submission/client/Client\\";
import { Client as SyspropClient } from \\"./resources/sysprop/client/Client\\";
import { Client as V2Client } from \\"./resources/v2/client/Client\\";

export declare namespace TraceMyApiClient {
  interface Options {
    environment?: environments.Environment | string;
    auth?: {
      token?: core.Supplier<core.BearerToken>;
    };
  }
}

export class TraceMyApiClient {
  constructor(private readonly options: TraceMyApiClient.Options) {}

  #admin: AdminClient | undefined;

  public get admin(): AdminClient {
    return (this.#admin ??= new AdminClient(this.options));
  }

  #homepage: HomepageClient | undefined;

  public get homepage(): HomepageClient {
    return (this.#homepage ??= new HomepageClient(this.options));
  }

  #migration: MigrationClient | undefined;

  public get migration(): MigrationClient {
    return (this.#migration ??= new MigrationClient(this.options));
  }

  #playlist: PlaylistClient | undefined;

  public get playlist(): PlaylistClient {
    return (this.#playlist ??= new PlaylistClient(this.options));
  }

  #problem: ProblemClient | undefined;

  public get problem(): ProblemClient {
    return (this.#problem ??= new ProblemClient(this.options));
  }

  #submission: SubmissionClient | undefined;

  public get submission(): SubmissionClient {
    return (this.#submission ??= new SubmissionClient(this.options));
  }

  #sysprop: SyspropClient | undefined;

  public get sysprop(): SyspropClient {
    return (this.#sysprop ??= new SyspropClient(this.options));
  }

  #v2: V2Client | undefined;

  public get v2(): V2Client {
    return (this.#v2 ??= new V2Client(this.options));
  }
}
",
        "name": "Client.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "import { parse } from \\"basic-auth\\";
import { Base64 } from \\"js-base64\\";

export interface BasicAuth {
  username: string;
  password: string;
}

export const BasicAuth = {
  toAuthorizationHeader: (basicAuth: BasicAuth | undefined): string | undefined => {
    if (basicAuth == null) {
      return undefined;
    }
    const token = Base64.encode(\`\${basicAuth.username}:\${basicAuth.password}\`);
    return \`Basic \${token}\`;
  },
  fromAuthorizationHeader: (header: string): BasicAuth => {
    const parsed = parse(header);
    if (parsed == null) {
      throw new Error(\\"Invalid basic auth\\");
    }
    return {
      username: parsed.name,
      password: parsed.pass,
    };
  },
};
",
                "name": "BasicAuth.ts",
                "type": "file",
              },
              Object {
                "contents": "export type BearerToken = string;

const BEARER_AUTH_HEADER_PREFIX = /^Bearer /i;

export const BearerToken = {
  toAuthorizationHeader: (token: BearerToken | undefined): string | undefined => {
    if (token == null) {
      return undefined;
    }
    return \`Bearer \${token}\`;
  },
  fromAuthorizationHeader: (header: string): BearerToken => {
    return header.replace(BEARER_AUTH_HEADER_PREFIX, \\"\\").trim() as BearerToken;
  },
};
",
                "name": "BearerToken.ts",
                "type": "file",
              },
              Object {
                "contents": "export { BasicAuth } from \\"./BasicAuth\\";
export { BearerToken } from \\"./BearerToken\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "auth",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export type APIResponse<Success, Failure> = SuccessfulResponse<Success> | FailedResponse<Failure>;

export interface SuccessfulResponse<T> {
  ok: true;
  body: T;
}

export interface FailedResponse<T> {
  ok: false;
  error: T;
}
",
                "name": "APIResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import axios, { AxiosError } from \\"axios\\";
import { APIResponse } from \\"./APIResponse\\";

export interface Fetcher {
  fetch: FetchFunction;
}

export type FetchFunction = (args: Fetcher.Args) => Promise<APIResponse<unknown, Fetcher.Error>>;

export declare namespace Fetcher {
  export interface Args {
    url: string;
    method: string;
    headers?: Record<string, string | undefined>;
    queryParameters?: URLSearchParams;
    body?: unknown;
    timeoutMs?: number;
  }

  export type Error = FailedStatusCodeError | NonJsonError | TimeoutError | UnknownError;

  export interface FailedStatusCodeError {
    reason: \\"status-code\\";
    statusCode: number;
    body: unknown;
  }

  export interface NonJsonError {
    reason: \\"non-json\\";
    statusCode: number;
    rawBody: string;
  }

  export interface TimeoutError {
    reason: \\"timeout\\";
  }

  export interface UnknownError {
    reason: \\"unknown\\";
    errorMessage: string;
  }
}

export const fetcher: FetchFunction = async (args) => {
  const headers: Record<string, string> = {
    \\"Content-Type\\": \\"application/json\\",
  };

  if (args.headers != null) {
    for (const [key, value] of Object.entries(args.headers)) {
      if (value != null) {
        headers[key] = value;
      }
    }
  }

  try {
    const response = await axios({
      url: args.url,
      params: args.queryParameters,
      method: args.method,
      headers,
      data: args.body,
      validateStatus: () => true,
      transformResponse: (response) => response,
      timeout: args.timeoutMs ?? 60_000,
      transitional: {
        clarifyTimeoutError: true,
      },
    });

    let body: unknown;
    if (response.data != null) {
      try {
        body = JSON.parse(response.data) ?? undefined;
      } catch {
        return {
          ok: false,
          error: {
            reason: \\"non-json\\",
            statusCode: response.status,
            rawBody: response.data,
          },
        };
      }
    }

    if (response.status >= 200 && response.status < 300) {
      return {
        ok: true,
        body,
      };
    } else {
      return {
        ok: false,
        error: {
          reason: \\"status-code\\",
          statusCode: response.status,
          body,
        },
      };
    }
  } catch (error) {
    if ((error as AxiosError).code === \\"ETIMEDOUT\\") {
      return {
        ok: false,
        error: {
          reason: \\"timeout\\",
        },
      };
    }

    return {
      ok: false,
      error: {
        reason: \\"unknown\\",
        errorMessage: (error as AxiosError).message,
      },
    };
  }
};
",
                "name": "Fetcher.ts",
                "type": "file",
              },
              Object {
                "contents": "export type Supplier<T> = T | Promise<T> | (() => T | Promise<T>);

export const Supplier = {
  get: async <T>(supplier: Supplier<T>): Promise<T> => {
    if (typeof supplier === \\"function\\") {
      return (supplier as () => T)();
    } else {
      return supplier;
    }
  },
};
",
                "name": "Supplier.ts",
                "type": "file",
              },
              Object {
                "contents": "export { type APIResponse } from \\"./APIResponse\\";
export { fetcher, type Fetcher, type FetchFunction } from \\"./Fetcher\\";
export { Supplier } from \\"./Supplier\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "fetcher",
            "type": "directory",
          },
          Object {
            "contents": "export * as schemas from \\"./schemas\\";
export * from \\"./fetcher\\";
export * from \\"./auth\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { SchemaUtils } from \\"./builders\\";

export type Schema<Raw = unknown, Parsed = unknown> = BaseSchema<Raw, Parsed> & SchemaUtils<Raw, Parsed>;

export type inferRaw<S extends Schema> = S extends Schema<infer Raw, any> ? Raw : never;
export type inferParsed<S extends Schema> = S extends Schema<any, infer Parsed> ? Parsed : never;

export interface BaseSchema<Raw, Parsed> {
  parse: (raw: Raw, opts?: SchemaOptions) => Parsed;
  json: (parsed: Parsed, opts?: SchemaOptions) => Raw;
}

export interface SchemaOptions {
  /**
   * @default false
   */
  skipUnknownKeysOnParse?: boolean;

  /**
   * @default false
   */
  includeUnknownKeysOnJson?: boolean;
}
",
                "name": "Schema.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function date(): Schema<string, Date> {
  const baseSchema: BaseSchema<string, Date> = {
    parse: (raw) => new Date(raw),
    json: (date) => date.toISOString(),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "date.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { date } from \\"./date\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "date",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function enum_<U extends string, E extends Readonly<[U, ...U[]]>>(_values: E): Schema<E[number], E[number]> {
  return createIdentitySchemaCreator<E[number]>()();
}
",
                        "name": "enum.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { enum_ } from \\"./enum\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "enum",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { identity } from \\"./identity\\";

export function createIdentitySchemaCreator<T>(): () => Schema<T, T> {
  return <T>() => identity<T>();
}
",
                        "name": "createIdentitySchemaCreator.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function identity<T>(): Schema<T, T> {
  const baseSchema: BaseSchema<T, T> = {
    parse: (raw) => raw,
    json: (parsed) => parsed,
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "identity.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { createIdentitySchemaCreator } from \\"./createIdentitySchemaCreator\\";
export { identity } from \\"./identity\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "identity",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./date\\";
export * from \\"./enum\\";
export * from \\"./identity\\";
export * from \\"./lazy\\";
export * from \\"./list\\";
export * from \\"./literals\\";
export * from \\"./object\\";
export * from \\"./object-like\\";
export * from \\"./primitives\\";
export * from \\"./record\\";
export * from \\"./schema-utils\\";
export * from \\"./set\\";
export * from \\"./union\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { lazy } from \\"./lazy\\";
export { lazyObject } from \\"./lazyObject\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

type Getter<Raw, Parsed> = () => Schema<Raw, Parsed>;
type MemoizedGetter<Raw, Parsed> = Getter<Raw, Parsed> & { __zurg_memoized?: Schema<Raw, Parsed> };

export function lazy<Raw, Parsed>(getter: Getter<Raw, Parsed>): Schema<Raw, Parsed> {
  const baseSchema = constructLazyBaseSchema(getter);
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function constructLazyBaseSchema<Raw, Parsed>(getter: Getter<Raw, Parsed>): BaseSchema<Raw, Parsed> {
  const getSchema = () => {
    const castedGetter = getter as MemoizedGetter<Raw, Parsed>;
    if (castedGetter.__zurg_memoized == null) {
      castedGetter.__zurg_memoized = getter();
    }
    return castedGetter.__zurg_memoized;
  };

  return {
    parse: (raw) => getSchema().parse(raw),
    json: (parsed) => getSchema().json(parsed),
  };
}
",
                        "name": "lazy.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { getObjectUtils } from \\"../object\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { ObjectSchema } from \\"../object/types\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { constructLazyBaseSchema } from \\"./lazy\\";

export function lazyObject<Raw, Parsed>(getter: () => ObjectSchema<Raw, Parsed>): ObjectSchema<Raw, Parsed> {
  const baseSchema = {
    ...OBJECT_LIKE_BRAND,
    ...constructLazyBaseSchema(getter),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}
",
                        "name": "lazyObject.ts",
                        "type": "file",
                      },
                    ],
                    "name": "lazy",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { list } from \\"./list\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function list<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Parsed[]> {
  const baseSchema: BaseSchema<Raw[], Parsed[]> = {
    parse: (raw, opts) => raw.map((item) => schema.parse(item, opts)),
    json: (parsed, opts) => parsed.map((item) => schema.json(item, opts)),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "list.ts",
                        "type": "file",
                      },
                    ],
                    "name": "list",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { stringLiteral } from \\"./stringLiteral\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function stringLiteral<V extends string>(_value: V): Schema<V, V> {
  return createIdentitySchemaCreator<V>()();
}
",
                        "name": "stringLiteral.ts",
                        "type": "file",
                      },
                    ],
                    "name": "literals",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { getObjectUtils, object } from \\"./object\\";
export { isProperty, property, type Property } from \\"./property\\";
export {
  type BaseObjectSchema,
  type inferObjectSchemaFromPropertySchemas,
  type inferParsedObject,
  type inferParsedObjectFromPropertySchemas,
  type inferParsedPropertySchema,
  type inferRawKey,
  type inferRawObject,
  type inferRawObjectFromPropertySchemas,
  type inferRawPropertySchema,
  type ObjectSchema,
  type ObjectUtils,
  type PropertySchemas,
} from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { isProperty } from \\"./property\\";
import {
  BaseObjectSchema,
  inferObjectSchemaFromPropertySchemas,
  inferParsedObjectFromPropertySchemas,
  inferRawObjectFromPropertySchemas,
  ObjectSchema,
  ObjectUtils,
  PropertySchemas,
} from \\"./types\\";

interface ObjectPropertyWithRawKey {
  rawKey: string;
  parsedKey: string | number | symbol;
  valueSchema: Schema<any, any>;
}

export function object<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(
  schemas: T
): inferObjectSchemaFromPropertySchemas<T> {
  const baseSchema: BaseObjectSchema<inferRawObjectFromPropertySchemas<T>, inferParsedObjectFromPropertySchemas<T>> = {
    ...OBJECT_LIKE_BRAND,

    parse: (raw, { skipUnknownKeysOnParse = false } = {}) => {
      const rawKeyToProperty: Record<string, ObjectPropertyWithRawKey> = {};

      for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
        const rawKey = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;

        const property: ObjectPropertyWithRawKey = {
          rawKey,
          parsedKey,
          valueSchema: isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.valueSchema : schemaOrObjectProperty,
        };

        rawKeyToProperty[rawKey] = property;
      }

      const parsed: Record<string | number | symbol, any> = {};

      for (const [rawKey, rawPropertyValue] of Object.entries(raw)) {
        const property = rawKeyToProperty[rawKey];

        if (property != null) {
          const value = property.valueSchema.parse(rawPropertyValue);
          parsed[property.parsedKey] = value;
        } else if (!skipUnknownKeysOnParse && rawPropertyValue != null) {
          parsed[rawKey] = rawPropertyValue;
        }
      }

      return parsed as inferParsedObjectFromPropertySchemas<T>;
    },

    json: (parsed, { includeUnknownKeysOnJson = false } = {}) => {
      const raw: Record<string | number | symbol, any> = {};

      for (const [parsedKey, parsedPropertyValue] of entries(parsed)) {
        const schemaOrObjectProperty = schemas[parsedKey as keyof T];
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (schemaOrObjectProperty != null) {
          if (isProperty(schemaOrObjectProperty)) {
            const value = schemaOrObjectProperty.valueSchema.json(parsedPropertyValue);
            raw[schemaOrObjectProperty.rawKey] = value;
          } else {
            const value = schemaOrObjectProperty.json(parsedPropertyValue);
            raw[parsedKey] = value;
          }
        } else if (includeUnknownKeysOnJson && parsedPropertyValue != null) {
          raw[parsedKey] = parsedPropertyValue;
        }
      }

      return raw as inferRawObjectFromPropertySchemas<T>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}

export function getObjectUtils<Raw, Parsed>(schema: BaseObjectSchema<Raw, Parsed>): ObjectUtils<Raw, Parsed> {
  return {
    extend: <RawExtension, ParsedExtension>(extension: ObjectSchema<RawExtension, ParsedExtension>) => {
      const baseSchema: BaseObjectSchema<Raw & RawExtension, Parsed & ParsedExtension> = {
        ...OBJECT_LIKE_BRAND,
        parse: (raw, opts) => ({
          ...schema.parse(raw, opts),
          ...extension.parse(raw, opts),
        }),
        json: (parsed, opts) => ({
          ...schema.json(parsed, opts),
          ...extension.json(parsed, opts),
        }),
      };

      return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
      };
    },
  };
}
",
                        "name": "object.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export function property<RawKey extends string, RawValue, ParsedValue>(
  rawKey: RawKey,
  valueSchema: Schema<RawValue, ParsedValue>
): Property<RawKey, RawValue, ParsedValue> {
  return {
    rawKey,
    valueSchema,
    isProperty: true,
  };
}

export interface Property<RawKey extends string, RawValue, ParsedValue> {
  rawKey: RawKey;
  valueSchema: Schema<RawValue, ParsedValue>;
  isProperty: true;
}

export function isProperty<O extends Property<any, any, any>>(maybeProperty: unknown): maybeProperty is O {
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return (maybeProperty as O).isProperty;
}
",
                        "name": "property.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsed, inferRaw, Schema } from \\"../../Schema\\";
import { addQuestionMarksToNullableProperties } from \\"../../utils/addQuestionMarksToNullableProperties\\";
import { BaseObjectLikeSchema, ObjectLikeSchema } from \\"../object-like\\";
import { Property } from \\"./property\\";

export type ObjectSchema<Raw, Parsed> = BaseObjectSchema<Raw, Parsed> &
  ObjectLikeSchema<Raw, Parsed> &
  ObjectUtils<Raw, Parsed>;

export type BaseObjectSchema<Raw, Parsed> = BaseObjectLikeSchema<Raw, Parsed>;

export interface ObjectUtils<Raw, Parsed> {
  extend: <RawExtension, ParsedExtension>(
    schemas: ObjectSchema<RawExtension, ParsedExtension>
  ) => ObjectSchema<Raw & RawExtension, Parsed & ParsedExtension>;
}

export type inferRawObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<infer Raw, any> ? Raw : never;

export type inferParsedObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<any, infer Parsed>
  ? Parsed
  : never;

export type inferObjectSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> = ObjectSchema<
  inferRawObjectFromPropertySchemas<T>,
  inferParsedObjectFromPropertySchemas<T>
>;

export type inferRawObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
  addQuestionMarksToNullableProperties<{
    [ParsedKey in keyof T as inferRawKey<ParsedKey, T[ParsedKey]>]: inferRawPropertySchema<T[ParsedKey]>;
  }>;

export type inferParsedObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
  addQuestionMarksToNullableProperties<{
    [K in keyof T]: inferParsedPropertySchema<T[K]>;
  }>;

export type PropertySchemas<ParsedKeys extends string | number | symbol> = Record<
  ParsedKeys,
  Property<any, any, any> | Schema<any, any>
>;

export type inferRawPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
  any,
  infer Raw,
  any
>
  ? Raw
  : P extends Schema<any, any>
  ? inferRaw<P>
  : never;

export type inferParsedPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
  any,
  any,
  infer Parsed
>
  ? Parsed
  : P extends Schema<any, any>
  ? inferParsed<P>
  : never;

export type inferRawKey<
  ParsedKey extends string | number | symbol,
  P extends Property<any, any, any> | Schema<any, any>
> = P extends Property<infer Raw, any, any> ? Raw : ParsedKey;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseObjectLikeSchema, ObjectLikeUtils } from \\"./types\\";
import { withProperties } from \\"./withProperties\\";

export function getObjectLikeUtils<Raw, Parsed>(
  schema: BaseObjectLikeSchema<Raw, Parsed>
): ObjectLikeUtils<Raw, Parsed> {
  return {
    withProperties: (properties) => withProperties(schema, properties),
  };
}
",
                        "name": "getObjectLikeUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getObjectLikeUtils } from \\"./getObjectLikeUtils\\";
export { OBJECT_LIKE_BRAND, type BaseObjectLikeSchema, type ObjectLikeSchema, type ObjectLikeUtils } from \\"./types\\";
export { withProperties } from \\"./withProperties\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";

export type ObjectLikeSchema<Raw, Parsed> = Schema<Raw, Parsed> &
  BaseObjectLikeSchema<Raw, Parsed> &
  ObjectLikeUtils<Raw, Parsed>;

export type BaseObjectLikeSchema<Raw, Parsed> = BaseSchema<Raw, Parsed> & {
  _objectLike: void;
};

export interface ObjectLikeUtils<Raw, Parsed> {
  withProperties: <T extends Record<string, any>>(properties: {
    [K in keyof T]: T[K] | ((parsed: Parsed) => T[K]);
  }) => ObjectLikeSchema<Raw, Parsed & T>;
}

export const OBJECT_LIKE_BRAND = undefined as unknown as { _objectLike: void };
",
                        "name": "types.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { getSchemaUtils } from \\"../schema-utils\\";
import { getObjectLikeUtils } from \\"./getObjectLikeUtils\\";
import { BaseObjectLikeSchema, ObjectLikeSchema, OBJECT_LIKE_BRAND } from \\"./types\\";

export function withProperties<RawObjectShape, ParsedObjectShape, Properties>(
  objectLike: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape>,
  properties: { [K in keyof Properties]: Properties[K] | ((parsed: ParsedObjectShape) => Properties[K]) }
): ObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> {
  const objectSchema: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> = {
    ...OBJECT_LIKE_BRAND,
    parse: (raw, opts) => {
      const parsedObject = objectLike.parse(raw, opts);
      const additionalProperties = Object.entries(properties).reduce<Record<string, any>>((processed, [key, value]) => {
        return {
          ...processed,
          [key]: typeof value === \\"function\\" ? value(parsedObject) : value,
        };
      }, {});

      return {
        ...parsedObject,
        ...(additionalProperties as Properties),
      };
    },
    json: (parsed, opts) => {
      // strip out added properties
      const addedPropertyKeys = new Set(Object.keys(properties));
      const parsedWithoutAddedProperties = Object.entries(parsed).reduce<Record<string, any>>(
        (filtered, [key, value]) => {
          if (!addedPropertyKeys.has(key)) {
            filtered[key] = value;
          }
          return filtered;
        },
        {}
      );

      return objectLike.json(parsedWithoutAddedProperties as ParsedObjectShape, opts);
    },
  };

  return {
    ...objectSchema,
    ...getSchemaUtils(objectSchema),
    ...getObjectLikeUtils(objectSchema),
  };
}
",
                        "name": "withProperties.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object-like",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const any = createIdentitySchemaCreator<any>();
",
                        "name": "any.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const boolean = createIdentitySchemaCreator<boolean>();
",
                        "name": "boolean.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { any } from \\"./any\\";
export { boolean } from \\"./boolean\\";
export { number } from \\"./number\\";
export { string } from \\"./string\\";
export { unknown } from \\"./unknown\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const number = createIdentitySchemaCreator<number>();
",
                        "name": "number.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const string = createIdentitySchemaCreator<string>();
",
                        "name": "string.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const unknown = createIdentitySchemaCreator<unknown>();
",
                        "name": "unknown.ts",
                        "type": "file",
                      },
                    ],
                    "name": "primitives",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { record } from \\"./record\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function record<RawKey extends string | number, ParsedKey extends string | number, RawValue, ParsedValue>(
  keySchema: Schema<RawKey, ParsedKey>,
  valueSchema: Schema<RawValue, ParsedValue>
): Schema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> {
  const baseSchema: BaseSchema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> = {
    parse: (raw, opts) => {
      return entries(raw).reduce(
        (parsed, [key, value]) => {
          parsed[keySchema.parse(key, opts)] = valueSchema.parse(value, opts);
          return parsed;
        },
        // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
        {} as Record<ParsedKey, ParsedValue>
      );
    },
    json: (parsed, opts) => {
      return entries(parsed).reduce(
        (raw, [key, value]) => {
          raw[keySchema.json(key, opts)] = valueSchema.json(value, opts);
          return raw;
        },
        // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
        {} as Record<RawKey, RawValue>
      );
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "record.ts",
                        "type": "file",
                      },
                    ],
                    "name": "record",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { OptionalSchema, OPTIONAL_BRAND } from \\"./types\\";

export interface SchemaUtils<Raw, Parsed> {
  optional: () => OptionalSchema<Raw, Parsed>;
  transform: <PostTransform>(transformer: BaseSchema<Parsed, PostTransform>) => Schema<Raw, PostTransform>;
}

export function getSchemaUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): SchemaUtils<Raw, Parsed> {
  return {
    optional: () => optional(schema),
    transform: (transformer) => transform(schema, transformer),
  };
}

/**
 * schema utils are defined in one file to resolve issues with circular imports
 */

export function optional<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): OptionalSchema<Raw, Parsed> {
  const baseSchema: BaseSchema<Raw | null | undefined, Parsed | undefined> = {
    parse: (raw, opts) => (raw != null ? schema.parse(raw, opts) : undefined),
    json: (parsed, opts) => (parsed != null ? schema.json(parsed, opts) : undefined),
  };

  return {
    ...OPTIONAL_BRAND,
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function transform<PreTransformRaw, PreTransformParsed, PostTransform>(
  schema: BaseSchema<PreTransformRaw, PreTransformParsed>,
  transformer: BaseSchema<PreTransformParsed, PostTransform>
): Schema<PreTransformRaw, PostTransform> {
  const baseSchema: BaseSchema<PreTransformRaw, PostTransform> = {
    parse: (raw, opts) => {
      const postTransformParsed = schema.parse(raw, opts);
      return transformer.parse(postTransformParsed, opts);
    },
    json: (parsed, opts) => {
      const preTransformParsed = transformer.json(parsed, opts);
      return schema.json(preTransformParsed, opts);
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "getSchemaUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getSchemaUtils, optional, transform, type SchemaUtils } from \\"./getSchemaUtils\\";
export { OPTIONAL_BRAND, type OptionalSchema } from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export const OPTIONAL_BRAND = undefined as unknown as { _isOptional: void };

export type OptionalSchema<Raw, Parsed> = Schema<Raw | null | undefined, Parsed | undefined> & {
  _isOptional: void;
};
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "schema-utils",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { set } from \\"./set\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function set<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Set<Parsed>> {
  const baseSchema: BaseSchema<Raw[], Set<Parsed>> = {
    parse: (raw, opts) => new Set(raw.map((item) => schema.parse(item, opts))),
    json: (parsed, opts) => [...parsed].map((item) => schema.json(item, opts)),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "set.ts",
                        "type": "file",
                      },
                    ],
                    "name": "set",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export function discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string>(
  parsedDiscriminant: ParsedDiscriminant,
  rawDiscriminant: RawDiscriminant
): Discriminant<RawDiscriminant, ParsedDiscriminant> {
  return {
    parsedDiscriminant,
    rawDiscriminant,
  };
}

export interface Discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string> {
  parsedDiscriminant: ParsedDiscriminant;
  rawDiscriminant: RawDiscriminant;
}
",
                        "name": "discriminant.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { discriminant, type Discriminant } from \\"./discriminant\\";
export {
  type inferParsedDiscriminant,
  type inferParsedUnion,
  type inferRawDiscriminant,
  type inferRawUnion,
  type UnionSubtypes,
} from \\"./types\\";
export { union } from \\"./union\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsedObject, inferRawObject, ObjectSchema } from \\"../object\\";
import { Discriminant } from \\"./discriminant\\";

export type UnionSubtypes<DiscriminantValues extends string | number | symbol> = {
  [K in DiscriminantValues]: ObjectSchema<any, any>;
};

export type inferRawUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
  [K in keyof U]: Record<inferRawDiscriminant<D>, K> & inferRawObject<U[K]>;
}[keyof U];

export type inferParsedUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
  [K in keyof U]: Record<inferParsedDiscriminant<D>, K> & inferParsedObject<U[K]>;
}[keyof U];

export type inferRawDiscriminant<D extends string | Discriminant<any, any>> = D extends string
  ? D
  : D extends Discriminant<infer Raw, any>
  ? Raw
  : never;

export type inferParsedDiscriminant<D extends string | Discriminant<any, any>> = D extends string
  ? D
  : D extends Discriminant<any, infer Parsed>
  ? Parsed
  : never;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseObjectLikeSchema, getObjectLikeUtils, ObjectLikeSchema, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { Discriminant } from \\"./discriminant\\";
import { inferParsedDiscriminant, inferParsedUnion, inferRawDiscriminant, inferRawUnion, UnionSubtypes } from \\"./types\\";

export function union<D extends string | Discriminant<any, any>, U extends UnionSubtypes<any>>(
  discriminant: D,
  union: U
): ObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> {
  const rawDiscriminant =
    typeof discriminant === \\"string\\" ? discriminant : (discriminant.rawDiscriminant as inferRawDiscriminant<D>);
  const parsedDiscriminant =
    typeof discriminant === \\"string\\" ? discriminant : (discriminant.parsedDiscriminant as inferParsedDiscriminant<D>);

  const baseSchema: BaseObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> = {
    ...OBJECT_LIKE_BRAND,

    parse: (raw, opts) => {
      const { [rawDiscriminant]: discriminantValue, ...additionalProperties } = raw;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [parsedDiscriminant]: discriminantValue,
        } as inferParsedUnion<D, U>;
      }

      return {
        ...additionalPropertySchemas.parse(additionalProperties, opts),
        [parsedDiscriminant]: discriminantValue,
      } as inferParsedUnion<D, U>;
    },

    json: (parsed, opts) => {
      const { [parsedDiscriminant]: discriminantValue, ...additionalProperties } = parsed;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [rawDiscriminant]: discriminantValue,
        } as unknown as inferRawUnion<D, U>;
      }

      return {
        ...additionalPropertySchemas.json(additionalProperties, opts),
        [rawDiscriminant]: discriminantValue,
      } as inferRawUnion<D, U>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
  };
}
",
                        "name": "union.ts",
                        "type": "file",
                      },
                    ],
                    "name": "union",
                    "type": "directory",
                  },
                ],
                "name": "builders",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./builders\\";
export { type inferParsed, type inferRaw, type Schema, type SchemaOptions } from \\"./Schema\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export type addQuestionMarksToNullableProperties<T> = {
  [K in OptionalKeys<T>]?: undefined extends T[K] ? T[K] : never;
} & Pick<T, RequiredKeys<T>>;

export type OptionalKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? K : never;
}[keyof T];

export type RequiredKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? never : K;
}[keyof T];
",
                    "name": "addQuestionMarksToNullableProperties.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function entries<T>(object: T): [keyof T, T[keyof T]][] {
  return Object.entries(object) as [keyof T, T[keyof T]][];
}
",
                    "name": "entries.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function keys<T>(object: T): (keyof T)[] {
  return Object.keys(object) as (keyof T)[];
}
",
                    "name": "keys.ts",
                    "type": "file",
                  },
                ],
                "name": "utils",
                "type": "directory",
              },
            ],
            "name": "schemas",
            "type": "directory",
          },
        ],
        "name": "core",
        "type": "directory",
      },
      Object {
        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export const Environment = {
  Prod: \\"prod.trace.com\\",
  /**
   * i'm staging
   */
  Staging: \\"staging.trace.com\\",
} as const;

export type Environment = typeof Environment.Prod | typeof Environment.Staging;
",
        "name": "environments.ts",
        "type": "file",
      },
      Object {
        "contents": "export * as TraceMyApi from \\"./resources\\";
export { TraceMyApiClient } from \\"./Client\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { TraceMyApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    auth?: {
      token?: core.Supplier<core.BearerToken>;
    };
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async updateTestSubmissionStatus(
    request: TraceMyApi.admin.updateTestSubmissionStatus.Request
  ): Promise<TraceMyApi.admin.updateTestSubmissionStatus.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-test-submission-status/\${request.submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
      body: serializers.submission.TestSubmissionStatus.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async sendTestSubmissionUpdate(
    request: TraceMyApi.admin.sendTestSubmissionUpdate.Request
  ): Promise<TraceMyApi.admin.sendTestSubmissionUpdate.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-test-submission-status-v2/\${request.submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
      body: serializers.submission.TestSubmissionUpdate.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async updateWorkspaceSubmissionStatus(
    request: TraceMyApi.admin.updateWorkspaceSubmissionStatus.Request
  ): Promise<TraceMyApi.admin.updateWorkspaceSubmissionStatus.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-workspace-submission-status/\${request.submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
      body: serializers.submission.WorkspaceSubmissionStatus.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async sendWorkspaceSubmissionUpdate(
    request: TraceMyApi.admin.sendWorkspaceSubmissionUpdate.Request
  ): Promise<TraceMyApi.admin.sendWorkspaceSubmissionUpdate.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-workspace-submission-status-v2/\${request.submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
      body: serializers.submission.WorkspaceSubmissionUpdate.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async storeTracedTestCase(
    request: TraceMyApi.admin.storeTracedTestCase.Request
  ): Promise<TraceMyApi.admin.storeTracedTestCase.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-test-trace/submission/\${request.submissionId}/testCase/\${request.testCaseId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
      body: serializers.admin.StoreTracedTestCaseRequest.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async storeTracedTestCaseV2(
    request: TraceMyApi.admin.storeTracedTestCaseV2.Request
  ): Promise<TraceMyApi.admin.storeTracedTestCaseV2.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-test-trace-v2/submission/\${request.submissionId}/testCase/\${request.testCaseId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
      body: serializers.admin.storeTracedTestCaseV2.Request.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async storeTracedWorkspace(
    request: TraceMyApi.admin.storeTracedWorkspace.Request
  ): Promise<TraceMyApi.admin.storeTracedWorkspace.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-workspace-trace/submission/\${request.submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
      body: serializers.admin.StoreTracedWorkspaceRequest.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async storeTracedWorkspaceV2(
    request: TraceMyApi.admin.storeTracedWorkspaceV2.Request
  ): Promise<TraceMyApi.admin.storeTracedWorkspaceV2.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-workspace-trace-v2/submission/\${request.submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
      body: serializers.admin.storeTracedWorkspaceV2.Request.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as updateTestSubmissionStatus from \\"./updateTestSubmissionStatus\\";
export * as sendTestSubmissionUpdate from \\"./sendTestSubmissionUpdate\\";
export * as updateWorkspaceSubmissionStatus from \\"./updateWorkspaceSubmissionStatus\\";
export * as sendWorkspaceSubmissionUpdate from \\"./sendWorkspaceSubmissionUpdate\\";
export * as storeTracedTestCase from \\"./storeTracedTestCase\\";
export * as storeTracedTestCaseV2 from \\"./storeTracedTestCaseV2\\";
export * as storeTracedWorkspace from \\"./storeTracedWorkspace\\";
export * as storeTracedWorkspaceV2 from \\"./storeTracedWorkspaceV2\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  submissionId: TraceMyApi.submission.SubmissionId;
  _body: TraceMyApi.submission.TestSubmissionUpdate;
}

export type Response = core.APIResponse<void, TraceMyApi.admin.sendTestSubmissionUpdate.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "sendTestSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  submissionId: TraceMyApi.submission.SubmissionId;
  _body: TraceMyApi.submission.WorkspaceSubmissionUpdate;
}

export type Response = core.APIResponse<void, TraceMyApi.admin.sendWorkspaceSubmissionUpdate.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "sendWorkspaceSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  submissionId: TraceMyApi.submission.SubmissionId;
  testCaseId: string;
  _body: TraceMyApi.admin.StoreTracedTestCaseRequest;
}

export type Response = core.APIResponse<void, TraceMyApi.admin.storeTracedTestCase.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "storeTracedTestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  submissionId: TraceMyApi.submission.SubmissionId;
  testCaseId: TraceMyApi.v2.problem.TestCaseId;
  _body: TraceMyApi.submission.TraceResponseV2[];
}

export type Response = core.APIResponse<void, TraceMyApi.admin.storeTracedTestCaseV2.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "storeTracedTestCaseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  submissionId: TraceMyApi.submission.SubmissionId;
  _body: TraceMyApi.admin.StoreTracedWorkspaceRequest;
}

export type Response = core.APIResponse<void, TraceMyApi.admin.storeTracedWorkspace.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "storeTracedWorkspace.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  submissionId: TraceMyApi.submission.SubmissionId;
  _body: TraceMyApi.submission.TraceResponseV2[];
}

export type Response = core.APIResponse<void, TraceMyApi.admin.storeTracedWorkspaceV2.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "storeTracedWorkspaceV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  submissionId: TraceMyApi.submission.SubmissionId;
  _body: TraceMyApi.submission.TestSubmissionStatus;
}

export type Response = core.APIResponse<void, TraceMyApi.admin.updateTestSubmissionStatus.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "updateTestSubmissionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  submissionId: TraceMyApi.submission.SubmissionId;
  _body: TraceMyApi.submission.WorkspaceSubmissionStatus;
}

export type Response = core.APIResponse<void, TraceMyApi.admin.updateWorkspaceSubmissionStatus.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "updateWorkspaceSubmissionStatus.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface StoreTracedTestCaseRequest {
  result: TraceMyApi.submission.TestCaseResultWithStdout;
  traceResponses: TraceMyApi.submission.TraceResponse[];
}
",
                    "name": "StoreTracedTestCaseRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface StoreTracedWorkspaceRequest {
  workspaceRunDetails: TraceMyApi.submission.WorkspaceRunDetails;
  traceResponses: TraceMyApi.submission.TraceResponse[];
}
",
                    "name": "StoreTracedWorkspaceRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./StoreTracedTestCaseRequest\\";
export * from \\"./StoreTracedWorkspaceRequest\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "admin",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface BinaryTreeNodeAndTreeValue {
  nodeId: TraceMyApi.commons.NodeId;
  fullTree: TraceMyApi.commons.BinaryTreeValue;
}
",
                    "name": "BinaryTreeNodeAndTreeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface BinaryTreeNodeValue {
  nodeId: TraceMyApi.commons.NodeId;
  val: number;
  right?: TraceMyApi.commons.NodeId;
  left?: TraceMyApi.commons.NodeId;
}
",
                    "name": "BinaryTreeNodeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface BinaryTreeValue {
  root?: TraceMyApi.commons.NodeId;
  nodes: Record<string, TraceMyApi.commons.BinaryTreeNodeValue>;
}
",
                    "name": "BinaryTreeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface DebugKeyValuePairs {
  key: TraceMyApi.commons.DebugVariableValue;
  value: TraceMyApi.commons.DebugVariableValue;
}
",
                    "name": "DebugKeyValuePairs.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface DebugMapValue {
  keyValuePairs: TraceMyApi.commons.DebugKeyValuePairs[];
}
",
                    "name": "DebugMapValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export type DebugVariableValue =
  | DebugVariableValue.IntegerValue
  | DebugVariableValue.BooleanValue
  | DebugVariableValue.DoubleValue
  | DebugVariableValue.StringValue
  | DebugVariableValue.CharValue
  | DebugVariableValue.MapValue
  | DebugVariableValue.ListValue
  | DebugVariableValue.BinaryTreeNodeValue
  | DebugVariableValue.SinglyLinkedListNodeValue
  | DebugVariableValue.DoublyLinkedListNodeValue
  | DebugVariableValue.UndefinedValue
  | DebugVariableValue.NullValue
  | DebugVariableValue.GenericValue
  | DebugVariableValue._Unknown;

export declare namespace DebugVariableValue {
  interface IntegerValue extends _Utils {
    type: \\"integerValue\\";
    value: number;
  }

  interface BooleanValue extends _Utils {
    type: \\"booleanValue\\";
    value: boolean;
  }

  interface DoubleValue extends _Utils {
    type: \\"doubleValue\\";
    value: number;
  }

  interface StringValue extends _Utils {
    type: \\"stringValue\\";
    value: string;
  }

  interface CharValue extends _Utils {
    type: \\"charValue\\";
    value: string;
  }

  interface MapValue extends TraceMyApi.commons.DebugMapValue, _Utils {
    type: \\"mapValue\\";
  }

  interface ListValue extends _Utils {
    type: \\"listValue\\";
    value: TraceMyApi.commons.DebugVariableValue[];
  }

  interface BinaryTreeNodeValue extends TraceMyApi.commons.BinaryTreeNodeAndTreeValue, _Utils {
    type: \\"binaryTreeNodeValue\\";
  }

  interface SinglyLinkedListNodeValue extends TraceMyApi.commons.SinglyLinkedListNodeAndListValue, _Utils {
    type: \\"singlyLinkedListNodeValue\\";
  }

  interface DoublyLinkedListNodeValue extends TraceMyApi.commons.DoublyLinkedListNodeAndListValue, _Utils {
    type: \\"doublyLinkedListNodeValue\\";
  }

  interface UndefinedValue extends _Utils {
    type: \\"undefinedValue\\";
  }

  interface NullValue extends _Utils {
    type: \\"nullValue\\";
  }

  interface GenericValue extends TraceMyApi.commons.GenericValue, _Utils {
    type: \\"genericValue\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: DebugVariableValue._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    integerValue: (value: number) => Result;
    booleanValue: (value: boolean) => Result;
    doubleValue: (value: number) => Result;
    stringValue: (value: string) => Result;
    charValue: (value: string) => Result;
    mapValue: (value: TraceMyApi.commons.DebugMapValue) => Result;
    listValue: (value: TraceMyApi.commons.DebugVariableValue[]) => Result;
    binaryTreeNodeValue: (value: TraceMyApi.commons.BinaryTreeNodeAndTreeValue) => Result;
    singlyLinkedListNodeValue: (value: TraceMyApi.commons.SinglyLinkedListNodeAndListValue) => Result;
    doublyLinkedListNodeValue: (value: TraceMyApi.commons.DoublyLinkedListNodeAndListValue) => Result;
    undefinedValue: () => Result;
    nullValue: () => Result;
    genericValue: (value: TraceMyApi.commons.GenericValue) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const DebugVariableValue = {
  integerValue: (value: number): DebugVariableValue.IntegerValue => {
    const valueWithoutVisit: Omit<DebugVariableValue.IntegerValue, \\"_visit\\"> = {
      value: value,
      type: \\"integerValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as DebugVariableValue.IntegerValue;
    castedValue._visit = (visitor) => visitor.integerValue(value);
    return castedValue;
  },

  booleanValue: (value: boolean): DebugVariableValue.BooleanValue => {
    const valueWithoutVisit: Omit<DebugVariableValue.BooleanValue, \\"_visit\\"> = {
      value: value,
      type: \\"booleanValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as DebugVariableValue.BooleanValue;
    castedValue._visit = (visitor) => visitor.booleanValue(value);
    return castedValue;
  },

  doubleValue: (value: number): DebugVariableValue.DoubleValue => {
    const valueWithoutVisit: Omit<DebugVariableValue.DoubleValue, \\"_visit\\"> = {
      value: value,
      type: \\"doubleValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as DebugVariableValue.DoubleValue;
    castedValue._visit = (visitor) => visitor.doubleValue(value);
    return castedValue;
  },

  stringValue: (value: string): DebugVariableValue.StringValue => {
    const valueWithoutVisit: Omit<DebugVariableValue.StringValue, \\"_visit\\"> = {
      value: value,
      type: \\"stringValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as DebugVariableValue.StringValue;
    castedValue._visit = (visitor) => visitor.stringValue(value);
    return castedValue;
  },

  charValue: (value: string): DebugVariableValue.CharValue => {
    const valueWithoutVisit: Omit<DebugVariableValue.CharValue, \\"_visit\\"> = {
      value: value,
      type: \\"charValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as DebugVariableValue.CharValue;
    castedValue._visit = (visitor) => visitor.charValue(value);
    return castedValue;
  },

  mapValue: (value: TraceMyApi.commons.DebugMapValue): DebugVariableValue.MapValue => {
    const valueWithoutVisit: Omit<DebugVariableValue.MapValue, \\"_visit\\"> = {
      ...value,
      type: \\"mapValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as DebugVariableValue.MapValue;
    castedValue._visit = (visitor) => visitor.mapValue(value);
    return castedValue;
  },

  listValue: (value: TraceMyApi.commons.DebugVariableValue[]): DebugVariableValue.ListValue => {
    const valueWithoutVisit: Omit<DebugVariableValue.ListValue, \\"_visit\\"> = {
      value: value,
      type: \\"listValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as DebugVariableValue.ListValue;
    castedValue._visit = (visitor) => visitor.listValue(value);
    return castedValue;
  },

  binaryTreeNodeValue: (
    value: TraceMyApi.commons.BinaryTreeNodeAndTreeValue
  ): DebugVariableValue.BinaryTreeNodeValue => {
    const valueWithoutVisit: Omit<DebugVariableValue.BinaryTreeNodeValue, \\"_visit\\"> = {
      ...value,
      type: \\"binaryTreeNodeValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as DebugVariableValue.BinaryTreeNodeValue;
    castedValue._visit = (visitor) => visitor.binaryTreeNodeValue(value);
    return castedValue;
  },

  singlyLinkedListNodeValue: (
    value: TraceMyApi.commons.SinglyLinkedListNodeAndListValue
  ): DebugVariableValue.SinglyLinkedListNodeValue => {
    const valueWithoutVisit: Omit<DebugVariableValue.SinglyLinkedListNodeValue, \\"_visit\\"> = {
      ...value,
      type: \\"singlyLinkedListNodeValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as DebugVariableValue.SinglyLinkedListNodeValue;
    castedValue._visit = (visitor) => visitor.singlyLinkedListNodeValue(value);
    return castedValue;
  },

  doublyLinkedListNodeValue: (
    value: TraceMyApi.commons.DoublyLinkedListNodeAndListValue
  ): DebugVariableValue.DoublyLinkedListNodeValue => {
    const valueWithoutVisit: Omit<DebugVariableValue.DoublyLinkedListNodeValue, \\"_visit\\"> = {
      ...value,
      type: \\"doublyLinkedListNodeValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as DebugVariableValue.DoublyLinkedListNodeValue;
    castedValue._visit = (visitor) => visitor.doublyLinkedListNodeValue(value);
    return castedValue;
  },

  undefinedValue: (): DebugVariableValue.UndefinedValue => {
    const valueWithoutVisit: Omit<DebugVariableValue.UndefinedValue, \\"_visit\\"> = {
      type: \\"undefinedValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as DebugVariableValue.UndefinedValue;
    castedValue._visit = (visitor) => visitor.undefinedValue();
    return castedValue;
  },

  nullValue: (): DebugVariableValue.NullValue => {
    const valueWithoutVisit: Omit<DebugVariableValue.NullValue, \\"_visit\\"> = {
      type: \\"nullValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as DebugVariableValue.NullValue;
    castedValue._visit = (visitor) => visitor.nullValue();
    return castedValue;
  },

  genericValue: (value: TraceMyApi.commons.GenericValue): DebugVariableValue.GenericValue => {
    const valueWithoutVisit: Omit<DebugVariableValue.GenericValue, \\"_visit\\"> = {
      ...value,
      type: \\"genericValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as DebugVariableValue.GenericValue;
    castedValue._visit = (visitor) => visitor.genericValue(value);
    return castedValue;
  },
} as const;
",
                    "name": "DebugVariableValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface DoublyLinkedListNodeAndListValue {
  nodeId: TraceMyApi.commons.NodeId;
  fullList: TraceMyApi.commons.DoublyLinkedListValue;
}
",
                    "name": "DoublyLinkedListNodeAndListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface DoublyLinkedListNodeValue {
  nodeId: TraceMyApi.commons.NodeId;
  val: number;
  next?: TraceMyApi.commons.NodeId;
  prev?: TraceMyApi.commons.NodeId;
}
",
                    "name": "DoublyLinkedListNodeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface DoublyLinkedListValue {
  head?: TraceMyApi.commons.NodeId;
  nodes: Record<string, TraceMyApi.commons.DoublyLinkedListNodeValue>;
}
",
                    "name": "DoublyLinkedListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface FileInfo {
  filename: string;
  contents: string;
}
",
                    "name": "FileInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface GenericValue {
  stringifiedType?: string;
  stringifiedValue: string;
}
",
                    "name": "GenericValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface KeyValuePair {
  key: TraceMyApi.commons.VariableValue;
  value: TraceMyApi.commons.VariableValue;
}
",
                    "name": "KeyValuePair.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface Language<RawValue extends Language.RawValue = Language.RawValue> {
  value: RawValue;
  visit: <Result>(visitor: Language._Visitor<Result>) => Result;
}

const _Java: Language<\\"JAVA\\"> = {
  value: \\"JAVA\\",
  visit: (visitor) => visitor.java(),
};
const _Javascript: Language<\\"JAVASCRIPT\\"> = {
  value: \\"JAVASCRIPT\\",
  visit: (visitor) => visitor.javascript(),
};
const _Python: Language<\\"PYTHON\\"> = {
  value: \\"PYTHON\\",
  visit: (visitor) => visitor.python(),
};
export const Language = {
  Java: _Java,
  Javascript: _Javascript,
  Python: _Python,
  _parse: (value: string): Language => {
    switch (value) {
      case \\"JAVA\\": {
        return _Java;
      }
      case \\"JAVASCRIPT\\": {
        return _Javascript;
      }
      case \\"PYTHON\\": {
        return _Python;
      }
      default: {
        return {
          value: value as Language.RawValue,
          visit: (visitor) => visitor._other(value),
        };
      }
    }
  },
} as const;

export declare namespace Language {
  type RawValue = \\"JAVA\\" | \\"JAVASCRIPT\\" | \\"PYTHON\\";

  interface _Visitor<Result> {
    java: () => Result;
    javascript: () => Result;
    python: () => Result;
    _other: (value: string) => Result;
  }
}
",
                    "name": "Language.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface ListType {
  valueType: TraceMyApi.commons.VariableType;
  /** Whether this list is fixed-size (for languages that supports fixed-size lists). Defaults to false. */
  isFixedLength?: boolean;
}
",
                    "name": "ListType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface MapType {
  keyType: TraceMyApi.commons.VariableType;
  valueType: TraceMyApi.commons.VariableType;
}
",
                    "name": "MapType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface MapValue {
  keyValuePairs: TraceMyApi.commons.KeyValuePair[];
}
",
                    "name": "MapValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export type NodeId = string;
",
                    "name": "NodeId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export type ProblemId = string;
",
                    "name": "ProblemId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface SinglyLinkedListNodeAndListValue {
  nodeId: TraceMyApi.commons.NodeId;
  fullList: TraceMyApi.commons.SinglyLinkedListValue;
}
",
                    "name": "SinglyLinkedListNodeAndListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface SinglyLinkedListNodeValue {
  nodeId: TraceMyApi.commons.NodeId;
  val: number;
  next?: TraceMyApi.commons.NodeId;
}
",
                    "name": "SinglyLinkedListNodeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface SinglyLinkedListValue {
  head?: TraceMyApi.commons.NodeId;
  nodes: Record<string, TraceMyApi.commons.SinglyLinkedListNodeValue>;
}
",
                    "name": "SinglyLinkedListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface TestCase {
  id: string;
  params: TraceMyApi.commons.VariableValue[];
}
",
                    "name": "TestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface TestCaseWithExpectedResult {
  testCase: TraceMyApi.commons.TestCase;
  expectedResult: TraceMyApi.commons.VariableValue;
}
",
                    "name": "TestCaseWithExpectedResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export type UserId = string;
",
                    "name": "UserId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export type VariableType =
  | VariableType.IntegerType
  | VariableType.DoubleType
  | VariableType.BooleanType
  | VariableType.StringType
  | VariableType.CharType
  | VariableType.ListType
  | VariableType.MapType
  | VariableType.BinaryTreeType
  | VariableType.SinglyLinkedListType
  | VariableType.DoublyLinkedListType
  | VariableType._Unknown;

export declare namespace VariableType {
  interface IntegerType extends _Utils {
    type: \\"integerType\\";
  }

  interface DoubleType extends _Utils {
    type: \\"doubleType\\";
  }

  interface BooleanType extends _Utils {
    type: \\"booleanType\\";
  }

  interface StringType extends _Utils {
    type: \\"stringType\\";
  }

  interface CharType extends _Utils {
    type: \\"charType\\";
  }

  interface ListType extends TraceMyApi.commons.ListType, _Utils {
    type: \\"listType\\";
  }

  interface MapType extends TraceMyApi.commons.MapType, _Utils {
    type: \\"mapType\\";
  }

  interface BinaryTreeType extends _Utils {
    type: \\"binaryTreeType\\";
  }

  interface SinglyLinkedListType extends _Utils {
    type: \\"singlyLinkedListType\\";
  }

  interface DoublyLinkedListType extends _Utils {
    type: \\"doublyLinkedListType\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: VariableType._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    integerType: () => Result;
    doubleType: () => Result;
    booleanType: () => Result;
    stringType: () => Result;
    charType: () => Result;
    listType: (value: TraceMyApi.commons.ListType) => Result;
    mapType: (value: TraceMyApi.commons.MapType) => Result;
    binaryTreeType: () => Result;
    singlyLinkedListType: () => Result;
    doublyLinkedListType: () => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const VariableType = {
  integerType: (): VariableType.IntegerType => {
    const valueWithoutVisit: Omit<VariableType.IntegerType, \\"_visit\\"> = {
      type: \\"integerType\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableType.IntegerType;
    castedValue._visit = (visitor) => visitor.integerType();
    return castedValue;
  },

  doubleType: (): VariableType.DoubleType => {
    const valueWithoutVisit: Omit<VariableType.DoubleType, \\"_visit\\"> = {
      type: \\"doubleType\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableType.DoubleType;
    castedValue._visit = (visitor) => visitor.doubleType();
    return castedValue;
  },

  booleanType: (): VariableType.BooleanType => {
    const valueWithoutVisit: Omit<VariableType.BooleanType, \\"_visit\\"> = {
      type: \\"booleanType\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableType.BooleanType;
    castedValue._visit = (visitor) => visitor.booleanType();
    return castedValue;
  },

  stringType: (): VariableType.StringType => {
    const valueWithoutVisit: Omit<VariableType.StringType, \\"_visit\\"> = {
      type: \\"stringType\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableType.StringType;
    castedValue._visit = (visitor) => visitor.stringType();
    return castedValue;
  },

  charType: (): VariableType.CharType => {
    const valueWithoutVisit: Omit<VariableType.CharType, \\"_visit\\"> = {
      type: \\"charType\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableType.CharType;
    castedValue._visit = (visitor) => visitor.charType();
    return castedValue;
  },

  listType: (value: TraceMyApi.commons.ListType): VariableType.ListType => {
    const valueWithoutVisit: Omit<VariableType.ListType, \\"_visit\\"> = {
      ...value,
      type: \\"listType\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableType.ListType;
    castedValue._visit = (visitor) => visitor.listType(value);
    return castedValue;
  },

  mapType: (value: TraceMyApi.commons.MapType): VariableType.MapType => {
    const valueWithoutVisit: Omit<VariableType.MapType, \\"_visit\\"> = {
      ...value,
      type: \\"mapType\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableType.MapType;
    castedValue._visit = (visitor) => visitor.mapType(value);
    return castedValue;
  },

  binaryTreeType: (): VariableType.BinaryTreeType => {
    const valueWithoutVisit: Omit<VariableType.BinaryTreeType, \\"_visit\\"> = {
      type: \\"binaryTreeType\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableType.BinaryTreeType;
    castedValue._visit = (visitor) => visitor.binaryTreeType();
    return castedValue;
  },

  singlyLinkedListType: (): VariableType.SinglyLinkedListType => {
    const valueWithoutVisit: Omit<VariableType.SinglyLinkedListType, \\"_visit\\"> = {
      type: \\"singlyLinkedListType\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableType.SinglyLinkedListType;
    castedValue._visit = (visitor) => visitor.singlyLinkedListType();
    return castedValue;
  },

  doublyLinkedListType: (): VariableType.DoublyLinkedListType => {
    const valueWithoutVisit: Omit<VariableType.DoublyLinkedListType, \\"_visit\\"> = {
      type: \\"doublyLinkedListType\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableType.DoublyLinkedListType;
    castedValue._visit = (visitor) => visitor.doublyLinkedListType();
    return castedValue;
  },
} as const;
",
                    "name": "VariableType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export type VariableValue =
  | VariableValue.IntegerValue
  | VariableValue.BooleanValue
  | VariableValue.DoubleValue
  | VariableValue.StringValue
  | VariableValue.CharValue
  | VariableValue.MapValue
  | VariableValue.ListValue
  | VariableValue.BinaryTreeValue
  | VariableValue.SinglyLinkedListValue
  | VariableValue.DoublyLinkedListValue
  | VariableValue.NullValue
  | VariableValue._Unknown;

export declare namespace VariableValue {
  interface IntegerValue extends _Utils {
    type: \\"integerValue\\";
    value: number;
  }

  interface BooleanValue extends _Utils {
    type: \\"booleanValue\\";
    value: boolean;
  }

  interface DoubleValue extends _Utils {
    type: \\"doubleValue\\";
    value: number;
  }

  interface StringValue extends _Utils {
    type: \\"stringValue\\";
    value: string;
  }

  interface CharValue extends _Utils {
    type: \\"charValue\\";
    value: string;
  }

  interface MapValue extends TraceMyApi.commons.MapValue, _Utils {
    type: \\"mapValue\\";
  }

  interface ListValue extends _Utils {
    type: \\"listValue\\";
    value: TraceMyApi.commons.VariableValue[];
  }

  interface BinaryTreeValue extends TraceMyApi.commons.BinaryTreeValue, _Utils {
    type: \\"binaryTreeValue\\";
  }

  interface SinglyLinkedListValue extends TraceMyApi.commons.SinglyLinkedListValue, _Utils {
    type: \\"singlyLinkedListValue\\";
  }

  interface DoublyLinkedListValue extends TraceMyApi.commons.DoublyLinkedListValue, _Utils {
    type: \\"doublyLinkedListValue\\";
  }

  interface NullValue extends _Utils {
    type: \\"nullValue\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: VariableValue._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    integerValue: (value: number) => Result;
    booleanValue: (value: boolean) => Result;
    doubleValue: (value: number) => Result;
    stringValue: (value: string) => Result;
    charValue: (value: string) => Result;
    mapValue: (value: TraceMyApi.commons.MapValue) => Result;
    listValue: (value: TraceMyApi.commons.VariableValue[]) => Result;
    binaryTreeValue: (value: TraceMyApi.commons.BinaryTreeValue) => Result;
    singlyLinkedListValue: (value: TraceMyApi.commons.SinglyLinkedListValue) => Result;
    doublyLinkedListValue: (value: TraceMyApi.commons.DoublyLinkedListValue) => Result;
    nullValue: () => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const VariableValue = {
  integerValue: (value: number): VariableValue.IntegerValue => {
    const valueWithoutVisit: Omit<VariableValue.IntegerValue, \\"_visit\\"> = {
      value: value,
      type: \\"integerValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableValue.IntegerValue;
    castedValue._visit = (visitor) => visitor.integerValue(value);
    return castedValue;
  },

  booleanValue: (value: boolean): VariableValue.BooleanValue => {
    const valueWithoutVisit: Omit<VariableValue.BooleanValue, \\"_visit\\"> = {
      value: value,
      type: \\"booleanValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableValue.BooleanValue;
    castedValue._visit = (visitor) => visitor.booleanValue(value);
    return castedValue;
  },

  doubleValue: (value: number): VariableValue.DoubleValue => {
    const valueWithoutVisit: Omit<VariableValue.DoubleValue, \\"_visit\\"> = {
      value: value,
      type: \\"doubleValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableValue.DoubleValue;
    castedValue._visit = (visitor) => visitor.doubleValue(value);
    return castedValue;
  },

  stringValue: (value: string): VariableValue.StringValue => {
    const valueWithoutVisit: Omit<VariableValue.StringValue, \\"_visit\\"> = {
      value: value,
      type: \\"stringValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableValue.StringValue;
    castedValue._visit = (visitor) => visitor.stringValue(value);
    return castedValue;
  },

  charValue: (value: string): VariableValue.CharValue => {
    const valueWithoutVisit: Omit<VariableValue.CharValue, \\"_visit\\"> = {
      value: value,
      type: \\"charValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableValue.CharValue;
    castedValue._visit = (visitor) => visitor.charValue(value);
    return castedValue;
  },

  mapValue: (value: TraceMyApi.commons.MapValue): VariableValue.MapValue => {
    const valueWithoutVisit: Omit<VariableValue.MapValue, \\"_visit\\"> = {
      ...value,
      type: \\"mapValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableValue.MapValue;
    castedValue._visit = (visitor) => visitor.mapValue(value);
    return castedValue;
  },

  listValue: (value: TraceMyApi.commons.VariableValue[]): VariableValue.ListValue => {
    const valueWithoutVisit: Omit<VariableValue.ListValue, \\"_visit\\"> = {
      value: value,
      type: \\"listValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableValue.ListValue;
    castedValue._visit = (visitor) => visitor.listValue(value);
    return castedValue;
  },

  binaryTreeValue: (value: TraceMyApi.commons.BinaryTreeValue): VariableValue.BinaryTreeValue => {
    const valueWithoutVisit: Omit<VariableValue.BinaryTreeValue, \\"_visit\\"> = {
      ...value,
      type: \\"binaryTreeValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableValue.BinaryTreeValue;
    castedValue._visit = (visitor) => visitor.binaryTreeValue(value);
    return castedValue;
  },

  singlyLinkedListValue: (value: TraceMyApi.commons.SinglyLinkedListValue): VariableValue.SinglyLinkedListValue => {
    const valueWithoutVisit: Omit<VariableValue.SinglyLinkedListValue, \\"_visit\\"> = {
      ...value,
      type: \\"singlyLinkedListValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableValue.SinglyLinkedListValue;
    castedValue._visit = (visitor) => visitor.singlyLinkedListValue(value);
    return castedValue;
  },

  doublyLinkedListValue: (value: TraceMyApi.commons.DoublyLinkedListValue): VariableValue.DoublyLinkedListValue => {
    const valueWithoutVisit: Omit<VariableValue.DoublyLinkedListValue, \\"_visit\\"> = {
      ...value,
      type: \\"doublyLinkedListValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableValue.DoublyLinkedListValue;
    castedValue._visit = (visitor) => visitor.doublyLinkedListValue(value);
    return castedValue;
  },

  nullValue: (): VariableValue.NullValue => {
    const valueWithoutVisit: Omit<VariableValue.NullValue, \\"_visit\\"> = {
      type: \\"nullValue\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as VariableValue.NullValue;
    castedValue._visit = (visitor) => visitor.nullValue();
    return castedValue;
  },
} as const;
",
                    "name": "VariableValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./UserId\\";
export * from \\"./ProblemId\\";
export * from \\"./NodeId\\";
export * from \\"./VariableType\\";
export * from \\"./ListType\\";
export * from \\"./MapType\\";
export * from \\"./VariableValue\\";
export * from \\"./DebugVariableValue\\";
export * from \\"./GenericValue\\";
export * from \\"./MapValue\\";
export * from \\"./KeyValuePair\\";
export * from \\"./BinaryTreeValue\\";
export * from \\"./BinaryTreeNodeValue\\";
export * from \\"./BinaryTreeNodeAndTreeValue\\";
export * from \\"./SinglyLinkedListValue\\";
export * from \\"./SinglyLinkedListNodeValue\\";
export * from \\"./SinglyLinkedListNodeAndListValue\\";
export * from \\"./DoublyLinkedListValue\\";
export * from \\"./DoublyLinkedListNodeValue\\";
export * from \\"./DoublyLinkedListNodeAndListValue\\";
export * from \\"./DebugMapValue\\";
export * from \\"./DebugKeyValuePairs\\";
export * from \\"./TestCase\\";
export * from \\"./TestCaseWithExpectedResult\\";
export * from \\"./FileInfo\\";
export * from \\"./Language\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "commons",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { TraceMyApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    auth?: {
      token?: core.Supplier<core.BearerToken>;
    };
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async getHomepageProblems(): Promise<TraceMyApi.homepage.getHomepageProblems.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/homepage-problems/\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.homepage.getHomepageProblems.Response.parse(
          response.body as serializers.commons.ProblemId.Raw[]
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async setHomepageProblems(
    request: TraceMyApi.commons.ProblemId[]
  ): Promise<TraceMyApi.homepage.setHomepageProblems.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/homepage-problems/\\"),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
      body: serializers.homepage.setHomepageProblems.Request.json(request),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<TraceMyApi.commons.ProblemId[], TraceMyApi.homepage.getHomepageProblems.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "getHomepageProblems.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getHomepageProblems from \\"./getHomepageProblems\\";
export * as setHomepageProblems from \\"./setHomepageProblems\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, TraceMyApi.homepage.setHomepageProblems.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "setHomepageProblems.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "homepage",
            "type": "directory",
          },
          Object {
            "contents": "export * as admin from \\"./admin\\";
export * from \\"./admin/types\\";
export * as commons from \\"./commons\\";
export * from \\"./commons/types\\";
export * as langServer from \\"./langServer\\";
export * from \\"./langServer/types\\";
export * as migration from \\"./migration\\";
export * from \\"./migration/types\\";
export * as playlist from \\"./playlist\\";
export * from \\"./playlist/types\\";
export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as submission from \\"./submission\\";
export * from \\"./submission/types\\";
export * as v2 from \\"./v2\\";
export * from \\"./playlist/errors\\";
export * as homepage from \\"./homepage\\";
export * as sysprop from \\"./sysprop\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface LangServerRequest {
  request?: unknown;
}
",
                    "name": "LangServerRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface LangServerResponse {
  response?: unknown;
}
",
                    "name": "LangServerResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./LangServerRequest\\";
export * from \\"./LangServerResponse\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "langServer",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { TraceMyApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    auth?: {
      token?: core.Supplier<core.BearerToken>;
    };
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async getAttemptedMigrations(): Promise<TraceMyApi.migration.getAttemptedMigrations.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/migration-info/all\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.migration.getAttemptedMigrations.Response.parse(
          response.body as serializers.migration.Migration.Raw[]
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  TraceMyApi.migration.Migration[],
  TraceMyApi.migration.getAttemptedMigrations.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "getAttemptedMigrations.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getAttemptedMigrations from \\"./getAttemptedMigrations\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface Migration {
  name: string;
  status: TraceMyApi.migration.MigrationStatus;
}
",
                    "name": "Migration.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface MigrationStatus<RawValue extends MigrationStatus.RawValue = MigrationStatus.RawValue> {
  value: RawValue;
  visit: <Result>(visitor: MigrationStatus._Visitor<Result>) => Result;
}

const _Running: MigrationStatus<\\"RUNNING\\"> = {
  value: \\"RUNNING\\",
  visit: (visitor) => visitor.running(),
};
const _Failed: MigrationStatus<\\"FAILED\\"> = {
  value: \\"FAILED\\",
  visit: (visitor) => visitor.failed(),
};
const _Finished: MigrationStatus<\\"FINISHED\\"> = {
  value: \\"FINISHED\\",
  visit: (visitor) => visitor.finished(),
};
export const MigrationStatus = {
  Running: _Running,
  Failed: _Failed,
  Finished: _Finished,
  _parse: (value: string): MigrationStatus => {
    switch (value) {
      case \\"RUNNING\\": {
        return _Running;
      }
      case \\"FAILED\\": {
        return _Failed;
      }
      case \\"FINISHED\\": {
        return _Finished;
      }
      default: {
        return {
          value: value as MigrationStatus.RawValue,
          visit: (visitor) => visitor._other(value),
        };
      }
    }
  },
} as const;

export declare namespace MigrationStatus {
  type RawValue = \\"RUNNING\\" | \\"FAILED\\" | \\"FINISHED\\";

  interface _Visitor<Result> {
    running: () => Result;
    failed: () => Result;
    finished: () => Result;
    _other: (value: string) => Result;
  }
}
",
                    "name": "MigrationStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./MigrationStatus\\";
export * from \\"./Migration\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "migration",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { TraceMyApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    auth?: {
      token?: core.Supplier<core.BearerToken>;
    };
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async createPlaylist(
    request: TraceMyApi.playlist.createPlaylist.Request
  ): Promise<TraceMyApi.playlist.createPlaylist.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/v2/playlist/\${request.serviceParam}create\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
      body: serializers.playlist.PlaylistCreateRequest.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.playlist.Playlist.parse(response.body as serializers.playlist.Playlist.Raw),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getPlaylists(
    request: TraceMyApi.playlist.getPlaylists.Request
  ): Promise<TraceMyApi.playlist.getPlaylists.Response> {
    const queryParameters = new URLSearchParams();
    if (request.limit != null) {
      queryParameters.append(\\"limit\\", request.limit.toString());
    }

    queryParameters.append(\\"otherField\\", request.otherField);
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/v2/playlist/\${request.serviceParam}all\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
      queryParameters: queryParameters,
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.playlist.getPlaylists.Response.parse(response.body as serializers.playlist.Playlist.Raw[]),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getPlaylist(
    request: TraceMyApi.playlist.getPlaylist.Request
  ): Promise<TraceMyApi.playlist.getPlaylist.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/v2/playlist/\${request.serviceParam}\${request.playlistId}\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.playlist.Playlist.parse(response.body as serializers.playlist.Playlist.Raw),
      };
    }

    if (response.error.reason === \\"status-code\\") {
      switch ((response.error.body as serializers.playlist.getPlaylist.Error.Raw)?.errorName) {
        case \\"PlaylistIdNotFoundError\\":
        case \\"UnauthorizedError\\":
          return {
            ok: false,
            error: serializers.playlist.getPlaylist.Error.parse(
              response.error.body as serializers.playlist.getPlaylist.Error.Raw
            ),
          };
      }
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async updatePlaylist(
    request: TraceMyApi.playlist.updatePlaylist.Request
  ): Promise<TraceMyApi.playlist.updatePlaylist.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/v2/playlist/\${request.serviceParam}\${request.playlistId}\`
      ),
      method: \\"PUT\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
      body: serializers.playlist.updatePlaylist.Request.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.playlist.updatePlaylist.Response.parse(
          response.body as serializers.playlist.Playlist.Raw | null | undefined
        ),
      };
    }

    if (response.error.reason === \\"status-code\\") {
      switch ((response.error.body as serializers.playlist.updatePlaylist.Error.Raw)?.errorName) {
        case \\"PlaylistIdNotFoundError\\":
          return {
            ok: false,
            error: serializers.playlist.updatePlaylist.Error.parse(
              response.error.body as serializers.playlist.updatePlaylist.Error.Raw
            ),
          };
      }
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async deletePlaylist(
    request: TraceMyApi.playlist.deletePlaylist.Request
  ): Promise<TraceMyApi.playlist.deletePlaylist.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/v2/playlist/\${request.serviceParam}\${request.playlistId}\`
      ),
      method: \\"DELETE\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  serviceParam: number;
  _body: TraceMyApi.playlist.PlaylistCreateRequest;
}

export type Response = core.APIResponse<TraceMyApi.playlist.Playlist, TraceMyApi.playlist.createPlaylist.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "createPlaylist.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  serviceParam: number;
  playlistId: TraceMyApi.playlist.PlaylistId;
}

export type Response = core.APIResponse<void, TraceMyApi.playlist.deletePlaylist.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "deletePlaylist.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  serviceParam: number;
  playlistId: TraceMyApi.playlist.PlaylistId;
}

export type Response = core.APIResponse<TraceMyApi.playlist.Playlist, TraceMyApi.playlist.getPlaylist.Error>;
export type Error = Error.PlaylistIdNotFoundError | Error.UnauthorizedError | Error._Unknown;

export declare namespace Error {
  interface PlaylistIdNotFoundError extends _Utils {
    errorName: \\"PlaylistIdNotFoundError\\";
    content: TraceMyApi.playlist.PlaylistIdNotFoundError;
  }

  interface UnauthorizedError extends _Utils {
    errorName: \\"UnauthorizedError\\";
  }

  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    playlistIdNotFoundError: (value: TraceMyApi.playlist.PlaylistIdNotFoundError) => Result;
    unauthorizedError: () => Result;
    _other: (value: core.Fetcher.Error) => Result;
  }
}

export const Error = {
  playlistIdNotFoundError: (value: TraceMyApi.playlist.PlaylistIdNotFoundError): Error.PlaylistIdNotFoundError => {
    const valueWithoutVisit: Omit<Error.PlaylistIdNotFoundError, \\"_visit\\"> = {
      content: value,
      errorName: \\"PlaylistIdNotFoundError\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as Error.PlaylistIdNotFoundError;
    castedValue._visit = (visitor) => visitor.playlistIdNotFoundError(value);
    return castedValue;
  },

  unauthorizedError: (): Error.UnauthorizedError => {
    const valueWithoutVisit: Omit<Error.UnauthorizedError, \\"_visit\\"> = {
      errorName: \\"UnauthorizedError\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as Error.UnauthorizedError;
    castedValue._visit = (visitor) => visitor.unauthorizedError();
    return castedValue;
  },
} as const;
",
                    "name": "getPlaylist.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  limit?: number;
  otherField: string;
  serviceParam: number;
}

export type Response = core.APIResponse<TraceMyApi.playlist.Playlist[], TraceMyApi.playlist.getPlaylists.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "getPlaylists.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as createPlaylist from \\"./createPlaylist\\";
export * as getPlaylists from \\"./getPlaylists\\";
export * as getPlaylist from \\"./getPlaylist\\";
export * as updatePlaylist from \\"./updatePlaylist\\";
export * as deletePlaylist from \\"./deletePlaylist\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  serviceParam: number;
  playlistId: TraceMyApi.playlist.PlaylistId;
  _body?: TraceMyApi.playlist.UpdatePlaylistRequest;
}

export type Response = core.APIResponse<
  TraceMyApi.playlist.Playlist | undefined,
  TraceMyApi.playlist.updatePlaylist.Error
>;
export type Error = Error.PlaylistIdNotFoundError | Error._Unknown;

export declare namespace Error {
  interface PlaylistIdNotFoundError extends _Utils {
    errorName: \\"PlaylistIdNotFoundError\\";
    content: TraceMyApi.playlist.PlaylistIdNotFoundError;
  }

  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    playlistIdNotFoundError: (value: TraceMyApi.playlist.PlaylistIdNotFoundError) => Result;
    _other: (value: core.Fetcher.Error) => Result;
  }
}

export const Error = {
  playlistIdNotFoundError: (value: TraceMyApi.playlist.PlaylistIdNotFoundError): Error.PlaylistIdNotFoundError => {
    const valueWithoutVisit: Omit<Error.PlaylistIdNotFoundError, \\"_visit\\"> = {
      content: value,
      errorName: \\"PlaylistIdNotFoundError\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as Error.PlaylistIdNotFoundError;
    castedValue._visit = (visitor) => visitor.playlistIdNotFoundError(value);
    return castedValue;
  },
} as const;
",
                    "name": "updatePlaylist.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export type PlaylistIdNotFoundError = TraceMyApi.playlist.PlaylistIdNotFoundErrorBody;
",
                    "name": "PlaylistIdNotFoundError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./PlaylistIdNotFoundError\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "errors",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./errors\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface Playlist extends TraceMyApi.playlist.PlaylistCreateRequest {
  playlistId: TraceMyApi.playlist.PlaylistId;
  ownerId: TraceMyApi.commons.UserId;
}
",
                    "name": "Playlist.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface PlaylistCreateRequest {
  name: string;
  problems: TraceMyApi.commons.ProblemId[];
}
",
                    "name": "PlaylistCreateRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export type PlaylistId = string;
",
                    "name": "PlaylistId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export type PlaylistIdNotFoundErrorBody = PlaylistIdNotFoundErrorBody.PlaylistId | PlaylistIdNotFoundErrorBody._Unknown;

export declare namespace PlaylistIdNotFoundErrorBody {
  interface PlaylistId extends _Utils {
    type: \\"playlistId\\";
    value: TraceMyApi.playlist.PlaylistId;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: PlaylistIdNotFoundErrorBody._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    playlistId: (value: TraceMyApi.playlist.PlaylistId) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const PlaylistIdNotFoundErrorBody = {
  playlistId: (value: TraceMyApi.playlist.PlaylistId): PlaylistIdNotFoundErrorBody.PlaylistId => {
    const valueWithoutVisit: Omit<PlaylistIdNotFoundErrorBody.PlaylistId, \\"_visit\\"> = {
      value: value,
      type: \\"playlistId\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as PlaylistIdNotFoundErrorBody.PlaylistId;
    castedValue._visit = (visitor) => visitor.playlistId(value);
    return castedValue;
  },
} as const;
",
                    "name": "PlaylistIdNotFoundErrorBody.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface ReservedKeywordEnum<RawValue extends ReservedKeywordEnum.RawValue = ReservedKeywordEnum.RawValue> {
  value: RawValue;
  visit: <Result>(visitor: ReservedKeywordEnum._Visitor<Result>) => Result;
}

const _Is: ReservedKeywordEnum<\\"is\\"> = {
  value: \\"is\\",
  visit: (visitor) => visitor.is(),
};
const _As: ReservedKeywordEnum<\\"as\\"> = {
  value: \\"as\\",
  visit: (visitor) => visitor.as(),
};
export const ReservedKeywordEnum = {
  Is: _Is,
  As: _As,
  _parse: (value: string): ReservedKeywordEnum => {
    switch (value) {
      case \\"is\\": {
        return _Is;
      }
      case \\"as\\": {
        return _As;
      }
      default: {
        return {
          value: value as ReservedKeywordEnum.RawValue,
          visit: (visitor) => visitor._other(value),
        };
      }
    }
  },
} as const;

export declare namespace ReservedKeywordEnum {
  type RawValue = \\"is\\" | \\"as\\";

  interface _Visitor<Result> {
    is: () => Result;
    as: () => Result;
    _other: (value: string) => Result;
  }
}
",
                    "name": "ReservedKeywordEnum.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface UpdatePlaylistRequest {
  name: string;
  problems: TraceMyApi.commons.ProblemId[];
}
",
                    "name": "UpdatePlaylistRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./PlaylistId\\";
export * from \\"./Playlist\\";
export * from \\"./PlaylistCreateRequest\\";
export * from \\"./UpdatePlaylistRequest\\";
export * from \\"./PlaylistIdNotFoundErrorBody\\";
export * from \\"./ReservedKeywordEnum\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "playlist",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { TraceMyApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    auth?: {
      token?: core.Supplier<core.BearerToken>;
    };
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async createProblem(
    request: TraceMyApi.problem.CreateProblemRequest
  ): Promise<TraceMyApi.problem.createProblem.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/problem-crud/create\\"),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
      body: serializers.problem.CreateProblemRequest.json(request),
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.problem.CreateProblemResponse.parse(
          response.body as serializers.problem.CreateProblemResponse.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async updateProblem(
    request: TraceMyApi.problem.updateProblem.Request
  ): Promise<TraceMyApi.problem.updateProblem.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/problem-crud/update/\${request.problemId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
      body: serializers.problem.CreateProblemRequest.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.problem.UpdateProblemResponse.parse(
          response.body as serializers.problem.UpdateProblemResponse.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async deleteProblem(
    request: TraceMyApi.problem.deleteProblem.Request
  ): Promise<TraceMyApi.problem.deleteProblem.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/problem-crud/delete/\${request.problemId}\`
      ),
      method: \\"DELETE\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getDefaultStarterFiles(
    request: TraceMyApi.problem.GetDefaultStarterFilesRequest
  ): Promise<TraceMyApi.problem.getDefaultStarterFiles.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/problem-crud/default-starter-files\\"),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
      body: serializers.problem.GetDefaultStarterFilesRequest.json(request),
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.problem.GetDefaultStarterFilesResponse.parse(
          response.body as serializers.problem.GetDefaultStarterFilesResponse.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  TraceMyApi.problem.CreateProblemResponse,
  TraceMyApi.problem.createProblem.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "createProblem.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  problemId: TraceMyApi.commons.ProblemId;
}

export type Response = core.APIResponse<void, TraceMyApi.problem.deleteProblem.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "deleteProblem.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  TraceMyApi.problem.GetDefaultStarterFilesResponse,
  TraceMyApi.problem.getDefaultStarterFiles.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "getDefaultStarterFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as createProblem from \\"./createProblem\\";
export * as updateProblem from \\"./updateProblem\\";
export * as deleteProblem from \\"./deleteProblem\\";
export * as getDefaultStarterFiles from \\"./getDefaultStarterFiles\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  problemId: TraceMyApi.commons.ProblemId;
  _body: TraceMyApi.problem.CreateProblemRequest;
}

export type Response = core.APIResponse<
  TraceMyApi.problem.UpdateProblemResponse,
  TraceMyApi.problem.updateProblem.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "updateProblem.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export type CreateProblemError = CreateProblemError.Generic | CreateProblemError._Unknown;

export declare namespace CreateProblemError {
  interface Generic extends TraceMyApi.problem.GenericCreateProblemError, _Utils {
    errorType: \\"generic\\";
  }

  interface _Unknown extends _Utils {
    errorType: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: CreateProblemError._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    generic: (value: TraceMyApi.problem.GenericCreateProblemError) => Result;
    _other: (value: { errorType: string }) => Result;
  }
}

export const CreateProblemError = {
  generic: (value: TraceMyApi.problem.GenericCreateProblemError): CreateProblemError.Generic => {
    const valueWithoutVisit: Omit<CreateProblemError.Generic, \\"_visit\\"> = {
      ...value,
      errorType: \\"generic\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CreateProblemError.Generic;
    castedValue._visit = (visitor) => visitor.generic(value);
    return castedValue;
  },
} as const;
",
                    "name": "CreateProblemError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface CreateProblemRequest {
  problemName: string;
  problemDescription: TraceMyApi.problem.ProblemDescription;
  files: Record<TraceMyApi.commons.Language.RawValue, TraceMyApi.problem.ProblemFiles>;
  inputParams: TraceMyApi.problem.VariableTypeAndName[];
  outputType: TraceMyApi.commons.VariableType;
  testcases: TraceMyApi.commons.TestCaseWithExpectedResult[];
  methodName: string;
}
",
                    "name": "CreateProblemRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export type CreateProblemResponse =
  | CreateProblemResponse.Success
  | CreateProblemResponse.Error
  | CreateProblemResponse._Unknown;

export declare namespace CreateProblemResponse {
  interface Success extends _Utils {
    type: \\"success\\";
    value: TraceMyApi.commons.ProblemId;
  }

  interface Error extends _Utils {
    type: \\"error\\";
    value: TraceMyApi.problem.CreateProblemError;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: CreateProblemResponse._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    success: (value: TraceMyApi.commons.ProblemId) => Result;
    error: (value: TraceMyApi.problem.CreateProblemError) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const CreateProblemResponse = {
  success: (value: TraceMyApi.commons.ProblemId): CreateProblemResponse.Success => {
    const valueWithoutVisit: Omit<CreateProblemResponse.Success, \\"_visit\\"> = {
      value: value,
      type: \\"success\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CreateProblemResponse.Success;
    castedValue._visit = (visitor) => visitor.success(value);
    return castedValue;
  },

  error: (value: TraceMyApi.problem.CreateProblemError): CreateProblemResponse.Error => {
    const valueWithoutVisit: Omit<CreateProblemResponse.Error, \\"_visit\\"> = {
      value: value,
      type: \\"error\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CreateProblemResponse.Error;
    castedValue._visit = (visitor) => visitor.error(value);
    return castedValue;
  },
} as const;
",
                    "name": "CreateProblemResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface GenericCreateProblemError {
  message: string;
  type: string;
  stacktrace: string;
}
",
                    "name": "GenericCreateProblemError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface GetDefaultStarterFilesRequest {
  inputParams: TraceMyApi.problem.VariableTypeAndName[];
  outputType: TraceMyApi.commons.VariableType;
  methodName: string;
}
",
                    "name": "GetDefaultStarterFilesRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface GetDefaultStarterFilesResponse {
  files: Record<TraceMyApi.commons.Language.RawValue, TraceMyApi.problem.ProblemFiles>;
}
",
                    "name": "GetDefaultStarterFilesResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface ProblemDescription {
  boards: TraceMyApi.problem.ProblemDescriptionBoard[];
}
",
                    "name": "ProblemDescription.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export type ProblemDescriptionBoard =
  | ProblemDescriptionBoard.Html
  | ProblemDescriptionBoard.Variable
  | ProblemDescriptionBoard.TestCaseId
  | ProblemDescriptionBoard._Unknown;

export declare namespace ProblemDescriptionBoard {
  interface Html extends _Utils {
    type: \\"html\\";
    value: string;
  }

  interface Variable extends _Utils {
    type: \\"variable\\";
    value: TraceMyApi.commons.VariableValue;
  }

  interface TestCaseId extends _Utils {
    type: \\"testCaseId\\";
    value: string;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: ProblemDescriptionBoard._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    html: (value: string) => Result;
    variable: (value: TraceMyApi.commons.VariableValue) => Result;
    testCaseId: (value: string) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const ProblemDescriptionBoard = {
  html: (value: string): ProblemDescriptionBoard.Html => {
    const valueWithoutVisit: Omit<ProblemDescriptionBoard.Html, \\"_visit\\"> = {
      value: value,
      type: \\"html\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as ProblemDescriptionBoard.Html;
    castedValue._visit = (visitor) => visitor.html(value);
    return castedValue;
  },

  variable: (value: TraceMyApi.commons.VariableValue): ProblemDescriptionBoard.Variable => {
    const valueWithoutVisit: Omit<ProblemDescriptionBoard.Variable, \\"_visit\\"> = {
      value: value,
      type: \\"variable\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as ProblemDescriptionBoard.Variable;
    castedValue._visit = (visitor) => visitor.variable(value);
    return castedValue;
  },

  testCaseId: (value: string): ProblemDescriptionBoard.TestCaseId => {
    const valueWithoutVisit: Omit<ProblemDescriptionBoard.TestCaseId, \\"_visit\\"> = {
      value: value,
      type: \\"testCaseId\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as ProblemDescriptionBoard.TestCaseId;
    castedValue._visit = (visitor) => visitor.testCaseId(value);
    return castedValue;
  },
} as const;
",
                    "name": "ProblemDescriptionBoard.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface ProblemFiles {
  solutionFile: TraceMyApi.commons.FileInfo;
  readOnlyFiles: TraceMyApi.commons.FileInfo[];
}
",
                    "name": "ProblemFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface ProblemInfo {
  problemId: TraceMyApi.commons.ProblemId;
  problemDescription: TraceMyApi.problem.ProblemDescription;
  problemName: string;
  problemVersion: number;
  files: Record<TraceMyApi.commons.Language.RawValue, TraceMyApi.problem.ProblemFiles>;
  inputParams: TraceMyApi.problem.VariableTypeAndName[];
  outputType: TraceMyApi.commons.VariableType;
  testcases: TraceMyApi.commons.TestCaseWithExpectedResult[];
  methodName: string;
  supportsCustomTestCases: boolean;
}
",
                    "name": "ProblemInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface UpdateProblemResponse {
  problemVersion: number;
}
",
                    "name": "UpdateProblemResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface VariableTypeAndName {
  variableType: TraceMyApi.commons.VariableType;
  name: string;
}
",
                    "name": "VariableTypeAndName.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./ProblemInfo\\";
export * from \\"./ProblemDescription\\";
export * from \\"./ProblemDescriptionBoard\\";
export * from \\"./ProblemFiles\\";
export * from \\"./VariableTypeAndName\\";
export * from \\"./CreateProblemRequest\\";
export * from \\"./CreateProblemResponse\\";
export * from \\"./UpdateProblemResponse\\";
export * from \\"./CreateProblemError\\";
export * from \\"./GenericCreateProblemError\\";
export * from \\"./GetDefaultStarterFilesRequest\\";
export * from \\"./GetDefaultStarterFilesResponse\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "problem",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { TraceMyApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    auth?: {
      token?: core.Supplier<core.BearerToken>;
    };
  }
}

/**
 * Responsible for spinning up and spinning down execution.
 */
export class Client {
  constructor(private readonly options: Client.Options) {}

  public async createExecutionSession(
    request: TraceMyApi.submission.createExecutionSession.Request
  ): Promise<TraceMyApi.submission.createExecutionSession.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/sessions/create-session/\${request.language}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.submission.ExecutionSessionResponse.parse(
          response.body as serializers.submission.ExecutionSessionResponse.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getExecutionSession(
    request: TraceMyApi.submission.getExecutionSession.Request
  ): Promise<TraceMyApi.submission.getExecutionSession.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \`/sessions/\${request.sessionId}\`),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.submission.getExecutionSession.Response.parse(
          response.body as serializers.submission.ExecutionSessionResponse.Raw | null | undefined
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async stopExecutionSession(
    request: TraceMyApi.submission.stopExecutionSession.Request
  ): Promise<TraceMyApi.submission.stopExecutionSession.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \`/sessions/stop/\${request.sessionId}\`),
      method: \\"DELETE\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getExecutionSessionsState(): Promise<TraceMyApi.submission.getExecutionSessionsState.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/sessions/execution-sessions-state\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.submission.GetExecutionSessionStateResponse.parse(
          response.body as serializers.submission.GetExecutionSessionStateResponse.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  language: TraceMyApi.commons.Language;
}

export type Response = core.APIResponse<
  TraceMyApi.submission.ExecutionSessionResponse,
  TraceMyApi.submission.createExecutionSession.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "createExecutionSession.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  sessionId: string;
}

export type Response = core.APIResponse<
  TraceMyApi.submission.ExecutionSessionResponse | undefined,
  TraceMyApi.submission.getExecutionSession.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "getExecutionSession.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  TraceMyApi.submission.GetExecutionSessionStateResponse,
  TraceMyApi.submission.getExecutionSessionsState.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "getExecutionSessionsState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as createExecutionSession from \\"./createExecutionSession\\";
export * as getExecutionSession from \\"./getExecutionSession\\";
export * as stopExecutionSession from \\"./stopExecutionSession\\";
export * as getExecutionSessionsState from \\"./getExecutionSessionsState\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  sessionId: string;
}

export type Response = core.APIResponse<void, TraceMyApi.submission.stopExecutionSession.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "stopExecutionSession.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export type ActualResult =
  | ActualResult.Value
  | ActualResult.Exception
  | ActualResult.ExceptionV2
  | ActualResult._Unknown;

export declare namespace ActualResult {
  interface Value extends _Utils {
    type: \\"value\\";
    value: TraceMyApi.commons.VariableValue;
  }

  interface Exception extends TraceMyApi.submission.ExceptionInfo, _Utils {
    type: \\"exception\\";
  }

  interface ExceptionV2 extends _Utils {
    type: \\"exceptionV2\\";
    value: TraceMyApi.submission.ExceptionV2;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: ActualResult._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    value: (value: TraceMyApi.commons.VariableValue) => Result;
    exception: (value: TraceMyApi.submission.ExceptionInfo) => Result;
    exceptionV2: (value: TraceMyApi.submission.ExceptionV2) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const ActualResult = {
  value: (value: TraceMyApi.commons.VariableValue): ActualResult.Value => {
    const valueWithoutVisit: Omit<ActualResult.Value, \\"_visit\\"> = {
      value: value,
      type: \\"value\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as ActualResult.Value;
    castedValue._visit = (visitor) => visitor.value(value);
    return castedValue;
  },

  exception: (value: TraceMyApi.submission.ExceptionInfo): ActualResult.Exception => {
    const valueWithoutVisit: Omit<ActualResult.Exception, \\"_visit\\"> = {
      ...value,
      type: \\"exception\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as ActualResult.Exception;
    castedValue._visit = (visitor) => visitor.exception(value);
    return castedValue;
  },

  exceptionV2: (value: TraceMyApi.submission.ExceptionV2): ActualResult.ExceptionV2 => {
    const valueWithoutVisit: Omit<ActualResult.ExceptionV2, \\"_visit\\"> = {
      value: value,
      type: \\"exceptionV2\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as ActualResult.ExceptionV2;
    castedValue._visit = (visitor) => visitor.exceptionV2(value);
    return castedValue;
  },
} as const;
",
                    "name": "ActualResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface BuildingExecutorResponse {
  submissionId: TraceMyApi.submission.SubmissionId;
  status: TraceMyApi.submission.ExecutionSessionStatus;
}
",
                    "name": "BuildingExecutorResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export type CodeExecutionUpdate =
  /**
   * Statuses if an executor for the session isn't ready (Before RunningResponse). */
  | CodeExecutionUpdate.BuildingExecutor
  /**
   * Sent once a test submission is executing. */
  | CodeExecutionUpdate.Running
  /**
   * Sent if a submission cannot be run (i.e. Compile Error). */
  | CodeExecutionUpdate.Errored
  /**
   * Sent if a submission is stopped. */
  | CodeExecutionUpdate.Stopped
  /**
   * Graded testcases without trace information. */
  | CodeExecutionUpdate.Graded
  /**
   * Graded submission for v2 problems. */
  | CodeExecutionUpdate.GradedV2
  /**
   * Workspace run without trace information. */
  | CodeExecutionUpdate.WorkspaceRan
  /**
   * Gives progress about what is being recorded. */
  | CodeExecutionUpdate.Recording
  /**
   * Graded testcases with trace information. */
  | CodeExecutionUpdate.Recorded
  /**
   * Sent if an invalid request is sent for a submission. */
  | CodeExecutionUpdate.InvalidRequest
  /**
   * Sent once a submission is graded and fully recorded. */
  | CodeExecutionUpdate.Finished
  | CodeExecutionUpdate._Unknown;

export declare namespace CodeExecutionUpdate {
  interface BuildingExecutor extends TraceMyApi.submission.BuildingExecutorResponse, _Utils {
    type: \\"buildingExecutor\\";
  }

  interface Running extends TraceMyApi.submission.RunningResponse, _Utils {
    type: \\"running\\";
  }

  interface Errored extends TraceMyApi.submission.ErroredResponse, _Utils {
    type: \\"errored\\";
  }

  interface Stopped extends TraceMyApi.submission.StoppedResponse, _Utils {
    type: \\"stopped\\";
  }

  interface Graded extends TraceMyApi.submission.GradedResponse, _Utils {
    type: \\"graded\\";
  }

  interface GradedV2 extends TraceMyApi.submission.GradedResponseV2, _Utils {
    type: \\"gradedV2\\";
  }

  interface WorkspaceRan extends TraceMyApi.submission.WorkspaceRanResponse, _Utils {
    type: \\"workspaceRan\\";
  }

  interface Recording extends TraceMyApi.submission.RecordingResponseNotification, _Utils {
    type: \\"recording\\";
  }

  interface Recorded extends TraceMyApi.submission.RecordedResponseNotification, _Utils {
    type: \\"recorded\\";
  }

  interface InvalidRequest extends TraceMyApi.submission.InvalidRequestResponse, _Utils {
    type: \\"invalidRequest\\";
  }

  interface Finished extends TraceMyApi.submission.FinishedResponse, _Utils {
    type: \\"finished\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: CodeExecutionUpdate._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    buildingExecutor: (value: TraceMyApi.submission.BuildingExecutorResponse) => Result;
    running: (value: TraceMyApi.submission.RunningResponse) => Result;
    errored: (value: TraceMyApi.submission.ErroredResponse) => Result;
    stopped: (value: TraceMyApi.submission.StoppedResponse) => Result;
    graded: (value: TraceMyApi.submission.GradedResponse) => Result;
    gradedV2: (value: TraceMyApi.submission.GradedResponseV2) => Result;
    workspaceRan: (value: TraceMyApi.submission.WorkspaceRanResponse) => Result;
    recording: (value: TraceMyApi.submission.RecordingResponseNotification) => Result;
    recorded: (value: TraceMyApi.submission.RecordedResponseNotification) => Result;
    invalidRequest: (value: TraceMyApi.submission.InvalidRequestResponse) => Result;
    finished: (value: TraceMyApi.submission.FinishedResponse) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const CodeExecutionUpdate = {
  buildingExecutor: (value: TraceMyApi.submission.BuildingExecutorResponse): CodeExecutionUpdate.BuildingExecutor => {
    const valueWithoutVisit: Omit<CodeExecutionUpdate.BuildingExecutor, \\"_visit\\"> = {
      ...value,
      type: \\"buildingExecutor\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CodeExecutionUpdate.BuildingExecutor;
    castedValue._visit = (visitor) => visitor.buildingExecutor(value);
    return castedValue;
  },

  running: (value: TraceMyApi.submission.RunningResponse): CodeExecutionUpdate.Running => {
    const valueWithoutVisit: Omit<CodeExecutionUpdate.Running, \\"_visit\\"> = {
      ...value,
      type: \\"running\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CodeExecutionUpdate.Running;
    castedValue._visit = (visitor) => visitor.running(value);
    return castedValue;
  },

  errored: (value: TraceMyApi.submission.ErroredResponse): CodeExecutionUpdate.Errored => {
    const valueWithoutVisit: Omit<CodeExecutionUpdate.Errored, \\"_visit\\"> = {
      ...value,
      type: \\"errored\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CodeExecutionUpdate.Errored;
    castedValue._visit = (visitor) => visitor.errored(value);
    return castedValue;
  },

  stopped: (value: TraceMyApi.submission.StoppedResponse): CodeExecutionUpdate.Stopped => {
    const valueWithoutVisit: Omit<CodeExecutionUpdate.Stopped, \\"_visit\\"> = {
      ...value,
      type: \\"stopped\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CodeExecutionUpdate.Stopped;
    castedValue._visit = (visitor) => visitor.stopped(value);
    return castedValue;
  },

  graded: (value: TraceMyApi.submission.GradedResponse): CodeExecutionUpdate.Graded => {
    const valueWithoutVisit: Omit<CodeExecutionUpdate.Graded, \\"_visit\\"> = {
      ...value,
      type: \\"graded\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CodeExecutionUpdate.Graded;
    castedValue._visit = (visitor) => visitor.graded(value);
    return castedValue;
  },

  gradedV2: (value: TraceMyApi.submission.GradedResponseV2): CodeExecutionUpdate.GradedV2 => {
    const valueWithoutVisit: Omit<CodeExecutionUpdate.GradedV2, \\"_visit\\"> = {
      ...value,
      type: \\"gradedV2\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CodeExecutionUpdate.GradedV2;
    castedValue._visit = (visitor) => visitor.gradedV2(value);
    return castedValue;
  },

  workspaceRan: (value: TraceMyApi.submission.WorkspaceRanResponse): CodeExecutionUpdate.WorkspaceRan => {
    const valueWithoutVisit: Omit<CodeExecutionUpdate.WorkspaceRan, \\"_visit\\"> = {
      ...value,
      type: \\"workspaceRan\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CodeExecutionUpdate.WorkspaceRan;
    castedValue._visit = (visitor) => visitor.workspaceRan(value);
    return castedValue;
  },

  recording: (value: TraceMyApi.submission.RecordingResponseNotification): CodeExecutionUpdate.Recording => {
    const valueWithoutVisit: Omit<CodeExecutionUpdate.Recording, \\"_visit\\"> = {
      ...value,
      type: \\"recording\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CodeExecutionUpdate.Recording;
    castedValue._visit = (visitor) => visitor.recording(value);
    return castedValue;
  },

  recorded: (value: TraceMyApi.submission.RecordedResponseNotification): CodeExecutionUpdate.Recorded => {
    const valueWithoutVisit: Omit<CodeExecutionUpdate.Recorded, \\"_visit\\"> = {
      ...value,
      type: \\"recorded\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CodeExecutionUpdate.Recorded;
    castedValue._visit = (visitor) => visitor.recorded(value);
    return castedValue;
  },

  invalidRequest: (value: TraceMyApi.submission.InvalidRequestResponse): CodeExecutionUpdate.InvalidRequest => {
    const valueWithoutVisit: Omit<CodeExecutionUpdate.InvalidRequest, \\"_visit\\"> = {
      ...value,
      type: \\"invalidRequest\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CodeExecutionUpdate.InvalidRequest;
    castedValue._visit = (visitor) => visitor.invalidRequest(value);
    return castedValue;
  },

  finished: (value: TraceMyApi.submission.FinishedResponse): CodeExecutionUpdate.Finished => {
    const valueWithoutVisit: Omit<CodeExecutionUpdate.Finished, \\"_visit\\"> = {
      ...value,
      type: \\"finished\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CodeExecutionUpdate.Finished;
    castedValue._visit = (visitor) => visitor.finished(value);
    return castedValue;
  },
} as const;
",
                    "name": "CodeExecutionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface CompileError {
  message: string;
}
",
                    "name": "CompileError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface CustomTestCasesUnsupported {
  problemId: TraceMyApi.commons.ProblemId;
  submissionId: TraceMyApi.submission.SubmissionId;
}
",
                    "name": "CustomTestCasesUnsupported.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export type ErrorInfo =
  | ErrorInfo.CompileError
  /**
   * If the submission cannot be executed and throws a runtime error before getting to any of the testcases.
   *  */
  | ErrorInfo.RuntimeError
  /**
   * If the trace backend encounters an unexpected error.
   *  */
  | ErrorInfo.InternalError
  | ErrorInfo._Unknown;

export declare namespace ErrorInfo {
  interface CompileError extends TraceMyApi.submission.CompileError, _Utils {
    type: \\"compileError\\";
  }

  interface RuntimeError extends TraceMyApi.submission.RuntimeError, _Utils {
    type: \\"runtimeError\\";
  }

  interface InternalError extends TraceMyApi.submission.InternalError, _Utils {
    type: \\"internalError\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: ErrorInfo._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    compileError: (value: TraceMyApi.submission.CompileError) => Result;
    runtimeError: (value: TraceMyApi.submission.RuntimeError) => Result;
    internalError: (value: TraceMyApi.submission.InternalError) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const ErrorInfo = {
  compileError: (value: TraceMyApi.submission.CompileError): ErrorInfo.CompileError => {
    const valueWithoutVisit: Omit<ErrorInfo.CompileError, \\"_visit\\"> = {
      ...value,
      type: \\"compileError\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as ErrorInfo.CompileError;
    castedValue._visit = (visitor) => visitor.compileError(value);
    return castedValue;
  },

  runtimeError: (value: TraceMyApi.submission.RuntimeError): ErrorInfo.RuntimeError => {
    const valueWithoutVisit: Omit<ErrorInfo.RuntimeError, \\"_visit\\"> = {
      ...value,
      type: \\"runtimeError\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as ErrorInfo.RuntimeError;
    castedValue._visit = (visitor) => visitor.runtimeError(value);
    return castedValue;
  },

  internalError: (value: TraceMyApi.submission.InternalError): ErrorInfo.InternalError => {
    const valueWithoutVisit: Omit<ErrorInfo.InternalError, \\"_visit\\"> = {
      ...value,
      type: \\"internalError\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as ErrorInfo.InternalError;
    castedValue._visit = (visitor) => visitor.internalError(value);
    return castedValue;
  },
} as const;
",
                    "name": "ErrorInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface ErroredResponse {
  submissionId: TraceMyApi.submission.SubmissionId;
  errorInfo: TraceMyApi.submission.ErrorInfo;
}
",
                    "name": "ErroredResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface ExceptionInfo {
  exceptionType: string;
  exceptionMessage: string;
  exceptionStacktrace: string;
}
",
                    "name": "ExceptionInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export type ExceptionV2 = ExceptionV2.Generic | ExceptionV2.Timeout | ExceptionV2._Unknown;

export declare namespace ExceptionV2 {
  interface Generic extends TraceMyApi.submission.ExceptionInfo, _Utils {
    type: \\"generic\\";
  }

  interface Timeout extends _Utils {
    type: \\"timeout\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: ExceptionV2._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    generic: (value: TraceMyApi.submission.ExceptionInfo) => Result;
    timeout: () => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const ExceptionV2 = {
  generic: (value: TraceMyApi.submission.ExceptionInfo): ExceptionV2.Generic => {
    const valueWithoutVisit: Omit<ExceptionV2.Generic, \\"_visit\\"> = {
      ...value,
      type: \\"generic\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as ExceptionV2.Generic;
    castedValue._visit = (visitor) => visitor.generic(value);
    return castedValue;
  },

  timeout: (): ExceptionV2.Timeout => {
    const valueWithoutVisit: Omit<ExceptionV2.Timeout, \\"_visit\\"> = {
      type: \\"timeout\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as ExceptionV2.Timeout;
    castedValue._visit = (visitor) => visitor.timeout();
    return castedValue;
  },
} as const;
",
                    "name": "ExceptionV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface ExecutionSessionResponse {
  sessionId: string;
  executionSessionUrl?: string;
  language: TraceMyApi.commons.Language;
  status: TraceMyApi.submission.ExecutionSessionStatus;
}
",
                    "name": "ExecutionSessionResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface ExecutionSessionState {
  lastTimeContacted?: string;
  sessionId: string;
  isWarmInstance: boolean;
  awsTaskId?: string;
  language: TraceMyApi.commons.Language;
  status: TraceMyApi.submission.ExecutionSessionStatus;
}
",
                    "name": "ExecutionSessionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface ExecutionSessionStatus<
  RawValue extends ExecutionSessionStatus.RawValue = ExecutionSessionStatus.RawValue
> {
  value: RawValue;
  visit: <Result>(visitor: ExecutionSessionStatus._Visitor<Result>) => Result;
}

const _CreatingContainer: ExecutionSessionStatus<\\"CREATING_CONTAINER\\"> = {
  value: \\"CREATING_CONTAINER\\",
  visit: (visitor) => visitor.creatingContainer(),
};
const _ProvisioningContainer: ExecutionSessionStatus<\\"PROVISIONING_CONTAINER\\"> = {
  value: \\"PROVISIONING_CONTAINER\\",
  visit: (visitor) => visitor.provisioningContainer(),
};
const _PendingContainer: ExecutionSessionStatus<\\"PENDING_CONTAINER\\"> = {
  value: \\"PENDING_CONTAINER\\",
  visit: (visitor) => visitor.pendingContainer(),
};
const _RunningContainer: ExecutionSessionStatus<\\"RUNNING_CONTAINER\\"> = {
  value: \\"RUNNING_CONTAINER\\",
  visit: (visitor) => visitor.runningContainer(),
};
const _LiveContainer: ExecutionSessionStatus<\\"LIVE_CONTAINER\\"> = {
  value: \\"LIVE_CONTAINER\\",
  visit: (visitor) => visitor.liveContainer(),
};
const _FailedToLaunch: ExecutionSessionStatus<\\"FAILED_TO_LAUNCH\\"> = {
  value: \\"FAILED_TO_LAUNCH\\",
  visit: (visitor) => visitor.failedToLaunch(),
};
export const ExecutionSessionStatus = {
  CreatingContainer: _CreatingContainer,
  ProvisioningContainer: _ProvisioningContainer,
  PendingContainer: _PendingContainer,
  RunningContainer: _RunningContainer,
  LiveContainer: _LiveContainer,
  FailedToLaunch: _FailedToLaunch,
  _parse: (value: string): ExecutionSessionStatus => {
    switch (value) {
      case \\"CREATING_CONTAINER\\": {
        return _CreatingContainer;
      }
      case \\"PROVISIONING_CONTAINER\\": {
        return _ProvisioningContainer;
      }
      case \\"PENDING_CONTAINER\\": {
        return _PendingContainer;
      }
      case \\"RUNNING_CONTAINER\\": {
        return _RunningContainer;
      }
      case \\"LIVE_CONTAINER\\": {
        return _LiveContainer;
      }
      case \\"FAILED_TO_LAUNCH\\": {
        return _FailedToLaunch;
      }
      default: {
        return {
          value: value as ExecutionSessionStatus.RawValue,
          visit: (visitor) => visitor._other(value),
        };
      }
    }
  },
} as const;

export declare namespace ExecutionSessionStatus {
  type RawValue =
    | \\"CREATING_CONTAINER\\"
    | \\"PROVISIONING_CONTAINER\\"
    | \\"PENDING_CONTAINER\\"
    | \\"RUNNING_CONTAINER\\"
    | \\"LIVE_CONTAINER\\"
    | \\"FAILED_TO_LAUNCH\\";

  interface _Visitor<Result> {
    creatingContainer: () => Result;
    provisioningContainer: () => Result;
    pendingContainer: () => Result;
    runningContainer: () => Result;
    liveContainer: () => Result;
    failedToLaunch: () => Result;
    _other: (value: string) => Result;
  }
}
",
                    "name": "ExecutionSessionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface ExistingSubmissionExecuting {
  submissionId: TraceMyApi.submission.SubmissionId;
}
",
                    "name": "ExistingSubmissionExecuting.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface ExpressionLocation {
  start: number;
  offset: number;
}
",
                    "name": "ExpressionLocation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface FinishedResponse {
  submissionId: TraceMyApi.submission.SubmissionId;
}
",
                    "name": "FinishedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface GetExecutionSessionStateResponse {
  states: Record<string, TraceMyApi.submission.ExecutionSessionState>;
  numWarmingInstances?: number;
  warmingSessionIds: string[];
}
",
                    "name": "GetExecutionSessionStateResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface GetSubmissionStateResponse {
  timeSubmitted?: Date;
  submission: string;
  language: TraceMyApi.commons.Language;
  submissionTypeState: TraceMyApi.submission.SubmissionTypeState;
}
",
                    "name": "GetSubmissionStateResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface GetTraceResponsesPageRequest {
  offset?: number;
}
",
                    "name": "GetTraceResponsesPageRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface GradedResponse {
  submissionId: TraceMyApi.submission.SubmissionId;
  testCases: Record<string, TraceMyApi.submission.TestCaseResultWithStdout>;
}
",
                    "name": "GradedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface GradedResponseV2 {
  submissionId: TraceMyApi.submission.SubmissionId;
  testCases: Record<string, TraceMyApi.submission.TestCaseGrade>;
}
",
                    "name": "GradedResponseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface GradedTestCaseUpdate {
  testCaseId: TraceMyApi.v2.problem.TestCaseId;
  grade: TraceMyApi.submission.TestCaseGrade;
}
",
                    "name": "GradedTestCaseUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface InitializeProblemRequest {
  problemId: TraceMyApi.commons.ProblemId;
  problemVersion?: number;
}
",
                    "name": "InitializeProblemRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface InternalError {
  exceptionInfo: TraceMyApi.submission.ExceptionInfo;
}
",
                    "name": "InternalError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export type InvalidRequestCause =
  /**
   * The submission request references a submission id that doesn't exist. */
  | InvalidRequestCause.SubmissionIdNotFound
  | InvalidRequestCause.CustomTestCasesUnsupported
  /**
   * The submission request was routed to an incorrect language executor. */
  | InvalidRequestCause.UnexpectedLanguage
  | InvalidRequestCause._Unknown;

export declare namespace InvalidRequestCause {
  interface SubmissionIdNotFound extends TraceMyApi.submission.SubmissionIdNotFound, _Utils {
    type: \\"submissionIdNotFound\\";
  }

  interface CustomTestCasesUnsupported extends TraceMyApi.submission.CustomTestCasesUnsupported, _Utils {
    type: \\"customTestCasesUnsupported\\";
  }

  interface UnexpectedLanguage extends TraceMyApi.submission.UnexpectedLanguageError, _Utils {
    type: \\"unexpectedLanguage\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: InvalidRequestCause._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    submissionIdNotFound: (value: TraceMyApi.submission.SubmissionIdNotFound) => Result;
    customTestCasesUnsupported: (value: TraceMyApi.submission.CustomTestCasesUnsupported) => Result;
    unexpectedLanguage: (value: TraceMyApi.submission.UnexpectedLanguageError) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const InvalidRequestCause = {
  submissionIdNotFound: (
    value: TraceMyApi.submission.SubmissionIdNotFound
  ): InvalidRequestCause.SubmissionIdNotFound => {
    const valueWithoutVisit: Omit<InvalidRequestCause.SubmissionIdNotFound, \\"_visit\\"> = {
      ...value,
      type: \\"submissionIdNotFound\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as InvalidRequestCause.SubmissionIdNotFound;
    castedValue._visit = (visitor) => visitor.submissionIdNotFound(value);
    return castedValue;
  },

  customTestCasesUnsupported: (
    value: TraceMyApi.submission.CustomTestCasesUnsupported
  ): InvalidRequestCause.CustomTestCasesUnsupported => {
    const valueWithoutVisit: Omit<InvalidRequestCause.CustomTestCasesUnsupported, \\"_visit\\"> = {
      ...value,
      type: \\"customTestCasesUnsupported\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as InvalidRequestCause.CustomTestCasesUnsupported;
    castedValue._visit = (visitor) => visitor.customTestCasesUnsupported(value);
    return castedValue;
  },

  unexpectedLanguage: (
    value: TraceMyApi.submission.UnexpectedLanguageError
  ): InvalidRequestCause.UnexpectedLanguage => {
    const valueWithoutVisit: Omit<InvalidRequestCause.UnexpectedLanguage, \\"_visit\\"> = {
      ...value,
      type: \\"unexpectedLanguage\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as InvalidRequestCause.UnexpectedLanguage;
    castedValue._visit = (visitor) => visitor.unexpectedLanguage(value);
    return castedValue;
  },
} as const;
",
                    "name": "InvalidRequestCause.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface InvalidRequestResponse {
  request: TraceMyApi.submission.SubmissionRequest;
  cause: TraceMyApi.submission.InvalidRequestCause;
}
",
                    "name": "InvalidRequestResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface LightweightStackframeInformation {
  numStackFrames: number;
  topStackFrameMethodName: string;
}
",
                    "name": "LightweightStackframeInformation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface RecordedResponseNotification {
  submissionId: TraceMyApi.submission.SubmissionId;
  traceResponsesSize: number;
  testCaseId?: string;
}
",
                    "name": "RecordedResponseNotification.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface RecordedTestCaseUpdate {
  testCaseId: TraceMyApi.v2.problem.TestCaseId;
  traceResponsesSize: number;
}
",
                    "name": "RecordedTestCaseUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface RecordingResponseNotification {
  submissionId: TraceMyApi.submission.SubmissionId;
  testCaseId?: string;
  lineNumber: number;
  lightweightStackInfo: TraceMyApi.submission.LightweightStackframeInformation;
  tracedFile?: TraceMyApi.submission.TracedFile;
}
",
                    "name": "RecordingResponseNotification.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface RunningResponse {
  submissionId: TraceMyApi.submission.SubmissionId;
  state: TraceMyApi.submission.RunningSubmissionState;
}
",
                    "name": "RunningResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface RunningSubmissionState<
  RawValue extends RunningSubmissionState.RawValue = RunningSubmissionState.RawValue
> {
  value: RawValue;
  visit: <Result>(visitor: RunningSubmissionState._Visitor<Result>) => Result;
}

const _QueueingSubmission: RunningSubmissionState<\\"QUEUEING_SUBMISSION\\"> = {
  value: \\"QUEUEING_SUBMISSION\\",
  visit: (visitor) => visitor.queueingSubmission(),
};
const _KillingHistoricalSubmissions: RunningSubmissionState<\\"KILLING_HISTORICAL_SUBMISSIONS\\"> = {
  value: \\"KILLING_HISTORICAL_SUBMISSIONS\\",
  visit: (visitor) => visitor.killingHistoricalSubmissions(),
};
const _WritingSubmissionToFile: RunningSubmissionState<\\"WRITING_SUBMISSION_TO_FILE\\"> = {
  value: \\"WRITING_SUBMISSION_TO_FILE\\",
  visit: (visitor) => visitor.writingSubmissionToFile(),
};
const _CompilingSubmission: RunningSubmissionState<\\"COMPILING_SUBMISSION\\"> = {
  value: \\"COMPILING_SUBMISSION\\",
  visit: (visitor) => visitor.compilingSubmission(),
};
const _RunningSubmission: RunningSubmissionState<\\"RUNNING_SUBMISSION\\"> = {
  value: \\"RUNNING_SUBMISSION\\",
  visit: (visitor) => visitor.runningSubmission(),
};
export const RunningSubmissionState = {
  QueueingSubmission: _QueueingSubmission,
  KillingHistoricalSubmissions: _KillingHistoricalSubmissions,
  WritingSubmissionToFile: _WritingSubmissionToFile,
  CompilingSubmission: _CompilingSubmission,
  RunningSubmission: _RunningSubmission,
  _parse: (value: string): RunningSubmissionState => {
    switch (value) {
      case \\"QUEUEING_SUBMISSION\\": {
        return _QueueingSubmission;
      }
      case \\"KILLING_HISTORICAL_SUBMISSIONS\\": {
        return _KillingHistoricalSubmissions;
      }
      case \\"WRITING_SUBMISSION_TO_FILE\\": {
        return _WritingSubmissionToFile;
      }
      case \\"COMPILING_SUBMISSION\\": {
        return _CompilingSubmission;
      }
      case \\"RUNNING_SUBMISSION\\": {
        return _RunningSubmission;
      }
      default: {
        return {
          value: value as RunningSubmissionState.RawValue,
          visit: (visitor) => visitor._other(value),
        };
      }
    }
  },
} as const;

export declare namespace RunningSubmissionState {
  type RawValue =
    | \\"QUEUEING_SUBMISSION\\"
    | \\"KILLING_HISTORICAL_SUBMISSIONS\\"
    | \\"WRITING_SUBMISSION_TO_FILE\\"
    | \\"COMPILING_SUBMISSION\\"
    | \\"RUNNING_SUBMISSION\\";

  interface _Visitor<Result> {
    queueingSubmission: () => Result;
    killingHistoricalSubmissions: () => Result;
    writingSubmissionToFile: () => Result;
    compilingSubmission: () => Result;
    runningSubmission: () => Result;
    _other: (value: string) => Result;
  }
}
",
                    "name": "RunningSubmissionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface RuntimeError {
  message: string;
}
",
                    "name": "RuntimeError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface Scope {
  variables: Record<string, TraceMyApi.commons.DebugVariableValue>;
}
",
                    "name": "Scope.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export type ShareId = string;
",
                    "name": "ShareId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface StackFrame {
  methodName: string;
  lineNumber: number;
  scopes: TraceMyApi.submission.Scope[];
}
",
                    "name": "StackFrame.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface StackInformation {
  numStackFrames: number;
  topStackFrame?: TraceMyApi.submission.StackFrame;
}
",
                    "name": "StackInformation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface StderrResponse {
  submissionId: TraceMyApi.submission.SubmissionId;
  stderr: string;
}
",
                    "name": "StderrResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface StdoutResponse {
  submissionId: TraceMyApi.submission.SubmissionId;
  stdout: string;
}
",
                    "name": "StdoutResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface StopRequest {
  submissionId: TraceMyApi.submission.SubmissionId;
}
",
                    "name": "StopRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface StoppedResponse {
  submissionId: TraceMyApi.submission.SubmissionId;
}
",
                    "name": "StoppedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface SubmissionFileInfo {
  directory: string;
  filename: string;
  contents: string;
}
",
                    "name": "SubmissionFileInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export type SubmissionId = string;
",
                    "name": "SubmissionId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface SubmissionIdNotFound {
  missingSubmissionId: TraceMyApi.submission.SubmissionId;
}
",
                    "name": "SubmissionIdNotFound.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export type SubmissionRequest =
  | SubmissionRequest.InitializeProblemRequest
  | SubmissionRequest.InitializeWorkspaceRequest
  | SubmissionRequest.SubmitV2
  | SubmissionRequest.WorkspaceSubmit
  | SubmissionRequest.Stop
  | SubmissionRequest._Unknown;

export declare namespace SubmissionRequest {
  interface InitializeProblemRequest extends TraceMyApi.submission.InitializeProblemRequest, _Utils {
    type: \\"initializeProblemRequest\\";
  }

  interface InitializeWorkspaceRequest extends _Utils {
    type: \\"initializeWorkspaceRequest\\";
  }

  interface SubmitV2 extends TraceMyApi.submission.SubmitRequestV2, _Utils {
    type: \\"submitV2\\";
  }

  interface WorkspaceSubmit extends TraceMyApi.submission.WorkspaceSubmitRequest, _Utils {
    type: \\"workspaceSubmit\\";
  }

  interface Stop extends TraceMyApi.submission.StopRequest, _Utils {
    type: \\"stop\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: SubmissionRequest._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    initializeProblemRequest: (value: TraceMyApi.submission.InitializeProblemRequest) => Result;
    initializeWorkspaceRequest: () => Result;
    submitV2: (value: TraceMyApi.submission.SubmitRequestV2) => Result;
    workspaceSubmit: (value: TraceMyApi.submission.WorkspaceSubmitRequest) => Result;
    stop: (value: TraceMyApi.submission.StopRequest) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const SubmissionRequest = {
  initializeProblemRequest: (
    value: TraceMyApi.submission.InitializeProblemRequest
  ): SubmissionRequest.InitializeProblemRequest => {
    const valueWithoutVisit: Omit<SubmissionRequest.InitializeProblemRequest, \\"_visit\\"> = {
      ...value,
      type: \\"initializeProblemRequest\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionRequest.InitializeProblemRequest;
    castedValue._visit = (visitor) => visitor.initializeProblemRequest(value);
    return castedValue;
  },

  initializeWorkspaceRequest: (): SubmissionRequest.InitializeWorkspaceRequest => {
    const valueWithoutVisit: Omit<SubmissionRequest.InitializeWorkspaceRequest, \\"_visit\\"> = {
      type: \\"initializeWorkspaceRequest\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionRequest.InitializeWorkspaceRequest;
    castedValue._visit = (visitor) => visitor.initializeWorkspaceRequest();
    return castedValue;
  },

  submitV2: (value: TraceMyApi.submission.SubmitRequestV2): SubmissionRequest.SubmitV2 => {
    const valueWithoutVisit: Omit<SubmissionRequest.SubmitV2, \\"_visit\\"> = {
      ...value,
      type: \\"submitV2\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionRequest.SubmitV2;
    castedValue._visit = (visitor) => visitor.submitV2(value);
    return castedValue;
  },

  workspaceSubmit: (value: TraceMyApi.submission.WorkspaceSubmitRequest): SubmissionRequest.WorkspaceSubmit => {
    const valueWithoutVisit: Omit<SubmissionRequest.WorkspaceSubmit, \\"_visit\\"> = {
      ...value,
      type: \\"workspaceSubmit\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionRequest.WorkspaceSubmit;
    castedValue._visit = (visitor) => visitor.workspaceSubmit(value);
    return castedValue;
  },

  stop: (value: TraceMyApi.submission.StopRequest): SubmissionRequest.Stop => {
    const valueWithoutVisit: Omit<SubmissionRequest.Stop, \\"_visit\\"> = {
      ...value,
      type: \\"stop\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionRequest.Stop;
    castedValue._visit = (visitor) => visitor.stop(value);
    return castedValue;
  },
} as const;
",
                    "name": "SubmissionRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export type SubmissionResponse =
  | SubmissionResponse.ServerInitialized
  | SubmissionResponse.ProblemInitialized
  | SubmissionResponse.WorkspaceInitialized
  | SubmissionResponse.ServerErrored
  | SubmissionResponse.CodeExecutionUpdate
  | SubmissionResponse.Terminated
  | SubmissionResponse._Unknown;

export declare namespace SubmissionResponse {
  interface ServerInitialized extends _Utils {
    type: \\"serverInitialized\\";
  }

  interface ProblemInitialized extends _Utils {
    type: \\"problemInitialized\\";
    value: TraceMyApi.commons.ProblemId;
  }

  interface WorkspaceInitialized extends _Utils {
    type: \\"workspaceInitialized\\";
  }

  interface ServerErrored extends TraceMyApi.submission.ExceptionInfo, _Utils {
    type: \\"serverErrored\\";
  }

  interface CodeExecutionUpdate extends _Utils {
    type: \\"codeExecutionUpdate\\";
    value: TraceMyApi.submission.CodeExecutionUpdate;
  }

  interface Terminated extends TraceMyApi.submission.TerminatedResponse, _Utils {
    type: \\"terminated\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: SubmissionResponse._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    serverInitialized: () => Result;
    problemInitialized: (value: TraceMyApi.commons.ProblemId) => Result;
    workspaceInitialized: () => Result;
    serverErrored: (value: TraceMyApi.submission.ExceptionInfo) => Result;
    codeExecutionUpdate: (value: TraceMyApi.submission.CodeExecutionUpdate) => Result;
    terminated: (value: TraceMyApi.submission.TerminatedResponse) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const SubmissionResponse = {
  serverInitialized: (): SubmissionResponse.ServerInitialized => {
    const valueWithoutVisit: Omit<SubmissionResponse.ServerInitialized, \\"_visit\\"> = {
      type: \\"serverInitialized\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionResponse.ServerInitialized;
    castedValue._visit = (visitor) => visitor.serverInitialized();
    return castedValue;
  },

  problemInitialized: (value: TraceMyApi.commons.ProblemId): SubmissionResponse.ProblemInitialized => {
    const valueWithoutVisit: Omit<SubmissionResponse.ProblemInitialized, \\"_visit\\"> = {
      value: value,
      type: \\"problemInitialized\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionResponse.ProblemInitialized;
    castedValue._visit = (visitor) => visitor.problemInitialized(value);
    return castedValue;
  },

  workspaceInitialized: (): SubmissionResponse.WorkspaceInitialized => {
    const valueWithoutVisit: Omit<SubmissionResponse.WorkspaceInitialized, \\"_visit\\"> = {
      type: \\"workspaceInitialized\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionResponse.WorkspaceInitialized;
    castedValue._visit = (visitor) => visitor.workspaceInitialized();
    return castedValue;
  },

  serverErrored: (value: TraceMyApi.submission.ExceptionInfo): SubmissionResponse.ServerErrored => {
    const valueWithoutVisit: Omit<SubmissionResponse.ServerErrored, \\"_visit\\"> = {
      ...value,
      type: \\"serverErrored\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionResponse.ServerErrored;
    castedValue._visit = (visitor) => visitor.serverErrored(value);
    return castedValue;
  },

  codeExecutionUpdate: (value: TraceMyApi.submission.CodeExecutionUpdate): SubmissionResponse.CodeExecutionUpdate => {
    const valueWithoutVisit: Omit<SubmissionResponse.CodeExecutionUpdate, \\"_visit\\"> = {
      value: value,
      type: \\"codeExecutionUpdate\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionResponse.CodeExecutionUpdate;
    castedValue._visit = (visitor) => visitor.codeExecutionUpdate(value);
    return castedValue;
  },

  terminated: (value: TraceMyApi.submission.TerminatedResponse): SubmissionResponse.Terminated => {
    const valueWithoutVisit: Omit<SubmissionResponse.Terminated, \\"_visit\\"> = {
      ...value,
      type: \\"terminated\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionResponse.Terminated;
    castedValue._visit = (visitor) => visitor.terminated(value);
    return castedValue;
  },
} as const;
",
                    "name": "SubmissionResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export type SubmissionStatusForTestCase =
  | SubmissionStatusForTestCase.Graded
  | SubmissionStatusForTestCase.GradedV2
  | SubmissionStatusForTestCase.Traced
  | SubmissionStatusForTestCase._Unknown;

export declare namespace SubmissionStatusForTestCase {
  interface Graded extends TraceMyApi.submission.TestCaseResultWithStdout, _Utils {
    type: \\"graded\\";
  }

  interface GradedV2 extends _Utils {
    type: \\"gradedV2\\";
    value: TraceMyApi.submission.TestCaseGrade;
  }

  interface Traced extends TraceMyApi.submission.TracedTestCase, _Utils {
    type: \\"traced\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: SubmissionStatusForTestCase._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    graded: (value: TraceMyApi.submission.TestCaseResultWithStdout) => Result;
    gradedV2: (value: TraceMyApi.submission.TestCaseGrade) => Result;
    traced: (value: TraceMyApi.submission.TracedTestCase) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const SubmissionStatusForTestCase = {
  graded: (value: TraceMyApi.submission.TestCaseResultWithStdout): SubmissionStatusForTestCase.Graded => {
    const valueWithoutVisit: Omit<SubmissionStatusForTestCase.Graded, \\"_visit\\"> = {
      ...value,
      type: \\"graded\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionStatusForTestCase.Graded;
    castedValue._visit = (visitor) => visitor.graded(value);
    return castedValue;
  },

  gradedV2: (value: TraceMyApi.submission.TestCaseGrade): SubmissionStatusForTestCase.GradedV2 => {
    const valueWithoutVisit: Omit<SubmissionStatusForTestCase.GradedV2, \\"_visit\\"> = {
      value: value,
      type: \\"gradedV2\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionStatusForTestCase.GradedV2;
    castedValue._visit = (visitor) => visitor.gradedV2(value);
    return castedValue;
  },

  traced: (value: TraceMyApi.submission.TracedTestCase): SubmissionStatusForTestCase.Traced => {
    const valueWithoutVisit: Omit<SubmissionStatusForTestCase.Traced, \\"_visit\\"> = {
      ...value,
      type: \\"traced\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionStatusForTestCase.Traced;
    castedValue._visit = (visitor) => visitor.traced(value);
    return castedValue;
  },
} as const;
",
                    "name": "SubmissionStatusForTestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export type SubmissionStatusV2 = SubmissionStatusV2.Test | SubmissionStatusV2.Workspace | SubmissionStatusV2._Unknown;

export declare namespace SubmissionStatusV2 {
  interface Test extends TraceMyApi.submission.TestSubmissionStatusV2, _Utils {
    type: \\"test\\";
  }

  interface Workspace extends TraceMyApi.submission.WorkspaceSubmissionStatusV2, _Utils {
    type: \\"workspace\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: SubmissionStatusV2._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    test: (value: TraceMyApi.submission.TestSubmissionStatusV2) => Result;
    workspace: (value: TraceMyApi.submission.WorkspaceSubmissionStatusV2) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const SubmissionStatusV2 = {
  test: (value: TraceMyApi.submission.TestSubmissionStatusV2): SubmissionStatusV2.Test => {
    const valueWithoutVisit: Omit<SubmissionStatusV2.Test, \\"_visit\\"> = {
      ...value,
      type: \\"test\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionStatusV2.Test;
    castedValue._visit = (visitor) => visitor.test(value);
    return castedValue;
  },

  workspace: (value: TraceMyApi.submission.WorkspaceSubmissionStatusV2): SubmissionStatusV2.Workspace => {
    const valueWithoutVisit: Omit<SubmissionStatusV2.Workspace, \\"_visit\\"> = {
      ...value,
      type: \\"workspace\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionStatusV2.Workspace;
    castedValue._visit = (visitor) => visitor.workspace(value);
    return castedValue;
  },
} as const;
",
                    "name": "SubmissionStatusV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

/**
 * Keep in sync with SubmissionType.
 */
export interface SubmissionTypeEnum<RawValue extends SubmissionTypeEnum.RawValue = SubmissionTypeEnum.RawValue> {
  value: RawValue;
  visit: <Result>(visitor: SubmissionTypeEnum._Visitor<Result>) => Result;
}

const _Test: SubmissionTypeEnum<\\"TEST\\"> = {
  value: \\"TEST\\",
  visit: (visitor) => visitor.test(),
};
export const SubmissionTypeEnum = {
  Test: _Test,
  _parse: (value: string): SubmissionTypeEnum => {
    switch (value) {
      case \\"TEST\\": {
        return _Test;
      }
      default: {
        return {
          value: value as SubmissionTypeEnum.RawValue,
          visit: (visitor) => visitor._other(value),
        };
      }
    }
  },
} as const;

export declare namespace SubmissionTypeEnum {
  type RawValue = \\"TEST\\";

  interface _Visitor<Result> {
    test: () => Result;
    _other: (value: string) => Result;
  }
}
",
                    "name": "SubmissionTypeEnum.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export type SubmissionTypeState =
  | SubmissionTypeState.Test
  | SubmissionTypeState.Workspace
  | SubmissionTypeState._Unknown;

export declare namespace SubmissionTypeState {
  interface Test extends TraceMyApi.submission.TestSubmissionState, _Utils {
    type: \\"test\\";
  }

  interface Workspace extends TraceMyApi.submission.WorkspaceSubmissionState, _Utils {
    type: \\"workspace\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: SubmissionTypeState._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    test: (value: TraceMyApi.submission.TestSubmissionState) => Result;
    workspace: (value: TraceMyApi.submission.WorkspaceSubmissionState) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const SubmissionTypeState = {
  test: (value: TraceMyApi.submission.TestSubmissionState): SubmissionTypeState.Test => {
    const valueWithoutVisit: Omit<SubmissionTypeState.Test, \\"_visit\\"> = {
      ...value,
      type: \\"test\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionTypeState.Test;
    castedValue._visit = (visitor) => visitor.test(value);
    return castedValue;
  },

  workspace: (value: TraceMyApi.submission.WorkspaceSubmissionState): SubmissionTypeState.Workspace => {
    const valueWithoutVisit: Omit<SubmissionTypeState.Workspace, \\"_visit\\"> = {
      ...value,
      type: \\"workspace\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as SubmissionTypeState.Workspace;
    castedValue._visit = (visitor) => visitor.workspace(value);
    return castedValue;
  },
} as const;
",
                    "name": "SubmissionTypeState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface SubmitRequestV2 {
  submissionId: TraceMyApi.submission.SubmissionId;
  language: TraceMyApi.commons.Language;
  submissionFiles: TraceMyApi.submission.SubmissionFileInfo[];
  problemId: TraceMyApi.commons.ProblemId;
  problemVersion?: number;
  userId?: string;
}
",
                    "name": "SubmitRequestV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface TerminatedResponse {}
",
                    "name": "TerminatedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export type TestCaseGrade = TestCaseGrade.Hidden | TestCaseGrade.NonHidden | TestCaseGrade._Unknown;

export declare namespace TestCaseGrade {
  interface Hidden extends TraceMyApi.submission.TestCaseHiddenGrade, _Utils {
    type: \\"hidden\\";
  }

  interface NonHidden extends TraceMyApi.submission.TestCaseNonHiddenGrade, _Utils {
    type: \\"nonHidden\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: TestCaseGrade._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    hidden: (value: TraceMyApi.submission.TestCaseHiddenGrade) => Result;
    nonHidden: (value: TraceMyApi.submission.TestCaseNonHiddenGrade) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const TestCaseGrade = {
  hidden: (value: TraceMyApi.submission.TestCaseHiddenGrade): TestCaseGrade.Hidden => {
    const valueWithoutVisit: Omit<TestCaseGrade.Hidden, \\"_visit\\"> = {
      ...value,
      type: \\"hidden\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestCaseGrade.Hidden;
    castedValue._visit = (visitor) => visitor.hidden(value);
    return castedValue;
  },

  nonHidden: (value: TraceMyApi.submission.TestCaseNonHiddenGrade): TestCaseGrade.NonHidden => {
    const valueWithoutVisit: Omit<TestCaseGrade.NonHidden, \\"_visit\\"> = {
      ...value,
      type: \\"nonHidden\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestCaseGrade.NonHidden;
    castedValue._visit = (visitor) => visitor.nonHidden(value);
    return castedValue;
  },
} as const;
",
                    "name": "TestCaseGrade.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface TestCaseHiddenGrade {
  passed: boolean;
}
",
                    "name": "TestCaseHiddenGrade.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface TestCaseNonHiddenGrade {
  passed: boolean;
  actualResult?: TraceMyApi.commons.VariableValue;
  exception?: TraceMyApi.submission.ExceptionV2;
  stdout: string;
}
",
                    "name": "TestCaseNonHiddenGrade.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface TestCaseResult {
  expectedResult: TraceMyApi.commons.VariableValue;
  actualResult: TraceMyApi.submission.ActualResult;
  passed: boolean;
}
",
                    "name": "TestCaseResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface TestCaseResultWithStdout {
  result: TraceMyApi.submission.TestCaseResult;
  stdout: string;
}
",
                    "name": "TestCaseResultWithStdout.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface TestSubmissionState {
  problemId: TraceMyApi.commons.ProblemId;
  defaultTestCases: TraceMyApi.commons.TestCase[];
  customTestCases: TraceMyApi.commons.TestCase[];
  status: TraceMyApi.submission.TestSubmissionStatus;
}
",
                    "name": "TestSubmissionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export type TestSubmissionStatus =
  | TestSubmissionStatus.Stopped
  | TestSubmissionStatus.Errored
  | TestSubmissionStatus.Running
  | TestSubmissionStatus.TestCaseIdToState
  | TestSubmissionStatus._Unknown;

export declare namespace TestSubmissionStatus {
  interface Stopped extends _Utils {
    type: \\"stopped\\";
  }

  interface Errored extends _Utils {
    type: \\"errored\\";
    value: TraceMyApi.submission.ErrorInfo;
  }

  interface Running extends _Utils {
    type: \\"running\\";
    value: TraceMyApi.submission.RunningSubmissionState;
  }

  interface TestCaseIdToState extends _Utils {
    type: \\"testCaseIdToState\\";
    value: Record<string, TraceMyApi.submission.SubmissionStatusForTestCase>;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: TestSubmissionStatus._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    stopped: () => Result;
    errored: (value: TraceMyApi.submission.ErrorInfo) => Result;
    running: (value: TraceMyApi.submission.RunningSubmissionState) => Result;
    testCaseIdToState: (value: Record<string, TraceMyApi.submission.SubmissionStatusForTestCase>) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const TestSubmissionStatus = {
  stopped: (): TestSubmissionStatus.Stopped => {
    const valueWithoutVisit: Omit<TestSubmissionStatus.Stopped, \\"_visit\\"> = {
      type: \\"stopped\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestSubmissionStatus.Stopped;
    castedValue._visit = (visitor) => visitor.stopped();
    return castedValue;
  },

  errored: (value: TraceMyApi.submission.ErrorInfo): TestSubmissionStatus.Errored => {
    const valueWithoutVisit: Omit<TestSubmissionStatus.Errored, \\"_visit\\"> = {
      value: value,
      type: \\"errored\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestSubmissionStatus.Errored;
    castedValue._visit = (visitor) => visitor.errored(value);
    return castedValue;
  },

  running: (value: TraceMyApi.submission.RunningSubmissionState): TestSubmissionStatus.Running => {
    const valueWithoutVisit: Omit<TestSubmissionStatus.Running, \\"_visit\\"> = {
      value: value,
      type: \\"running\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestSubmissionStatus.Running;
    castedValue._visit = (visitor) => visitor.running(value);
    return castedValue;
  },

  testCaseIdToState: (
    value: Record<string, TraceMyApi.submission.SubmissionStatusForTestCase>
  ): TestSubmissionStatus.TestCaseIdToState => {
    const valueWithoutVisit: Omit<TestSubmissionStatus.TestCaseIdToState, \\"_visit\\"> = {
      value: value,
      type: \\"testCaseIdToState\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestSubmissionStatus.TestCaseIdToState;
    castedValue._visit = (visitor) => visitor.testCaseIdToState(value);
    return castedValue;
  },
} as const;
",
                    "name": "TestSubmissionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface TestSubmissionStatusV2 {
  updates: TraceMyApi.submission.TestSubmissionUpdate[];
  problemId: TraceMyApi.commons.ProblemId;
  problemVersion: number;
  problemInfo: TraceMyApi.v2.problem.ProblemInfoV2;
}
",
                    "name": "TestSubmissionStatusV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface TestSubmissionUpdate {
  updateTime: Date;
  updateInfo: TraceMyApi.submission.TestSubmissionUpdateInfo;
}
",
                    "name": "TestSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export type TestSubmissionUpdateInfo =
  | TestSubmissionUpdateInfo.Running
  | TestSubmissionUpdateInfo.Stopped
  | TestSubmissionUpdateInfo.Errored
  | TestSubmissionUpdateInfo.GradedTestCase
  | TestSubmissionUpdateInfo.RecordedTestCase
  | TestSubmissionUpdateInfo.Finished
  | TestSubmissionUpdateInfo._Unknown;

export declare namespace TestSubmissionUpdateInfo {
  interface Running extends _Utils {
    type: \\"running\\";
    value: TraceMyApi.submission.RunningSubmissionState;
  }

  interface Stopped extends _Utils {
    type: \\"stopped\\";
  }

  interface Errored extends _Utils {
    type: \\"errored\\";
    value: TraceMyApi.submission.ErrorInfo;
  }

  interface GradedTestCase extends TraceMyApi.submission.GradedTestCaseUpdate, _Utils {
    type: \\"gradedTestCase\\";
  }

  interface RecordedTestCase extends TraceMyApi.submission.RecordedTestCaseUpdate, _Utils {
    type: \\"recordedTestCase\\";
  }

  interface Finished extends _Utils {
    type: \\"finished\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: TestSubmissionUpdateInfo._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    running: (value: TraceMyApi.submission.RunningSubmissionState) => Result;
    stopped: () => Result;
    errored: (value: TraceMyApi.submission.ErrorInfo) => Result;
    gradedTestCase: (value: TraceMyApi.submission.GradedTestCaseUpdate) => Result;
    recordedTestCase: (value: TraceMyApi.submission.RecordedTestCaseUpdate) => Result;
    finished: () => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const TestSubmissionUpdateInfo = {
  running: (value: TraceMyApi.submission.RunningSubmissionState): TestSubmissionUpdateInfo.Running => {
    const valueWithoutVisit: Omit<TestSubmissionUpdateInfo.Running, \\"_visit\\"> = {
      value: value,
      type: \\"running\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestSubmissionUpdateInfo.Running;
    castedValue._visit = (visitor) => visitor.running(value);
    return castedValue;
  },

  stopped: (): TestSubmissionUpdateInfo.Stopped => {
    const valueWithoutVisit: Omit<TestSubmissionUpdateInfo.Stopped, \\"_visit\\"> = {
      type: \\"stopped\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestSubmissionUpdateInfo.Stopped;
    castedValue._visit = (visitor) => visitor.stopped();
    return castedValue;
  },

  errored: (value: TraceMyApi.submission.ErrorInfo): TestSubmissionUpdateInfo.Errored => {
    const valueWithoutVisit: Omit<TestSubmissionUpdateInfo.Errored, \\"_visit\\"> = {
      value: value,
      type: \\"errored\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestSubmissionUpdateInfo.Errored;
    castedValue._visit = (visitor) => visitor.errored(value);
    return castedValue;
  },

  gradedTestCase: (value: TraceMyApi.submission.GradedTestCaseUpdate): TestSubmissionUpdateInfo.GradedTestCase => {
    const valueWithoutVisit: Omit<TestSubmissionUpdateInfo.GradedTestCase, \\"_visit\\"> = {
      ...value,
      type: \\"gradedTestCase\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestSubmissionUpdateInfo.GradedTestCase;
    castedValue._visit = (visitor) => visitor.gradedTestCase(value);
    return castedValue;
  },

  recordedTestCase: (
    value: TraceMyApi.submission.RecordedTestCaseUpdate
  ): TestSubmissionUpdateInfo.RecordedTestCase => {
    const valueWithoutVisit: Omit<TestSubmissionUpdateInfo.RecordedTestCase, \\"_visit\\"> = {
      ...value,
      type: \\"recordedTestCase\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestSubmissionUpdateInfo.RecordedTestCase;
    castedValue._visit = (visitor) => visitor.recordedTestCase(value);
    return castedValue;
  },

  finished: (): TestSubmissionUpdateInfo.Finished => {
    const valueWithoutVisit: Omit<TestSubmissionUpdateInfo.Finished, \\"_visit\\"> = {
      type: \\"finished\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestSubmissionUpdateInfo.Finished;
    castedValue._visit = (visitor) => visitor.finished();
    return castedValue;
  },
} as const;
",
                    "name": "TestSubmissionUpdateInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface TraceResponse {
  submissionId: TraceMyApi.submission.SubmissionId;
  lineNumber: number;
  returnValue?: TraceMyApi.commons.DebugVariableValue;
  expressionLocation?: TraceMyApi.submission.ExpressionLocation;
  stack: TraceMyApi.submission.StackInformation;
  stdout?: string;
}
",
                    "name": "TraceResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface TraceResponseV2 {
  submissionId: TraceMyApi.submission.SubmissionId;
  lineNumber: number;
  file: TraceMyApi.submission.TracedFile;
  returnValue?: TraceMyApi.commons.DebugVariableValue;
  expressionLocation?: TraceMyApi.submission.ExpressionLocation;
  stack: TraceMyApi.submission.StackInformation;
  stdout?: string;
}
",
                    "name": "TraceResponseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface TraceResponsesPage {
  /**
   * If present, use this to load subseqent pages.
   * The offset is the id of the next trace response to load.
   *
   */
  offset?: number;
  traceResponses: TraceMyApi.submission.TraceResponse[];
}
",
                    "name": "TraceResponsesPage.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface TraceResponsesPageV2 {
  /**
   * If present, use this to load subseqent pages.
   * The offset is the id of the next trace response to load.
   *
   */
  offset?: number;
  traceResponses: TraceMyApi.submission.TraceResponseV2[];
}
",
                    "name": "TraceResponsesPageV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface TracedFile {
  filename: string;
  directory: string;
}
",
                    "name": "TracedFile.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface TracedTestCase {
  result: TraceMyApi.submission.TestCaseResultWithStdout;
  traceResponsesSize: number;
}
",
                    "name": "TracedTestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface UnexpectedLanguageError {
  expectedLanguage: TraceMyApi.commons.Language;
  actualLanguage: TraceMyApi.commons.Language;
}
",
                    "name": "UnexpectedLanguageError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface WorkspaceFiles {
  mainFile: TraceMyApi.commons.FileInfo;
  readOnlyFiles: TraceMyApi.commons.FileInfo[];
}
",
                    "name": "WorkspaceFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface WorkspaceRanResponse {
  submissionId: TraceMyApi.submission.SubmissionId;
  runDetails: TraceMyApi.submission.WorkspaceRunDetails;
}
",
                    "name": "WorkspaceRanResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface WorkspaceRunDetails {
  exceptionV2?: TraceMyApi.submission.ExceptionV2;
  exception?: TraceMyApi.submission.ExceptionInfo;
  stdout: string;
}
",
                    "name": "WorkspaceRunDetails.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface WorkspaceStarterFilesResponse {
  files: Record<TraceMyApi.commons.Language.RawValue, TraceMyApi.submission.WorkspaceFiles>;
}
",
                    "name": "WorkspaceStarterFilesResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface WorkspaceStarterFilesResponseV2 {
  filesByLanguage: Record<TraceMyApi.commons.Language.RawValue, TraceMyApi.v2.problem.Files>;
}
",
                    "name": "WorkspaceStarterFilesResponseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface WorkspaceSubmissionState {
  status: TraceMyApi.submission.WorkspaceSubmissionStatus;
}
",
                    "name": "WorkspaceSubmissionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export type WorkspaceSubmissionStatus =
  | WorkspaceSubmissionStatus.Stopped
  | WorkspaceSubmissionStatus.Errored
  | WorkspaceSubmissionStatus.Running
  | WorkspaceSubmissionStatus.Ran
  | WorkspaceSubmissionStatus.Traced
  | WorkspaceSubmissionStatus._Unknown;

export declare namespace WorkspaceSubmissionStatus {
  interface Stopped extends _Utils {
    type: \\"stopped\\";
  }

  interface Errored extends _Utils {
    type: \\"errored\\";
    value: TraceMyApi.submission.ErrorInfo;
  }

  interface Running extends _Utils {
    type: \\"running\\";
    value: TraceMyApi.submission.RunningSubmissionState;
  }

  interface Ran extends TraceMyApi.submission.WorkspaceRunDetails, _Utils {
    type: \\"ran\\";
  }

  interface Traced extends TraceMyApi.submission.WorkspaceRunDetails, _Utils {
    type: \\"traced\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: WorkspaceSubmissionStatus._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    stopped: () => Result;
    errored: (value: TraceMyApi.submission.ErrorInfo) => Result;
    running: (value: TraceMyApi.submission.RunningSubmissionState) => Result;
    ran: (value: TraceMyApi.submission.WorkspaceRunDetails) => Result;
    traced: (value: TraceMyApi.submission.WorkspaceRunDetails) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const WorkspaceSubmissionStatus = {
  stopped: (): WorkspaceSubmissionStatus.Stopped => {
    const valueWithoutVisit: Omit<WorkspaceSubmissionStatus.Stopped, \\"_visit\\"> = {
      type: \\"stopped\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as WorkspaceSubmissionStatus.Stopped;
    castedValue._visit = (visitor) => visitor.stopped();
    return castedValue;
  },

  errored: (value: TraceMyApi.submission.ErrorInfo): WorkspaceSubmissionStatus.Errored => {
    const valueWithoutVisit: Omit<WorkspaceSubmissionStatus.Errored, \\"_visit\\"> = {
      value: value,
      type: \\"errored\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as WorkspaceSubmissionStatus.Errored;
    castedValue._visit = (visitor) => visitor.errored(value);
    return castedValue;
  },

  running: (value: TraceMyApi.submission.RunningSubmissionState): WorkspaceSubmissionStatus.Running => {
    const valueWithoutVisit: Omit<WorkspaceSubmissionStatus.Running, \\"_visit\\"> = {
      value: value,
      type: \\"running\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as WorkspaceSubmissionStatus.Running;
    castedValue._visit = (visitor) => visitor.running(value);
    return castedValue;
  },

  ran: (value: TraceMyApi.submission.WorkspaceRunDetails): WorkspaceSubmissionStatus.Ran => {
    const valueWithoutVisit: Omit<WorkspaceSubmissionStatus.Ran, \\"_visit\\"> = {
      ...value,
      type: \\"ran\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as WorkspaceSubmissionStatus.Ran;
    castedValue._visit = (visitor) => visitor.ran(value);
    return castedValue;
  },

  traced: (value: TraceMyApi.submission.WorkspaceRunDetails): WorkspaceSubmissionStatus.Traced => {
    const valueWithoutVisit: Omit<WorkspaceSubmissionStatus.Traced, \\"_visit\\"> = {
      ...value,
      type: \\"traced\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as WorkspaceSubmissionStatus.Traced;
    castedValue._visit = (visitor) => visitor.traced(value);
    return castedValue;
  },
} as const;
",
                    "name": "WorkspaceSubmissionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface WorkspaceSubmissionStatusV2 {
  updates: TraceMyApi.submission.WorkspaceSubmissionUpdate[];
}
",
                    "name": "WorkspaceSubmissionStatusV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface WorkspaceSubmissionUpdate {
  updateTime: Date;
  updateInfo: TraceMyApi.submission.WorkspaceSubmissionUpdateInfo;
}
",
                    "name": "WorkspaceSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export type WorkspaceSubmissionUpdateInfo =
  | WorkspaceSubmissionUpdateInfo.Running
  | WorkspaceSubmissionUpdateInfo.Ran
  | WorkspaceSubmissionUpdateInfo.Stopped
  | WorkspaceSubmissionUpdateInfo.Traced
  | WorkspaceSubmissionUpdateInfo.TracedV2
  | WorkspaceSubmissionUpdateInfo.Errored
  | WorkspaceSubmissionUpdateInfo.Finished
  | WorkspaceSubmissionUpdateInfo._Unknown;

export declare namespace WorkspaceSubmissionUpdateInfo {
  interface Running extends _Utils {
    type: \\"running\\";
    value: TraceMyApi.submission.RunningSubmissionState;
  }

  interface Ran extends TraceMyApi.submission.WorkspaceRunDetails, _Utils {
    type: \\"ran\\";
  }

  interface Stopped extends _Utils {
    type: \\"stopped\\";
  }

  interface Traced extends _Utils {
    type: \\"traced\\";
  }

  interface TracedV2 extends TraceMyApi.submission.WorkspaceTracedUpdate, _Utils {
    type: \\"tracedV2\\";
  }

  interface Errored extends _Utils {
    type: \\"errored\\";
    value: TraceMyApi.submission.ErrorInfo;
  }

  interface Finished extends _Utils {
    type: \\"finished\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: WorkspaceSubmissionUpdateInfo._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    running: (value: TraceMyApi.submission.RunningSubmissionState) => Result;
    ran: (value: TraceMyApi.submission.WorkspaceRunDetails) => Result;
    stopped: () => Result;
    traced: () => Result;
    tracedV2: (value: TraceMyApi.submission.WorkspaceTracedUpdate) => Result;
    errored: (value: TraceMyApi.submission.ErrorInfo) => Result;
    finished: () => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const WorkspaceSubmissionUpdateInfo = {
  running: (value: TraceMyApi.submission.RunningSubmissionState): WorkspaceSubmissionUpdateInfo.Running => {
    const valueWithoutVisit: Omit<WorkspaceSubmissionUpdateInfo.Running, \\"_visit\\"> = {
      value: value,
      type: \\"running\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as WorkspaceSubmissionUpdateInfo.Running;
    castedValue._visit = (visitor) => visitor.running(value);
    return castedValue;
  },

  ran: (value: TraceMyApi.submission.WorkspaceRunDetails): WorkspaceSubmissionUpdateInfo.Ran => {
    const valueWithoutVisit: Omit<WorkspaceSubmissionUpdateInfo.Ran, \\"_visit\\"> = {
      ...value,
      type: \\"ran\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as WorkspaceSubmissionUpdateInfo.Ran;
    castedValue._visit = (visitor) => visitor.ran(value);
    return castedValue;
  },

  stopped: (): WorkspaceSubmissionUpdateInfo.Stopped => {
    const valueWithoutVisit: Omit<WorkspaceSubmissionUpdateInfo.Stopped, \\"_visit\\"> = {
      type: \\"stopped\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as WorkspaceSubmissionUpdateInfo.Stopped;
    castedValue._visit = (visitor) => visitor.stopped();
    return castedValue;
  },

  traced: (): WorkspaceSubmissionUpdateInfo.Traced => {
    const valueWithoutVisit: Omit<WorkspaceSubmissionUpdateInfo.Traced, \\"_visit\\"> = {
      type: \\"traced\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as WorkspaceSubmissionUpdateInfo.Traced;
    castedValue._visit = (visitor) => visitor.traced();
    return castedValue;
  },

  tracedV2: (value: TraceMyApi.submission.WorkspaceTracedUpdate): WorkspaceSubmissionUpdateInfo.TracedV2 => {
    const valueWithoutVisit: Omit<WorkspaceSubmissionUpdateInfo.TracedV2, \\"_visit\\"> = {
      ...value,
      type: \\"tracedV2\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as WorkspaceSubmissionUpdateInfo.TracedV2;
    castedValue._visit = (visitor) => visitor.tracedV2(value);
    return castedValue;
  },

  errored: (value: TraceMyApi.submission.ErrorInfo): WorkspaceSubmissionUpdateInfo.Errored => {
    const valueWithoutVisit: Omit<WorkspaceSubmissionUpdateInfo.Errored, \\"_visit\\"> = {
      value: value,
      type: \\"errored\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as WorkspaceSubmissionUpdateInfo.Errored;
    castedValue._visit = (visitor) => visitor.errored(value);
    return castedValue;
  },

  finished: (): WorkspaceSubmissionUpdateInfo.Finished => {
    const valueWithoutVisit: Omit<WorkspaceSubmissionUpdateInfo.Finished, \\"_visit\\"> = {
      type: \\"finished\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as WorkspaceSubmissionUpdateInfo.Finished;
    castedValue._visit = (visitor) => visitor.finished();
    return castedValue;
  },
} as const;
",
                    "name": "WorkspaceSubmissionUpdateInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";

export interface WorkspaceSubmitRequest {
  submissionId: TraceMyApi.submission.SubmissionId;
  language: TraceMyApi.commons.Language;
  submissionFiles: TraceMyApi.submission.SubmissionFileInfo[];
  userId?: string;
}
",
                    "name": "WorkspaceSubmitRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface WorkspaceTracedUpdate {
  traceResponsesSize: number;
}
",
                    "name": "WorkspaceTracedUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./SubmissionId\\";
export * from \\"./ShareId\\";
export * from \\"./SubmissionRequest\\";
export * from \\"./InitializeProblemRequest\\";
export * from \\"./SubmitRequestV2\\";
export * from \\"./WorkspaceSubmitRequest\\";
export * from \\"./SubmissionFileInfo\\";
export * from \\"./SubmissionTypeEnum\\";
export * from \\"./StopRequest\\";
export * from \\"./SubmissionResponse\\";
export * from \\"./CodeExecutionUpdate\\";
export * from \\"./BuildingExecutorResponse\\";
export * from \\"./RunningResponse\\";
export * from \\"./RunningSubmissionState\\";
export * from \\"./ErroredResponse\\";
export * from \\"./ErrorInfo\\";
export * from \\"./CompileError\\";
export * from \\"./RuntimeError\\";
export * from \\"./InternalError\\";
export * from \\"./StoppedResponse\\";
export * from \\"./WorkspaceRanResponse\\";
export * from \\"./WorkspaceRunDetails\\";
export * from \\"./GradedResponse\\";
export * from \\"./GradedResponseV2\\";
export * from \\"./TestCaseGrade\\";
export * from \\"./TestCaseHiddenGrade\\";
export * from \\"./TestCaseNonHiddenGrade\\";
export * from \\"./RecordedResponseNotification\\";
export * from \\"./RecordingResponseNotification\\";
export * from \\"./LightweightStackframeInformation\\";
export * from \\"./TestCaseResultWithStdout\\";
export * from \\"./TestCaseResult\\";
export * from \\"./ActualResult\\";
export * from \\"./ExceptionV2\\";
export * from \\"./ExceptionInfo\\";
export * from \\"./InvalidRequestResponse\\";
export * from \\"./InvalidRequestCause\\";
export * from \\"./ExistingSubmissionExecuting\\";
export * from \\"./SubmissionIdNotFound\\";
export * from \\"./CustomTestCasesUnsupported\\";
export * from \\"./UnexpectedLanguageError\\";
export * from \\"./TerminatedResponse\\";
export * from \\"./FinishedResponse\\";
export * from \\"./StdoutResponse\\";
export * from \\"./StderrResponse\\";
export * from \\"./TraceResponse\\";
export * from \\"./TraceResponseV2\\";
export * from \\"./TracedFile\\";
export * from \\"./ExpressionLocation\\";
export * from \\"./StackInformation\\";
export * from \\"./StackFrame\\";
export * from \\"./Scope\\";
export * from \\"./ExecutionSessionResponse\\";
export * from \\"./ExecutionSessionStatus\\";
export * from \\"./SubmissionStatusV2\\";
export * from \\"./TestSubmissionStatusV2\\";
export * from \\"./WorkspaceSubmissionStatusV2\\";
export * from \\"./TestSubmissionUpdate\\";
export * from \\"./TestSubmissionUpdateInfo\\";
export * from \\"./WorkspaceSubmissionUpdate\\";
export * from \\"./WorkspaceSubmissionUpdateInfo\\";
export * from \\"./GradedTestCaseUpdate\\";
export * from \\"./RecordedTestCaseUpdate\\";
export * from \\"./WorkspaceTracedUpdate\\";
export * from \\"./SubmissionTypeState\\";
export * from \\"./WorkspaceSubmissionState\\";
export * from \\"./WorkspaceSubmissionStatus\\";
export * from \\"./TestSubmissionState\\";
export * from \\"./TestSubmissionStatus\\";
export * from \\"./SubmissionStatusForTestCase\\";
export * from \\"./TracedTestCase\\";
export * from \\"./TraceResponsesPage\\";
export * from \\"./TraceResponsesPageV2\\";
export * from \\"./GetTraceResponsesPageRequest\\";
export * from \\"./WorkspaceStarterFilesResponse\\";
export * from \\"./WorkspaceStarterFilesResponseV2\\";
export * from \\"./WorkspaceFiles\\";
export * from \\"./ExecutionSessionState\\";
export * from \\"./GetExecutionSessionStateResponse\\";
export * from \\"./GetSubmissionStateResponse\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "submission",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { TraceMyApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    auth?: {
      token?: core.Supplier<core.BearerToken>;
    };
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async setNumWarmInstances(
    request: TraceMyApi.sysprop.setNumWarmInstances.Request
  ): Promise<TraceMyApi.sysprop.setNumWarmInstances.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/sysprop/num-warm-instances/\${request.language}/\${request.numWarmInstances}\`
      ),
      method: \\"PUT\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getNumWarmInstances(): Promise<TraceMyApi.sysprop.getNumWarmInstances.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/sysprop/num-warm-instances\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.sysprop.getNumWarmInstances.Response.parse(
          response.body as Record<serializers.commons.Language.Raw, number>
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  Record<TraceMyApi.commons.Language.RawValue, number>,
  TraceMyApi.sysprop.getNumWarmInstances.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "getNumWarmInstances.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as setNumWarmInstances from \\"./setNumWarmInstances\\";
export * as getNumWarmInstances from \\"./getNumWarmInstances\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  language: TraceMyApi.commons.Language;
  numWarmInstances: number;
}

export type Response = core.APIResponse<void, TraceMyApi.sysprop.setNumWarmInstances.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "setNumWarmInstances.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "sysprop",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { Client as ProblemClient } from \\"../resources/problem/client/Client\\";
import { Client as V3Client } from \\"../resources/v3/client/Client\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    auth?: {
      token?: core.Supplier<core.BearerToken>;
    };
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  #problem: ProblemClient | undefined;

  public get problem(): ProblemClient {
    return (this.#problem ??= new ProblemClient(this.options));
  }

  #v3: V3Client | undefined;

  public get v3(): V3Client {
    return (this.#v3 ??= new V3Client(this.options));
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export {};
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./resources\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as v3 from \\"./v3\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../../environments\\";
import * as core from \\"../../../../../core\\";
import { TraceMyApi } from \\"../../../../..\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    auth?: {
      token?: core.Supplier<core.BearerToken>;
    };
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async getLightweightProblems(): Promise<TraceMyApi.v2.problem.getLightweightProblems.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/problems-v2/lightweight-problem-info\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.v2.problem.getLightweightProblems.Response.parse(
          response.body as serializers.v2.problem.LightweightProblemInfoV2.Raw[]
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getProblems(): Promise<TraceMyApi.v2.problem.getProblems.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/problems-v2/problem-info\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.v2.problem.getProblems.Response.parse(
          response.body as serializers.v2.problem.ProblemInfoV2.Raw[]
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getLatestProblem(
    request: TraceMyApi.v2.problem.getLatestProblem.Request
  ): Promise<TraceMyApi.v2.problem.getLatestProblem.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/problems-v2/problem-info/\${request.problemId}\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.v2.problem.ProblemInfoV2.parse(response.body as serializers.v2.problem.ProblemInfoV2.Raw),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getProblemVersion(
    request: TraceMyApi.v2.problem.getProblemVersion.Request
  ): Promise<TraceMyApi.v2.problem.getProblemVersion.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/problems-v2/problem-info/\${request.problemId}/version/\${request.problemVersion}\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.v2.problem.ProblemInfoV2.parse(response.body as serializers.v2.problem.ProblemInfoV2.Raw),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                            "name": "Client.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export interface Request {
  problemId: TraceMyApi.commons.ProblemId;
}

export type Response = core.APIResponse<
  TraceMyApi.v2.problem.ProblemInfoV2,
  TraceMyApi.v2.problem.getLatestProblem.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                            "name": "getLatestProblem.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export type Response = core.APIResponse<
  TraceMyApi.v2.problem.LightweightProblemInfoV2[],
  TraceMyApi.v2.problem.getLightweightProblems.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                            "name": "getLightweightProblems.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export interface Request {
  problemId: TraceMyApi.commons.ProblemId;
  problemVersion: number;
}

export type Response = core.APIResponse<
  TraceMyApi.v2.problem.ProblemInfoV2,
  TraceMyApi.v2.problem.getProblemVersion.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                            "name": "getProblemVersion.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export type Response = core.APIResponse<TraceMyApi.v2.problem.ProblemInfoV2[], TraceMyApi.v2.problem.getProblems.Error>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                            "name": "getProblems.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
export * as getLatestProblem from \\"./getLatestProblem\\";
export * as getProblemVersion from \\"./getProblemVersion\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "client",
                        "type": "directory",
                      },
                      Object {
                        "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export type AssertCorrectnessCheck =
  | AssertCorrectnessCheck.DeepEquality
  | AssertCorrectnessCheck.Custom
  | AssertCorrectnessCheck._Unknown;

export declare namespace AssertCorrectnessCheck {
  interface DeepEquality extends TraceMyApi.v2.problem.DeepEqualityCorrectnessCheck, _Utils {
    type: \\"deepEquality\\";
  }

  interface Custom extends TraceMyApi.v2.problem.VoidFunctionDefinitionThatTakesActualResult, _Utils {
    type: \\"custom\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: AssertCorrectnessCheck._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    deepEquality: (value: TraceMyApi.v2.problem.DeepEqualityCorrectnessCheck) => Result;
    custom: (value: TraceMyApi.v2.problem.VoidFunctionDefinitionThatTakesActualResult) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const AssertCorrectnessCheck = {
  deepEquality: (value: TraceMyApi.v2.problem.DeepEqualityCorrectnessCheck): AssertCorrectnessCheck.DeepEquality => {
    const valueWithoutVisit: Omit<AssertCorrectnessCheck.DeepEquality, \\"_visit\\"> = {
      ...value,
      type: \\"deepEquality\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as AssertCorrectnessCheck.DeepEquality;
    castedValue._visit = (visitor) => visitor.deepEquality(value);
    return castedValue;
  },

  custom: (value: TraceMyApi.v2.problem.VoidFunctionDefinitionThatTakesActualResult): AssertCorrectnessCheck.Custom => {
    const valueWithoutVisit: Omit<AssertCorrectnessCheck.Custom, \\"_visit\\"> = {
      ...value,
      type: \\"custom\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as AssertCorrectnessCheck.Custom;
    castedValue._visit = (visitor) => visitor.custom(value);
    return castedValue;
  },
} as const;
",
                            "name": "AssertCorrectnessCheck.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export interface BasicCustomFiles {
  methodName: string;
  signature: TraceMyApi.v2.problem.NonVoidFunctionSignature;
  additionalFiles: Record<TraceMyApi.commons.Language.RawValue, TraceMyApi.v2.problem.Files>;
  basicTestCaseTemplate: TraceMyApi.v2.problem.BasicTestCaseTemplate;
}
",
                            "name": "BasicCustomFiles.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export interface BasicTestCaseTemplate {
  templateId: TraceMyApi.v2.problem.TestCaseTemplateId;
  name: string;
  description: TraceMyApi.v2.problem.TestCaseImplementationDescription;
  expectedValueParameterId: TraceMyApi.v2.problem.ParameterId;
}
",
                            "name": "BasicTestCaseTemplate.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export interface CreateProblemRequestV2 {
  problemName: string;
  problemDescription: TraceMyApi.problem.ProblemDescription;
  customFiles: TraceMyApi.v2.problem.CustomFiles;
  customTestCaseTemplates: TraceMyApi.v2.problem.TestCaseTemplate[];
  testcases: TraceMyApi.v2.problem.TestCaseV2[];
  supportedLanguages: TraceMyApi.commons.Language[];
  isPublic: boolean;
}
",
                            "name": "CreateProblemRequestV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export type CustomFiles = CustomFiles.Basic | CustomFiles.Custom | CustomFiles._Unknown;

export declare namespace CustomFiles {
  interface Basic extends TraceMyApi.v2.problem.BasicCustomFiles, _Utils {
    type: \\"basic\\";
  }

  interface Custom extends _Utils {
    type: \\"custom\\";
    value: Record<TraceMyApi.commons.Language.RawValue, TraceMyApi.v2.problem.Files>;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: CustomFiles._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    basic: (value: TraceMyApi.v2.problem.BasicCustomFiles) => Result;
    custom: (value: Record<TraceMyApi.commons.Language.RawValue, TraceMyApi.v2.problem.Files>) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const CustomFiles = {
  basic: (value: TraceMyApi.v2.problem.BasicCustomFiles): CustomFiles.Basic => {
    const valueWithoutVisit: Omit<CustomFiles.Basic, \\"_visit\\"> = {
      ...value,
      type: \\"basic\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CustomFiles.Basic;
    castedValue._visit = (visitor) => visitor.basic(value);
    return castedValue;
  },

  custom: (value: Record<TraceMyApi.commons.Language.RawValue, TraceMyApi.v2.problem.Files>): CustomFiles.Custom => {
    const valueWithoutVisit: Omit<CustomFiles.Custom, \\"_visit\\"> = {
      value: value,
      type: \\"custom\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CustomFiles.Custom;
    castedValue._visit = (visitor) => visitor.custom(value);
    return castedValue;
  },
} as const;
",
                            "name": "CustomFiles.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export interface DeepEqualityCorrectnessCheck {
  expectedValueParameterId: TraceMyApi.v2.problem.ParameterId;
}
",
                            "name": "DeepEqualityCorrectnessCheck.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export interface DefaultProvidedFile {
  file: TraceMyApi.v2.problem.FileInfoV2;
  relatedTypes: TraceMyApi.commons.VariableType[];
}
",
                            "name": "DefaultProvidedFile.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface FileInfoV2 {
  filename: string;
  directory: string;
  contents: string;
  editable: boolean;
}
",
                            "name": "FileInfoV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export interface Files {
  files: TraceMyApi.v2.problem.FileInfoV2[];
}
",
                            "name": "Files.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface FunctionImplementation {
  impl: string;
  imports?: string;
}
",
                            "name": "FunctionImplementation.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export interface FunctionImplementationForMultipleLanguages {
  codeByLanguage: Record<TraceMyApi.commons.Language.RawValue, TraceMyApi.v2.problem.FunctionImplementation>;
}
",
                            "name": "FunctionImplementationForMultipleLanguages.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export type FunctionSignature =
  | FunctionSignature.Void
  | FunctionSignature.NonVoid
  /**
   * Useful when specifying custom grading for a testcase where actualResult is defined. */
  | FunctionSignature.VoidThatTakesActualResult
  | FunctionSignature._Unknown;

export declare namespace FunctionSignature {
  interface Void extends TraceMyApi.v2.problem.VoidFunctionSignature, _Utils {
    type: \\"void\\";
  }

  interface NonVoid extends TraceMyApi.v2.problem.NonVoidFunctionSignature, _Utils {
    type: \\"nonVoid\\";
  }

  interface VoidThatTakesActualResult extends TraceMyApi.v2.problem.VoidFunctionSignatureThatTakesActualResult, _Utils {
    type: \\"voidThatTakesActualResult\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: FunctionSignature._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    void: (value: TraceMyApi.v2.problem.VoidFunctionSignature) => Result;
    nonVoid: (value: TraceMyApi.v2.problem.NonVoidFunctionSignature) => Result;
    voidThatTakesActualResult: (value: TraceMyApi.v2.problem.VoidFunctionSignatureThatTakesActualResult) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const FunctionSignature = {
  void: (value: TraceMyApi.v2.problem.VoidFunctionSignature): FunctionSignature.Void => {
    const valueWithoutVisit: Omit<FunctionSignature.Void, \\"_visit\\"> = {
      ...value,
      type: \\"void\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as FunctionSignature.Void;
    castedValue._visit = (visitor) => visitor.void(value);
    return castedValue;
  },

  nonVoid: (value: TraceMyApi.v2.problem.NonVoidFunctionSignature): FunctionSignature.NonVoid => {
    const valueWithoutVisit: Omit<FunctionSignature.NonVoid, \\"_visit\\"> = {
      ...value,
      type: \\"nonVoid\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as FunctionSignature.NonVoid;
    castedValue._visit = (visitor) => visitor.nonVoid(value);
    return castedValue;
  },

  voidThatTakesActualResult: (
    value: TraceMyApi.v2.problem.VoidFunctionSignatureThatTakesActualResult
  ): FunctionSignature.VoidThatTakesActualResult => {
    const valueWithoutVisit: Omit<FunctionSignature.VoidThatTakesActualResult, \\"_visit\\"> = {
      ...value,
      type: \\"voidThatTakesActualResult\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as FunctionSignature.VoidThatTakesActualResult;
    castedValue._visit = (visitor) => visitor.voidThatTakesActualResult(value);
    return castedValue;
  },
} as const;
",
                            "name": "FunctionSignature.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export interface GeneratedFiles {
  generatedTestCaseFiles: Record<TraceMyApi.commons.Language.RawValue, TraceMyApi.v2.problem.Files>;
  generatedTemplateFiles: Record<TraceMyApi.commons.Language.RawValue, TraceMyApi.v2.problem.Files>;
  other: Record<TraceMyApi.commons.Language.RawValue, TraceMyApi.v2.problem.Files>;
}
",
                            "name": "GeneratedFiles.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export interface GetBasicSolutionFileRequest {
  methodName: string;
  signature: TraceMyApi.v2.problem.NonVoidFunctionSignature;
}
",
                            "name": "GetBasicSolutionFileRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export interface GetBasicSolutionFileResponse {
  solutionFileByLanguage: Record<TraceMyApi.commons.Language.RawValue, TraceMyApi.v2.problem.FileInfoV2>;
}
",
                            "name": "GetBasicSolutionFileResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export interface GetFunctionSignatureRequest {
  functionSignature: TraceMyApi.v2.problem.FunctionSignature;
}
",
                            "name": "GetFunctionSignatureRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export interface GetFunctionSignatureResponse {
  functionByLanguage: Record<TraceMyApi.commons.Language.RawValue, string>;
}
",
                            "name": "GetFunctionSignatureResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export interface GetGeneratedTestCaseFileRequest {
  template?: TraceMyApi.v2.problem.TestCaseTemplate;
  testCase: TraceMyApi.v2.problem.TestCaseV2;
}
",
                            "name": "GetGeneratedTestCaseFileRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export interface GetGeneratedTestCaseTemplateFileRequest {
  template: TraceMyApi.v2.problem.TestCaseTemplate;
}
",
                            "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export interface LightweightProblemInfoV2 {
  problemId: TraceMyApi.commons.ProblemId;
  problemName: string;
  problemVersion: number;
  variableTypes: TraceMyApi.commons.VariableType[];
}
",
                            "name": "LightweightProblemInfoV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export interface NonVoidFunctionDefinition {
  signature: TraceMyApi.v2.problem.NonVoidFunctionSignature;
  code: TraceMyApi.v2.problem.FunctionImplementationForMultipleLanguages;
}
",
                            "name": "NonVoidFunctionDefinition.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export interface NonVoidFunctionSignature {
  parameters: TraceMyApi.v2.problem.Parameter[];
  returnType: TraceMyApi.commons.VariableType;
}
",
                            "name": "NonVoidFunctionSignature.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export interface Parameter {
  parameterId: TraceMyApi.v2.problem.ParameterId;
  name: string;
  variableType: TraceMyApi.commons.VariableType;
}
",
                            "name": "Parameter.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export type ParameterId = string;
",
                            "name": "ParameterId.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export interface ProblemInfoV2 {
  problemId: TraceMyApi.commons.ProblemId;
  problemDescription: TraceMyApi.problem.ProblemDescription;
  problemName: string;
  problemVersion: number;
  supportedLanguages: TraceMyApi.commons.Language[];
  customFiles: TraceMyApi.v2.problem.CustomFiles;
  generatedFiles: TraceMyApi.v2.problem.GeneratedFiles;
  customTestCaseTemplates: TraceMyApi.v2.problem.TestCaseTemplate[];
  testcases: TraceMyApi.v2.problem.TestCaseV2[];
  isPublic: boolean;
}
",
                            "name": "ProblemInfoV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface TestCaseExpects {
  expectedStdout?: string;
}
",
                            "name": "TestCaseExpects.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export type TestCaseFunction = TestCaseFunction.WithActualResult | TestCaseFunction.Custom | TestCaseFunction._Unknown;

export declare namespace TestCaseFunction {
  interface WithActualResult extends TraceMyApi.v2.problem.TestCaseWithActualResultImplementation, _Utils {
    type: \\"withActualResult\\";
  }

  interface Custom extends TraceMyApi.v2.problem.VoidFunctionDefinition, _Utils {
    type: \\"custom\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: TestCaseFunction._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    withActualResult: (value: TraceMyApi.v2.problem.TestCaseWithActualResultImplementation) => Result;
    custom: (value: TraceMyApi.v2.problem.VoidFunctionDefinition) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const TestCaseFunction = {
  withActualResult: (
    value: TraceMyApi.v2.problem.TestCaseWithActualResultImplementation
  ): TestCaseFunction.WithActualResult => {
    const valueWithoutVisit: Omit<TestCaseFunction.WithActualResult, \\"_visit\\"> = {
      ...value,
      type: \\"withActualResult\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestCaseFunction.WithActualResult;
    castedValue._visit = (visitor) => visitor.withActualResult(value);
    return castedValue;
  },

  custom: (value: TraceMyApi.v2.problem.VoidFunctionDefinition): TestCaseFunction.Custom => {
    const valueWithoutVisit: Omit<TestCaseFunction.Custom, \\"_visit\\"> = {
      ...value,
      type: \\"custom\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestCaseFunction.Custom;
    castedValue._visit = (visitor) => visitor.custom(value);
    return castedValue;
  },
} as const;
",
                            "name": "TestCaseFunction.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export type TestCaseId = string;
",
                            "name": "TestCaseId.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export interface TestCaseImplementation {
  description: TraceMyApi.v2.problem.TestCaseImplementationDescription;
  function: TraceMyApi.v2.problem.TestCaseFunction;
}
",
                            "name": "TestCaseImplementation.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export interface TestCaseImplementationDescription {
  boards: TraceMyApi.v2.problem.TestCaseImplementationDescriptionBoard[];
}
",
                            "name": "TestCaseImplementationDescription.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export type TestCaseImplementationDescriptionBoard =
  | TestCaseImplementationDescriptionBoard.Html
  | TestCaseImplementationDescriptionBoard.ParamId
  | TestCaseImplementationDescriptionBoard._Unknown;

export declare namespace TestCaseImplementationDescriptionBoard {
  interface Html extends _Utils {
    type: \\"html\\";
    value: string;
  }

  interface ParamId extends _Utils {
    type: \\"paramId\\";
    value: TraceMyApi.v2.problem.ParameterId;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: TestCaseImplementationDescriptionBoard._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    html: (value: string) => Result;
    paramId: (value: TraceMyApi.v2.problem.ParameterId) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const TestCaseImplementationDescriptionBoard = {
  html: (value: string): TestCaseImplementationDescriptionBoard.Html => {
    const valueWithoutVisit: Omit<TestCaseImplementationDescriptionBoard.Html, \\"_visit\\"> = {
      value: value,
      type: \\"html\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestCaseImplementationDescriptionBoard.Html;
    castedValue._visit = (visitor) => visitor.html(value);
    return castedValue;
  },

  paramId: (value: TraceMyApi.v2.problem.ParameterId): TestCaseImplementationDescriptionBoard.ParamId => {
    const valueWithoutVisit: Omit<TestCaseImplementationDescriptionBoard.ParamId, \\"_visit\\"> = {
      value: value,
      type: \\"paramId\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestCaseImplementationDescriptionBoard.ParamId;
    castedValue._visit = (visitor) => visitor.paramId(value);
    return castedValue;
  },
} as const;
",
                            "name": "TestCaseImplementationDescriptionBoard.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export type TestCaseImplementationReference =
  | TestCaseImplementationReference.TemplateId
  | TestCaseImplementationReference.Implementation
  | TestCaseImplementationReference._Unknown;

export declare namespace TestCaseImplementationReference {
  interface TemplateId extends _Utils {
    type: \\"templateId\\";
    value: TraceMyApi.v2.problem.TestCaseTemplateId;
  }

  interface Implementation extends TraceMyApi.v2.problem.TestCaseImplementation, _Utils {
    type: \\"implementation\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: TestCaseImplementationReference._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    templateId: (value: TraceMyApi.v2.problem.TestCaseTemplateId) => Result;
    implementation: (value: TraceMyApi.v2.problem.TestCaseImplementation) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const TestCaseImplementationReference = {
  templateId: (value: TraceMyApi.v2.problem.TestCaseTemplateId): TestCaseImplementationReference.TemplateId => {
    const valueWithoutVisit: Omit<TestCaseImplementationReference.TemplateId, \\"_visit\\"> = {
      value: value,
      type: \\"templateId\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestCaseImplementationReference.TemplateId;
    castedValue._visit = (visitor) => visitor.templateId(value);
    return castedValue;
  },

  implementation: (
    value: TraceMyApi.v2.problem.TestCaseImplementation
  ): TestCaseImplementationReference.Implementation => {
    const valueWithoutVisit: Omit<TestCaseImplementationReference.Implementation, \\"_visit\\"> = {
      ...value,
      type: \\"implementation\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestCaseImplementationReference.Implementation;
    castedValue._visit = (visitor) => visitor.implementation(value);
    return castedValue;
  },
} as const;
",
                            "name": "TestCaseImplementationReference.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export interface TestCaseMetadata {
  id: TraceMyApi.v2.problem.TestCaseId;
  name: string;
  hidden: boolean;
}
",
                            "name": "TestCaseMetadata.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export interface TestCaseTemplate {
  templateId: TraceMyApi.v2.problem.TestCaseTemplateId;
  name: string;
  implementation: TraceMyApi.v2.problem.TestCaseImplementation;
}
",
                            "name": "TestCaseTemplate.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export type TestCaseTemplateId = string;
",
                            "name": "TestCaseTemplateId.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export interface TestCaseV2 {
  metadata: TraceMyApi.v2.problem.TestCaseMetadata;
  implementation: TraceMyApi.v2.problem.TestCaseImplementationReference;
  arguments: Record<string, TraceMyApi.commons.VariableValue>;
  expects?: TraceMyApi.v2.problem.TestCaseExpects;
}
",
                            "name": "TestCaseV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export interface TestCaseWithActualResultImplementation {
  getActualResult: TraceMyApi.v2.problem.NonVoidFunctionDefinition;
  assertCorrectnessCheck: TraceMyApi.v2.problem.AssertCorrectnessCheck;
}
",
                            "name": "TestCaseWithActualResultImplementation.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export interface VoidFunctionDefinition {
  parameters: TraceMyApi.v2.problem.Parameter[];
  code: TraceMyApi.v2.problem.FunctionImplementationForMultipleLanguages;
}
",
                            "name": "VoidFunctionDefinition.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

/**
 * The generated signature will include an additional param, actualResult
 */
export interface VoidFunctionDefinitionThatTakesActualResult {
  additionalParameters: TraceMyApi.v2.problem.Parameter[];
  code: TraceMyApi.v2.problem.FunctionImplementationForMultipleLanguages;
}
",
                            "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export interface VoidFunctionSignature {
  parameters: TraceMyApi.v2.problem.Parameter[];
}
",
                            "name": "VoidFunctionSignature.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";

export interface VoidFunctionSignatureThatTakesActualResult {
  parameters: TraceMyApi.v2.problem.Parameter[];
  actualResultType: TraceMyApi.commons.VariableType;
}
",
                            "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "types",
                        "type": "directory",
                      },
                    ],
                    "name": "problem",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../../environments\\";
import * as core from \\"../../../../../core\\";
import { Client as ProblemClient } from \\"../resources/problem/client/Client\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    auth?: {
      token?: core.Supplier<core.BearerToken>;
    };
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  #problem: ProblemClient | undefined;

  public get problem(): ProblemClient {
    return (this.#problem ??= new ProblemClient(this.options));
  }
}
",
                            "name": "Client.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export {};
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "client",
                        "type": "directory",
                      },
                      Object {
                        "contents": "export * from \\"./resources\\";
export * from \\"./client\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": Array [
                              Object {
                                "contents": Array [
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../../../../environments\\";
import * as core from \\"../../../../../../../core\\";
import { TraceMyApi } from \\"../../../../../../..\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../../../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    auth?: {
      token?: core.Supplier<core.BearerToken>;
    };
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async getLightweightProblems(): Promise<TraceMyApi.v2.v3.problem.getLightweightProblems.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/problems-v2/lightweight-problem-info\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.v2.v3.problem.getLightweightProblems.Response.parse(
          response.body as serializers.v2.v3.problem.LightweightProblemInfoV2.Raw[]
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getProblems(): Promise<TraceMyApi.v2.v3.problem.getProblems.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/problems-v2/problem-info\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.v2.v3.problem.getProblems.Response.parse(
          response.body as serializers.v2.v3.problem.ProblemInfoV2.Raw[]
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getLatestProblem(
    request: TraceMyApi.v2.v3.problem.getLatestProblem.Request
  ): Promise<TraceMyApi.v2.v3.problem.getLatestProblem.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/problems-v2/problem-info/\${request.problemId}\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.v2.v3.problem.ProblemInfoV2.parse(
          response.body as serializers.v2.v3.problem.ProblemInfoV2.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getProblemVersion(
    request: TraceMyApi.v2.v3.problem.getProblemVersion.Request
  ): Promise<TraceMyApi.v2.v3.problem.getProblemVersion.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/problems-v2/problem-info/\${request.problemId}/version/\${request.problemVersion}\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.v2.v3.problem.ProblemInfoV2.parse(
          response.body as serializers.v2.v3.problem.ProblemInfoV2.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                                    "name": "Client.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";

export interface Request {
  problemId: TraceMyApi.commons.ProblemId;
}

export type Response = core.APIResponse<
  TraceMyApi.v2.v3.problem.ProblemInfoV2,
  TraceMyApi.v2.v3.problem.getLatestProblem.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                                    "name": "getLatestProblem.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";

export type Response = core.APIResponse<
  TraceMyApi.v2.v3.problem.LightweightProblemInfoV2[],
  TraceMyApi.v2.v3.problem.getLightweightProblems.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                                    "name": "getLightweightProblems.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";

export interface Request {
  problemId: TraceMyApi.commons.ProblemId;
  problemVersion: number;
}

export type Response = core.APIResponse<
  TraceMyApi.v2.v3.problem.ProblemInfoV2,
  TraceMyApi.v2.v3.problem.getProblemVersion.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                                    "name": "getProblemVersion.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";

export type Response = core.APIResponse<
  TraceMyApi.v2.v3.problem.ProblemInfoV2[],
  TraceMyApi.v2.v3.problem.getProblems.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                                    "name": "getProblems.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
export * as getLatestProblem from \\"./getLatestProblem\\";
export * as getProblemVersion from \\"./getProblemVersion\\";
",
                                    "name": "index.ts",
                                    "type": "file",
                                  },
                                ],
                                "name": "client",
                                "type": "directory",
                              },
                              Object {
                                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                                "name": "index.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": Array [
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export type AssertCorrectnessCheck =
  | AssertCorrectnessCheck.DeepEquality
  | AssertCorrectnessCheck.Custom
  | AssertCorrectnessCheck._Unknown;

export declare namespace AssertCorrectnessCheck {
  interface DeepEquality extends TraceMyApi.v2.v3.problem.DeepEqualityCorrectnessCheck, _Utils {
    type: \\"deepEquality\\";
  }

  interface Custom extends TraceMyApi.v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult, _Utils {
    type: \\"custom\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: AssertCorrectnessCheck._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    deepEquality: (value: TraceMyApi.v2.v3.problem.DeepEqualityCorrectnessCheck) => Result;
    custom: (value: TraceMyApi.v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const AssertCorrectnessCheck = {
  deepEquality: (value: TraceMyApi.v2.v3.problem.DeepEqualityCorrectnessCheck): AssertCorrectnessCheck.DeepEquality => {
    const valueWithoutVisit: Omit<AssertCorrectnessCheck.DeepEquality, \\"_visit\\"> = {
      ...value,
      type: \\"deepEquality\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as AssertCorrectnessCheck.DeepEquality;
    castedValue._visit = (visitor) => visitor.deepEquality(value);
    return castedValue;
  },

  custom: (
    value: TraceMyApi.v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult
  ): AssertCorrectnessCheck.Custom => {
    const valueWithoutVisit: Omit<AssertCorrectnessCheck.Custom, \\"_visit\\"> = {
      ...value,
      type: \\"custom\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as AssertCorrectnessCheck.Custom;
    castedValue._visit = (visitor) => visitor.custom(value);
    return castedValue;
  },
} as const;
",
                                    "name": "AssertCorrectnessCheck.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export interface BasicCustomFiles {
  methodName: string;
  signature: TraceMyApi.v2.v3.problem.NonVoidFunctionSignature;
  additionalFiles: Record<TraceMyApi.commons.Language.RawValue, TraceMyApi.v2.v3.problem.Files>;
  basicTestCaseTemplate: TraceMyApi.v2.v3.problem.BasicTestCaseTemplate;
}
",
                                    "name": "BasicCustomFiles.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export interface BasicTestCaseTemplate {
  templateId: TraceMyApi.v2.v3.problem.TestCaseTemplateId;
  name: string;
  description: TraceMyApi.v2.v3.problem.TestCaseImplementationDescription;
  expectedValueParameterId: TraceMyApi.v2.v3.problem.ParameterId;
}
",
                                    "name": "BasicTestCaseTemplate.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export interface CreateProblemRequestV2 {
  problemName: string;
  problemDescription: TraceMyApi.problem.ProblemDescription;
  customFiles: TraceMyApi.v2.v3.problem.CustomFiles;
  customTestCaseTemplates: TraceMyApi.v2.v3.problem.TestCaseTemplate[];
  testcases: TraceMyApi.v2.v3.problem.TestCaseV2[];
  supportedLanguages: TraceMyApi.commons.Language[];
  isPublic: boolean;
}
",
                                    "name": "CreateProblemRequestV2.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export type CustomFiles = CustomFiles.Basic | CustomFiles.Custom | CustomFiles._Unknown;

export declare namespace CustomFiles {
  interface Basic extends TraceMyApi.v2.v3.problem.BasicCustomFiles, _Utils {
    type: \\"basic\\";
  }

  interface Custom extends _Utils {
    type: \\"custom\\";
    value: Record<TraceMyApi.commons.Language.RawValue, TraceMyApi.v2.v3.problem.Files>;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: CustomFiles._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    basic: (value: TraceMyApi.v2.v3.problem.BasicCustomFiles) => Result;
    custom: (value: Record<TraceMyApi.commons.Language.RawValue, TraceMyApi.v2.v3.problem.Files>) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const CustomFiles = {
  basic: (value: TraceMyApi.v2.v3.problem.BasicCustomFiles): CustomFiles.Basic => {
    const valueWithoutVisit: Omit<CustomFiles.Basic, \\"_visit\\"> = {
      ...value,
      type: \\"basic\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CustomFiles.Basic;
    castedValue._visit = (visitor) => visitor.basic(value);
    return castedValue;
  },

  custom: (value: Record<TraceMyApi.commons.Language.RawValue, TraceMyApi.v2.v3.problem.Files>): CustomFiles.Custom => {
    const valueWithoutVisit: Omit<CustomFiles.Custom, \\"_visit\\"> = {
      value: value,
      type: \\"custom\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as CustomFiles.Custom;
    castedValue._visit = (visitor) => visitor.custom(value);
    return castedValue;
  },
} as const;
",
                                    "name": "CustomFiles.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export interface DeepEqualityCorrectnessCheck {
  expectedValueParameterId: TraceMyApi.v2.v3.problem.ParameterId;
}
",
                                    "name": "DeepEqualityCorrectnessCheck.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export interface DefaultProvidedFile {
  file: TraceMyApi.v2.v3.problem.FileInfoV2;
  relatedTypes: TraceMyApi.commons.VariableType[];
}
",
                                    "name": "DefaultProvidedFile.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface FileInfoV2 {
  filename: string;
  directory: string;
  contents: string;
  editable: boolean;
}
",
                                    "name": "FileInfoV2.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export interface Files {
  files: TraceMyApi.v2.v3.problem.FileInfoV2[];
}
",
                                    "name": "Files.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface FunctionImplementation {
  impl: string;
  imports?: string;
}
",
                                    "name": "FunctionImplementation.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export interface FunctionImplementationForMultipleLanguages {
  codeByLanguage: Record<TraceMyApi.commons.Language.RawValue, TraceMyApi.v2.v3.problem.FunctionImplementation>;
}
",
                                    "name": "FunctionImplementationForMultipleLanguages.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export type FunctionSignature =
  | FunctionSignature.Void
  | FunctionSignature.NonVoid
  /**
   * Useful when specifying custom grading for a testcase where actualResult is defined. */
  | FunctionSignature.VoidThatTakesActualResult
  | FunctionSignature._Unknown;

export declare namespace FunctionSignature {
  interface Void extends TraceMyApi.v2.v3.problem.VoidFunctionSignature, _Utils {
    type: \\"void\\";
  }

  interface NonVoid extends TraceMyApi.v2.v3.problem.NonVoidFunctionSignature, _Utils {
    type: \\"nonVoid\\";
  }

  interface VoidThatTakesActualResult
    extends TraceMyApi.v2.v3.problem.VoidFunctionSignatureThatTakesActualResult,
      _Utils {
    type: \\"voidThatTakesActualResult\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: FunctionSignature._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    void: (value: TraceMyApi.v2.v3.problem.VoidFunctionSignature) => Result;
    nonVoid: (value: TraceMyApi.v2.v3.problem.NonVoidFunctionSignature) => Result;
    voidThatTakesActualResult: (value: TraceMyApi.v2.v3.problem.VoidFunctionSignatureThatTakesActualResult) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const FunctionSignature = {
  void: (value: TraceMyApi.v2.v3.problem.VoidFunctionSignature): FunctionSignature.Void => {
    const valueWithoutVisit: Omit<FunctionSignature.Void, \\"_visit\\"> = {
      ...value,
      type: \\"void\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as FunctionSignature.Void;
    castedValue._visit = (visitor) => visitor.void(value);
    return castedValue;
  },

  nonVoid: (value: TraceMyApi.v2.v3.problem.NonVoidFunctionSignature): FunctionSignature.NonVoid => {
    const valueWithoutVisit: Omit<FunctionSignature.NonVoid, \\"_visit\\"> = {
      ...value,
      type: \\"nonVoid\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as FunctionSignature.NonVoid;
    castedValue._visit = (visitor) => visitor.nonVoid(value);
    return castedValue;
  },

  voidThatTakesActualResult: (
    value: TraceMyApi.v2.v3.problem.VoidFunctionSignatureThatTakesActualResult
  ): FunctionSignature.VoidThatTakesActualResult => {
    const valueWithoutVisit: Omit<FunctionSignature.VoidThatTakesActualResult, \\"_visit\\"> = {
      ...value,
      type: \\"voidThatTakesActualResult\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as FunctionSignature.VoidThatTakesActualResult;
    castedValue._visit = (visitor) => visitor.voidThatTakesActualResult(value);
    return castedValue;
  },
} as const;
",
                                    "name": "FunctionSignature.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export interface GeneratedFiles {
  generatedTestCaseFiles: Record<TraceMyApi.commons.Language.RawValue, TraceMyApi.v2.v3.problem.Files>;
  generatedTemplateFiles: Record<TraceMyApi.commons.Language.RawValue, TraceMyApi.v2.v3.problem.Files>;
  other: Record<TraceMyApi.commons.Language.RawValue, TraceMyApi.v2.v3.problem.Files>;
}
",
                                    "name": "GeneratedFiles.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export interface GetBasicSolutionFileRequest {
  methodName: string;
  signature: TraceMyApi.v2.v3.problem.NonVoidFunctionSignature;
}
",
                                    "name": "GetBasicSolutionFileRequest.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export interface GetBasicSolutionFileResponse {
  solutionFileByLanguage: Record<TraceMyApi.commons.Language.RawValue, TraceMyApi.v2.v3.problem.FileInfoV2>;
}
",
                                    "name": "GetBasicSolutionFileResponse.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export interface GetFunctionSignatureRequest {
  functionSignature: TraceMyApi.v2.v3.problem.FunctionSignature;
}
",
                                    "name": "GetFunctionSignatureRequest.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export interface GetFunctionSignatureResponse {
  functionByLanguage: Record<TraceMyApi.commons.Language.RawValue, string>;
}
",
                                    "name": "GetFunctionSignatureResponse.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export interface GetGeneratedTestCaseFileRequest {
  template?: TraceMyApi.v2.v3.problem.TestCaseTemplate;
  testCase: TraceMyApi.v2.v3.problem.TestCaseV2;
}
",
                                    "name": "GetGeneratedTestCaseFileRequest.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export interface GetGeneratedTestCaseTemplateFileRequest {
  template: TraceMyApi.v2.v3.problem.TestCaseTemplate;
}
",
                                    "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export interface LightweightProblemInfoV2 {
  problemId: TraceMyApi.commons.ProblemId;
  problemName: string;
  problemVersion: number;
  variableTypes: TraceMyApi.commons.VariableType[];
}
",
                                    "name": "LightweightProblemInfoV2.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export interface NonVoidFunctionDefinition {
  signature: TraceMyApi.v2.v3.problem.NonVoidFunctionSignature;
  code: TraceMyApi.v2.v3.problem.FunctionImplementationForMultipleLanguages;
}
",
                                    "name": "NonVoidFunctionDefinition.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export interface NonVoidFunctionSignature {
  parameters: TraceMyApi.v2.v3.problem.Parameter[];
  returnType: TraceMyApi.commons.VariableType;
}
",
                                    "name": "NonVoidFunctionSignature.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export interface Parameter {
  parameterId: TraceMyApi.v2.v3.problem.ParameterId;
  name: string;
  variableType: TraceMyApi.commons.VariableType;
}
",
                                    "name": "Parameter.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export type ParameterId = string;
",
                                    "name": "ParameterId.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export interface ProblemInfoV2 {
  problemId: TraceMyApi.commons.ProblemId;
  problemDescription: TraceMyApi.problem.ProblemDescription;
  problemName: string;
  problemVersion: number;
  supportedLanguages: TraceMyApi.commons.Language[];
  customFiles: TraceMyApi.v2.v3.problem.CustomFiles;
  generatedFiles: TraceMyApi.v2.v3.problem.GeneratedFiles;
  customTestCaseTemplates: TraceMyApi.v2.v3.problem.TestCaseTemplate[];
  testcases: TraceMyApi.v2.v3.problem.TestCaseV2[];
  isPublic: boolean;
}
",
                                    "name": "ProblemInfoV2.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface TestCaseExpects {
  expectedStdout?: string;
}
",
                                    "name": "TestCaseExpects.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export type TestCaseFunction = TestCaseFunction.WithActualResult | TestCaseFunction.Custom | TestCaseFunction._Unknown;

export declare namespace TestCaseFunction {
  interface WithActualResult extends TraceMyApi.v2.v3.problem.TestCaseWithActualResultImplementation, _Utils {
    type: \\"withActualResult\\";
  }

  interface Custom extends TraceMyApi.v2.v3.problem.VoidFunctionDefinition, _Utils {
    type: \\"custom\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: TestCaseFunction._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    withActualResult: (value: TraceMyApi.v2.v3.problem.TestCaseWithActualResultImplementation) => Result;
    custom: (value: TraceMyApi.v2.v3.problem.VoidFunctionDefinition) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const TestCaseFunction = {
  withActualResult: (
    value: TraceMyApi.v2.v3.problem.TestCaseWithActualResultImplementation
  ): TestCaseFunction.WithActualResult => {
    const valueWithoutVisit: Omit<TestCaseFunction.WithActualResult, \\"_visit\\"> = {
      ...value,
      type: \\"withActualResult\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestCaseFunction.WithActualResult;
    castedValue._visit = (visitor) => visitor.withActualResult(value);
    return castedValue;
  },

  custom: (value: TraceMyApi.v2.v3.problem.VoidFunctionDefinition): TestCaseFunction.Custom => {
    const valueWithoutVisit: Omit<TestCaseFunction.Custom, \\"_visit\\"> = {
      ...value,
      type: \\"custom\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestCaseFunction.Custom;
    castedValue._visit = (visitor) => visitor.custom(value);
    return castedValue;
  },
} as const;
",
                                    "name": "TestCaseFunction.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export type TestCaseId = string;
",
                                    "name": "TestCaseId.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export interface TestCaseImplementation {
  description: TraceMyApi.v2.v3.problem.TestCaseImplementationDescription;
  function: TraceMyApi.v2.v3.problem.TestCaseFunction;
}
",
                                    "name": "TestCaseImplementation.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export interface TestCaseImplementationDescription {
  boards: TraceMyApi.v2.v3.problem.TestCaseImplementationDescriptionBoard[];
}
",
                                    "name": "TestCaseImplementationDescription.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export type TestCaseImplementationDescriptionBoard =
  | TestCaseImplementationDescriptionBoard.Html
  | TestCaseImplementationDescriptionBoard.ParamId
  | TestCaseImplementationDescriptionBoard._Unknown;

export declare namespace TestCaseImplementationDescriptionBoard {
  interface Html extends _Utils {
    type: \\"html\\";
    value: string;
  }

  interface ParamId extends _Utils {
    type: \\"paramId\\";
    value: TraceMyApi.v2.v3.problem.ParameterId;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: TestCaseImplementationDescriptionBoard._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    html: (value: string) => Result;
    paramId: (value: TraceMyApi.v2.v3.problem.ParameterId) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const TestCaseImplementationDescriptionBoard = {
  html: (value: string): TestCaseImplementationDescriptionBoard.Html => {
    const valueWithoutVisit: Omit<TestCaseImplementationDescriptionBoard.Html, \\"_visit\\"> = {
      value: value,
      type: \\"html\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestCaseImplementationDescriptionBoard.Html;
    castedValue._visit = (visitor) => visitor.html(value);
    return castedValue;
  },

  paramId: (value: TraceMyApi.v2.v3.problem.ParameterId): TestCaseImplementationDescriptionBoard.ParamId => {
    const valueWithoutVisit: Omit<TestCaseImplementationDescriptionBoard.ParamId, \\"_visit\\"> = {
      value: value,
      type: \\"paramId\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestCaseImplementationDescriptionBoard.ParamId;
    castedValue._visit = (visitor) => visitor.paramId(value);
    return castedValue;
  },
} as const;
",
                                    "name": "TestCaseImplementationDescriptionBoard.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export type TestCaseImplementationReference =
  | TestCaseImplementationReference.TemplateId
  | TestCaseImplementationReference.Implementation
  | TestCaseImplementationReference._Unknown;

export declare namespace TestCaseImplementationReference {
  interface TemplateId extends _Utils {
    type: \\"templateId\\";
    value: TraceMyApi.v2.v3.problem.TestCaseTemplateId;
  }

  interface Implementation extends TraceMyApi.v2.v3.problem.TestCaseImplementation, _Utils {
    type: \\"implementation\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: TestCaseImplementationReference._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    templateId: (value: TraceMyApi.v2.v3.problem.TestCaseTemplateId) => Result;
    implementation: (value: TraceMyApi.v2.v3.problem.TestCaseImplementation) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const TestCaseImplementationReference = {
  templateId: (value: TraceMyApi.v2.v3.problem.TestCaseTemplateId): TestCaseImplementationReference.TemplateId => {
    const valueWithoutVisit: Omit<TestCaseImplementationReference.TemplateId, \\"_visit\\"> = {
      value: value,
      type: \\"templateId\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestCaseImplementationReference.TemplateId;
    castedValue._visit = (visitor) => visitor.templateId(value);
    return castedValue;
  },

  implementation: (
    value: TraceMyApi.v2.v3.problem.TestCaseImplementation
  ): TestCaseImplementationReference.Implementation => {
    const valueWithoutVisit: Omit<TestCaseImplementationReference.Implementation, \\"_visit\\"> = {
      ...value,
      type: \\"implementation\\",
    };
    Object.defineProperty(valueWithoutVisit, \\"_visit\\", {
      enumerable: false,
      writable: true,
    });
    const castedValue = valueWithoutVisit as TestCaseImplementationReference.Implementation;
    castedValue._visit = (visitor) => visitor.implementation(value);
    return castedValue;
  },
} as const;
",
                                    "name": "TestCaseImplementationReference.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export interface TestCaseMetadata {
  id: TraceMyApi.v2.v3.problem.TestCaseId;
  name: string;
  hidden: boolean;
}
",
                                    "name": "TestCaseMetadata.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export interface TestCaseTemplate {
  templateId: TraceMyApi.v2.v3.problem.TestCaseTemplateId;
  name: string;
  implementation: TraceMyApi.v2.v3.problem.TestCaseImplementation;
}
",
                                    "name": "TestCaseTemplate.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export type TestCaseTemplateId = string;
",
                                    "name": "TestCaseTemplateId.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export interface TestCaseV2 {
  metadata: TraceMyApi.v2.v3.problem.TestCaseMetadata;
  implementation: TraceMyApi.v2.v3.problem.TestCaseImplementationReference;
  arguments: Record<string, TraceMyApi.commons.VariableValue>;
  expects?: TraceMyApi.v2.v3.problem.TestCaseExpects;
}
",
                                    "name": "TestCaseV2.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export interface TestCaseWithActualResultImplementation {
  getActualResult: TraceMyApi.v2.v3.problem.NonVoidFunctionDefinition;
  assertCorrectnessCheck: TraceMyApi.v2.v3.problem.AssertCorrectnessCheck;
}
",
                                    "name": "TestCaseWithActualResultImplementation.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export interface VoidFunctionDefinition {
  parameters: TraceMyApi.v2.v3.problem.Parameter[];
  code: TraceMyApi.v2.v3.problem.FunctionImplementationForMultipleLanguages;
}
",
                                    "name": "VoidFunctionDefinition.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

/**
 * The generated signature will include an additional param, actualResult
 */
export interface VoidFunctionDefinitionThatTakesActualResult {
  additionalParameters: TraceMyApi.v2.v3.problem.Parameter[];
  code: TraceMyApi.v2.v3.problem.FunctionImplementationForMultipleLanguages;
}
",
                                    "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export interface VoidFunctionSignature {
  parameters: TraceMyApi.v2.v3.problem.Parameter[];
}
",
                                    "name": "VoidFunctionSignature.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";

export interface VoidFunctionSignatureThatTakesActualResult {
  parameters: TraceMyApi.v2.v3.problem.Parameter[];
  actualResultType: TraceMyApi.commons.VariableType;
}
",
                                    "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                                    "name": "index.ts",
                                    "type": "file",
                                  },
                                ],
                                "name": "types",
                                "type": "directory",
                              },
                            ],
                            "name": "problem",
                            "type": "directory",
                          },
                        ],
                        "name": "resources",
                        "type": "directory",
                      },
                    ],
                    "name": "v3",
                    "type": "directory",
                  },
                ],
                "name": "resources",
                "type": "directory",
              },
            ],
            "name": "v2",
            "type": "directory",
          },
        ],
        "name": "resources",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "export * as storeTracedTestCaseV2 from \\"./storeTracedTestCaseV2\\";
export * as storeTracedWorkspaceV2 from \\"./storeTracedWorkspaceV2\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.submission.TraceResponseV2.Raw[],
  TraceMyApi.submission.TraceResponseV2[]
> = core.schemas.list(core.schemas.lazyObject(() => serializers.submission.TraceResponseV2));
",
                    "name": "storeTracedTestCaseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.submission.TraceResponseV2.Raw[],
  TraceMyApi.submission.TraceResponseV2[]
> = core.schemas.list(core.schemas.lazyObject(() => serializers.submission.TraceResponseV2));
",
                    "name": "storeTracedWorkspaceV2.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const StoreTracedTestCaseRequest: core.schemas.ObjectSchema<
  StoreTracedTestCaseRequest.Raw,
  TraceMyApi.admin.StoreTracedTestCaseRequest
> = core.schemas.object({
  result: core.schemas.lazyObject(() => serializers.submission.TestCaseResultWithStdout),
  traceResponses: core.schemas.list(core.schemas.lazyObject(() => serializers.submission.TraceResponse)),
});

export declare namespace StoreTracedTestCaseRequest {
  interface Raw {
    result: serializers.submission.TestCaseResultWithStdout.Raw;
    traceResponses: serializers.submission.TraceResponse.Raw[];
  }
}
",
                    "name": "StoreTracedTestCaseRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const StoreTracedWorkspaceRequest: core.schemas.ObjectSchema<
  StoreTracedWorkspaceRequest.Raw,
  TraceMyApi.admin.StoreTracedWorkspaceRequest
> = core.schemas.object({
  workspaceRunDetails: core.schemas.lazyObject(() => serializers.submission.WorkspaceRunDetails),
  traceResponses: core.schemas.list(core.schemas.lazyObject(() => serializers.submission.TraceResponse)),
});

export declare namespace StoreTracedWorkspaceRequest {
  interface Raw {
    workspaceRunDetails: serializers.submission.WorkspaceRunDetails.Raw;
    traceResponses: serializers.submission.TraceResponse.Raw[];
  }
}
",
                    "name": "StoreTracedWorkspaceRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./StoreTracedTestCaseRequest\\";
export * from \\"./StoreTracedWorkspaceRequest\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "admin",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const BinaryTreeNodeAndTreeValue: core.schemas.ObjectSchema<
  BinaryTreeNodeAndTreeValue.Raw,
  TraceMyApi.commons.BinaryTreeNodeAndTreeValue
> = core.schemas.object({
  nodeId: core.schemas.lazy(() => serializers.commons.NodeId),
  fullTree: core.schemas.lazyObject(() => serializers.commons.BinaryTreeValue),
});

export declare namespace BinaryTreeNodeAndTreeValue {
  interface Raw {
    nodeId: serializers.commons.NodeId.Raw;
    fullTree: serializers.commons.BinaryTreeValue.Raw;
  }
}
",
                    "name": "BinaryTreeNodeAndTreeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const BinaryTreeNodeValue: core.schemas.ObjectSchema<
  BinaryTreeNodeValue.Raw,
  TraceMyApi.commons.BinaryTreeNodeValue
> = core.schemas.object({
  nodeId: core.schemas.lazy(() => serializers.commons.NodeId),
  val: core.schemas.number(),
  right: core.schemas.lazy(() => serializers.commons.NodeId).optional(),
  left: core.schemas.lazy(() => serializers.commons.NodeId).optional(),
});

export declare namespace BinaryTreeNodeValue {
  interface Raw {
    nodeId: serializers.commons.NodeId.Raw;
    val: number;
    right?: serializers.commons.NodeId.Raw | null;
    left?: serializers.commons.NodeId.Raw | null;
  }
}
",
                    "name": "BinaryTreeNodeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const BinaryTreeValue: core.schemas.ObjectSchema<BinaryTreeValue.Raw, TraceMyApi.commons.BinaryTreeValue> =
  core.schemas.object({
    root: core.schemas.lazy(() => serializers.commons.NodeId).optional(),
    nodes: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(() => serializers.commons.BinaryTreeNodeValue)
    ),
  });

export declare namespace BinaryTreeValue {
  interface Raw {
    root?: serializers.commons.NodeId.Raw | null;
    nodes: Record<serializers.commons.NodeId.Raw, serializers.commons.BinaryTreeNodeValue.Raw>;
  }
}
",
                    "name": "BinaryTreeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const DebugKeyValuePairs: core.schemas.ObjectSchema<
  DebugKeyValuePairs.Raw,
  TraceMyApi.commons.DebugKeyValuePairs
> = core.schemas.object({
  key: core.schemas.lazy(() => serializers.commons.DebugVariableValue),
  value: core.schemas.lazy(() => serializers.commons.DebugVariableValue),
});

export declare namespace DebugKeyValuePairs {
  interface Raw {
    key: serializers.commons.DebugVariableValue.Raw;
    value: serializers.commons.DebugVariableValue.Raw;
  }
}
",
                    "name": "DebugKeyValuePairs.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const DebugMapValue: core.schemas.ObjectSchema<DebugMapValue.Raw, TraceMyApi.commons.DebugMapValue> =
  core.schemas.object({
    keyValuePairs: core.schemas.list(core.schemas.lazyObject(() => serializers.commons.DebugKeyValuePairs)),
  });

export declare namespace DebugMapValue {
  interface Raw {
    keyValuePairs: serializers.commons.DebugKeyValuePairs.Raw[];
  }
}
",
                    "name": "DebugMapValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const DebugVariableValue: core.schemas.Schema<DebugVariableValue.Raw, TraceMyApi.commons.DebugVariableValue> =
  core.schemas
    .union(\\"type\\", {
      integerValue: core.schemas.object({
        value: core.schemas.number(),
      }),
      booleanValue: core.schemas.object({
        value: core.schemas.boolean(),
      }),
      doubleValue: core.schemas.object({
        value: core.schemas.number(),
      }),
      stringValue: core.schemas.object({
        value: core.schemas.string(),
      }),
      charValue: core.schemas.object({
        value: core.schemas.string(),
      }),
      mapValue: core.schemas.lazyObject(() => serializers.commons.DebugMapValue),
      listValue: core.schemas.object({
        value: core.schemas.list(core.schemas.lazy(() => serializers.commons.DebugVariableValue)),
      }),
      binaryTreeNodeValue: core.schemas.lazyObject(() => serializers.commons.BinaryTreeNodeAndTreeValue),
      singlyLinkedListNodeValue: core.schemas.lazyObject(() => serializers.commons.SinglyLinkedListNodeAndListValue),
      doublyLinkedListNodeValue: core.schemas.lazyObject(() => serializers.commons.DoublyLinkedListNodeAndListValue),
      undefinedValue: core.schemas.object({}),
      nullValue: core.schemas.object({}),
      genericValue: core.schemas.lazyObject(() => serializers.commons.GenericValue),
    })
    .transform<TraceMyApi.commons.DebugVariableValue>({
      parse: (value) => {
        switch (value.type) {
          case \\"integerValue\\": {
            return TraceMyApi.commons.DebugVariableValue.integerValue(value.value);
          }
          case \\"booleanValue\\": {
            return TraceMyApi.commons.DebugVariableValue.booleanValue(value.value);
          }
          case \\"doubleValue\\": {
            return TraceMyApi.commons.DebugVariableValue.doubleValue(value.value);
          }
          case \\"stringValue\\": {
            return TraceMyApi.commons.DebugVariableValue.stringValue(value.value);
          }
          case \\"charValue\\": {
            return TraceMyApi.commons.DebugVariableValue.charValue(value.value);
          }
          case \\"mapValue\\": {
            return TraceMyApi.commons.DebugVariableValue.mapValue(value);
          }
          case \\"listValue\\": {
            return TraceMyApi.commons.DebugVariableValue.listValue(value.value);
          }
          case \\"binaryTreeNodeValue\\": {
            return TraceMyApi.commons.DebugVariableValue.binaryTreeNodeValue(value);
          }
          case \\"singlyLinkedListNodeValue\\": {
            return TraceMyApi.commons.DebugVariableValue.singlyLinkedListNodeValue(value);
          }
          case \\"doublyLinkedListNodeValue\\": {
            return TraceMyApi.commons.DebugVariableValue.doublyLinkedListNodeValue(value);
          }
          case \\"undefinedValue\\": {
            return TraceMyApi.commons.DebugVariableValue.undefinedValue();
          }
          case \\"nullValue\\": {
            return TraceMyApi.commons.DebugVariableValue.nullValue();
          }
          case \\"genericValue\\": {
            return TraceMyApi.commons.DebugVariableValue.genericValue(value);
          }
          default: {
            return {
              ...(value as any),
              _visit: (visitor) => visitor._other(value),
            };
          }
        }
      },
      json: (value) => value as any,
    });

export declare namespace DebugVariableValue {
  type Raw =
    | DebugVariableValue.IntegerValue
    | DebugVariableValue.BooleanValue
    | DebugVariableValue.DoubleValue
    | DebugVariableValue.StringValue
    | DebugVariableValue.CharValue
    | DebugVariableValue.MapValue
    | DebugVariableValue.ListValue
    | DebugVariableValue.BinaryTreeNodeValue
    | DebugVariableValue.SinglyLinkedListNodeValue
    | DebugVariableValue.DoublyLinkedListNodeValue
    | DebugVariableValue.UndefinedValue
    | DebugVariableValue.NullValue
    | DebugVariableValue.GenericValue;

  interface IntegerValue {
    type: \\"integerValue\\";
    value: number;
  }

  interface BooleanValue {
    type: \\"booleanValue\\";
    value: boolean;
  }

  interface DoubleValue {
    type: \\"doubleValue\\";
    value: number;
  }

  interface StringValue {
    type: \\"stringValue\\";
    value: string;
  }

  interface CharValue {
    type: \\"charValue\\";
    value: string;
  }

  interface MapValue extends serializers.commons.DebugMapValue.Raw {
    type: \\"mapValue\\";
  }

  interface ListValue {
    type: \\"listValue\\";
    value: serializers.commons.DebugVariableValue.Raw[];
  }

  interface BinaryTreeNodeValue extends serializers.commons.BinaryTreeNodeAndTreeValue.Raw {
    type: \\"binaryTreeNodeValue\\";
  }

  interface SinglyLinkedListNodeValue extends serializers.commons.SinglyLinkedListNodeAndListValue.Raw {
    type: \\"singlyLinkedListNodeValue\\";
  }

  interface DoublyLinkedListNodeValue extends serializers.commons.DoublyLinkedListNodeAndListValue.Raw {
    type: \\"doublyLinkedListNodeValue\\";
  }

  interface UndefinedValue {
    type: \\"undefinedValue\\";
  }

  interface NullValue {
    type: \\"nullValue\\";
  }

  interface GenericValue extends serializers.commons.GenericValue.Raw {
    type: \\"genericValue\\";
  }
}
",
                    "name": "DebugVariableValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const DoublyLinkedListNodeAndListValue: core.schemas.ObjectSchema<
  DoublyLinkedListNodeAndListValue.Raw,
  TraceMyApi.commons.DoublyLinkedListNodeAndListValue
> = core.schemas.object({
  nodeId: core.schemas.lazy(() => serializers.commons.NodeId),
  fullList: core.schemas.lazyObject(() => serializers.commons.DoublyLinkedListValue),
});

export declare namespace DoublyLinkedListNodeAndListValue {
  interface Raw {
    nodeId: serializers.commons.NodeId.Raw;
    fullList: serializers.commons.DoublyLinkedListValue.Raw;
  }
}
",
                    "name": "DoublyLinkedListNodeAndListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const DoublyLinkedListNodeValue: core.schemas.ObjectSchema<
  DoublyLinkedListNodeValue.Raw,
  TraceMyApi.commons.DoublyLinkedListNodeValue
> = core.schemas.object({
  nodeId: core.schemas.lazy(() => serializers.commons.NodeId),
  val: core.schemas.number(),
  next: core.schemas.lazy(() => serializers.commons.NodeId).optional(),
  prev: core.schemas.lazy(() => serializers.commons.NodeId).optional(),
});

export declare namespace DoublyLinkedListNodeValue {
  interface Raw {
    nodeId: serializers.commons.NodeId.Raw;
    val: number;
    next?: serializers.commons.NodeId.Raw | null;
    prev?: serializers.commons.NodeId.Raw | null;
  }
}
",
                    "name": "DoublyLinkedListNodeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const DoublyLinkedListValue: core.schemas.ObjectSchema<
  DoublyLinkedListValue.Raw,
  TraceMyApi.commons.DoublyLinkedListValue
> = core.schemas.object({
  head: core.schemas.lazy(() => serializers.commons.NodeId).optional(),
  nodes: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => serializers.commons.DoublyLinkedListNodeValue)
  ),
});

export declare namespace DoublyLinkedListValue {
  interface Raw {
    head?: serializers.commons.NodeId.Raw | null;
    nodes: Record<serializers.commons.NodeId.Raw, serializers.commons.DoublyLinkedListNodeValue.Raw>;
  }
}
",
                    "name": "DoublyLinkedListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const FileInfo: core.schemas.ObjectSchema<FileInfo.Raw, TraceMyApi.commons.FileInfo> = core.schemas.object({
  filename: core.schemas.string(),
  contents: core.schemas.string(),
});

export declare namespace FileInfo {
  interface Raw {
    filename: string;
    contents: string;
  }
}
",
                    "name": "FileInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const GenericValue: core.schemas.ObjectSchema<GenericValue.Raw, TraceMyApi.commons.GenericValue> =
  core.schemas.object({
    stringifiedType: core.schemas.string().optional(),
    stringifiedValue: core.schemas.string(),
  });

export declare namespace GenericValue {
  interface Raw {
    stringifiedType?: string | null;
    stringifiedValue: string;
  }
}
",
                    "name": "GenericValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const KeyValuePair: core.schemas.ObjectSchema<KeyValuePair.Raw, TraceMyApi.commons.KeyValuePair> =
  core.schemas.object({
    key: core.schemas.lazy(() => serializers.commons.VariableValue),
    value: core.schemas.lazy(() => serializers.commons.VariableValue),
  });

export declare namespace KeyValuePair {
  interface Raw {
    key: serializers.commons.VariableValue.Raw;
    value: serializers.commons.VariableValue.Raw;
  }
}
",
                    "name": "KeyValuePair.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Language: core.schemas.Schema<Language.Raw, TraceMyApi.commons.Language> = core.schemas
  .string()
  .transform<TraceMyApi.commons.Language>({
    parse: (value) => TraceMyApi.commons.Language._parse(value),
    json: ({ value }) => value,
  });

export declare namespace Language {
  type Raw = string;
}
",
                    "name": "Language.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const ListType: core.schemas.ObjectSchema<ListType.Raw, TraceMyApi.commons.ListType> = core.schemas.object({
  valueType: core.schemas.lazy(() => serializers.commons.VariableType),
  isFixedLength: core.schemas.boolean().optional(),
});

export declare namespace ListType {
  interface Raw {
    valueType: serializers.commons.VariableType.Raw;
    isFixedLength?: boolean | null;
  }
}
",
                    "name": "ListType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const MapType: core.schemas.ObjectSchema<MapType.Raw, TraceMyApi.commons.MapType> = core.schemas.object({
  keyType: core.schemas.lazy(() => serializers.commons.VariableType),
  valueType: core.schemas.lazy(() => serializers.commons.VariableType),
});

export declare namespace MapType {
  interface Raw {
    keyType: serializers.commons.VariableType.Raw;
    valueType: serializers.commons.VariableType.Raw;
  }
}
",
                    "name": "MapType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const MapValue: core.schemas.ObjectSchema<MapValue.Raw, TraceMyApi.commons.MapValue> = core.schemas.object({
  keyValuePairs: core.schemas.list(core.schemas.lazyObject(() => serializers.commons.KeyValuePair)),
});

export declare namespace MapValue {
  interface Raw {
    keyValuePairs: serializers.commons.KeyValuePair.Raw[];
  }
}
",
                    "name": "MapValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const NodeId: core.schemas.Schema<NodeId.Raw, TraceMyApi.commons.NodeId> = core.schemas.string();

export declare namespace NodeId {
  type Raw = string;
}
",
                    "name": "NodeId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const ProblemId: core.schemas.Schema<ProblemId.Raw, TraceMyApi.commons.ProblemId> = core.schemas.string();

export declare namespace ProblemId {
  type Raw = string;
}
",
                    "name": "ProblemId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const SinglyLinkedListNodeAndListValue: core.schemas.ObjectSchema<
  SinglyLinkedListNodeAndListValue.Raw,
  TraceMyApi.commons.SinglyLinkedListNodeAndListValue
> = core.schemas.object({
  nodeId: core.schemas.lazy(() => serializers.commons.NodeId),
  fullList: core.schemas.lazyObject(() => serializers.commons.SinglyLinkedListValue),
});

export declare namespace SinglyLinkedListNodeAndListValue {
  interface Raw {
    nodeId: serializers.commons.NodeId.Raw;
    fullList: serializers.commons.SinglyLinkedListValue.Raw;
  }
}
",
                    "name": "SinglyLinkedListNodeAndListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const SinglyLinkedListNodeValue: core.schemas.ObjectSchema<
  SinglyLinkedListNodeValue.Raw,
  TraceMyApi.commons.SinglyLinkedListNodeValue
> = core.schemas.object({
  nodeId: core.schemas.lazy(() => serializers.commons.NodeId),
  val: core.schemas.number(),
  next: core.schemas.lazy(() => serializers.commons.NodeId).optional(),
});

export declare namespace SinglyLinkedListNodeValue {
  interface Raw {
    nodeId: serializers.commons.NodeId.Raw;
    val: number;
    next?: serializers.commons.NodeId.Raw | null;
  }
}
",
                    "name": "SinglyLinkedListNodeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const SinglyLinkedListValue: core.schemas.ObjectSchema<
  SinglyLinkedListValue.Raw,
  TraceMyApi.commons.SinglyLinkedListValue
> = core.schemas.object({
  head: core.schemas.lazy(() => serializers.commons.NodeId).optional(),
  nodes: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => serializers.commons.SinglyLinkedListNodeValue)
  ),
});

export declare namespace SinglyLinkedListValue {
  interface Raw {
    head?: serializers.commons.NodeId.Raw | null;
    nodes: Record<serializers.commons.NodeId.Raw, serializers.commons.SinglyLinkedListNodeValue.Raw>;
  }
}
",
                    "name": "SinglyLinkedListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TestCase: core.schemas.ObjectSchema<TestCase.Raw, TraceMyApi.commons.TestCase> = core.schemas.object({
  id: core.schemas.string(),
  params: core.schemas.list(core.schemas.lazy(() => serializers.commons.VariableValue)),
});

export declare namespace TestCase {
  interface Raw {
    id: string;
    params: serializers.commons.VariableValue.Raw[];
  }
}
",
                    "name": "TestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TestCaseWithExpectedResult: core.schemas.ObjectSchema<
  TestCaseWithExpectedResult.Raw,
  TraceMyApi.commons.TestCaseWithExpectedResult
> = core.schemas.object({
  testCase: core.schemas.lazyObject(() => serializers.commons.TestCase),
  expectedResult: core.schemas.lazy(() => serializers.commons.VariableValue),
});

export declare namespace TestCaseWithExpectedResult {
  interface Raw {
    testCase: serializers.commons.TestCase.Raw;
    expectedResult: serializers.commons.VariableValue.Raw;
  }
}
",
                    "name": "TestCaseWithExpectedResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const UserId: core.schemas.Schema<UserId.Raw, TraceMyApi.commons.UserId> = core.schemas.string();

export declare namespace UserId {
  type Raw = string;
}
",
                    "name": "UserId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const VariableType: core.schemas.Schema<VariableType.Raw, TraceMyApi.commons.VariableType> = core.schemas
  .union(\\"type\\", {
    integerType: core.schemas.object({}),
    doubleType: core.schemas.object({}),
    booleanType: core.schemas.object({}),
    stringType: core.schemas.object({}),
    charType: core.schemas.object({}),
    listType: core.schemas.lazyObject(() => serializers.commons.ListType),
    mapType: core.schemas.lazyObject(() => serializers.commons.MapType),
    binaryTreeType: core.schemas.object({}),
    singlyLinkedListType: core.schemas.object({}),
    doublyLinkedListType: core.schemas.object({}),
  })
  .transform<TraceMyApi.commons.VariableType>({
    parse: (value) => {
      switch (value.type) {
        case \\"integerType\\": {
          return TraceMyApi.commons.VariableType.integerType();
        }
        case \\"doubleType\\": {
          return TraceMyApi.commons.VariableType.doubleType();
        }
        case \\"booleanType\\": {
          return TraceMyApi.commons.VariableType.booleanType();
        }
        case \\"stringType\\": {
          return TraceMyApi.commons.VariableType.stringType();
        }
        case \\"charType\\": {
          return TraceMyApi.commons.VariableType.charType();
        }
        case \\"listType\\": {
          return TraceMyApi.commons.VariableType.listType(value);
        }
        case \\"mapType\\": {
          return TraceMyApi.commons.VariableType.mapType(value);
        }
        case \\"binaryTreeType\\": {
          return TraceMyApi.commons.VariableType.binaryTreeType();
        }
        case \\"singlyLinkedListType\\": {
          return TraceMyApi.commons.VariableType.singlyLinkedListType();
        }
        case \\"doublyLinkedListType\\": {
          return TraceMyApi.commons.VariableType.doublyLinkedListType();
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace VariableType {
  type Raw =
    | VariableType.IntegerType
    | VariableType.DoubleType
    | VariableType.BooleanType
    | VariableType.StringType
    | VariableType.CharType
    | VariableType.ListType
    | VariableType.MapType
    | VariableType.BinaryTreeType
    | VariableType.SinglyLinkedListType
    | VariableType.DoublyLinkedListType;

  interface IntegerType {
    type: \\"integerType\\";
  }

  interface DoubleType {
    type: \\"doubleType\\";
  }

  interface BooleanType {
    type: \\"booleanType\\";
  }

  interface StringType {
    type: \\"stringType\\";
  }

  interface CharType {
    type: \\"charType\\";
  }

  interface ListType extends serializers.commons.ListType.Raw {
    type: \\"listType\\";
  }

  interface MapType extends serializers.commons.MapType.Raw {
    type: \\"mapType\\";
  }

  interface BinaryTreeType {
    type: \\"binaryTreeType\\";
  }

  interface SinglyLinkedListType {
    type: \\"singlyLinkedListType\\";
  }

  interface DoublyLinkedListType {
    type: \\"doublyLinkedListType\\";
  }
}
",
                    "name": "VariableType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const VariableValue: core.schemas.Schema<VariableValue.Raw, TraceMyApi.commons.VariableValue> = core.schemas
  .union(\\"type\\", {
    integerValue: core.schemas.object({
      value: core.schemas.number(),
    }),
    booleanValue: core.schemas.object({
      value: core.schemas.boolean(),
    }),
    doubleValue: core.schemas.object({
      value: core.schemas.number(),
    }),
    stringValue: core.schemas.object({
      value: core.schemas.string(),
    }),
    charValue: core.schemas.object({
      value: core.schemas.string(),
    }),
    mapValue: core.schemas.lazyObject(() => serializers.commons.MapValue),
    listValue: core.schemas.object({
      value: core.schemas.list(core.schemas.lazy(() => serializers.commons.VariableValue)),
    }),
    binaryTreeValue: core.schemas.lazyObject(() => serializers.commons.BinaryTreeValue),
    singlyLinkedListValue: core.schemas.lazyObject(() => serializers.commons.SinglyLinkedListValue),
    doublyLinkedListValue: core.schemas.lazyObject(() => serializers.commons.DoublyLinkedListValue),
    nullValue: core.schemas.object({}),
  })
  .transform<TraceMyApi.commons.VariableValue>({
    parse: (value) => {
      switch (value.type) {
        case \\"integerValue\\": {
          return TraceMyApi.commons.VariableValue.integerValue(value.value);
        }
        case \\"booleanValue\\": {
          return TraceMyApi.commons.VariableValue.booleanValue(value.value);
        }
        case \\"doubleValue\\": {
          return TraceMyApi.commons.VariableValue.doubleValue(value.value);
        }
        case \\"stringValue\\": {
          return TraceMyApi.commons.VariableValue.stringValue(value.value);
        }
        case \\"charValue\\": {
          return TraceMyApi.commons.VariableValue.charValue(value.value);
        }
        case \\"mapValue\\": {
          return TraceMyApi.commons.VariableValue.mapValue(value);
        }
        case \\"listValue\\": {
          return TraceMyApi.commons.VariableValue.listValue(value.value);
        }
        case \\"binaryTreeValue\\": {
          return TraceMyApi.commons.VariableValue.binaryTreeValue(value);
        }
        case \\"singlyLinkedListValue\\": {
          return TraceMyApi.commons.VariableValue.singlyLinkedListValue(value);
        }
        case \\"doublyLinkedListValue\\": {
          return TraceMyApi.commons.VariableValue.doublyLinkedListValue(value);
        }
        case \\"nullValue\\": {
          return TraceMyApi.commons.VariableValue.nullValue();
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace VariableValue {
  type Raw =
    | VariableValue.IntegerValue
    | VariableValue.BooleanValue
    | VariableValue.DoubleValue
    | VariableValue.StringValue
    | VariableValue.CharValue
    | VariableValue.MapValue
    | VariableValue.ListValue
    | VariableValue.BinaryTreeValue
    | VariableValue.SinglyLinkedListValue
    | VariableValue.DoublyLinkedListValue
    | VariableValue.NullValue;

  interface IntegerValue {
    type: \\"integerValue\\";
    value: number;
  }

  interface BooleanValue {
    type: \\"booleanValue\\";
    value: boolean;
  }

  interface DoubleValue {
    type: \\"doubleValue\\";
    value: number;
  }

  interface StringValue {
    type: \\"stringValue\\";
    value: string;
  }

  interface CharValue {
    type: \\"charValue\\";
    value: string;
  }

  interface MapValue extends serializers.commons.MapValue.Raw {
    type: \\"mapValue\\";
  }

  interface ListValue {
    type: \\"listValue\\";
    value: serializers.commons.VariableValue.Raw[];
  }

  interface BinaryTreeValue extends serializers.commons.BinaryTreeValue.Raw {
    type: \\"binaryTreeValue\\";
  }

  interface SinglyLinkedListValue extends serializers.commons.SinglyLinkedListValue.Raw {
    type: \\"singlyLinkedListValue\\";
  }

  interface DoublyLinkedListValue extends serializers.commons.DoublyLinkedListValue.Raw {
    type: \\"doublyLinkedListValue\\";
  }

  interface NullValue {
    type: \\"nullValue\\";
  }
}
",
                    "name": "VariableValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./UserId\\";
export * from \\"./ProblemId\\";
export * from \\"./NodeId\\";
export * from \\"./VariableType\\";
export * from \\"./ListType\\";
export * from \\"./MapType\\";
export * from \\"./VariableValue\\";
export * from \\"./DebugVariableValue\\";
export * from \\"./GenericValue\\";
export * from \\"./MapValue\\";
export * from \\"./KeyValuePair\\";
export * from \\"./BinaryTreeValue\\";
export * from \\"./BinaryTreeNodeValue\\";
export * from \\"./BinaryTreeNodeAndTreeValue\\";
export * from \\"./SinglyLinkedListValue\\";
export * from \\"./SinglyLinkedListNodeValue\\";
export * from \\"./SinglyLinkedListNodeAndListValue\\";
export * from \\"./DoublyLinkedListValue\\";
export * from \\"./DoublyLinkedListNodeValue\\";
export * from \\"./DoublyLinkedListNodeAndListValue\\";
export * from \\"./DebugMapValue\\";
export * from \\"./DebugKeyValuePairs\\";
export * from \\"./TestCase\\";
export * from \\"./TestCaseWithExpectedResult\\";
export * from \\"./FileInfo\\";
export * from \\"./Language\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "commons",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<serializers.commons.ProblemId.Raw[], TraceMyApi.commons.ProblemId[]> =
  core.schemas.list(core.schemas.lazy(() => serializers.commons.ProblemId));
",
                    "name": "getHomepageProblems.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getHomepageProblems from \\"./getHomepageProblems\\";
export * as setHomepageProblems from \\"./setHomepageProblems\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<serializers.commons.ProblemId.Raw[], TraceMyApi.commons.ProblemId[]> =
  core.schemas.list(core.schemas.lazy(() => serializers.commons.ProblemId));
",
                    "name": "setHomepageProblems.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "homepage",
            "type": "directory",
          },
          Object {
            "contents": "export * as admin from \\"./admin\\";
export * from \\"./admin/types\\";
export * as commons from \\"./commons\\";
export * from \\"./commons/types\\";
export * as langServer from \\"./langServer\\";
export * from \\"./langServer/types\\";
export * as migration from \\"./migration\\";
export * from \\"./migration/types\\";
export * as playlist from \\"./playlist\\";
export * from \\"./playlist/types\\";
export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as submission from \\"./submission\\";
export * from \\"./submission/types\\";
export * as v2 from \\"./v2\\";
export * from \\"./playlist/errors\\";
export * as homepage from \\"./homepage\\";
export * as sysprop from \\"./sysprop\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const LangServerRequest: core.schemas.ObjectSchema<
  LangServerRequest.Raw,
  TraceMyApi.langServer.LangServerRequest
> = core.schemas.object({
  request: core.schemas.unknown(),
});

export declare namespace LangServerRequest {
  interface Raw {
    request?: unknown;
  }
}
",
                    "name": "LangServerRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const LangServerResponse: core.schemas.ObjectSchema<
  LangServerResponse.Raw,
  TraceMyApi.langServer.LangServerResponse
> = core.schemas.object({
  response: core.schemas.unknown(),
});

export declare namespace LangServerResponse {
  interface Raw {
    response?: unknown;
  }
}
",
                    "name": "LangServerResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./LangServerRequest\\";
export * from \\"./LangServerResponse\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "langServer",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<serializers.migration.Migration.Raw[], TraceMyApi.migration.Migration[]> =
  core.schemas.list(core.schemas.lazyObject(() => serializers.migration.Migration));
",
                    "name": "getAttemptedMigrations.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getAttemptedMigrations from \\"./getAttemptedMigrations\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const Migration: core.schemas.ObjectSchema<Migration.Raw, TraceMyApi.migration.Migration> = core.schemas.object({
  name: core.schemas.string(),
  status: core.schemas.lazy(() => serializers.migration.MigrationStatus),
});

export declare namespace Migration {
  interface Raw {
    name: string;
    status: serializers.migration.MigrationStatus.Raw;
  }
}
",
                    "name": "Migration.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const MigrationStatus: core.schemas.Schema<MigrationStatus.Raw, TraceMyApi.migration.MigrationStatus> =
  core.schemas.string().transform<TraceMyApi.migration.MigrationStatus>({
    parse: (value) => TraceMyApi.migration.MigrationStatus._parse(value),
    json: ({ value }) => value,
  });

export declare namespace MigrationStatus {
  type Raw = string;
}
",
                    "name": "MigrationStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./MigrationStatus\\";
export * from \\"./Migration\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "migration",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const Error: core.schemas.Schema<Error.Raw, TraceMyApi.playlist.getPlaylist.Error> = core.schemas
  .union(\\"errorName\\", {
    PlaylistIdNotFoundError: core.schemas.object({
      content: core.schemas.lazy(() => serializers.playlist.PlaylistIdNotFoundError),
    }),
    UnauthorizedError: core.schemas.object({}),
  })
  .transform<TraceMyApi.playlist.getPlaylist.Error>({
    parse: (value) => {
      switch (value.errorName) {
        case \\"PlaylistIdNotFoundError\\": {
          return TraceMyApi.playlist.getPlaylist.Error.playlistIdNotFoundError(value.content);
        }
        case \\"UnauthorizedError\\": {
          return TraceMyApi.playlist.getPlaylist.Error.unauthorizedError();
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace Error {
  type Raw = Error.PlaylistIdNotFoundError | Error.UnauthorizedError;

  interface PlaylistIdNotFoundError {
    errorName: \\"PlaylistIdNotFoundError\\";
    content: serializers.playlist.PlaylistIdNotFoundError.Raw;
  }

  interface UnauthorizedError {
    errorName: \\"UnauthorizedError\\";
  }
}
",
                    "name": "getPlaylist.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<serializers.playlist.Playlist.Raw[], TraceMyApi.playlist.Playlist[]> =
  core.schemas.list(core.schemas.lazyObject(() => serializers.playlist.Playlist));
",
                    "name": "getPlaylists.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getPlaylists from \\"./getPlaylists\\";
export * as getPlaylist from \\"./getPlaylist\\";
export * as updatePlaylist from \\"./updatePlaylist\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.playlist.UpdatePlaylistRequest.Raw | null | undefined,
  TraceMyApi.playlist.UpdatePlaylistRequest | undefined
> = core.schemas.lazyObject(() => serializers.playlist.UpdatePlaylistRequest).optional();
export const Response: core.schemas.Schema<
  serializers.playlist.Playlist.Raw | null | undefined,
  TraceMyApi.playlist.Playlist | undefined
> = core.schemas.lazyObject(() => serializers.playlist.Playlist).optional();
export const Error: core.schemas.Schema<Error.Raw, TraceMyApi.playlist.updatePlaylist.Error> = core.schemas
  .union(\\"errorName\\", {
    PlaylistIdNotFoundError: core.schemas.object({
      content: core.schemas.lazy(() => serializers.playlist.PlaylistIdNotFoundError),
    }),
  })
  .transform<TraceMyApi.playlist.updatePlaylist.Error>({
    parse: (value) => {
      switch (value.errorName) {
        case \\"PlaylistIdNotFoundError\\": {
          return TraceMyApi.playlist.updatePlaylist.Error.playlistIdNotFoundError(value.content);
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace Error {
  type Raw = Error.PlaylistIdNotFoundError;

  interface PlaylistIdNotFoundError {
    errorName: \\"PlaylistIdNotFoundError\\";
    content: serializers.playlist.PlaylistIdNotFoundError.Raw;
  }
}
",
                    "name": "updatePlaylist.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const PlaylistIdNotFoundError: core.schemas.Schema<
  PlaylistIdNotFoundError.Raw,
  TraceMyApi.playlist.PlaylistIdNotFoundError
> = core.schemas.lazy(() => serializers.playlist.PlaylistIdNotFoundErrorBody);

export declare namespace PlaylistIdNotFoundError {
  type Raw = serializers.playlist.PlaylistIdNotFoundErrorBody.Raw;
}
",
                    "name": "PlaylistIdNotFoundError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./PlaylistIdNotFoundError\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "errors",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./errors\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const Playlist: core.schemas.ObjectSchema<Playlist.Raw, TraceMyApi.playlist.Playlist> = core.schemas
  .object({
    playlistId: core.schemas.property(
      \\"playlist_id\\",
      core.schemas.lazy(() => serializers.playlist.PlaylistId)
    ),
    ownerId: core.schemas.property(
      \\"owner-id\\",
      core.schemas.lazy(() => serializers.commons.UserId)
    ),
  })
  .extend(core.schemas.lazyObject(() => serializers.playlist.PlaylistCreateRequest));

export declare namespace Playlist {
  interface Raw extends serializers.playlist.PlaylistCreateRequest.Raw {
    playlist_id: serializers.playlist.PlaylistId.Raw;
    \\"owner-id\\": serializers.commons.UserId.Raw;
  }
}
",
                    "name": "Playlist.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const PlaylistCreateRequest: core.schemas.ObjectSchema<
  PlaylistCreateRequest.Raw,
  TraceMyApi.playlist.PlaylistCreateRequest
> = core.schemas.object({
  name: core.schemas.string(),
  problems: core.schemas.list(core.schemas.lazy(() => serializers.commons.ProblemId)),
});

export declare namespace PlaylistCreateRequest {
  interface Raw {
    name: string;
    problems: serializers.commons.ProblemId.Raw[];
  }
}
",
                    "name": "PlaylistCreateRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const PlaylistId: core.schemas.Schema<PlaylistId.Raw, TraceMyApi.playlist.PlaylistId> = core.schemas.string();

export declare namespace PlaylistId {
  type Raw = string;
}
",
                    "name": "PlaylistId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const PlaylistIdNotFoundErrorBody: core.schemas.Schema<
  PlaylistIdNotFoundErrorBody.Raw,
  TraceMyApi.playlist.PlaylistIdNotFoundErrorBody
> = core.schemas
  .union(\\"type\\", {
    playlistId: core.schemas.object({
      value: core.schemas.lazy(() => serializers.playlist.PlaylistId),
    }),
  })
  .transform<TraceMyApi.playlist.PlaylistIdNotFoundErrorBody>({
    parse: (value) => {
      switch (value.type) {
        case \\"playlistId\\": {
          return TraceMyApi.playlist.PlaylistIdNotFoundErrorBody.playlistId(value.value);
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace PlaylistIdNotFoundErrorBody {
  type Raw = PlaylistIdNotFoundErrorBody.PlaylistId;

  interface PlaylistId {
    type: \\"playlistId\\";
    value: serializers.playlist.PlaylistId.Raw;
  }
}
",
                    "name": "PlaylistIdNotFoundErrorBody.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const ReservedKeywordEnum: core.schemas.Schema<
  ReservedKeywordEnum.Raw,
  TraceMyApi.playlist.ReservedKeywordEnum
> = core.schemas.string().transform<TraceMyApi.playlist.ReservedKeywordEnum>({
  parse: (value) => TraceMyApi.playlist.ReservedKeywordEnum._parse(value),
  json: ({ value }) => value,
});

export declare namespace ReservedKeywordEnum {
  type Raw = string;
}
",
                    "name": "ReservedKeywordEnum.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const UpdatePlaylistRequest: core.schemas.ObjectSchema<
  UpdatePlaylistRequest.Raw,
  TraceMyApi.playlist.UpdatePlaylistRequest
> = core.schemas.object({
  name: core.schemas.string(),
  problems: core.schemas.list(core.schemas.lazy(() => serializers.commons.ProblemId)),
});

export declare namespace UpdatePlaylistRequest {
  interface Raw {
    name: string;
    problems: serializers.commons.ProblemId.Raw[];
  }
}
",
                    "name": "UpdatePlaylistRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./PlaylistId\\";
export * from \\"./Playlist\\";
export * from \\"./PlaylistCreateRequest\\";
export * from \\"./UpdatePlaylistRequest\\";
export * from \\"./PlaylistIdNotFoundErrorBody\\";
export * from \\"./ReservedKeywordEnum\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "playlist",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const CreateProblemError: core.schemas.Schema<CreateProblemError.Raw, TraceMyApi.problem.CreateProblemError> =
  core.schemas
    .union(core.schemas.discriminant(\\"errorType\\", \\"_type\\"), {
      generic: core.schemas.lazyObject(() => serializers.problem.GenericCreateProblemError),
    })
    .transform<TraceMyApi.problem.CreateProblemError>({
      parse: (value) => {
        switch (value.errorType) {
          case \\"generic\\": {
            return TraceMyApi.problem.CreateProblemError.generic(value);
          }
          default: {
            return {
              ...(value as any),
              _visit: (visitor) => visitor._other(value),
            };
          }
        }
      },
      json: (value) => value as any,
    });

export declare namespace CreateProblemError {
  type Raw = CreateProblemError.Generic;

  interface Generic extends serializers.problem.GenericCreateProblemError.Raw {
    _type: \\"generic\\";
  }
}
",
                    "name": "CreateProblemError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const CreateProblemRequest: core.schemas.ObjectSchema<
  CreateProblemRequest.Raw,
  TraceMyApi.problem.CreateProblemRequest
> = core.schemas.object({
  problemName: core.schemas.string(),
  problemDescription: core.schemas.lazyObject(() => serializers.problem.ProblemDescription),
  files: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => serializers.problem.ProblemFiles)
  ),
  inputParams: core.schemas.list(core.schemas.lazyObject(() => serializers.problem.VariableTypeAndName)),
  outputType: core.schemas.lazy(() => serializers.commons.VariableType),
  testcases: core.schemas.list(core.schemas.lazyObject(() => serializers.commons.TestCaseWithExpectedResult)),
  methodName: core.schemas.string(),
});

export declare namespace CreateProblemRequest {
  interface Raw {
    problemName: string;
    problemDescription: serializers.problem.ProblemDescription.Raw;
    files: Record<serializers.commons.Language.Raw, serializers.problem.ProblemFiles.Raw>;
    inputParams: serializers.problem.VariableTypeAndName.Raw[];
    outputType: serializers.commons.VariableType.Raw;
    testcases: serializers.commons.TestCaseWithExpectedResult.Raw[];
    methodName: string;
  }
}
",
                    "name": "CreateProblemRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const CreateProblemResponse: core.schemas.Schema<
  CreateProblemResponse.Raw,
  TraceMyApi.problem.CreateProblemResponse
> = core.schemas
  .union(\\"type\\", {
    success: core.schemas.object({
      value: core.schemas.lazy(() => serializers.commons.ProblemId),
    }),
    error: core.schemas.object({
      value: core.schemas.lazy(() => serializers.problem.CreateProblemError),
    }),
  })
  .transform<TraceMyApi.problem.CreateProblemResponse>({
    parse: (value) => {
      switch (value.type) {
        case \\"success\\": {
          return TraceMyApi.problem.CreateProblemResponse.success(value.value);
        }
        case \\"error\\": {
          return TraceMyApi.problem.CreateProblemResponse.error(value.value);
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace CreateProblemResponse {
  type Raw = CreateProblemResponse.Success | CreateProblemResponse.Error;

  interface Success {
    type: \\"success\\";
    value: serializers.commons.ProblemId.Raw;
  }

  interface Error {
    type: \\"error\\";
    value: serializers.problem.CreateProblemError.Raw;
  }
}
",
                    "name": "CreateProblemResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const GenericCreateProblemError: core.schemas.ObjectSchema<
  GenericCreateProblemError.Raw,
  TraceMyApi.problem.GenericCreateProblemError
> = core.schemas.object({
  message: core.schemas.string(),
  type: core.schemas.string(),
  stacktrace: core.schemas.string(),
});

export declare namespace GenericCreateProblemError {
  interface Raw {
    message: string;
    type: string;
    stacktrace: string;
  }
}
",
                    "name": "GenericCreateProblemError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const GetDefaultStarterFilesRequest: core.schemas.ObjectSchema<
  GetDefaultStarterFilesRequest.Raw,
  TraceMyApi.problem.GetDefaultStarterFilesRequest
> = core.schemas.object({
  inputParams: core.schemas.list(core.schemas.lazyObject(() => serializers.problem.VariableTypeAndName)),
  outputType: core.schemas.lazy(() => serializers.commons.VariableType),
  methodName: core.schemas.string(),
});

export declare namespace GetDefaultStarterFilesRequest {
  interface Raw {
    inputParams: serializers.problem.VariableTypeAndName.Raw[];
    outputType: serializers.commons.VariableType.Raw;
    methodName: string;
  }
}
",
                    "name": "GetDefaultStarterFilesRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const GetDefaultStarterFilesResponse: core.schemas.ObjectSchema<
  GetDefaultStarterFilesResponse.Raw,
  TraceMyApi.problem.GetDefaultStarterFilesResponse
> = core.schemas.object({
  files: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => serializers.problem.ProblemFiles)
  ),
});

export declare namespace GetDefaultStarterFilesResponse {
  interface Raw {
    files: Record<serializers.commons.Language.Raw, serializers.problem.ProblemFiles.Raw>;
  }
}
",
                    "name": "GetDefaultStarterFilesResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const ProblemDescription: core.schemas.ObjectSchema<
  ProblemDescription.Raw,
  TraceMyApi.problem.ProblemDescription
> = core.schemas.object({
  boards: core.schemas.list(core.schemas.lazy(() => serializers.problem.ProblemDescriptionBoard)),
});

export declare namespace ProblemDescription {
  interface Raw {
    boards: serializers.problem.ProblemDescriptionBoard.Raw[];
  }
}
",
                    "name": "ProblemDescription.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const ProblemDescriptionBoard: core.schemas.Schema<
  ProblemDescriptionBoard.Raw,
  TraceMyApi.problem.ProblemDescriptionBoard
> = core.schemas
  .union(\\"type\\", {
    html: core.schemas.object({
      value: core.schemas.string(),
    }),
    variable: core.schemas.object({
      value: core.schemas.lazy(() => serializers.commons.VariableValue),
    }),
    testCaseId: core.schemas.object({
      value: core.schemas.string(),
    }),
  })
  .transform<TraceMyApi.problem.ProblemDescriptionBoard>({
    parse: (value) => {
      switch (value.type) {
        case \\"html\\": {
          return TraceMyApi.problem.ProblemDescriptionBoard.html(value.value);
        }
        case \\"variable\\": {
          return TraceMyApi.problem.ProblemDescriptionBoard.variable(value.value);
        }
        case \\"testCaseId\\": {
          return TraceMyApi.problem.ProblemDescriptionBoard.testCaseId(value.value);
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace ProblemDescriptionBoard {
  type Raw = ProblemDescriptionBoard.Html | ProblemDescriptionBoard.Variable | ProblemDescriptionBoard.TestCaseId;

  interface Html {
    type: \\"html\\";
    value: string;
  }

  interface Variable {
    type: \\"variable\\";
    value: serializers.commons.VariableValue.Raw;
  }

  interface TestCaseId {
    type: \\"testCaseId\\";
    value: string;
  }
}
",
                    "name": "ProblemDescriptionBoard.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const ProblemFiles: core.schemas.ObjectSchema<ProblemFiles.Raw, TraceMyApi.problem.ProblemFiles> =
  core.schemas.object({
    solutionFile: core.schemas.lazyObject(() => serializers.commons.FileInfo),
    readOnlyFiles: core.schemas.list(core.schemas.lazyObject(() => serializers.commons.FileInfo)),
  });

export declare namespace ProblemFiles {
  interface Raw {
    solutionFile: serializers.commons.FileInfo.Raw;
    readOnlyFiles: serializers.commons.FileInfo.Raw[];
  }
}
",
                    "name": "ProblemFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const ProblemInfo: core.schemas.ObjectSchema<ProblemInfo.Raw, TraceMyApi.problem.ProblemInfo> =
  core.schemas.object({
    problemId: core.schemas.lazy(() => serializers.commons.ProblemId),
    problemDescription: core.schemas.lazyObject(() => serializers.problem.ProblemDescription),
    problemName: core.schemas.string(),
    problemVersion: core.schemas.number(),
    files: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(() => serializers.problem.ProblemFiles)
    ),
    inputParams: core.schemas.list(core.schemas.lazyObject(() => serializers.problem.VariableTypeAndName)),
    outputType: core.schemas.lazy(() => serializers.commons.VariableType),
    testcases: core.schemas.list(core.schemas.lazyObject(() => serializers.commons.TestCaseWithExpectedResult)),
    methodName: core.schemas.string(),
    supportsCustomTestCases: core.schemas.boolean(),
  });

export declare namespace ProblemInfo {
  interface Raw {
    problemId: serializers.commons.ProblemId.Raw;
    problemDescription: serializers.problem.ProblemDescription.Raw;
    problemName: string;
    problemVersion: number;
    files: Record<serializers.commons.Language.Raw, serializers.problem.ProblemFiles.Raw>;
    inputParams: serializers.problem.VariableTypeAndName.Raw[];
    outputType: serializers.commons.VariableType.Raw;
    testcases: serializers.commons.TestCaseWithExpectedResult.Raw[];
    methodName: string;
    supportsCustomTestCases: boolean;
  }
}
",
                    "name": "ProblemInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const UpdateProblemResponse: core.schemas.ObjectSchema<
  UpdateProblemResponse.Raw,
  TraceMyApi.problem.UpdateProblemResponse
> = core.schemas.object({
  problemVersion: core.schemas.number(),
});

export declare namespace UpdateProblemResponse {
  interface Raw {
    problemVersion: number;
  }
}
",
                    "name": "UpdateProblemResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const VariableTypeAndName: core.schemas.ObjectSchema<
  VariableTypeAndName.Raw,
  TraceMyApi.problem.VariableTypeAndName
> = core.schemas.object({
  variableType: core.schemas.lazy(() => serializers.commons.VariableType),
  name: core.schemas.string(),
});

export declare namespace VariableTypeAndName {
  interface Raw {
    variableType: serializers.commons.VariableType.Raw;
    name: string;
  }
}
",
                    "name": "VariableTypeAndName.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./ProblemInfo\\";
export * from \\"./ProblemDescription\\";
export * from \\"./ProblemDescriptionBoard\\";
export * from \\"./ProblemFiles\\";
export * from \\"./VariableTypeAndName\\";
export * from \\"./CreateProblemRequest\\";
export * from \\"./CreateProblemResponse\\";
export * from \\"./UpdateProblemResponse\\";
export * from \\"./CreateProblemError\\";
export * from \\"./GenericCreateProblemError\\";
export * from \\"./GetDefaultStarterFilesRequest\\";
export * from \\"./GetDefaultStarterFilesResponse\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "problem",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  serializers.submission.ExecutionSessionResponse.Raw | null | undefined,
  TraceMyApi.submission.ExecutionSessionResponse | undefined
> = core.schemas.lazyObject(() => serializers.submission.ExecutionSessionResponse).optional();
",
                    "name": "getExecutionSession.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getExecutionSession from \\"./getExecutionSession\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const ActualResult: core.schemas.Schema<ActualResult.Raw, TraceMyApi.submission.ActualResult> = core.schemas
  .union(\\"type\\", {
    value: core.schemas.object({
      value: core.schemas.lazy(() => serializers.commons.VariableValue),
    }),
    exception: core.schemas.lazyObject(() => serializers.submission.ExceptionInfo),
    exceptionV2: core.schemas.object({
      value: core.schemas.lazy(() => serializers.submission.ExceptionV2),
    }),
  })
  .transform<TraceMyApi.submission.ActualResult>({
    parse: (value) => {
      switch (value.type) {
        case \\"value\\": {
          return TraceMyApi.submission.ActualResult.value(value.value);
        }
        case \\"exception\\": {
          return TraceMyApi.submission.ActualResult.exception(value);
        }
        case \\"exceptionV2\\": {
          return TraceMyApi.submission.ActualResult.exceptionV2(value.value);
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace ActualResult {
  type Raw = ActualResult.Value | ActualResult.Exception | ActualResult.ExceptionV2;

  interface Value {
    type: \\"value\\";
    value: serializers.commons.VariableValue.Raw;
  }

  interface Exception extends serializers.submission.ExceptionInfo.Raw {
    type: \\"exception\\";
  }

  interface ExceptionV2 {
    type: \\"exceptionV2\\";
    value: serializers.submission.ExceptionV2.Raw;
  }
}
",
                    "name": "ActualResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const BuildingExecutorResponse: core.schemas.ObjectSchema<
  BuildingExecutorResponse.Raw,
  TraceMyApi.submission.BuildingExecutorResponse
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => serializers.submission.SubmissionId),
  status: core.schemas.lazy(() => serializers.submission.ExecutionSessionStatus),
});

export declare namespace BuildingExecutorResponse {
  interface Raw {
    submissionId: serializers.submission.SubmissionId.Raw;
    status: serializers.submission.ExecutionSessionStatus.Raw;
  }
}
",
                    "name": "BuildingExecutorResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const CodeExecutionUpdate: core.schemas.Schema<
  CodeExecutionUpdate.Raw,
  TraceMyApi.submission.CodeExecutionUpdate
> = core.schemas
  .union(\\"type\\", {
    buildingExecutor: core.schemas.lazyObject(() => serializers.submission.BuildingExecutorResponse),
    running: core.schemas.lazyObject(() => serializers.submission.RunningResponse),
    errored: core.schemas.lazyObject(() => serializers.submission.ErroredResponse),
    stopped: core.schemas.lazyObject(() => serializers.submission.StoppedResponse),
    graded: core.schemas.lazyObject(() => serializers.submission.GradedResponse),
    gradedV2: core.schemas.lazyObject(() => serializers.submission.GradedResponseV2),
    workspaceRan: core.schemas.lazyObject(() => serializers.submission.WorkspaceRanResponse),
    recording: core.schemas.lazyObject(() => serializers.submission.RecordingResponseNotification),
    recorded: core.schemas.lazyObject(() => serializers.submission.RecordedResponseNotification),
    invalidRequest: core.schemas.lazyObject(() => serializers.submission.InvalidRequestResponse),
    finished: core.schemas.lazyObject(() => serializers.submission.FinishedResponse),
  })
  .transform<TraceMyApi.submission.CodeExecutionUpdate>({
    parse: (value) => {
      switch (value.type) {
        case \\"buildingExecutor\\": {
          return TraceMyApi.submission.CodeExecutionUpdate.buildingExecutor(value);
        }
        case \\"running\\": {
          return TraceMyApi.submission.CodeExecutionUpdate.running(value);
        }
        case \\"errored\\": {
          return TraceMyApi.submission.CodeExecutionUpdate.errored(value);
        }
        case \\"stopped\\": {
          return TraceMyApi.submission.CodeExecutionUpdate.stopped(value);
        }
        case \\"graded\\": {
          return TraceMyApi.submission.CodeExecutionUpdate.graded(value);
        }
        case \\"gradedV2\\": {
          return TraceMyApi.submission.CodeExecutionUpdate.gradedV2(value);
        }
        case \\"workspaceRan\\": {
          return TraceMyApi.submission.CodeExecutionUpdate.workspaceRan(value);
        }
        case \\"recording\\": {
          return TraceMyApi.submission.CodeExecutionUpdate.recording(value);
        }
        case \\"recorded\\": {
          return TraceMyApi.submission.CodeExecutionUpdate.recorded(value);
        }
        case \\"invalidRequest\\": {
          return TraceMyApi.submission.CodeExecutionUpdate.invalidRequest(value);
        }
        case \\"finished\\": {
          return TraceMyApi.submission.CodeExecutionUpdate.finished(value);
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace CodeExecutionUpdate {
  type Raw =
    | CodeExecutionUpdate.BuildingExecutor
    | CodeExecutionUpdate.Running
    | CodeExecutionUpdate.Errored
    | CodeExecutionUpdate.Stopped
    | CodeExecutionUpdate.Graded
    | CodeExecutionUpdate.GradedV2
    | CodeExecutionUpdate.WorkspaceRan
    | CodeExecutionUpdate.Recording
    | CodeExecutionUpdate.Recorded
    | CodeExecutionUpdate.InvalidRequest
    | CodeExecutionUpdate.Finished;

  interface BuildingExecutor extends serializers.submission.BuildingExecutorResponse.Raw {
    type: \\"buildingExecutor\\";
  }

  interface Running extends serializers.submission.RunningResponse.Raw {
    type: \\"running\\";
  }

  interface Errored extends serializers.submission.ErroredResponse.Raw {
    type: \\"errored\\";
  }

  interface Stopped extends serializers.submission.StoppedResponse.Raw {
    type: \\"stopped\\";
  }

  interface Graded extends serializers.submission.GradedResponse.Raw {
    type: \\"graded\\";
  }

  interface GradedV2 extends serializers.submission.GradedResponseV2.Raw {
    type: \\"gradedV2\\";
  }

  interface WorkspaceRan extends serializers.submission.WorkspaceRanResponse.Raw {
    type: \\"workspaceRan\\";
  }

  interface Recording extends serializers.submission.RecordingResponseNotification.Raw {
    type: \\"recording\\";
  }

  interface Recorded extends serializers.submission.RecordedResponseNotification.Raw {
    type: \\"recorded\\";
  }

  interface InvalidRequest extends serializers.submission.InvalidRequestResponse.Raw {
    type: \\"invalidRequest\\";
  }

  interface Finished extends serializers.submission.FinishedResponse.Raw {
    type: \\"finished\\";
  }
}
",
                    "name": "CodeExecutionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const CompileError: core.schemas.ObjectSchema<CompileError.Raw, TraceMyApi.submission.CompileError> =
  core.schemas.object({
    message: core.schemas.string(),
  });

export declare namespace CompileError {
  interface Raw {
    message: string;
  }
}
",
                    "name": "CompileError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const CustomTestCasesUnsupported: core.schemas.ObjectSchema<
  CustomTestCasesUnsupported.Raw,
  TraceMyApi.submission.CustomTestCasesUnsupported
> = core.schemas.object({
  problemId: core.schemas.lazy(() => serializers.commons.ProblemId),
  submissionId: core.schemas.lazy(() => serializers.submission.SubmissionId),
});

export declare namespace CustomTestCasesUnsupported {
  interface Raw {
    problemId: serializers.commons.ProblemId.Raw;
    submissionId: serializers.submission.SubmissionId.Raw;
  }
}
",
                    "name": "CustomTestCasesUnsupported.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const ErrorInfo: core.schemas.Schema<ErrorInfo.Raw, TraceMyApi.submission.ErrorInfo> = core.schemas
  .union(\\"type\\", {
    compileError: core.schemas.lazyObject(() => serializers.submission.CompileError),
    runtimeError: core.schemas.lazyObject(() => serializers.submission.RuntimeError),
    internalError: core.schemas.lazyObject(() => serializers.submission.InternalError),
  })
  .transform<TraceMyApi.submission.ErrorInfo>({
    parse: (value) => {
      switch (value.type) {
        case \\"compileError\\": {
          return TraceMyApi.submission.ErrorInfo.compileError(value);
        }
        case \\"runtimeError\\": {
          return TraceMyApi.submission.ErrorInfo.runtimeError(value);
        }
        case \\"internalError\\": {
          return TraceMyApi.submission.ErrorInfo.internalError(value);
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace ErrorInfo {
  type Raw = ErrorInfo.CompileError | ErrorInfo.RuntimeError | ErrorInfo.InternalError;

  interface CompileError extends serializers.submission.CompileError.Raw {
    type: \\"compileError\\";
  }

  interface RuntimeError extends serializers.submission.RuntimeError.Raw {
    type: \\"runtimeError\\";
  }

  interface InternalError extends serializers.submission.InternalError.Raw {
    type: \\"internalError\\";
  }
}
",
                    "name": "ErrorInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const ErroredResponse: core.schemas.ObjectSchema<ErroredResponse.Raw, TraceMyApi.submission.ErroredResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => serializers.submission.SubmissionId),
    errorInfo: core.schemas.lazy(() => serializers.submission.ErrorInfo),
  });

export declare namespace ErroredResponse {
  interface Raw {
    submissionId: serializers.submission.SubmissionId.Raw;
    errorInfo: serializers.submission.ErrorInfo.Raw;
  }
}
",
                    "name": "ErroredResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const ExceptionInfo: core.schemas.ObjectSchema<ExceptionInfo.Raw, TraceMyApi.submission.ExceptionInfo> =
  core.schemas.object({
    exceptionType: core.schemas.string(),
    exceptionMessage: core.schemas.string(),
    exceptionStacktrace: core.schemas.string(),
  });

export declare namespace ExceptionInfo {
  interface Raw {
    exceptionType: string;
    exceptionMessage: string;
    exceptionStacktrace: string;
  }
}
",
                    "name": "ExceptionInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const ExceptionV2: core.schemas.Schema<ExceptionV2.Raw, TraceMyApi.submission.ExceptionV2> = core.schemas
  .union(\\"type\\", {
    generic: core.schemas.lazyObject(() => serializers.submission.ExceptionInfo),
    timeout: core.schemas.object({}),
  })
  .transform<TraceMyApi.submission.ExceptionV2>({
    parse: (value) => {
      switch (value.type) {
        case \\"generic\\": {
          return TraceMyApi.submission.ExceptionV2.generic(value);
        }
        case \\"timeout\\": {
          return TraceMyApi.submission.ExceptionV2.timeout();
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace ExceptionV2 {
  type Raw = ExceptionV2.Generic | ExceptionV2.Timeout;

  interface Generic extends serializers.submission.ExceptionInfo.Raw {
    type: \\"generic\\";
  }

  interface Timeout {
    type: \\"timeout\\";
  }
}
",
                    "name": "ExceptionV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const ExecutionSessionResponse: core.schemas.ObjectSchema<
  ExecutionSessionResponse.Raw,
  TraceMyApi.submission.ExecutionSessionResponse
> = core.schemas.object({
  sessionId: core.schemas.string(),
  executionSessionUrl: core.schemas.string().optional(),
  language: core.schemas.lazy(() => serializers.commons.Language),
  status: core.schemas.lazy(() => serializers.submission.ExecutionSessionStatus),
});

export declare namespace ExecutionSessionResponse {
  interface Raw {
    sessionId: string;
    executionSessionUrl?: string | null;
    language: serializers.commons.Language.Raw;
    status: serializers.submission.ExecutionSessionStatus.Raw;
  }
}
",
                    "name": "ExecutionSessionResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const ExecutionSessionState: core.schemas.ObjectSchema<
  ExecutionSessionState.Raw,
  TraceMyApi.submission.ExecutionSessionState
> = core.schemas.object({
  lastTimeContacted: core.schemas.string().optional(),
  sessionId: core.schemas.string(),
  isWarmInstance: core.schemas.boolean(),
  awsTaskId: core.schemas.string().optional(),
  language: core.schemas.lazy(() => serializers.commons.Language),
  status: core.schemas.lazy(() => serializers.submission.ExecutionSessionStatus),
});

export declare namespace ExecutionSessionState {
  interface Raw {
    lastTimeContacted?: string | null;
    sessionId: string;
    isWarmInstance: boolean;
    awsTaskId?: string | null;
    language: serializers.commons.Language.Raw;
    status: serializers.submission.ExecutionSessionStatus.Raw;
  }
}
",
                    "name": "ExecutionSessionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const ExecutionSessionStatus: core.schemas.Schema<
  ExecutionSessionStatus.Raw,
  TraceMyApi.submission.ExecutionSessionStatus
> = core.schemas.string().transform<TraceMyApi.submission.ExecutionSessionStatus>({
  parse: (value) => TraceMyApi.submission.ExecutionSessionStatus._parse(value),
  json: ({ value }) => value,
});

export declare namespace ExecutionSessionStatus {
  type Raw = string;
}
",
                    "name": "ExecutionSessionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const ExistingSubmissionExecuting: core.schemas.ObjectSchema<
  ExistingSubmissionExecuting.Raw,
  TraceMyApi.submission.ExistingSubmissionExecuting
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => serializers.submission.SubmissionId),
});

export declare namespace ExistingSubmissionExecuting {
  interface Raw {
    submissionId: serializers.submission.SubmissionId.Raw;
  }
}
",
                    "name": "ExistingSubmissionExecuting.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const ExpressionLocation: core.schemas.ObjectSchema<
  ExpressionLocation.Raw,
  TraceMyApi.submission.ExpressionLocation
> = core.schemas.object({
  start: core.schemas.number(),
  offset: core.schemas.number(),
});

export declare namespace ExpressionLocation {
  interface Raw {
    start: number;
    offset: number;
  }
}
",
                    "name": "ExpressionLocation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const FinishedResponse: core.schemas.ObjectSchema<FinishedResponse.Raw, TraceMyApi.submission.FinishedResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => serializers.submission.SubmissionId),
  });

export declare namespace FinishedResponse {
  interface Raw {
    submissionId: serializers.submission.SubmissionId.Raw;
  }
}
",
                    "name": "FinishedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const GetExecutionSessionStateResponse: core.schemas.ObjectSchema<
  GetExecutionSessionStateResponse.Raw,
  TraceMyApi.submission.GetExecutionSessionStateResponse
> = core.schemas.object({
  states: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => serializers.submission.ExecutionSessionState)
  ),
  numWarmingInstances: core.schemas.number().optional(),
  warmingSessionIds: core.schemas.list(core.schemas.string()),
});

export declare namespace GetExecutionSessionStateResponse {
  interface Raw {
    states: Record<string, serializers.submission.ExecutionSessionState.Raw>;
    numWarmingInstances?: number | null;
    warmingSessionIds: string[];
  }
}
",
                    "name": "GetExecutionSessionStateResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const GetSubmissionStateResponse: core.schemas.ObjectSchema<
  GetSubmissionStateResponse.Raw,
  TraceMyApi.submission.GetSubmissionStateResponse
> = core.schemas.object({
  timeSubmitted: core.schemas.date().optional(),
  submission: core.schemas.string(),
  language: core.schemas.lazy(() => serializers.commons.Language),
  submissionTypeState: core.schemas.lazy(() => serializers.submission.SubmissionTypeState),
});

export declare namespace GetSubmissionStateResponse {
  interface Raw {
    timeSubmitted?: string | null;
    submission: string;
    language: serializers.commons.Language.Raw;
    submissionTypeState: serializers.submission.SubmissionTypeState.Raw;
  }
}
",
                    "name": "GetSubmissionStateResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const GetTraceResponsesPageRequest: core.schemas.ObjectSchema<
  GetTraceResponsesPageRequest.Raw,
  TraceMyApi.submission.GetTraceResponsesPageRequest
> = core.schemas.object({
  offset: core.schemas.number().optional(),
});

export declare namespace GetTraceResponsesPageRequest {
  interface Raw {
    offset?: number | null;
  }
}
",
                    "name": "GetTraceResponsesPageRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const GradedResponse: core.schemas.ObjectSchema<GradedResponse.Raw, TraceMyApi.submission.GradedResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => serializers.submission.SubmissionId),
    testCases: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(() => serializers.submission.TestCaseResultWithStdout)
    ),
  });

export declare namespace GradedResponse {
  interface Raw {
    submissionId: serializers.submission.SubmissionId.Raw;
    testCases: Record<string, serializers.submission.TestCaseResultWithStdout.Raw>;
  }
}
",
                    "name": "GradedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const GradedResponseV2: core.schemas.ObjectSchema<GradedResponseV2.Raw, TraceMyApi.submission.GradedResponseV2> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => serializers.submission.SubmissionId),
    testCases: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazy(() => serializers.submission.TestCaseGrade)
    ),
  });

export declare namespace GradedResponseV2 {
  interface Raw {
    submissionId: serializers.submission.SubmissionId.Raw;
    testCases: Record<serializers.v2.problem.TestCaseId.Raw, serializers.submission.TestCaseGrade.Raw>;
  }
}
",
                    "name": "GradedResponseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const GradedTestCaseUpdate: core.schemas.ObjectSchema<
  GradedTestCaseUpdate.Raw,
  TraceMyApi.submission.GradedTestCaseUpdate
> = core.schemas.object({
  testCaseId: core.schemas.lazy(() => serializers.v2.problem.TestCaseId),
  grade: core.schemas.lazy(() => serializers.submission.TestCaseGrade),
});

export declare namespace GradedTestCaseUpdate {
  interface Raw {
    testCaseId: serializers.v2.problem.TestCaseId.Raw;
    grade: serializers.submission.TestCaseGrade.Raw;
  }
}
",
                    "name": "GradedTestCaseUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const InitializeProblemRequest: core.schemas.ObjectSchema<
  InitializeProblemRequest.Raw,
  TraceMyApi.submission.InitializeProblemRequest
> = core.schemas.object({
  problemId: core.schemas.lazy(() => serializers.commons.ProblemId),
  problemVersion: core.schemas.number().optional(),
});

export declare namespace InitializeProblemRequest {
  interface Raw {
    problemId: serializers.commons.ProblemId.Raw;
    problemVersion?: number | null;
  }
}
",
                    "name": "InitializeProblemRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const InternalError: core.schemas.ObjectSchema<InternalError.Raw, TraceMyApi.submission.InternalError> =
  core.schemas.object({
    exceptionInfo: core.schemas.lazyObject(() => serializers.submission.ExceptionInfo),
  });

export declare namespace InternalError {
  interface Raw {
    exceptionInfo: serializers.submission.ExceptionInfo.Raw;
  }
}
",
                    "name": "InternalError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const InvalidRequestCause: core.schemas.Schema<
  InvalidRequestCause.Raw,
  TraceMyApi.submission.InvalidRequestCause
> = core.schemas
  .union(\\"type\\", {
    submissionIdNotFound: core.schemas.lazyObject(() => serializers.submission.SubmissionIdNotFound),
    customTestCasesUnsupported: core.schemas.lazyObject(() => serializers.submission.CustomTestCasesUnsupported),
    unexpectedLanguage: core.schemas.lazyObject(() => serializers.submission.UnexpectedLanguageError),
  })
  .transform<TraceMyApi.submission.InvalidRequestCause>({
    parse: (value) => {
      switch (value.type) {
        case \\"submissionIdNotFound\\": {
          return TraceMyApi.submission.InvalidRequestCause.submissionIdNotFound(value);
        }
        case \\"customTestCasesUnsupported\\": {
          return TraceMyApi.submission.InvalidRequestCause.customTestCasesUnsupported(value);
        }
        case \\"unexpectedLanguage\\": {
          return TraceMyApi.submission.InvalidRequestCause.unexpectedLanguage(value);
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace InvalidRequestCause {
  type Raw =
    | InvalidRequestCause.SubmissionIdNotFound
    | InvalidRequestCause.CustomTestCasesUnsupported
    | InvalidRequestCause.UnexpectedLanguage;

  interface SubmissionIdNotFound extends serializers.submission.SubmissionIdNotFound.Raw {
    type: \\"submissionIdNotFound\\";
  }

  interface CustomTestCasesUnsupported extends serializers.submission.CustomTestCasesUnsupported.Raw {
    type: \\"customTestCasesUnsupported\\";
  }

  interface UnexpectedLanguage extends serializers.submission.UnexpectedLanguageError.Raw {
    type: \\"unexpectedLanguage\\";
  }
}
",
                    "name": "InvalidRequestCause.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const InvalidRequestResponse: core.schemas.ObjectSchema<
  InvalidRequestResponse.Raw,
  TraceMyApi.submission.InvalidRequestResponse
> = core.schemas.object({
  request: core.schemas.lazy(() => serializers.submission.SubmissionRequest),
  cause: core.schemas.lazy(() => serializers.submission.InvalidRequestCause),
});

export declare namespace InvalidRequestResponse {
  interface Raw {
    request: serializers.submission.SubmissionRequest.Raw;
    cause: serializers.submission.InvalidRequestCause.Raw;
  }
}
",
                    "name": "InvalidRequestResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const LightweightStackframeInformation: core.schemas.ObjectSchema<
  LightweightStackframeInformation.Raw,
  TraceMyApi.submission.LightweightStackframeInformation
> = core.schemas.object({
  numStackFrames: core.schemas.number(),
  topStackFrameMethodName: core.schemas.string(),
});

export declare namespace LightweightStackframeInformation {
  interface Raw {
    numStackFrames: number;
    topStackFrameMethodName: string;
  }
}
",
                    "name": "LightweightStackframeInformation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const RecordedResponseNotification: core.schemas.ObjectSchema<
  RecordedResponseNotification.Raw,
  TraceMyApi.submission.RecordedResponseNotification
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => serializers.submission.SubmissionId),
  traceResponsesSize: core.schemas.number(),
  testCaseId: core.schemas.string().optional(),
});

export declare namespace RecordedResponseNotification {
  interface Raw {
    submissionId: serializers.submission.SubmissionId.Raw;
    traceResponsesSize: number;
    testCaseId?: string | null;
  }
}
",
                    "name": "RecordedResponseNotification.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const RecordedTestCaseUpdate: core.schemas.ObjectSchema<
  RecordedTestCaseUpdate.Raw,
  TraceMyApi.submission.RecordedTestCaseUpdate
> = core.schemas.object({
  testCaseId: core.schemas.lazy(() => serializers.v2.problem.TestCaseId),
  traceResponsesSize: core.schemas.number(),
});

export declare namespace RecordedTestCaseUpdate {
  interface Raw {
    testCaseId: serializers.v2.problem.TestCaseId.Raw;
    traceResponsesSize: number;
  }
}
",
                    "name": "RecordedTestCaseUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const RecordingResponseNotification: core.schemas.ObjectSchema<
  RecordingResponseNotification.Raw,
  TraceMyApi.submission.RecordingResponseNotification
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => serializers.submission.SubmissionId),
  testCaseId: core.schemas.string().optional(),
  lineNumber: core.schemas.number(),
  lightweightStackInfo: core.schemas.lazyObject(() => serializers.submission.LightweightStackframeInformation),
  tracedFile: core.schemas.lazyObject(() => serializers.submission.TracedFile).optional(),
});

export declare namespace RecordingResponseNotification {
  interface Raw {
    submissionId: serializers.submission.SubmissionId.Raw;
    testCaseId?: string | null;
    lineNumber: number;
    lightweightStackInfo: serializers.submission.LightweightStackframeInformation.Raw;
    tracedFile?: serializers.submission.TracedFile.Raw | null;
  }
}
",
                    "name": "RecordingResponseNotification.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const RunningResponse: core.schemas.ObjectSchema<RunningResponse.Raw, TraceMyApi.submission.RunningResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => serializers.submission.SubmissionId),
    state: core.schemas.lazy(() => serializers.submission.RunningSubmissionState),
  });

export declare namespace RunningResponse {
  interface Raw {
    submissionId: serializers.submission.SubmissionId.Raw;
    state: serializers.submission.RunningSubmissionState.Raw;
  }
}
",
                    "name": "RunningResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const RunningSubmissionState: core.schemas.Schema<
  RunningSubmissionState.Raw,
  TraceMyApi.submission.RunningSubmissionState
> = core.schemas.string().transform<TraceMyApi.submission.RunningSubmissionState>({
  parse: (value) => TraceMyApi.submission.RunningSubmissionState._parse(value),
  json: ({ value }) => value,
});

export declare namespace RunningSubmissionState {
  type Raw = string;
}
",
                    "name": "RunningSubmissionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const RuntimeError: core.schemas.ObjectSchema<RuntimeError.Raw, TraceMyApi.submission.RuntimeError> =
  core.schemas.object({
    message: core.schemas.string(),
  });

export declare namespace RuntimeError {
  interface Raw {
    message: string;
  }
}
",
                    "name": "RuntimeError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const Scope: core.schemas.ObjectSchema<Scope.Raw, TraceMyApi.submission.Scope> = core.schemas.object({
  variables: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazy(() => serializers.commons.DebugVariableValue)
  ),
});

export declare namespace Scope {
  interface Raw {
    variables: Record<string, serializers.commons.DebugVariableValue.Raw>;
  }
}
",
                    "name": "Scope.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const ShareId: core.schemas.Schema<ShareId.Raw, TraceMyApi.submission.ShareId> = core.schemas.string();

export declare namespace ShareId {
  type Raw = string;
}
",
                    "name": "ShareId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const StackFrame: core.schemas.ObjectSchema<StackFrame.Raw, TraceMyApi.submission.StackFrame> =
  core.schemas.object({
    methodName: core.schemas.string(),
    lineNumber: core.schemas.number(),
    scopes: core.schemas.list(core.schemas.lazyObject(() => serializers.submission.Scope)),
  });

export declare namespace StackFrame {
  interface Raw {
    methodName: string;
    lineNumber: number;
    scopes: serializers.submission.Scope.Raw[];
  }
}
",
                    "name": "StackFrame.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const StackInformation: core.schemas.ObjectSchema<StackInformation.Raw, TraceMyApi.submission.StackInformation> =
  core.schemas.object({
    numStackFrames: core.schemas.number(),
    topStackFrame: core.schemas.lazyObject(() => serializers.submission.StackFrame).optional(),
  });

export declare namespace StackInformation {
  interface Raw {
    numStackFrames: number;
    topStackFrame?: serializers.submission.StackFrame.Raw | null;
  }
}
",
                    "name": "StackInformation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const StderrResponse: core.schemas.ObjectSchema<StderrResponse.Raw, TraceMyApi.submission.StderrResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => serializers.submission.SubmissionId),
    stderr: core.schemas.string(),
  });

export declare namespace StderrResponse {
  interface Raw {
    submissionId: serializers.submission.SubmissionId.Raw;
    stderr: string;
  }
}
",
                    "name": "StderrResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const StdoutResponse: core.schemas.ObjectSchema<StdoutResponse.Raw, TraceMyApi.submission.StdoutResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => serializers.submission.SubmissionId),
    stdout: core.schemas.string(),
  });

export declare namespace StdoutResponse {
  interface Raw {
    submissionId: serializers.submission.SubmissionId.Raw;
    stdout: string;
  }
}
",
                    "name": "StdoutResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const StopRequest: core.schemas.ObjectSchema<StopRequest.Raw, TraceMyApi.submission.StopRequest> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => serializers.submission.SubmissionId),
  });

export declare namespace StopRequest {
  interface Raw {
    submissionId: serializers.submission.SubmissionId.Raw;
  }
}
",
                    "name": "StopRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const StoppedResponse: core.schemas.ObjectSchema<StoppedResponse.Raw, TraceMyApi.submission.StoppedResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => serializers.submission.SubmissionId),
  });

export declare namespace StoppedResponse {
  interface Raw {
    submissionId: serializers.submission.SubmissionId.Raw;
  }
}
",
                    "name": "StoppedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const SubmissionFileInfo: core.schemas.ObjectSchema<
  SubmissionFileInfo.Raw,
  TraceMyApi.submission.SubmissionFileInfo
> = core.schemas.object({
  directory: core.schemas.string(),
  filename: core.schemas.string(),
  contents: core.schemas.string(),
});

export declare namespace SubmissionFileInfo {
  interface Raw {
    directory: string;
    filename: string;
    contents: string;
  }
}
",
                    "name": "SubmissionFileInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const SubmissionId: core.schemas.Schema<SubmissionId.Raw, TraceMyApi.submission.SubmissionId> =
  core.schemas.string();

export declare namespace SubmissionId {
  type Raw = string;
}
",
                    "name": "SubmissionId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const SubmissionIdNotFound: core.schemas.ObjectSchema<
  SubmissionIdNotFound.Raw,
  TraceMyApi.submission.SubmissionIdNotFound
> = core.schemas.object({
  missingSubmissionId: core.schemas.lazy(() => serializers.submission.SubmissionId),
});

export declare namespace SubmissionIdNotFound {
  interface Raw {
    missingSubmissionId: serializers.submission.SubmissionId.Raw;
  }
}
",
                    "name": "SubmissionIdNotFound.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const SubmissionRequest: core.schemas.Schema<SubmissionRequest.Raw, TraceMyApi.submission.SubmissionRequest> =
  core.schemas
    .union(\\"type\\", {
      initializeProblemRequest: core.schemas.lazyObject(() => serializers.submission.InitializeProblemRequest),
      initializeWorkspaceRequest: core.schemas.object({}),
      submitV2: core.schemas.lazyObject(() => serializers.submission.SubmitRequestV2),
      workspaceSubmit: core.schemas.lazyObject(() => serializers.submission.WorkspaceSubmitRequest),
      stop: core.schemas.lazyObject(() => serializers.submission.StopRequest),
    })
    .transform<TraceMyApi.submission.SubmissionRequest>({
      parse: (value) => {
        switch (value.type) {
          case \\"initializeProblemRequest\\": {
            return TraceMyApi.submission.SubmissionRequest.initializeProblemRequest(value);
          }
          case \\"initializeWorkspaceRequest\\": {
            return TraceMyApi.submission.SubmissionRequest.initializeWorkspaceRequest();
          }
          case \\"submitV2\\": {
            return TraceMyApi.submission.SubmissionRequest.submitV2(value);
          }
          case \\"workspaceSubmit\\": {
            return TraceMyApi.submission.SubmissionRequest.workspaceSubmit(value);
          }
          case \\"stop\\": {
            return TraceMyApi.submission.SubmissionRequest.stop(value);
          }
          default: {
            return {
              ...(value as any),
              _visit: (visitor) => visitor._other(value),
            };
          }
        }
      },
      json: (value) => value as any,
    });

export declare namespace SubmissionRequest {
  type Raw =
    | SubmissionRequest.InitializeProblemRequest
    | SubmissionRequest.InitializeWorkspaceRequest
    | SubmissionRequest.SubmitV2
    | SubmissionRequest.WorkspaceSubmit
    | SubmissionRequest.Stop;

  interface InitializeProblemRequest extends serializers.submission.InitializeProblemRequest.Raw {
    type: \\"initializeProblemRequest\\";
  }

  interface InitializeWorkspaceRequest {
    type: \\"initializeWorkspaceRequest\\";
  }

  interface SubmitV2 extends serializers.submission.SubmitRequestV2.Raw {
    type: \\"submitV2\\";
  }

  interface WorkspaceSubmit extends serializers.submission.WorkspaceSubmitRequest.Raw {
    type: \\"workspaceSubmit\\";
  }

  interface Stop extends serializers.submission.StopRequest.Raw {
    type: \\"stop\\";
  }
}
",
                    "name": "SubmissionRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const SubmissionResponse: core.schemas.Schema<SubmissionResponse.Raw, TraceMyApi.submission.SubmissionResponse> =
  core.schemas
    .union(\\"type\\", {
      serverInitialized: core.schemas.object({}),
      problemInitialized: core.schemas.object({
        value: core.schemas.lazy(() => serializers.commons.ProblemId),
      }),
      workspaceInitialized: core.schemas.object({}),
      serverErrored: core.schemas.lazyObject(() => serializers.submission.ExceptionInfo),
      codeExecutionUpdate: core.schemas.object({
        value: core.schemas.lazy(() => serializers.submission.CodeExecutionUpdate),
      }),
      terminated: core.schemas.lazyObject(() => serializers.submission.TerminatedResponse),
    })
    .transform<TraceMyApi.submission.SubmissionResponse>({
      parse: (value) => {
        switch (value.type) {
          case \\"serverInitialized\\": {
            return TraceMyApi.submission.SubmissionResponse.serverInitialized();
          }
          case \\"problemInitialized\\": {
            return TraceMyApi.submission.SubmissionResponse.problemInitialized(value.value);
          }
          case \\"workspaceInitialized\\": {
            return TraceMyApi.submission.SubmissionResponse.workspaceInitialized();
          }
          case \\"serverErrored\\": {
            return TraceMyApi.submission.SubmissionResponse.serverErrored(value);
          }
          case \\"codeExecutionUpdate\\": {
            return TraceMyApi.submission.SubmissionResponse.codeExecutionUpdate(value.value);
          }
          case \\"terminated\\": {
            return TraceMyApi.submission.SubmissionResponse.terminated(value);
          }
          default: {
            return {
              ...(value as any),
              _visit: (visitor) => visitor._other(value),
            };
          }
        }
      },
      json: (value) => value as any,
    });

export declare namespace SubmissionResponse {
  type Raw =
    | SubmissionResponse.ServerInitialized
    | SubmissionResponse.ProblemInitialized
    | SubmissionResponse.WorkspaceInitialized
    | SubmissionResponse.ServerErrored
    | SubmissionResponse.CodeExecutionUpdate
    | SubmissionResponse.Terminated;

  interface ServerInitialized {
    type: \\"serverInitialized\\";
  }

  interface ProblemInitialized {
    type: \\"problemInitialized\\";
    value: serializers.commons.ProblemId.Raw;
  }

  interface WorkspaceInitialized {
    type: \\"workspaceInitialized\\";
  }

  interface ServerErrored extends serializers.submission.ExceptionInfo.Raw {
    type: \\"serverErrored\\";
  }

  interface CodeExecutionUpdate {
    type: \\"codeExecutionUpdate\\";
    value: serializers.submission.CodeExecutionUpdate.Raw;
  }

  interface Terminated extends serializers.submission.TerminatedResponse.Raw {
    type: \\"terminated\\";
  }
}
",
                    "name": "SubmissionResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const SubmissionStatusForTestCase: core.schemas.Schema<
  SubmissionStatusForTestCase.Raw,
  TraceMyApi.submission.SubmissionStatusForTestCase
> = core.schemas
  .union(\\"type\\", {
    graded: core.schemas.lazyObject(() => serializers.submission.TestCaseResultWithStdout),
    gradedV2: core.schemas.object({
      value: core.schemas.lazy(() => serializers.submission.TestCaseGrade),
    }),
    traced: core.schemas.lazyObject(() => serializers.submission.TracedTestCase),
  })
  .transform<TraceMyApi.submission.SubmissionStatusForTestCase>({
    parse: (value) => {
      switch (value.type) {
        case \\"graded\\": {
          return TraceMyApi.submission.SubmissionStatusForTestCase.graded(value);
        }
        case \\"gradedV2\\": {
          return TraceMyApi.submission.SubmissionStatusForTestCase.gradedV2(value.value);
        }
        case \\"traced\\": {
          return TraceMyApi.submission.SubmissionStatusForTestCase.traced(value);
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace SubmissionStatusForTestCase {
  type Raw =
    | SubmissionStatusForTestCase.Graded
    | SubmissionStatusForTestCase.GradedV2
    | SubmissionStatusForTestCase.Traced;

  interface Graded extends serializers.submission.TestCaseResultWithStdout.Raw {
    type: \\"graded\\";
  }

  interface GradedV2 {
    type: \\"gradedV2\\";
    value: serializers.submission.TestCaseGrade.Raw;
  }

  interface Traced extends serializers.submission.TracedTestCase.Raw {
    type: \\"traced\\";
  }
}
",
                    "name": "SubmissionStatusForTestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const SubmissionStatusV2: core.schemas.Schema<SubmissionStatusV2.Raw, TraceMyApi.submission.SubmissionStatusV2> =
  core.schemas
    .union(\\"type\\", {
      test: core.schemas.lazyObject(() => serializers.submission.TestSubmissionStatusV2),
      workspace: core.schemas.lazyObject(() => serializers.submission.WorkspaceSubmissionStatusV2),
    })
    .transform<TraceMyApi.submission.SubmissionStatusV2>({
      parse: (value) => {
        switch (value.type) {
          case \\"test\\": {
            return TraceMyApi.submission.SubmissionStatusV2.test(value);
          }
          case \\"workspace\\": {
            return TraceMyApi.submission.SubmissionStatusV2.workspace(value);
          }
          default: {
            return {
              ...(value as any),
              _visit: (visitor) => visitor._other(value),
            };
          }
        }
      },
      json: (value) => value as any,
    });

export declare namespace SubmissionStatusV2 {
  type Raw = SubmissionStatusV2.Test | SubmissionStatusV2.Workspace;

  interface Test extends serializers.submission.TestSubmissionStatusV2.Raw {
    type: \\"test\\";
  }

  interface Workspace extends serializers.submission.WorkspaceSubmissionStatusV2.Raw {
    type: \\"workspace\\";
  }
}
",
                    "name": "SubmissionStatusV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const SubmissionTypeEnum: core.schemas.Schema<SubmissionTypeEnum.Raw, TraceMyApi.submission.SubmissionTypeEnum> =
  core.schemas.string().transform<TraceMyApi.submission.SubmissionTypeEnum>({
    parse: (value) => TraceMyApi.submission.SubmissionTypeEnum._parse(value),
    json: ({ value }) => value,
  });

export declare namespace SubmissionTypeEnum {
  type Raw = string;
}
",
                    "name": "SubmissionTypeEnum.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const SubmissionTypeState: core.schemas.Schema<
  SubmissionTypeState.Raw,
  TraceMyApi.submission.SubmissionTypeState
> = core.schemas
  .union(\\"type\\", {
    test: core.schemas.lazyObject(() => serializers.submission.TestSubmissionState),
    workspace: core.schemas.lazyObject(() => serializers.submission.WorkspaceSubmissionState),
  })
  .transform<TraceMyApi.submission.SubmissionTypeState>({
    parse: (value) => {
      switch (value.type) {
        case \\"test\\": {
          return TraceMyApi.submission.SubmissionTypeState.test(value);
        }
        case \\"workspace\\": {
          return TraceMyApi.submission.SubmissionTypeState.workspace(value);
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace SubmissionTypeState {
  type Raw = SubmissionTypeState.Test | SubmissionTypeState.Workspace;

  interface Test extends serializers.submission.TestSubmissionState.Raw {
    type: \\"test\\";
  }

  interface Workspace extends serializers.submission.WorkspaceSubmissionState.Raw {
    type: \\"workspace\\";
  }
}
",
                    "name": "SubmissionTypeState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const SubmitRequestV2: core.schemas.ObjectSchema<SubmitRequestV2.Raw, TraceMyApi.submission.SubmitRequestV2> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => serializers.submission.SubmissionId),
    language: core.schemas.lazy(() => serializers.commons.Language),
    submissionFiles: core.schemas.list(core.schemas.lazyObject(() => serializers.submission.SubmissionFileInfo)),
    problemId: core.schemas.lazy(() => serializers.commons.ProblemId),
    problemVersion: core.schemas.number().optional(),
    userId: core.schemas.string().optional(),
  });

export declare namespace SubmitRequestV2 {
  interface Raw {
    submissionId: serializers.submission.SubmissionId.Raw;
    language: serializers.commons.Language.Raw;
    submissionFiles: serializers.submission.SubmissionFileInfo.Raw[];
    problemId: serializers.commons.ProblemId.Raw;
    problemVersion?: number | null;
    userId?: string | null;
  }
}
",
                    "name": "SubmitRequestV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const TerminatedResponse: core.schemas.ObjectSchema<
  TerminatedResponse.Raw,
  TraceMyApi.submission.TerminatedResponse
> = core.schemas.object({});

export declare namespace TerminatedResponse {
  interface Raw {}
}
",
                    "name": "TerminatedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TestCaseGrade: core.schemas.Schema<TestCaseGrade.Raw, TraceMyApi.submission.TestCaseGrade> = core.schemas
  .union(\\"type\\", {
    hidden: core.schemas.lazyObject(() => serializers.submission.TestCaseHiddenGrade),
    nonHidden: core.schemas.lazyObject(() => serializers.submission.TestCaseNonHiddenGrade),
  })
  .transform<TraceMyApi.submission.TestCaseGrade>({
    parse: (value) => {
      switch (value.type) {
        case \\"hidden\\": {
          return TraceMyApi.submission.TestCaseGrade.hidden(value);
        }
        case \\"nonHidden\\": {
          return TraceMyApi.submission.TestCaseGrade.nonHidden(value);
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestCaseGrade {
  type Raw = TestCaseGrade.Hidden | TestCaseGrade.NonHidden;

  interface Hidden extends serializers.submission.TestCaseHiddenGrade.Raw {
    type: \\"hidden\\";
  }

  interface NonHidden extends serializers.submission.TestCaseNonHiddenGrade.Raw {
    type: \\"nonHidden\\";
  }
}
",
                    "name": "TestCaseGrade.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const TestCaseHiddenGrade: core.schemas.ObjectSchema<
  TestCaseHiddenGrade.Raw,
  TraceMyApi.submission.TestCaseHiddenGrade
> = core.schemas.object({
  passed: core.schemas.boolean(),
});

export declare namespace TestCaseHiddenGrade {
  interface Raw {
    passed: boolean;
  }
}
",
                    "name": "TestCaseHiddenGrade.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TestCaseNonHiddenGrade: core.schemas.ObjectSchema<
  TestCaseNonHiddenGrade.Raw,
  TraceMyApi.submission.TestCaseNonHiddenGrade
> = core.schemas.object({
  passed: core.schemas.boolean(),
  actualResult: core.schemas.lazy(() => serializers.commons.VariableValue).optional(),
  exception: core.schemas.lazy(() => serializers.submission.ExceptionV2).optional(),
  stdout: core.schemas.string(),
});

export declare namespace TestCaseNonHiddenGrade {
  interface Raw {
    passed: boolean;
    actualResult?: serializers.commons.VariableValue.Raw | null;
    exception?: serializers.submission.ExceptionV2.Raw | null;
    stdout: string;
  }
}
",
                    "name": "TestCaseNonHiddenGrade.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TestCaseResult: core.schemas.ObjectSchema<TestCaseResult.Raw, TraceMyApi.submission.TestCaseResult> =
  core.schemas.object({
    expectedResult: core.schemas.lazy(() => serializers.commons.VariableValue),
    actualResult: core.schemas.lazy(() => serializers.submission.ActualResult),
    passed: core.schemas.boolean(),
  });

export declare namespace TestCaseResult {
  interface Raw {
    expectedResult: serializers.commons.VariableValue.Raw;
    actualResult: serializers.submission.ActualResult.Raw;
    passed: boolean;
  }
}
",
                    "name": "TestCaseResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TestCaseResultWithStdout: core.schemas.ObjectSchema<
  TestCaseResultWithStdout.Raw,
  TraceMyApi.submission.TestCaseResultWithStdout
> = core.schemas.object({
  result: core.schemas.lazyObject(() => serializers.submission.TestCaseResult),
  stdout: core.schemas.string(),
});

export declare namespace TestCaseResultWithStdout {
  interface Raw {
    result: serializers.submission.TestCaseResult.Raw;
    stdout: string;
  }
}
",
                    "name": "TestCaseResultWithStdout.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TestSubmissionState: core.schemas.ObjectSchema<
  TestSubmissionState.Raw,
  TraceMyApi.submission.TestSubmissionState
> = core.schemas.object({
  problemId: core.schemas.lazy(() => serializers.commons.ProblemId),
  defaultTestCases: core.schemas.list(core.schemas.lazyObject(() => serializers.commons.TestCase)),
  customTestCases: core.schemas.list(core.schemas.lazyObject(() => serializers.commons.TestCase)),
  status: core.schemas.lazy(() => serializers.submission.TestSubmissionStatus),
});

export declare namespace TestSubmissionState {
  interface Raw {
    problemId: serializers.commons.ProblemId.Raw;
    defaultTestCases: serializers.commons.TestCase.Raw[];
    customTestCases: serializers.commons.TestCase.Raw[];
    status: serializers.submission.TestSubmissionStatus.Raw;
  }
}
",
                    "name": "TestSubmissionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TestSubmissionStatus: core.schemas.Schema<
  TestSubmissionStatus.Raw,
  TraceMyApi.submission.TestSubmissionStatus
> = core.schemas
  .union(\\"type\\", {
    stopped: core.schemas.object({}),
    errored: core.schemas.object({
      value: core.schemas.lazy(() => serializers.submission.ErrorInfo),
    }),
    running: core.schemas.object({
      value: core.schemas.lazy(() => serializers.submission.RunningSubmissionState),
    }),
    testCaseIdToState: core.schemas.object({
      value: core.schemas.record(
        core.schemas.string(),
        core.schemas.lazy(() => serializers.submission.SubmissionStatusForTestCase)
      ),
    }),
  })
  .transform<TraceMyApi.submission.TestSubmissionStatus>({
    parse: (value) => {
      switch (value.type) {
        case \\"stopped\\": {
          return TraceMyApi.submission.TestSubmissionStatus.stopped();
        }
        case \\"errored\\": {
          return TraceMyApi.submission.TestSubmissionStatus.errored(value.value);
        }
        case \\"running\\": {
          return TraceMyApi.submission.TestSubmissionStatus.running(value.value);
        }
        case \\"testCaseIdToState\\": {
          return TraceMyApi.submission.TestSubmissionStatus.testCaseIdToState(value.value);
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestSubmissionStatus {
  type Raw =
    | TestSubmissionStatus.Stopped
    | TestSubmissionStatus.Errored
    | TestSubmissionStatus.Running
    | TestSubmissionStatus.TestCaseIdToState;

  interface Stopped {
    type: \\"stopped\\";
  }

  interface Errored {
    type: \\"errored\\";
    value: serializers.submission.ErrorInfo.Raw;
  }

  interface Running {
    type: \\"running\\";
    value: serializers.submission.RunningSubmissionState.Raw;
  }

  interface TestCaseIdToState {
    type: \\"testCaseIdToState\\";
    value: Record<string, serializers.submission.SubmissionStatusForTestCase.Raw>;
  }
}
",
                    "name": "TestSubmissionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TestSubmissionStatusV2: core.schemas.ObjectSchema<
  TestSubmissionStatusV2.Raw,
  TraceMyApi.submission.TestSubmissionStatusV2
> = core.schemas.object({
  updates: core.schemas.list(core.schemas.lazyObject(() => serializers.submission.TestSubmissionUpdate)),
  problemId: core.schemas.lazy(() => serializers.commons.ProblemId),
  problemVersion: core.schemas.number(),
  problemInfo: core.schemas.lazyObject(() => serializers.v2.problem.ProblemInfoV2),
});

export declare namespace TestSubmissionStatusV2 {
  interface Raw {
    updates: serializers.submission.TestSubmissionUpdate.Raw[];
    problemId: serializers.commons.ProblemId.Raw;
    problemVersion: number;
    problemInfo: serializers.v2.problem.ProblemInfoV2.Raw;
  }
}
",
                    "name": "TestSubmissionStatusV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TestSubmissionUpdate: core.schemas.ObjectSchema<
  TestSubmissionUpdate.Raw,
  TraceMyApi.submission.TestSubmissionUpdate
> = core.schemas.object({
  updateTime: core.schemas.date(),
  updateInfo: core.schemas.lazy(() => serializers.submission.TestSubmissionUpdateInfo),
});

export declare namespace TestSubmissionUpdate {
  interface Raw {
    updateTime: string;
    updateInfo: serializers.submission.TestSubmissionUpdateInfo.Raw;
  }
}
",
                    "name": "TestSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TestSubmissionUpdateInfo: core.schemas.Schema<
  TestSubmissionUpdateInfo.Raw,
  TraceMyApi.submission.TestSubmissionUpdateInfo
> = core.schemas
  .union(\\"type\\", {
    running: core.schemas.object({
      value: core.schemas.lazy(() => serializers.submission.RunningSubmissionState),
    }),
    stopped: core.schemas.object({}),
    errored: core.schemas.object({
      value: core.schemas.lazy(() => serializers.submission.ErrorInfo),
    }),
    gradedTestCase: core.schemas.lazyObject(() => serializers.submission.GradedTestCaseUpdate),
    recordedTestCase: core.schemas.lazyObject(() => serializers.submission.RecordedTestCaseUpdate),
    finished: core.schemas.object({}),
  })
  .transform<TraceMyApi.submission.TestSubmissionUpdateInfo>({
    parse: (value) => {
      switch (value.type) {
        case \\"running\\": {
          return TraceMyApi.submission.TestSubmissionUpdateInfo.running(value.value);
        }
        case \\"stopped\\": {
          return TraceMyApi.submission.TestSubmissionUpdateInfo.stopped();
        }
        case \\"errored\\": {
          return TraceMyApi.submission.TestSubmissionUpdateInfo.errored(value.value);
        }
        case \\"gradedTestCase\\": {
          return TraceMyApi.submission.TestSubmissionUpdateInfo.gradedTestCase(value);
        }
        case \\"recordedTestCase\\": {
          return TraceMyApi.submission.TestSubmissionUpdateInfo.recordedTestCase(value);
        }
        case \\"finished\\": {
          return TraceMyApi.submission.TestSubmissionUpdateInfo.finished();
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestSubmissionUpdateInfo {
  type Raw =
    | TestSubmissionUpdateInfo.Running
    | TestSubmissionUpdateInfo.Stopped
    | TestSubmissionUpdateInfo.Errored
    | TestSubmissionUpdateInfo.GradedTestCase
    | TestSubmissionUpdateInfo.RecordedTestCase
    | TestSubmissionUpdateInfo.Finished;

  interface Running {
    type: \\"running\\";
    value: serializers.submission.RunningSubmissionState.Raw;
  }

  interface Stopped {
    type: \\"stopped\\";
  }

  interface Errored {
    type: \\"errored\\";
    value: serializers.submission.ErrorInfo.Raw;
  }

  interface GradedTestCase extends serializers.submission.GradedTestCaseUpdate.Raw {
    type: \\"gradedTestCase\\";
  }

  interface RecordedTestCase extends serializers.submission.RecordedTestCaseUpdate.Raw {
    type: \\"recordedTestCase\\";
  }

  interface Finished {
    type: \\"finished\\";
  }
}
",
                    "name": "TestSubmissionUpdateInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TraceResponse: core.schemas.ObjectSchema<TraceResponse.Raw, TraceMyApi.submission.TraceResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => serializers.submission.SubmissionId),
    lineNumber: core.schemas.number(),
    returnValue: core.schemas.lazy(() => serializers.commons.DebugVariableValue).optional(),
    expressionLocation: core.schemas.lazyObject(() => serializers.submission.ExpressionLocation).optional(),
    stack: core.schemas.lazyObject(() => serializers.submission.StackInformation),
    stdout: core.schemas.string().optional(),
  });

export declare namespace TraceResponse {
  interface Raw {
    submissionId: serializers.submission.SubmissionId.Raw;
    lineNumber: number;
    returnValue?: serializers.commons.DebugVariableValue.Raw | null;
    expressionLocation?: serializers.submission.ExpressionLocation.Raw | null;
    stack: serializers.submission.StackInformation.Raw;
    stdout?: string | null;
  }
}
",
                    "name": "TraceResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TraceResponseV2: core.schemas.ObjectSchema<TraceResponseV2.Raw, TraceMyApi.submission.TraceResponseV2> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => serializers.submission.SubmissionId),
    lineNumber: core.schemas.number(),
    file: core.schemas.lazyObject(() => serializers.submission.TracedFile),
    returnValue: core.schemas.lazy(() => serializers.commons.DebugVariableValue).optional(),
    expressionLocation: core.schemas.lazyObject(() => serializers.submission.ExpressionLocation).optional(),
    stack: core.schemas.lazyObject(() => serializers.submission.StackInformation),
    stdout: core.schemas.string().optional(),
  });

export declare namespace TraceResponseV2 {
  interface Raw {
    submissionId: serializers.submission.SubmissionId.Raw;
    lineNumber: number;
    file: serializers.submission.TracedFile.Raw;
    returnValue?: serializers.commons.DebugVariableValue.Raw | null;
    expressionLocation?: serializers.submission.ExpressionLocation.Raw | null;
    stack: serializers.submission.StackInformation.Raw;
    stdout?: string | null;
  }
}
",
                    "name": "TraceResponseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TraceResponsesPage: core.schemas.ObjectSchema<
  TraceResponsesPage.Raw,
  TraceMyApi.submission.TraceResponsesPage
> = core.schemas.object({
  offset: core.schemas.number().optional(),
  traceResponses: core.schemas.list(core.schemas.lazyObject(() => serializers.submission.TraceResponse)),
});

export declare namespace TraceResponsesPage {
  interface Raw {
    offset?: number | null;
    traceResponses: serializers.submission.TraceResponse.Raw[];
  }
}
",
                    "name": "TraceResponsesPage.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TraceResponsesPageV2: core.schemas.ObjectSchema<
  TraceResponsesPageV2.Raw,
  TraceMyApi.submission.TraceResponsesPageV2
> = core.schemas.object({
  offset: core.schemas.number().optional(),
  traceResponses: core.schemas.list(core.schemas.lazyObject(() => serializers.submission.TraceResponseV2)),
});

export declare namespace TraceResponsesPageV2 {
  interface Raw {
    offset?: number | null;
    traceResponses: serializers.submission.TraceResponseV2.Raw[];
  }
}
",
                    "name": "TraceResponsesPageV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const TracedFile: core.schemas.ObjectSchema<TracedFile.Raw, TraceMyApi.submission.TracedFile> =
  core.schemas.object({
    filename: core.schemas.string(),
    directory: core.schemas.string(),
  });

export declare namespace TracedFile {
  interface Raw {
    filename: string;
    directory: string;
  }
}
",
                    "name": "TracedFile.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TracedTestCase: core.schemas.ObjectSchema<TracedTestCase.Raw, TraceMyApi.submission.TracedTestCase> =
  core.schemas.object({
    result: core.schemas.lazyObject(() => serializers.submission.TestCaseResultWithStdout),
    traceResponsesSize: core.schemas.number(),
  });

export declare namespace TracedTestCase {
  interface Raw {
    result: serializers.submission.TestCaseResultWithStdout.Raw;
    traceResponsesSize: number;
  }
}
",
                    "name": "TracedTestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const UnexpectedLanguageError: core.schemas.ObjectSchema<
  UnexpectedLanguageError.Raw,
  TraceMyApi.submission.UnexpectedLanguageError
> = core.schemas.object({
  expectedLanguage: core.schemas.lazy(() => serializers.commons.Language),
  actualLanguage: core.schemas.lazy(() => serializers.commons.Language),
});

export declare namespace UnexpectedLanguageError {
  interface Raw {
    expectedLanguage: serializers.commons.Language.Raw;
    actualLanguage: serializers.commons.Language.Raw;
  }
}
",
                    "name": "UnexpectedLanguageError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const WorkspaceFiles: core.schemas.ObjectSchema<WorkspaceFiles.Raw, TraceMyApi.submission.WorkspaceFiles> =
  core.schemas.object({
    mainFile: core.schemas.lazyObject(() => serializers.commons.FileInfo),
    readOnlyFiles: core.schemas.list(core.schemas.lazyObject(() => serializers.commons.FileInfo)),
  });

export declare namespace WorkspaceFiles {
  interface Raw {
    mainFile: serializers.commons.FileInfo.Raw;
    readOnlyFiles: serializers.commons.FileInfo.Raw[];
  }
}
",
                    "name": "WorkspaceFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const WorkspaceRanResponse: core.schemas.ObjectSchema<
  WorkspaceRanResponse.Raw,
  TraceMyApi.submission.WorkspaceRanResponse
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => serializers.submission.SubmissionId),
  runDetails: core.schemas.lazyObject(() => serializers.submission.WorkspaceRunDetails),
});

export declare namespace WorkspaceRanResponse {
  interface Raw {
    submissionId: serializers.submission.SubmissionId.Raw;
    runDetails: serializers.submission.WorkspaceRunDetails.Raw;
  }
}
",
                    "name": "WorkspaceRanResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const WorkspaceRunDetails: core.schemas.ObjectSchema<
  WorkspaceRunDetails.Raw,
  TraceMyApi.submission.WorkspaceRunDetails
> = core.schemas.object({
  exceptionV2: core.schemas.lazy(() => serializers.submission.ExceptionV2).optional(),
  exception: core.schemas.lazyObject(() => serializers.submission.ExceptionInfo).optional(),
  stdout: core.schemas.string(),
});

export declare namespace WorkspaceRunDetails {
  interface Raw {
    exceptionV2?: serializers.submission.ExceptionV2.Raw | null;
    exception?: serializers.submission.ExceptionInfo.Raw | null;
    stdout: string;
  }
}
",
                    "name": "WorkspaceRunDetails.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const WorkspaceStarterFilesResponse: core.schemas.ObjectSchema<
  WorkspaceStarterFilesResponse.Raw,
  TraceMyApi.submission.WorkspaceStarterFilesResponse
> = core.schemas.object({
  files: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => serializers.submission.WorkspaceFiles)
  ),
});

export declare namespace WorkspaceStarterFilesResponse {
  interface Raw {
    files: Record<serializers.commons.Language.Raw, serializers.submission.WorkspaceFiles.Raw>;
  }
}
",
                    "name": "WorkspaceStarterFilesResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const WorkspaceStarterFilesResponseV2: core.schemas.ObjectSchema<
  WorkspaceStarterFilesResponseV2.Raw,
  TraceMyApi.submission.WorkspaceStarterFilesResponseV2
> = core.schemas.object({
  filesByLanguage: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => serializers.v2.problem.Files)
  ),
});

export declare namespace WorkspaceStarterFilesResponseV2 {
  interface Raw {
    filesByLanguage: Record<serializers.commons.Language.Raw, serializers.v2.problem.Files.Raw>;
  }
}
",
                    "name": "WorkspaceStarterFilesResponseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const WorkspaceSubmissionState: core.schemas.ObjectSchema<
  WorkspaceSubmissionState.Raw,
  TraceMyApi.submission.WorkspaceSubmissionState
> = core.schemas.object({
  status: core.schemas.lazy(() => serializers.submission.WorkspaceSubmissionStatus),
});

export declare namespace WorkspaceSubmissionState {
  interface Raw {
    status: serializers.submission.WorkspaceSubmissionStatus.Raw;
  }
}
",
                    "name": "WorkspaceSubmissionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const WorkspaceSubmissionStatus: core.schemas.Schema<
  WorkspaceSubmissionStatus.Raw,
  TraceMyApi.submission.WorkspaceSubmissionStatus
> = core.schemas
  .union(\\"type\\", {
    stopped: core.schemas.object({}),
    errored: core.schemas.object({
      value: core.schemas.lazy(() => serializers.submission.ErrorInfo),
    }),
    running: core.schemas.object({
      value: core.schemas.lazy(() => serializers.submission.RunningSubmissionState),
    }),
    ran: core.schemas.lazyObject(() => serializers.submission.WorkspaceRunDetails),
    traced: core.schemas.lazyObject(() => serializers.submission.WorkspaceRunDetails),
  })
  .transform<TraceMyApi.submission.WorkspaceSubmissionStatus>({
    parse: (value) => {
      switch (value.type) {
        case \\"stopped\\": {
          return TraceMyApi.submission.WorkspaceSubmissionStatus.stopped();
        }
        case \\"errored\\": {
          return TraceMyApi.submission.WorkspaceSubmissionStatus.errored(value.value);
        }
        case \\"running\\": {
          return TraceMyApi.submission.WorkspaceSubmissionStatus.running(value.value);
        }
        case \\"ran\\": {
          return TraceMyApi.submission.WorkspaceSubmissionStatus.ran(value);
        }
        case \\"traced\\": {
          return TraceMyApi.submission.WorkspaceSubmissionStatus.traced(value);
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace WorkspaceSubmissionStatus {
  type Raw =
    | WorkspaceSubmissionStatus.Stopped
    | WorkspaceSubmissionStatus.Errored
    | WorkspaceSubmissionStatus.Running
    | WorkspaceSubmissionStatus.Ran
    | WorkspaceSubmissionStatus.Traced;

  interface Stopped {
    type: \\"stopped\\";
  }

  interface Errored {
    type: \\"errored\\";
    value: serializers.submission.ErrorInfo.Raw;
  }

  interface Running {
    type: \\"running\\";
    value: serializers.submission.RunningSubmissionState.Raw;
  }

  interface Ran extends serializers.submission.WorkspaceRunDetails.Raw {
    type: \\"ran\\";
  }

  interface Traced extends serializers.submission.WorkspaceRunDetails.Raw {
    type: \\"traced\\";
  }
}
",
                    "name": "WorkspaceSubmissionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const WorkspaceSubmissionStatusV2: core.schemas.ObjectSchema<
  WorkspaceSubmissionStatusV2.Raw,
  TraceMyApi.submission.WorkspaceSubmissionStatusV2
> = core.schemas.object({
  updates: core.schemas.list(core.schemas.lazyObject(() => serializers.submission.WorkspaceSubmissionUpdate)),
});

export declare namespace WorkspaceSubmissionStatusV2 {
  interface Raw {
    updates: serializers.submission.WorkspaceSubmissionUpdate.Raw[];
  }
}
",
                    "name": "WorkspaceSubmissionStatusV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const WorkspaceSubmissionUpdate: core.schemas.ObjectSchema<
  WorkspaceSubmissionUpdate.Raw,
  TraceMyApi.submission.WorkspaceSubmissionUpdate
> = core.schemas.object({
  updateTime: core.schemas.date(),
  updateInfo: core.schemas.lazy(() => serializers.submission.WorkspaceSubmissionUpdateInfo),
});

export declare namespace WorkspaceSubmissionUpdate {
  interface Raw {
    updateTime: string;
    updateInfo: serializers.submission.WorkspaceSubmissionUpdateInfo.Raw;
  }
}
",
                    "name": "WorkspaceSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const WorkspaceSubmissionUpdateInfo: core.schemas.Schema<
  WorkspaceSubmissionUpdateInfo.Raw,
  TraceMyApi.submission.WorkspaceSubmissionUpdateInfo
> = core.schemas
  .union(\\"type\\", {
    running: core.schemas.object({
      value: core.schemas.lazy(() => serializers.submission.RunningSubmissionState),
    }),
    ran: core.schemas.lazyObject(() => serializers.submission.WorkspaceRunDetails),
    stopped: core.schemas.object({}),
    traced: core.schemas.object({}),
    tracedV2: core.schemas.lazyObject(() => serializers.submission.WorkspaceTracedUpdate),
    errored: core.schemas.object({
      value: core.schemas.lazy(() => serializers.submission.ErrorInfo),
    }),
    finished: core.schemas.object({}),
  })
  .transform<TraceMyApi.submission.WorkspaceSubmissionUpdateInfo>({
    parse: (value) => {
      switch (value.type) {
        case \\"running\\": {
          return TraceMyApi.submission.WorkspaceSubmissionUpdateInfo.running(value.value);
        }
        case \\"ran\\": {
          return TraceMyApi.submission.WorkspaceSubmissionUpdateInfo.ran(value);
        }
        case \\"stopped\\": {
          return TraceMyApi.submission.WorkspaceSubmissionUpdateInfo.stopped();
        }
        case \\"traced\\": {
          return TraceMyApi.submission.WorkspaceSubmissionUpdateInfo.traced();
        }
        case \\"tracedV2\\": {
          return TraceMyApi.submission.WorkspaceSubmissionUpdateInfo.tracedV2(value);
        }
        case \\"errored\\": {
          return TraceMyApi.submission.WorkspaceSubmissionUpdateInfo.errored(value.value);
        }
        case \\"finished\\": {
          return TraceMyApi.submission.WorkspaceSubmissionUpdateInfo.finished();
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace WorkspaceSubmissionUpdateInfo {
  type Raw =
    | WorkspaceSubmissionUpdateInfo.Running
    | WorkspaceSubmissionUpdateInfo.Ran
    | WorkspaceSubmissionUpdateInfo.Stopped
    | WorkspaceSubmissionUpdateInfo.Traced
    | WorkspaceSubmissionUpdateInfo.TracedV2
    | WorkspaceSubmissionUpdateInfo.Errored
    | WorkspaceSubmissionUpdateInfo.Finished;

  interface Running {
    type: \\"running\\";
    value: serializers.submission.RunningSubmissionState.Raw;
  }

  interface Ran extends serializers.submission.WorkspaceRunDetails.Raw {
    type: \\"ran\\";
  }

  interface Stopped {
    type: \\"stopped\\";
  }

  interface Traced {
    type: \\"traced\\";
  }

  interface TracedV2 extends serializers.submission.WorkspaceTracedUpdate.Raw {
    type: \\"tracedV2\\";
  }

  interface Errored {
    type: \\"errored\\";
    value: serializers.submission.ErrorInfo.Raw;
  }

  interface Finished {
    type: \\"finished\\";
  }
}
",
                    "name": "WorkspaceSubmissionUpdateInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const WorkspaceSubmitRequest: core.schemas.ObjectSchema<
  WorkspaceSubmitRequest.Raw,
  TraceMyApi.submission.WorkspaceSubmitRequest
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => serializers.submission.SubmissionId),
  language: core.schemas.lazy(() => serializers.commons.Language),
  submissionFiles: core.schemas.list(core.schemas.lazyObject(() => serializers.submission.SubmissionFileInfo)),
  userId: core.schemas.string().optional(),
});

export declare namespace WorkspaceSubmitRequest {
  interface Raw {
    submissionId: serializers.submission.SubmissionId.Raw;
    language: serializers.commons.Language.Raw;
    submissionFiles: serializers.submission.SubmissionFileInfo.Raw[];
    userId?: string | null;
  }
}
",
                    "name": "WorkspaceSubmitRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const WorkspaceTracedUpdate: core.schemas.ObjectSchema<
  WorkspaceTracedUpdate.Raw,
  TraceMyApi.submission.WorkspaceTracedUpdate
> = core.schemas.object({
  traceResponsesSize: core.schemas.number(),
});

export declare namespace WorkspaceTracedUpdate {
  interface Raw {
    traceResponsesSize: number;
  }
}
",
                    "name": "WorkspaceTracedUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./SubmissionId\\";
export * from \\"./ShareId\\";
export * from \\"./SubmissionRequest\\";
export * from \\"./InitializeProblemRequest\\";
export * from \\"./SubmitRequestV2\\";
export * from \\"./WorkspaceSubmitRequest\\";
export * from \\"./SubmissionFileInfo\\";
export * from \\"./SubmissionTypeEnum\\";
export * from \\"./StopRequest\\";
export * from \\"./SubmissionResponse\\";
export * from \\"./CodeExecutionUpdate\\";
export * from \\"./BuildingExecutorResponse\\";
export * from \\"./RunningResponse\\";
export * from \\"./RunningSubmissionState\\";
export * from \\"./ErroredResponse\\";
export * from \\"./ErrorInfo\\";
export * from \\"./CompileError\\";
export * from \\"./RuntimeError\\";
export * from \\"./InternalError\\";
export * from \\"./StoppedResponse\\";
export * from \\"./WorkspaceRanResponse\\";
export * from \\"./WorkspaceRunDetails\\";
export * from \\"./GradedResponse\\";
export * from \\"./GradedResponseV2\\";
export * from \\"./TestCaseGrade\\";
export * from \\"./TestCaseHiddenGrade\\";
export * from \\"./TestCaseNonHiddenGrade\\";
export * from \\"./RecordedResponseNotification\\";
export * from \\"./RecordingResponseNotification\\";
export * from \\"./LightweightStackframeInformation\\";
export * from \\"./TestCaseResultWithStdout\\";
export * from \\"./TestCaseResult\\";
export * from \\"./ActualResult\\";
export * from \\"./ExceptionV2\\";
export * from \\"./ExceptionInfo\\";
export * from \\"./InvalidRequestResponse\\";
export * from \\"./InvalidRequestCause\\";
export * from \\"./ExistingSubmissionExecuting\\";
export * from \\"./SubmissionIdNotFound\\";
export * from \\"./CustomTestCasesUnsupported\\";
export * from \\"./UnexpectedLanguageError\\";
export * from \\"./TerminatedResponse\\";
export * from \\"./FinishedResponse\\";
export * from \\"./StdoutResponse\\";
export * from \\"./StderrResponse\\";
export * from \\"./TraceResponse\\";
export * from \\"./TraceResponseV2\\";
export * from \\"./TracedFile\\";
export * from \\"./ExpressionLocation\\";
export * from \\"./StackInformation\\";
export * from \\"./StackFrame\\";
export * from \\"./Scope\\";
export * from \\"./ExecutionSessionResponse\\";
export * from \\"./ExecutionSessionStatus\\";
export * from \\"./SubmissionStatusV2\\";
export * from \\"./TestSubmissionStatusV2\\";
export * from \\"./WorkspaceSubmissionStatusV2\\";
export * from \\"./TestSubmissionUpdate\\";
export * from \\"./TestSubmissionUpdateInfo\\";
export * from \\"./WorkspaceSubmissionUpdate\\";
export * from \\"./WorkspaceSubmissionUpdateInfo\\";
export * from \\"./GradedTestCaseUpdate\\";
export * from \\"./RecordedTestCaseUpdate\\";
export * from \\"./WorkspaceTracedUpdate\\";
export * from \\"./SubmissionTypeState\\";
export * from \\"./WorkspaceSubmissionState\\";
export * from \\"./WorkspaceSubmissionStatus\\";
export * from \\"./TestSubmissionState\\";
export * from \\"./TestSubmissionStatus\\";
export * from \\"./SubmissionStatusForTestCase\\";
export * from \\"./TracedTestCase\\";
export * from \\"./TraceResponsesPage\\";
export * from \\"./TraceResponsesPageV2\\";
export * from \\"./GetTraceResponsesPageRequest\\";
export * from \\"./WorkspaceStarterFilesResponse\\";
export * from \\"./WorkspaceStarterFilesResponseV2\\";
export * from \\"./WorkspaceFiles\\";
export * from \\"./ExecutionSessionState\\";
export * from \\"./GetExecutionSessionStateResponse\\";
export * from \\"./GetSubmissionStateResponse\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "submission",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceMyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  Record<serializers.commons.Language.Raw, number>,
  Record<TraceMyApi.commons.Language.RawValue, number>
> = core.schemas.record(core.schemas.string(), core.schemas.number());
",
                    "name": "getNumWarmInstances.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getNumWarmInstances from \\"./getNumWarmInstances\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "sysprop",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./resources\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as v3 from \\"./v3\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const Response: core.schemas.Schema<
  serializers.v2.problem.LightweightProblemInfoV2.Raw[],
  TraceMyApi.v2.problem.LightweightProblemInfoV2[]
> = core.schemas.list(core.schemas.lazyObject(() => serializers.v2.problem.LightweightProblemInfoV2));
",
                            "name": "getLightweightProblems.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const Response: core.schemas.Schema<
  serializers.v2.problem.ProblemInfoV2.Raw[],
  TraceMyApi.v2.problem.ProblemInfoV2[]
> = core.schemas.list(core.schemas.lazyObject(() => serializers.v2.problem.ProblemInfoV2));
",
                            "name": "getProblems.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "client",
                        "type": "directory",
                      },
                      Object {
                        "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const AssertCorrectnessCheck: core.schemas.Schema<
  AssertCorrectnessCheck.Raw,
  TraceMyApi.v2.problem.AssertCorrectnessCheck
> = core.schemas
  .union(\\"type\\", {
    deepEquality: core.schemas.lazyObject(() => serializers.v2.problem.DeepEqualityCorrectnessCheck),
    custom: core.schemas.lazyObject(() => serializers.v2.problem.VoidFunctionDefinitionThatTakesActualResult),
  })
  .transform<TraceMyApi.v2.problem.AssertCorrectnessCheck>({
    parse: (value) => {
      switch (value.type) {
        case \\"deepEquality\\": {
          return TraceMyApi.v2.problem.AssertCorrectnessCheck.deepEquality(value);
        }
        case \\"custom\\": {
          return TraceMyApi.v2.problem.AssertCorrectnessCheck.custom(value);
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace AssertCorrectnessCheck {
  type Raw = AssertCorrectnessCheck.DeepEquality | AssertCorrectnessCheck.Custom;

  interface DeepEquality extends serializers.v2.problem.DeepEqualityCorrectnessCheck.Raw {
    type: \\"deepEquality\\";
  }

  interface Custom extends serializers.v2.problem.VoidFunctionDefinitionThatTakesActualResult.Raw {
    type: \\"custom\\";
  }
}
",
                            "name": "AssertCorrectnessCheck.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const BasicCustomFiles: core.schemas.ObjectSchema<BasicCustomFiles.Raw, TraceMyApi.v2.problem.BasicCustomFiles> =
  core.schemas.object({
    methodName: core.schemas.string(),
    signature: core.schemas.lazyObject(() => serializers.v2.problem.NonVoidFunctionSignature),
    additionalFiles: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(() => serializers.v2.problem.Files)
    ),
    basicTestCaseTemplate: core.schemas.lazyObject(() => serializers.v2.problem.BasicTestCaseTemplate),
  });

export declare namespace BasicCustomFiles {
  interface Raw {
    methodName: string;
    signature: serializers.v2.problem.NonVoidFunctionSignature.Raw;
    additionalFiles: Record<serializers.commons.Language.Raw, serializers.v2.problem.Files.Raw>;
    basicTestCaseTemplate: serializers.v2.problem.BasicTestCaseTemplate.Raw;
  }
}
",
                            "name": "BasicCustomFiles.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const BasicTestCaseTemplate: core.schemas.ObjectSchema<
  BasicTestCaseTemplate.Raw,
  TraceMyApi.v2.problem.BasicTestCaseTemplate
> = core.schemas.object({
  templateId: core.schemas.lazy(() => serializers.v2.problem.TestCaseTemplateId),
  name: core.schemas.string(),
  description: core.schemas.lazyObject(() => serializers.v2.problem.TestCaseImplementationDescription),
  expectedValueParameterId: core.schemas.lazy(() => serializers.v2.problem.ParameterId),
});

export declare namespace BasicTestCaseTemplate {
  interface Raw {
    templateId: serializers.v2.problem.TestCaseTemplateId.Raw;
    name: string;
    description: serializers.v2.problem.TestCaseImplementationDescription.Raw;
    expectedValueParameterId: serializers.v2.problem.ParameterId.Raw;
  }
}
",
                            "name": "BasicTestCaseTemplate.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const CreateProblemRequestV2: core.schemas.ObjectSchema<
  CreateProblemRequestV2.Raw,
  TraceMyApi.v2.problem.CreateProblemRequestV2
> = core.schemas.object({
  problemName: core.schemas.string(),
  problemDescription: core.schemas.lazyObject(() => serializers.problem.ProblemDescription),
  customFiles: core.schemas.lazy(() => serializers.v2.problem.CustomFiles),
  customTestCaseTemplates: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.problem.TestCaseTemplate)),
  testcases: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.problem.TestCaseV2)),
  supportedLanguages: core.schemas.list(core.schemas.lazy(() => serializers.commons.Language)),
  isPublic: core.schemas.boolean(),
});

export declare namespace CreateProblemRequestV2 {
  interface Raw {
    problemName: string;
    problemDescription: serializers.problem.ProblemDescription.Raw;
    customFiles: serializers.v2.problem.CustomFiles.Raw;
    customTestCaseTemplates: serializers.v2.problem.TestCaseTemplate.Raw[];
    testcases: serializers.v2.problem.TestCaseV2.Raw[];
    supportedLanguages: serializers.commons.Language.Raw[];
    isPublic: boolean;
  }
}
",
                            "name": "CreateProblemRequestV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const CustomFiles: core.schemas.Schema<CustomFiles.Raw, TraceMyApi.v2.problem.CustomFiles> = core.schemas
  .union(\\"type\\", {
    basic: core.schemas.lazyObject(() => serializers.v2.problem.BasicCustomFiles),
    custom: core.schemas.object({
      value: core.schemas.record(
        core.schemas.string(),
        core.schemas.lazyObject(() => serializers.v2.problem.Files)
      ),
    }),
  })
  .transform<TraceMyApi.v2.problem.CustomFiles>({
    parse: (value) => {
      switch (value.type) {
        case \\"basic\\": {
          return TraceMyApi.v2.problem.CustomFiles.basic(value);
        }
        case \\"custom\\": {
          return TraceMyApi.v2.problem.CustomFiles.custom(value.value);
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace CustomFiles {
  type Raw = CustomFiles.Basic | CustomFiles.Custom;

  interface Basic extends serializers.v2.problem.BasicCustomFiles.Raw {
    type: \\"basic\\";
  }

  interface Custom {
    type: \\"custom\\";
    value: Record<serializers.commons.Language.Raw, serializers.v2.problem.Files.Raw>;
  }
}
",
                            "name": "CustomFiles.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const DeepEqualityCorrectnessCheck: core.schemas.ObjectSchema<
  DeepEqualityCorrectnessCheck.Raw,
  TraceMyApi.v2.problem.DeepEqualityCorrectnessCheck
> = core.schemas.object({
  expectedValueParameterId: core.schemas.lazy(() => serializers.v2.problem.ParameterId),
});

export declare namespace DeepEqualityCorrectnessCheck {
  interface Raw {
    expectedValueParameterId: serializers.v2.problem.ParameterId.Raw;
  }
}
",
                            "name": "DeepEqualityCorrectnessCheck.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const DefaultProvidedFile: core.schemas.ObjectSchema<
  DefaultProvidedFile.Raw,
  TraceMyApi.v2.problem.DefaultProvidedFile
> = core.schemas.object({
  file: core.schemas.lazyObject(() => serializers.v2.problem.FileInfoV2),
  relatedTypes: core.schemas.list(core.schemas.lazy(() => serializers.commons.VariableType)),
});

export declare namespace DefaultProvidedFile {
  interface Raw {
    file: serializers.v2.problem.FileInfoV2.Raw;
    relatedTypes: serializers.commons.VariableType.Raw[];
  }
}
",
                            "name": "DefaultProvidedFile.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const FileInfoV2: core.schemas.ObjectSchema<FileInfoV2.Raw, TraceMyApi.v2.problem.FileInfoV2> =
  core.schemas.object({
    filename: core.schemas.string(),
    directory: core.schemas.string(),
    contents: core.schemas.string(),
    editable: core.schemas.boolean(),
  });

export declare namespace FileInfoV2 {
  interface Raw {
    filename: string;
    directory: string;
    contents: string;
    editable: boolean;
  }
}
",
                            "name": "FileInfoV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const Files: core.schemas.ObjectSchema<Files.Raw, TraceMyApi.v2.problem.Files> = core.schemas.object({
  files: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.problem.FileInfoV2)),
});

export declare namespace Files {
  interface Raw {
    files: serializers.v2.problem.FileInfoV2.Raw[];
  }
}
",
                            "name": "Files.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const FunctionImplementation: core.schemas.ObjectSchema<
  FunctionImplementation.Raw,
  TraceMyApi.v2.problem.FunctionImplementation
> = core.schemas.object({
  impl: core.schemas.string(),
  imports: core.schemas.string().optional(),
});

export declare namespace FunctionImplementation {
  interface Raw {
    impl: string;
    imports?: string | null;
  }
}
",
                            "name": "FunctionImplementation.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const FunctionImplementationForMultipleLanguages: core.schemas.ObjectSchema<
  FunctionImplementationForMultipleLanguages.Raw,
  TraceMyApi.v2.problem.FunctionImplementationForMultipleLanguages
> = core.schemas.object({
  codeByLanguage: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => serializers.v2.problem.FunctionImplementation)
  ),
});

export declare namespace FunctionImplementationForMultipleLanguages {
  interface Raw {
    codeByLanguage: Record<serializers.commons.Language.Raw, serializers.v2.problem.FunctionImplementation.Raw>;
  }
}
",
                            "name": "FunctionImplementationForMultipleLanguages.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const FunctionSignature: core.schemas.Schema<FunctionSignature.Raw, TraceMyApi.v2.problem.FunctionSignature> =
  core.schemas
    .union(\\"type\\", {
      void: core.schemas.lazyObject(() => serializers.v2.problem.VoidFunctionSignature),
      nonVoid: core.schemas.lazyObject(() => serializers.v2.problem.NonVoidFunctionSignature),
      voidThatTakesActualResult: core.schemas.lazyObject(
        () => serializers.v2.problem.VoidFunctionSignatureThatTakesActualResult
      ),
    })
    .transform<TraceMyApi.v2.problem.FunctionSignature>({
      parse: (value) => {
        switch (value.type) {
          case \\"void\\": {
            return TraceMyApi.v2.problem.FunctionSignature.void(value);
          }
          case \\"nonVoid\\": {
            return TraceMyApi.v2.problem.FunctionSignature.nonVoid(value);
          }
          case \\"voidThatTakesActualResult\\": {
            return TraceMyApi.v2.problem.FunctionSignature.voidThatTakesActualResult(value);
          }
          default: {
            return {
              ...(value as any),
              _visit: (visitor) => visitor._other(value),
            };
          }
        }
      },
      json: (value) => value as any,
    });

export declare namespace FunctionSignature {
  type Raw = FunctionSignature.Void | FunctionSignature.NonVoid | FunctionSignature.VoidThatTakesActualResult;

  interface Void extends serializers.v2.problem.VoidFunctionSignature.Raw {
    type: \\"void\\";
  }

  interface NonVoid extends serializers.v2.problem.NonVoidFunctionSignature.Raw {
    type: \\"nonVoid\\";
  }

  interface VoidThatTakesActualResult extends serializers.v2.problem.VoidFunctionSignatureThatTakesActualResult.Raw {
    type: \\"voidThatTakesActualResult\\";
  }
}
",
                            "name": "FunctionSignature.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const GeneratedFiles: core.schemas.ObjectSchema<GeneratedFiles.Raw, TraceMyApi.v2.problem.GeneratedFiles> =
  core.schemas.object({
    generatedTestCaseFiles: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(() => serializers.v2.problem.Files)
    ),
    generatedTemplateFiles: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(() => serializers.v2.problem.Files)
    ),
    other: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(() => serializers.v2.problem.Files)
    ),
  });

export declare namespace GeneratedFiles {
  interface Raw {
    generatedTestCaseFiles: Record<serializers.commons.Language.Raw, serializers.v2.problem.Files.Raw>;
    generatedTemplateFiles: Record<serializers.commons.Language.Raw, serializers.v2.problem.Files.Raw>;
    other: Record<serializers.commons.Language.Raw, serializers.v2.problem.Files.Raw>;
  }
}
",
                            "name": "GeneratedFiles.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const GetBasicSolutionFileRequest: core.schemas.ObjectSchema<
  GetBasicSolutionFileRequest.Raw,
  TraceMyApi.v2.problem.GetBasicSolutionFileRequest
> = core.schemas.object({
  methodName: core.schemas.string(),
  signature: core.schemas.lazyObject(() => serializers.v2.problem.NonVoidFunctionSignature),
});

export declare namespace GetBasicSolutionFileRequest {
  interface Raw {
    methodName: string;
    signature: serializers.v2.problem.NonVoidFunctionSignature.Raw;
  }
}
",
                            "name": "GetBasicSolutionFileRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const GetBasicSolutionFileResponse: core.schemas.ObjectSchema<
  GetBasicSolutionFileResponse.Raw,
  TraceMyApi.v2.problem.GetBasicSolutionFileResponse
> = core.schemas.object({
  solutionFileByLanguage: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => serializers.v2.problem.FileInfoV2)
  ),
});

export declare namespace GetBasicSolutionFileResponse {
  interface Raw {
    solutionFileByLanguage: Record<serializers.commons.Language.Raw, serializers.v2.problem.FileInfoV2.Raw>;
  }
}
",
                            "name": "GetBasicSolutionFileResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const GetFunctionSignatureRequest: core.schemas.ObjectSchema<
  GetFunctionSignatureRequest.Raw,
  TraceMyApi.v2.problem.GetFunctionSignatureRequest
> = core.schemas.object({
  functionSignature: core.schemas.lazy(() => serializers.v2.problem.FunctionSignature),
});

export declare namespace GetFunctionSignatureRequest {
  interface Raw {
    functionSignature: serializers.v2.problem.FunctionSignature.Raw;
  }
}
",
                            "name": "GetFunctionSignatureRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const GetFunctionSignatureResponse: core.schemas.ObjectSchema<
  GetFunctionSignatureResponse.Raw,
  TraceMyApi.v2.problem.GetFunctionSignatureResponse
> = core.schemas.object({
  functionByLanguage: core.schemas.record(core.schemas.string(), core.schemas.string()),
});

export declare namespace GetFunctionSignatureResponse {
  interface Raw {
    functionByLanguage: Record<serializers.commons.Language.Raw, string>;
  }
}
",
                            "name": "GetFunctionSignatureResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const GetGeneratedTestCaseFileRequest: core.schemas.ObjectSchema<
  GetGeneratedTestCaseFileRequest.Raw,
  TraceMyApi.v2.problem.GetGeneratedTestCaseFileRequest
> = core.schemas.object({
  template: core.schemas.lazyObject(() => serializers.v2.problem.TestCaseTemplate).optional(),
  testCase: core.schemas.lazyObject(() => serializers.v2.problem.TestCaseV2),
});

export declare namespace GetGeneratedTestCaseFileRequest {
  interface Raw {
    template?: serializers.v2.problem.TestCaseTemplate.Raw | null;
    testCase: serializers.v2.problem.TestCaseV2.Raw;
  }
}
",
                            "name": "GetGeneratedTestCaseFileRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const GetGeneratedTestCaseTemplateFileRequest: core.schemas.ObjectSchema<
  GetGeneratedTestCaseTemplateFileRequest.Raw,
  TraceMyApi.v2.problem.GetGeneratedTestCaseTemplateFileRequest
> = core.schemas.object({
  template: core.schemas.lazyObject(() => serializers.v2.problem.TestCaseTemplate),
});

export declare namespace GetGeneratedTestCaseTemplateFileRequest {
  interface Raw {
    template: serializers.v2.problem.TestCaseTemplate.Raw;
  }
}
",
                            "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const LightweightProblemInfoV2: core.schemas.ObjectSchema<
  LightweightProblemInfoV2.Raw,
  TraceMyApi.v2.problem.LightweightProblemInfoV2
> = core.schemas.object({
  problemId: core.schemas.lazy(() => serializers.commons.ProblemId),
  problemName: core.schemas.string(),
  problemVersion: core.schemas.number(),
  variableTypes: core.schemas.list(core.schemas.lazy(() => serializers.commons.VariableType)),
});

export declare namespace LightweightProblemInfoV2 {
  interface Raw {
    problemId: serializers.commons.ProblemId.Raw;
    problemName: string;
    problemVersion: number;
    variableTypes: serializers.commons.VariableType.Raw[];
  }
}
",
                            "name": "LightweightProblemInfoV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const NonVoidFunctionDefinition: core.schemas.ObjectSchema<
  NonVoidFunctionDefinition.Raw,
  TraceMyApi.v2.problem.NonVoidFunctionDefinition
> = core.schemas.object({
  signature: core.schemas.lazyObject(() => serializers.v2.problem.NonVoidFunctionSignature),
  code: core.schemas.lazyObject(() => serializers.v2.problem.FunctionImplementationForMultipleLanguages),
});

export declare namespace NonVoidFunctionDefinition {
  interface Raw {
    signature: serializers.v2.problem.NonVoidFunctionSignature.Raw;
    code: serializers.v2.problem.FunctionImplementationForMultipleLanguages.Raw;
  }
}
",
                            "name": "NonVoidFunctionDefinition.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const NonVoidFunctionSignature: core.schemas.ObjectSchema<
  NonVoidFunctionSignature.Raw,
  TraceMyApi.v2.problem.NonVoidFunctionSignature
> = core.schemas.object({
  parameters: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.problem.Parameter)),
  returnType: core.schemas.lazy(() => serializers.commons.VariableType),
});

export declare namespace NonVoidFunctionSignature {
  interface Raw {
    parameters: serializers.v2.problem.Parameter.Raw[];
    returnType: serializers.commons.VariableType.Raw;
  }
}
",
                            "name": "NonVoidFunctionSignature.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const Parameter: core.schemas.ObjectSchema<Parameter.Raw, TraceMyApi.v2.problem.Parameter> = core.schemas.object(
  {
    parameterId: core.schemas.lazy(() => serializers.v2.problem.ParameterId),
    name: core.schemas.string(),
    variableType: core.schemas.lazy(() => serializers.commons.VariableType),
  }
);

export declare namespace Parameter {
  interface Raw {
    parameterId: serializers.v2.problem.ParameterId.Raw;
    name: string;
    variableType: serializers.commons.VariableType.Raw;
  }
}
",
                            "name": "Parameter.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const ParameterId: core.schemas.Schema<ParameterId.Raw, TraceMyApi.v2.problem.ParameterId> =
  core.schemas.string();

export declare namespace ParameterId {
  type Raw = string;
}
",
                            "name": "ParameterId.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const ProblemInfoV2: core.schemas.ObjectSchema<ProblemInfoV2.Raw, TraceMyApi.v2.problem.ProblemInfoV2> =
  core.schemas.object({
    problemId: core.schemas.lazy(() => serializers.commons.ProblemId),
    problemDescription: core.schemas.lazyObject(() => serializers.problem.ProblemDescription),
    problemName: core.schemas.string(),
    problemVersion: core.schemas.number(),
    supportedLanguages: core.schemas.list(core.schemas.lazy(() => serializers.commons.Language)),
    customFiles: core.schemas.lazy(() => serializers.v2.problem.CustomFiles),
    generatedFiles: core.schemas.lazyObject(() => serializers.v2.problem.GeneratedFiles),
    customTestCaseTemplates: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.problem.TestCaseTemplate)),
    testcases: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.problem.TestCaseV2)),
    isPublic: core.schemas.boolean(),
  });

export declare namespace ProblemInfoV2 {
  interface Raw {
    problemId: serializers.commons.ProblemId.Raw;
    problemDescription: serializers.problem.ProblemDescription.Raw;
    problemName: string;
    problemVersion: number;
    supportedLanguages: serializers.commons.Language.Raw[];
    customFiles: serializers.v2.problem.CustomFiles.Raw;
    generatedFiles: serializers.v2.problem.GeneratedFiles.Raw;
    customTestCaseTemplates: serializers.v2.problem.TestCaseTemplate.Raw[];
    testcases: serializers.v2.problem.TestCaseV2.Raw[];
    isPublic: boolean;
  }
}
",
                            "name": "ProblemInfoV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const TestCaseExpects: core.schemas.ObjectSchema<TestCaseExpects.Raw, TraceMyApi.v2.problem.TestCaseExpects> =
  core.schemas.object({
    expectedStdout: core.schemas.string().optional(),
  });

export declare namespace TestCaseExpects {
  interface Raw {
    expectedStdout?: string | null;
  }
}
",
                            "name": "TestCaseExpects.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const TestCaseFunction: core.schemas.Schema<TestCaseFunction.Raw, TraceMyApi.v2.problem.TestCaseFunction> =
  core.schemas
    .union(\\"type\\", {
      withActualResult: core.schemas.lazyObject(() => serializers.v2.problem.TestCaseWithActualResultImplementation),
      custom: core.schemas.lazyObject(() => serializers.v2.problem.VoidFunctionDefinition),
    })
    .transform<TraceMyApi.v2.problem.TestCaseFunction>({
      parse: (value) => {
        switch (value.type) {
          case \\"withActualResult\\": {
            return TraceMyApi.v2.problem.TestCaseFunction.withActualResult(value);
          }
          case \\"custom\\": {
            return TraceMyApi.v2.problem.TestCaseFunction.custom(value);
          }
          default: {
            return {
              ...(value as any),
              _visit: (visitor) => visitor._other(value),
            };
          }
        }
      },
      json: (value) => value as any,
    });

export declare namespace TestCaseFunction {
  type Raw = TestCaseFunction.WithActualResult | TestCaseFunction.Custom;

  interface WithActualResult extends serializers.v2.problem.TestCaseWithActualResultImplementation.Raw {
    type: \\"withActualResult\\";
  }

  interface Custom extends serializers.v2.problem.VoidFunctionDefinition.Raw {
    type: \\"custom\\";
  }
}
",
                            "name": "TestCaseFunction.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const TestCaseId: core.schemas.Schema<TestCaseId.Raw, TraceMyApi.v2.problem.TestCaseId> = core.schemas.string();

export declare namespace TestCaseId {
  type Raw = string;
}
",
                            "name": "TestCaseId.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const TestCaseImplementation: core.schemas.ObjectSchema<
  TestCaseImplementation.Raw,
  TraceMyApi.v2.problem.TestCaseImplementation
> = core.schemas.object({
  description: core.schemas.lazyObject(() => serializers.v2.problem.TestCaseImplementationDescription),
  function: core.schemas.lazy(() => serializers.v2.problem.TestCaseFunction),
});

export declare namespace TestCaseImplementation {
  interface Raw {
    description: serializers.v2.problem.TestCaseImplementationDescription.Raw;
    function: serializers.v2.problem.TestCaseFunction.Raw;
  }
}
",
                            "name": "TestCaseImplementation.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const TestCaseImplementationDescription: core.schemas.ObjectSchema<
  TestCaseImplementationDescription.Raw,
  TraceMyApi.v2.problem.TestCaseImplementationDescription
> = core.schemas.object({
  boards: core.schemas.list(core.schemas.lazy(() => serializers.v2.problem.TestCaseImplementationDescriptionBoard)),
});

export declare namespace TestCaseImplementationDescription {
  interface Raw {
    boards: serializers.v2.problem.TestCaseImplementationDescriptionBoard.Raw[];
  }
}
",
                            "name": "TestCaseImplementationDescription.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const TestCaseImplementationDescriptionBoard: core.schemas.Schema<
  TestCaseImplementationDescriptionBoard.Raw,
  TraceMyApi.v2.problem.TestCaseImplementationDescriptionBoard
> = core.schemas
  .union(\\"type\\", {
    html: core.schemas.object({
      value: core.schemas.string(),
    }),
    paramId: core.schemas.object({
      value: core.schemas.lazy(() => serializers.v2.problem.ParameterId),
    }),
  })
  .transform<TraceMyApi.v2.problem.TestCaseImplementationDescriptionBoard>({
    parse: (value) => {
      switch (value.type) {
        case \\"html\\": {
          return TraceMyApi.v2.problem.TestCaseImplementationDescriptionBoard.html(value.value);
        }
        case \\"paramId\\": {
          return TraceMyApi.v2.problem.TestCaseImplementationDescriptionBoard.paramId(value.value);
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestCaseImplementationDescriptionBoard {
  type Raw = TestCaseImplementationDescriptionBoard.Html | TestCaseImplementationDescriptionBoard.ParamId;

  interface Html {
    type: \\"html\\";
    value: string;
  }

  interface ParamId {
    type: \\"paramId\\";
    value: serializers.v2.problem.ParameterId.Raw;
  }
}
",
                            "name": "TestCaseImplementationDescriptionBoard.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const TestCaseImplementationReference: core.schemas.Schema<
  TestCaseImplementationReference.Raw,
  TraceMyApi.v2.problem.TestCaseImplementationReference
> = core.schemas
  .union(\\"type\\", {
    templateId: core.schemas.object({
      value: core.schemas.lazy(() => serializers.v2.problem.TestCaseTemplateId),
    }),
    implementation: core.schemas.lazyObject(() => serializers.v2.problem.TestCaseImplementation),
  })
  .transform<TraceMyApi.v2.problem.TestCaseImplementationReference>({
    parse: (value) => {
      switch (value.type) {
        case \\"templateId\\": {
          return TraceMyApi.v2.problem.TestCaseImplementationReference.templateId(value.value);
        }
        case \\"implementation\\": {
          return TraceMyApi.v2.problem.TestCaseImplementationReference.implementation(value);
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestCaseImplementationReference {
  type Raw = TestCaseImplementationReference.TemplateId | TestCaseImplementationReference.Implementation;

  interface TemplateId {
    type: \\"templateId\\";
    value: serializers.v2.problem.TestCaseTemplateId.Raw;
  }

  interface Implementation extends serializers.v2.problem.TestCaseImplementation.Raw {
    type: \\"implementation\\";
  }
}
",
                            "name": "TestCaseImplementationReference.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const TestCaseMetadata: core.schemas.ObjectSchema<TestCaseMetadata.Raw, TraceMyApi.v2.problem.TestCaseMetadata> =
  core.schemas.object({
    id: core.schemas.lazy(() => serializers.v2.problem.TestCaseId),
    name: core.schemas.string(),
    hidden: core.schemas.boolean(),
  });

export declare namespace TestCaseMetadata {
  interface Raw {
    id: serializers.v2.problem.TestCaseId.Raw;
    name: string;
    hidden: boolean;
  }
}
",
                            "name": "TestCaseMetadata.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const TestCaseTemplate: core.schemas.ObjectSchema<TestCaseTemplate.Raw, TraceMyApi.v2.problem.TestCaseTemplate> =
  core.schemas.object({
    templateId: core.schemas.lazy(() => serializers.v2.problem.TestCaseTemplateId),
    name: core.schemas.string(),
    implementation: core.schemas.lazyObject(() => serializers.v2.problem.TestCaseImplementation),
  });

export declare namespace TestCaseTemplate {
  interface Raw {
    templateId: serializers.v2.problem.TestCaseTemplateId.Raw;
    name: string;
    implementation: serializers.v2.problem.TestCaseImplementation.Raw;
  }
}
",
                            "name": "TestCaseTemplate.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const TestCaseTemplateId: core.schemas.Schema<TestCaseTemplateId.Raw, TraceMyApi.v2.problem.TestCaseTemplateId> =
  core.schemas.string();

export declare namespace TestCaseTemplateId {
  type Raw = string;
}
",
                            "name": "TestCaseTemplateId.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const TestCaseV2: core.schemas.ObjectSchema<TestCaseV2.Raw, TraceMyApi.v2.problem.TestCaseV2> =
  core.schemas.object({
    metadata: core.schemas.lazyObject(() => serializers.v2.problem.TestCaseMetadata),
    implementation: core.schemas.lazy(() => serializers.v2.problem.TestCaseImplementationReference),
    arguments: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazy(() => serializers.commons.VariableValue)
    ),
    expects: core.schemas.lazyObject(() => serializers.v2.problem.TestCaseExpects).optional(),
  });

export declare namespace TestCaseV2 {
  interface Raw {
    metadata: serializers.v2.problem.TestCaseMetadata.Raw;
    implementation: serializers.v2.problem.TestCaseImplementationReference.Raw;
    arguments: Record<serializers.v2.problem.ParameterId.Raw, serializers.commons.VariableValue.Raw>;
    expects?: serializers.v2.problem.TestCaseExpects.Raw | null;
  }
}
",
                            "name": "TestCaseV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const TestCaseWithActualResultImplementation: core.schemas.ObjectSchema<
  TestCaseWithActualResultImplementation.Raw,
  TraceMyApi.v2.problem.TestCaseWithActualResultImplementation
> = core.schemas.object({
  getActualResult: core.schemas.lazyObject(() => serializers.v2.problem.NonVoidFunctionDefinition),
  assertCorrectnessCheck: core.schemas.lazy(() => serializers.v2.problem.AssertCorrectnessCheck),
});

export declare namespace TestCaseWithActualResultImplementation {
  interface Raw {
    getActualResult: serializers.v2.problem.NonVoidFunctionDefinition.Raw;
    assertCorrectnessCheck: serializers.v2.problem.AssertCorrectnessCheck.Raw;
  }
}
",
                            "name": "TestCaseWithActualResultImplementation.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const VoidFunctionDefinition: core.schemas.ObjectSchema<
  VoidFunctionDefinition.Raw,
  TraceMyApi.v2.problem.VoidFunctionDefinition
> = core.schemas.object({
  parameters: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.problem.Parameter)),
  code: core.schemas.lazyObject(() => serializers.v2.problem.FunctionImplementationForMultipleLanguages),
});

export declare namespace VoidFunctionDefinition {
  interface Raw {
    parameters: serializers.v2.problem.Parameter.Raw[];
    code: serializers.v2.problem.FunctionImplementationForMultipleLanguages.Raw;
  }
}
",
                            "name": "VoidFunctionDefinition.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const VoidFunctionDefinitionThatTakesActualResult: core.schemas.ObjectSchema<
  VoidFunctionDefinitionThatTakesActualResult.Raw,
  TraceMyApi.v2.problem.VoidFunctionDefinitionThatTakesActualResult
> = core.schemas.object({
  additionalParameters: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.problem.Parameter)),
  code: core.schemas.lazyObject(() => serializers.v2.problem.FunctionImplementationForMultipleLanguages),
});

export declare namespace VoidFunctionDefinitionThatTakesActualResult {
  interface Raw {
    additionalParameters: serializers.v2.problem.Parameter.Raw[];
    code: serializers.v2.problem.FunctionImplementationForMultipleLanguages.Raw;
  }
}
",
                            "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const VoidFunctionSignature: core.schemas.ObjectSchema<
  VoidFunctionSignature.Raw,
  TraceMyApi.v2.problem.VoidFunctionSignature
> = core.schemas.object({
  parameters: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.problem.Parameter)),
});

export declare namespace VoidFunctionSignature {
  interface Raw {
    parameters: serializers.v2.problem.Parameter.Raw[];
  }
}
",
                            "name": "VoidFunctionSignature.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const VoidFunctionSignatureThatTakesActualResult: core.schemas.ObjectSchema<
  VoidFunctionSignatureThatTakesActualResult.Raw,
  TraceMyApi.v2.problem.VoidFunctionSignatureThatTakesActualResult
> = core.schemas.object({
  parameters: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.problem.Parameter)),
  actualResultType: core.schemas.lazy(() => serializers.commons.VariableType),
});

export declare namespace VoidFunctionSignatureThatTakesActualResult {
  interface Raw {
    parameters: serializers.v2.problem.Parameter.Raw[];
    actualResultType: serializers.commons.VariableType.Raw;
  }
}
",
                            "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "types",
                        "type": "directory",
                      },
                    ],
                    "name": "problem",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export * from \\"./resources\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": Array [
                              Object {
                                "contents": Array [
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";

export const Response: core.schemas.Schema<
  serializers.v2.v3.problem.LightweightProblemInfoV2.Raw[],
  TraceMyApi.v2.v3.problem.LightweightProblemInfoV2[]
> = core.schemas.list(core.schemas.lazyObject(() => serializers.v2.v3.problem.LightweightProblemInfoV2));
",
                                    "name": "getLightweightProblems.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";

export const Response: core.schemas.Schema<
  serializers.v2.v3.problem.ProblemInfoV2.Raw[],
  TraceMyApi.v2.v3.problem.ProblemInfoV2[]
> = core.schemas.list(core.schemas.lazyObject(() => serializers.v2.v3.problem.ProblemInfoV2));
",
                                    "name": "getProblems.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
",
                                    "name": "index.ts",
                                    "type": "file",
                                  },
                                ],
                                "name": "client",
                                "type": "directory",
                              },
                              Object {
                                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                                "name": "index.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": Array [
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const AssertCorrectnessCheck: core.schemas.Schema<
  AssertCorrectnessCheck.Raw,
  TraceMyApi.v2.v3.problem.AssertCorrectnessCheck
> = core.schemas
  .union(\\"type\\", {
    deepEquality: core.schemas.lazyObject(() => serializers.v2.v3.problem.DeepEqualityCorrectnessCheck),
    custom: core.schemas.lazyObject(() => serializers.v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult),
  })
  .transform<TraceMyApi.v2.v3.problem.AssertCorrectnessCheck>({
    parse: (value) => {
      switch (value.type) {
        case \\"deepEquality\\": {
          return TraceMyApi.v2.v3.problem.AssertCorrectnessCheck.deepEquality(value);
        }
        case \\"custom\\": {
          return TraceMyApi.v2.v3.problem.AssertCorrectnessCheck.custom(value);
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace AssertCorrectnessCheck {
  type Raw = AssertCorrectnessCheck.DeepEquality | AssertCorrectnessCheck.Custom;

  interface DeepEquality extends serializers.v2.v3.problem.DeepEqualityCorrectnessCheck.Raw {
    type: \\"deepEquality\\";
  }

  interface Custom extends serializers.v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult.Raw {
    type: \\"custom\\";
  }
}
",
                                    "name": "AssertCorrectnessCheck.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const BasicCustomFiles: core.schemas.ObjectSchema<
  BasicCustomFiles.Raw,
  TraceMyApi.v2.v3.problem.BasicCustomFiles
> = core.schemas.object({
  methodName: core.schemas.string(),
  signature: core.schemas.lazyObject(() => serializers.v2.v3.problem.NonVoidFunctionSignature),
  additionalFiles: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => serializers.v2.v3.problem.Files)
  ),
  basicTestCaseTemplate: core.schemas.lazyObject(() => serializers.v2.v3.problem.BasicTestCaseTemplate),
});

export declare namespace BasicCustomFiles {
  interface Raw {
    methodName: string;
    signature: serializers.v2.v3.problem.NonVoidFunctionSignature.Raw;
    additionalFiles: Record<serializers.commons.Language.Raw, serializers.v2.v3.problem.Files.Raw>;
    basicTestCaseTemplate: serializers.v2.v3.problem.BasicTestCaseTemplate.Raw;
  }
}
",
                                    "name": "BasicCustomFiles.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const BasicTestCaseTemplate: core.schemas.ObjectSchema<
  BasicTestCaseTemplate.Raw,
  TraceMyApi.v2.v3.problem.BasicTestCaseTemplate
> = core.schemas.object({
  templateId: core.schemas.lazy(() => serializers.v2.v3.problem.TestCaseTemplateId),
  name: core.schemas.string(),
  description: core.schemas.lazyObject(() => serializers.v2.v3.problem.TestCaseImplementationDescription),
  expectedValueParameterId: core.schemas.lazy(() => serializers.v2.v3.problem.ParameterId),
});

export declare namespace BasicTestCaseTemplate {
  interface Raw {
    templateId: serializers.v2.v3.problem.TestCaseTemplateId.Raw;
    name: string;
    description: serializers.v2.v3.problem.TestCaseImplementationDescription.Raw;
    expectedValueParameterId: serializers.v2.v3.problem.ParameterId.Raw;
  }
}
",
                                    "name": "BasicTestCaseTemplate.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const CreateProblemRequestV2: core.schemas.ObjectSchema<
  CreateProblemRequestV2.Raw,
  TraceMyApi.v2.v3.problem.CreateProblemRequestV2
> = core.schemas.object({
  problemName: core.schemas.string(),
  problemDescription: core.schemas.lazyObject(() => serializers.problem.ProblemDescription),
  customFiles: core.schemas.lazy(() => serializers.v2.v3.problem.CustomFiles),
  customTestCaseTemplates: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.v3.problem.TestCaseTemplate)),
  testcases: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.v3.problem.TestCaseV2)),
  supportedLanguages: core.schemas.list(core.schemas.lazy(() => serializers.commons.Language)),
  isPublic: core.schemas.boolean(),
});

export declare namespace CreateProblemRequestV2 {
  interface Raw {
    problemName: string;
    problemDescription: serializers.problem.ProblemDescription.Raw;
    customFiles: serializers.v2.v3.problem.CustomFiles.Raw;
    customTestCaseTemplates: serializers.v2.v3.problem.TestCaseTemplate.Raw[];
    testcases: serializers.v2.v3.problem.TestCaseV2.Raw[];
    supportedLanguages: serializers.commons.Language.Raw[];
    isPublic: boolean;
  }
}
",
                                    "name": "CreateProblemRequestV2.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const CustomFiles: core.schemas.Schema<CustomFiles.Raw, TraceMyApi.v2.v3.problem.CustomFiles> = core.schemas
  .union(\\"type\\", {
    basic: core.schemas.lazyObject(() => serializers.v2.v3.problem.BasicCustomFiles),
    custom: core.schemas.object({
      value: core.schemas.record(
        core.schemas.string(),
        core.schemas.lazyObject(() => serializers.v2.v3.problem.Files)
      ),
    }),
  })
  .transform<TraceMyApi.v2.v3.problem.CustomFiles>({
    parse: (value) => {
      switch (value.type) {
        case \\"basic\\": {
          return TraceMyApi.v2.v3.problem.CustomFiles.basic(value);
        }
        case \\"custom\\": {
          return TraceMyApi.v2.v3.problem.CustomFiles.custom(value.value);
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace CustomFiles {
  type Raw = CustomFiles.Basic | CustomFiles.Custom;

  interface Basic extends serializers.v2.v3.problem.BasicCustomFiles.Raw {
    type: \\"basic\\";
  }

  interface Custom {
    type: \\"custom\\";
    value: Record<serializers.commons.Language.Raw, serializers.v2.v3.problem.Files.Raw>;
  }
}
",
                                    "name": "CustomFiles.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const DeepEqualityCorrectnessCheck: core.schemas.ObjectSchema<
  DeepEqualityCorrectnessCheck.Raw,
  TraceMyApi.v2.v3.problem.DeepEqualityCorrectnessCheck
> = core.schemas.object({
  expectedValueParameterId: core.schemas.lazy(() => serializers.v2.v3.problem.ParameterId),
});

export declare namespace DeepEqualityCorrectnessCheck {
  interface Raw {
    expectedValueParameterId: serializers.v2.v3.problem.ParameterId.Raw;
  }
}
",
                                    "name": "DeepEqualityCorrectnessCheck.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const DefaultProvidedFile: core.schemas.ObjectSchema<
  DefaultProvidedFile.Raw,
  TraceMyApi.v2.v3.problem.DefaultProvidedFile
> = core.schemas.object({
  file: core.schemas.lazyObject(() => serializers.v2.v3.problem.FileInfoV2),
  relatedTypes: core.schemas.list(core.schemas.lazy(() => serializers.commons.VariableType)),
});

export declare namespace DefaultProvidedFile {
  interface Raw {
    file: serializers.v2.v3.problem.FileInfoV2.Raw;
    relatedTypes: serializers.commons.VariableType.Raw[];
  }
}
",
                                    "name": "DefaultProvidedFile.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";

export const FileInfoV2: core.schemas.ObjectSchema<FileInfoV2.Raw, TraceMyApi.v2.v3.problem.FileInfoV2> =
  core.schemas.object({
    filename: core.schemas.string(),
    directory: core.schemas.string(),
    contents: core.schemas.string(),
    editable: core.schemas.boolean(),
  });

export declare namespace FileInfoV2 {
  interface Raw {
    filename: string;
    directory: string;
    contents: string;
    editable: boolean;
  }
}
",
                                    "name": "FileInfoV2.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const Files: core.schemas.ObjectSchema<Files.Raw, TraceMyApi.v2.v3.problem.Files> = core.schemas.object({
  files: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.v3.problem.FileInfoV2)),
});

export declare namespace Files {
  interface Raw {
    files: serializers.v2.v3.problem.FileInfoV2.Raw[];
  }
}
",
                                    "name": "Files.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";

export const FunctionImplementation: core.schemas.ObjectSchema<
  FunctionImplementation.Raw,
  TraceMyApi.v2.v3.problem.FunctionImplementation
> = core.schemas.object({
  impl: core.schemas.string(),
  imports: core.schemas.string().optional(),
});

export declare namespace FunctionImplementation {
  interface Raw {
    impl: string;
    imports?: string | null;
  }
}
",
                                    "name": "FunctionImplementation.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const FunctionImplementationForMultipleLanguages: core.schemas.ObjectSchema<
  FunctionImplementationForMultipleLanguages.Raw,
  TraceMyApi.v2.v3.problem.FunctionImplementationForMultipleLanguages
> = core.schemas.object({
  codeByLanguage: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => serializers.v2.v3.problem.FunctionImplementation)
  ),
});

export declare namespace FunctionImplementationForMultipleLanguages {
  interface Raw {
    codeByLanguage: Record<serializers.commons.Language.Raw, serializers.v2.v3.problem.FunctionImplementation.Raw>;
  }
}
",
                                    "name": "FunctionImplementationForMultipleLanguages.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const FunctionSignature: core.schemas.Schema<FunctionSignature.Raw, TraceMyApi.v2.v3.problem.FunctionSignature> =
  core.schemas
    .union(\\"type\\", {
      void: core.schemas.lazyObject(() => serializers.v2.v3.problem.VoidFunctionSignature),
      nonVoid: core.schemas.lazyObject(() => serializers.v2.v3.problem.NonVoidFunctionSignature),
      voidThatTakesActualResult: core.schemas.lazyObject(
        () => serializers.v2.v3.problem.VoidFunctionSignatureThatTakesActualResult
      ),
    })
    .transform<TraceMyApi.v2.v3.problem.FunctionSignature>({
      parse: (value) => {
        switch (value.type) {
          case \\"void\\": {
            return TraceMyApi.v2.v3.problem.FunctionSignature.void(value);
          }
          case \\"nonVoid\\": {
            return TraceMyApi.v2.v3.problem.FunctionSignature.nonVoid(value);
          }
          case \\"voidThatTakesActualResult\\": {
            return TraceMyApi.v2.v3.problem.FunctionSignature.voidThatTakesActualResult(value);
          }
          default: {
            return {
              ...(value as any),
              _visit: (visitor) => visitor._other(value),
            };
          }
        }
      },
      json: (value) => value as any,
    });

export declare namespace FunctionSignature {
  type Raw = FunctionSignature.Void | FunctionSignature.NonVoid | FunctionSignature.VoidThatTakesActualResult;

  interface Void extends serializers.v2.v3.problem.VoidFunctionSignature.Raw {
    type: \\"void\\";
  }

  interface NonVoid extends serializers.v2.v3.problem.NonVoidFunctionSignature.Raw {
    type: \\"nonVoid\\";
  }

  interface VoidThatTakesActualResult extends serializers.v2.v3.problem.VoidFunctionSignatureThatTakesActualResult.Raw {
    type: \\"voidThatTakesActualResult\\";
  }
}
",
                                    "name": "FunctionSignature.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const GeneratedFiles: core.schemas.ObjectSchema<GeneratedFiles.Raw, TraceMyApi.v2.v3.problem.GeneratedFiles> =
  core.schemas.object({
    generatedTestCaseFiles: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(() => serializers.v2.v3.problem.Files)
    ),
    generatedTemplateFiles: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(() => serializers.v2.v3.problem.Files)
    ),
    other: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(() => serializers.v2.v3.problem.Files)
    ),
  });

export declare namespace GeneratedFiles {
  interface Raw {
    generatedTestCaseFiles: Record<serializers.commons.Language.Raw, serializers.v2.v3.problem.Files.Raw>;
    generatedTemplateFiles: Record<serializers.commons.Language.Raw, serializers.v2.v3.problem.Files.Raw>;
    other: Record<serializers.commons.Language.Raw, serializers.v2.v3.problem.Files.Raw>;
  }
}
",
                                    "name": "GeneratedFiles.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const GetBasicSolutionFileRequest: core.schemas.ObjectSchema<
  GetBasicSolutionFileRequest.Raw,
  TraceMyApi.v2.v3.problem.GetBasicSolutionFileRequest
> = core.schemas.object({
  methodName: core.schemas.string(),
  signature: core.schemas.lazyObject(() => serializers.v2.v3.problem.NonVoidFunctionSignature),
});

export declare namespace GetBasicSolutionFileRequest {
  interface Raw {
    methodName: string;
    signature: serializers.v2.v3.problem.NonVoidFunctionSignature.Raw;
  }
}
",
                                    "name": "GetBasicSolutionFileRequest.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const GetBasicSolutionFileResponse: core.schemas.ObjectSchema<
  GetBasicSolutionFileResponse.Raw,
  TraceMyApi.v2.v3.problem.GetBasicSolutionFileResponse
> = core.schemas.object({
  solutionFileByLanguage: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => serializers.v2.v3.problem.FileInfoV2)
  ),
});

export declare namespace GetBasicSolutionFileResponse {
  interface Raw {
    solutionFileByLanguage: Record<serializers.commons.Language.Raw, serializers.v2.v3.problem.FileInfoV2.Raw>;
  }
}
",
                                    "name": "GetBasicSolutionFileResponse.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const GetFunctionSignatureRequest: core.schemas.ObjectSchema<
  GetFunctionSignatureRequest.Raw,
  TraceMyApi.v2.v3.problem.GetFunctionSignatureRequest
> = core.schemas.object({
  functionSignature: core.schemas.lazy(() => serializers.v2.v3.problem.FunctionSignature),
});

export declare namespace GetFunctionSignatureRequest {
  interface Raw {
    functionSignature: serializers.v2.v3.problem.FunctionSignature.Raw;
  }
}
",
                                    "name": "GetFunctionSignatureRequest.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const GetFunctionSignatureResponse: core.schemas.ObjectSchema<
  GetFunctionSignatureResponse.Raw,
  TraceMyApi.v2.v3.problem.GetFunctionSignatureResponse
> = core.schemas.object({
  functionByLanguage: core.schemas.record(core.schemas.string(), core.schemas.string()),
});

export declare namespace GetFunctionSignatureResponse {
  interface Raw {
    functionByLanguage: Record<serializers.commons.Language.Raw, string>;
  }
}
",
                                    "name": "GetFunctionSignatureResponse.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const GetGeneratedTestCaseFileRequest: core.schemas.ObjectSchema<
  GetGeneratedTestCaseFileRequest.Raw,
  TraceMyApi.v2.v3.problem.GetGeneratedTestCaseFileRequest
> = core.schemas.object({
  template: core.schemas.lazyObject(() => serializers.v2.v3.problem.TestCaseTemplate).optional(),
  testCase: core.schemas.lazyObject(() => serializers.v2.v3.problem.TestCaseV2),
});

export declare namespace GetGeneratedTestCaseFileRequest {
  interface Raw {
    template?: serializers.v2.v3.problem.TestCaseTemplate.Raw | null;
    testCase: serializers.v2.v3.problem.TestCaseV2.Raw;
  }
}
",
                                    "name": "GetGeneratedTestCaseFileRequest.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const GetGeneratedTestCaseTemplateFileRequest: core.schemas.ObjectSchema<
  GetGeneratedTestCaseTemplateFileRequest.Raw,
  TraceMyApi.v2.v3.problem.GetGeneratedTestCaseTemplateFileRequest
> = core.schemas.object({
  template: core.schemas.lazyObject(() => serializers.v2.v3.problem.TestCaseTemplate),
});

export declare namespace GetGeneratedTestCaseTemplateFileRequest {
  interface Raw {
    template: serializers.v2.v3.problem.TestCaseTemplate.Raw;
  }
}
",
                                    "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const LightweightProblemInfoV2: core.schemas.ObjectSchema<
  LightweightProblemInfoV2.Raw,
  TraceMyApi.v2.v3.problem.LightweightProblemInfoV2
> = core.schemas.object({
  problemId: core.schemas.lazy(() => serializers.commons.ProblemId),
  problemName: core.schemas.string(),
  problemVersion: core.schemas.number(),
  variableTypes: core.schemas.list(core.schemas.lazy(() => serializers.commons.VariableType)),
});

export declare namespace LightweightProblemInfoV2 {
  interface Raw {
    problemId: serializers.commons.ProblemId.Raw;
    problemName: string;
    problemVersion: number;
    variableTypes: serializers.commons.VariableType.Raw[];
  }
}
",
                                    "name": "LightweightProblemInfoV2.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const NonVoidFunctionDefinition: core.schemas.ObjectSchema<
  NonVoidFunctionDefinition.Raw,
  TraceMyApi.v2.v3.problem.NonVoidFunctionDefinition
> = core.schemas.object({
  signature: core.schemas.lazyObject(() => serializers.v2.v3.problem.NonVoidFunctionSignature),
  code: core.schemas.lazyObject(() => serializers.v2.v3.problem.FunctionImplementationForMultipleLanguages),
});

export declare namespace NonVoidFunctionDefinition {
  interface Raw {
    signature: serializers.v2.v3.problem.NonVoidFunctionSignature.Raw;
    code: serializers.v2.v3.problem.FunctionImplementationForMultipleLanguages.Raw;
  }
}
",
                                    "name": "NonVoidFunctionDefinition.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const NonVoidFunctionSignature: core.schemas.ObjectSchema<
  NonVoidFunctionSignature.Raw,
  TraceMyApi.v2.v3.problem.NonVoidFunctionSignature
> = core.schemas.object({
  parameters: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.v3.problem.Parameter)),
  returnType: core.schemas.lazy(() => serializers.commons.VariableType),
});

export declare namespace NonVoidFunctionSignature {
  interface Raw {
    parameters: serializers.v2.v3.problem.Parameter.Raw[];
    returnType: serializers.commons.VariableType.Raw;
  }
}
",
                                    "name": "NonVoidFunctionSignature.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const Parameter: core.schemas.ObjectSchema<Parameter.Raw, TraceMyApi.v2.v3.problem.Parameter> =
  core.schemas.object({
    parameterId: core.schemas.lazy(() => serializers.v2.v3.problem.ParameterId),
    name: core.schemas.string(),
    variableType: core.schemas.lazy(() => serializers.commons.VariableType),
  });

export declare namespace Parameter {
  interface Raw {
    parameterId: serializers.v2.v3.problem.ParameterId.Raw;
    name: string;
    variableType: serializers.commons.VariableType.Raw;
  }
}
",
                                    "name": "Parameter.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";

export const ParameterId: core.schemas.Schema<ParameterId.Raw, TraceMyApi.v2.v3.problem.ParameterId> =
  core.schemas.string();

export declare namespace ParameterId {
  type Raw = string;
}
",
                                    "name": "ParameterId.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const ProblemInfoV2: core.schemas.ObjectSchema<ProblemInfoV2.Raw, TraceMyApi.v2.v3.problem.ProblemInfoV2> =
  core.schemas.object({
    problemId: core.schemas.lazy(() => serializers.commons.ProblemId),
    problemDescription: core.schemas.lazyObject(() => serializers.problem.ProblemDescription),
    problemName: core.schemas.string(),
    problemVersion: core.schemas.number(),
    supportedLanguages: core.schemas.list(core.schemas.lazy(() => serializers.commons.Language)),
    customFiles: core.schemas.lazy(() => serializers.v2.v3.problem.CustomFiles),
    generatedFiles: core.schemas.lazyObject(() => serializers.v2.v3.problem.GeneratedFiles),
    customTestCaseTemplates: core.schemas.list(
      core.schemas.lazyObject(() => serializers.v2.v3.problem.TestCaseTemplate)
    ),
    testcases: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.v3.problem.TestCaseV2)),
    isPublic: core.schemas.boolean(),
  });

export declare namespace ProblemInfoV2 {
  interface Raw {
    problemId: serializers.commons.ProblemId.Raw;
    problemDescription: serializers.problem.ProblemDescription.Raw;
    problemName: string;
    problemVersion: number;
    supportedLanguages: serializers.commons.Language.Raw[];
    customFiles: serializers.v2.v3.problem.CustomFiles.Raw;
    generatedFiles: serializers.v2.v3.problem.GeneratedFiles.Raw;
    customTestCaseTemplates: serializers.v2.v3.problem.TestCaseTemplate.Raw[];
    testcases: serializers.v2.v3.problem.TestCaseV2.Raw[];
    isPublic: boolean;
  }
}
",
                                    "name": "ProblemInfoV2.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";

export const TestCaseExpects: core.schemas.ObjectSchema<TestCaseExpects.Raw, TraceMyApi.v2.v3.problem.TestCaseExpects> =
  core.schemas.object({
    expectedStdout: core.schemas.string().optional(),
  });

export declare namespace TestCaseExpects {
  interface Raw {
    expectedStdout?: string | null;
  }
}
",
                                    "name": "TestCaseExpects.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const TestCaseFunction: core.schemas.Schema<TestCaseFunction.Raw, TraceMyApi.v2.v3.problem.TestCaseFunction> =
  core.schemas
    .union(\\"type\\", {
      withActualResult: core.schemas.lazyObject(() => serializers.v2.v3.problem.TestCaseWithActualResultImplementation),
      custom: core.schemas.lazyObject(() => serializers.v2.v3.problem.VoidFunctionDefinition),
    })
    .transform<TraceMyApi.v2.v3.problem.TestCaseFunction>({
      parse: (value) => {
        switch (value.type) {
          case \\"withActualResult\\": {
            return TraceMyApi.v2.v3.problem.TestCaseFunction.withActualResult(value);
          }
          case \\"custom\\": {
            return TraceMyApi.v2.v3.problem.TestCaseFunction.custom(value);
          }
          default: {
            return {
              ...(value as any),
              _visit: (visitor) => visitor._other(value),
            };
          }
        }
      },
      json: (value) => value as any,
    });

export declare namespace TestCaseFunction {
  type Raw = TestCaseFunction.WithActualResult | TestCaseFunction.Custom;

  interface WithActualResult extends serializers.v2.v3.problem.TestCaseWithActualResultImplementation.Raw {
    type: \\"withActualResult\\";
  }

  interface Custom extends serializers.v2.v3.problem.VoidFunctionDefinition.Raw {
    type: \\"custom\\";
  }
}
",
                                    "name": "TestCaseFunction.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";

export const TestCaseId: core.schemas.Schema<TestCaseId.Raw, TraceMyApi.v2.v3.problem.TestCaseId> =
  core.schemas.string();

export declare namespace TestCaseId {
  type Raw = string;
}
",
                                    "name": "TestCaseId.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const TestCaseImplementation: core.schemas.ObjectSchema<
  TestCaseImplementation.Raw,
  TraceMyApi.v2.v3.problem.TestCaseImplementation
> = core.schemas.object({
  description: core.schemas.lazyObject(() => serializers.v2.v3.problem.TestCaseImplementationDescription),
  function: core.schemas.lazy(() => serializers.v2.v3.problem.TestCaseFunction),
});

export declare namespace TestCaseImplementation {
  interface Raw {
    description: serializers.v2.v3.problem.TestCaseImplementationDescription.Raw;
    function: serializers.v2.v3.problem.TestCaseFunction.Raw;
  }
}
",
                                    "name": "TestCaseImplementation.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const TestCaseImplementationDescription: core.schemas.ObjectSchema<
  TestCaseImplementationDescription.Raw,
  TraceMyApi.v2.v3.problem.TestCaseImplementationDescription
> = core.schemas.object({
  boards: core.schemas.list(core.schemas.lazy(() => serializers.v2.v3.problem.TestCaseImplementationDescriptionBoard)),
});

export declare namespace TestCaseImplementationDescription {
  interface Raw {
    boards: serializers.v2.v3.problem.TestCaseImplementationDescriptionBoard.Raw[];
  }
}
",
                                    "name": "TestCaseImplementationDescription.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const TestCaseImplementationDescriptionBoard: core.schemas.Schema<
  TestCaseImplementationDescriptionBoard.Raw,
  TraceMyApi.v2.v3.problem.TestCaseImplementationDescriptionBoard
> = core.schemas
  .union(\\"type\\", {
    html: core.schemas.object({
      value: core.schemas.string(),
    }),
    paramId: core.schemas.object({
      value: core.schemas.lazy(() => serializers.v2.v3.problem.ParameterId),
    }),
  })
  .transform<TraceMyApi.v2.v3.problem.TestCaseImplementationDescriptionBoard>({
    parse: (value) => {
      switch (value.type) {
        case \\"html\\": {
          return TraceMyApi.v2.v3.problem.TestCaseImplementationDescriptionBoard.html(value.value);
        }
        case \\"paramId\\": {
          return TraceMyApi.v2.v3.problem.TestCaseImplementationDescriptionBoard.paramId(value.value);
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestCaseImplementationDescriptionBoard {
  type Raw = TestCaseImplementationDescriptionBoard.Html | TestCaseImplementationDescriptionBoard.ParamId;

  interface Html {
    type: \\"html\\";
    value: string;
  }

  interface ParamId {
    type: \\"paramId\\";
    value: serializers.v2.v3.problem.ParameterId.Raw;
  }
}
",
                                    "name": "TestCaseImplementationDescriptionBoard.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const TestCaseImplementationReference: core.schemas.Schema<
  TestCaseImplementationReference.Raw,
  TraceMyApi.v2.v3.problem.TestCaseImplementationReference
> = core.schemas
  .union(\\"type\\", {
    templateId: core.schemas.object({
      value: core.schemas.lazy(() => serializers.v2.v3.problem.TestCaseTemplateId),
    }),
    implementation: core.schemas.lazyObject(() => serializers.v2.v3.problem.TestCaseImplementation),
  })
  .transform<TraceMyApi.v2.v3.problem.TestCaseImplementationReference>({
    parse: (value) => {
      switch (value.type) {
        case \\"templateId\\": {
          return TraceMyApi.v2.v3.problem.TestCaseImplementationReference.templateId(value.value);
        }
        case \\"implementation\\": {
          return TraceMyApi.v2.v3.problem.TestCaseImplementationReference.implementation(value);
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestCaseImplementationReference {
  type Raw = TestCaseImplementationReference.TemplateId | TestCaseImplementationReference.Implementation;

  interface TemplateId {
    type: \\"templateId\\";
    value: serializers.v2.v3.problem.TestCaseTemplateId.Raw;
  }

  interface Implementation extends serializers.v2.v3.problem.TestCaseImplementation.Raw {
    type: \\"implementation\\";
  }
}
",
                                    "name": "TestCaseImplementationReference.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const TestCaseMetadata: core.schemas.ObjectSchema<
  TestCaseMetadata.Raw,
  TraceMyApi.v2.v3.problem.TestCaseMetadata
> = core.schemas.object({
  id: core.schemas.lazy(() => serializers.v2.v3.problem.TestCaseId),
  name: core.schemas.string(),
  hidden: core.schemas.boolean(),
});

export declare namespace TestCaseMetadata {
  interface Raw {
    id: serializers.v2.v3.problem.TestCaseId.Raw;
    name: string;
    hidden: boolean;
  }
}
",
                                    "name": "TestCaseMetadata.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const TestCaseTemplate: core.schemas.ObjectSchema<
  TestCaseTemplate.Raw,
  TraceMyApi.v2.v3.problem.TestCaseTemplate
> = core.schemas.object({
  templateId: core.schemas.lazy(() => serializers.v2.v3.problem.TestCaseTemplateId),
  name: core.schemas.string(),
  implementation: core.schemas.lazyObject(() => serializers.v2.v3.problem.TestCaseImplementation),
});

export declare namespace TestCaseTemplate {
  interface Raw {
    templateId: serializers.v2.v3.problem.TestCaseTemplateId.Raw;
    name: string;
    implementation: serializers.v2.v3.problem.TestCaseImplementation.Raw;
  }
}
",
                                    "name": "TestCaseTemplate.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";

export const TestCaseTemplateId: core.schemas.Schema<
  TestCaseTemplateId.Raw,
  TraceMyApi.v2.v3.problem.TestCaseTemplateId
> = core.schemas.string();

export declare namespace TestCaseTemplateId {
  type Raw = string;
}
",
                                    "name": "TestCaseTemplateId.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const TestCaseV2: core.schemas.ObjectSchema<TestCaseV2.Raw, TraceMyApi.v2.v3.problem.TestCaseV2> =
  core.schemas.object({
    metadata: core.schemas.lazyObject(() => serializers.v2.v3.problem.TestCaseMetadata),
    implementation: core.schemas.lazy(() => serializers.v2.v3.problem.TestCaseImplementationReference),
    arguments: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazy(() => serializers.commons.VariableValue)
    ),
    expects: core.schemas.lazyObject(() => serializers.v2.v3.problem.TestCaseExpects).optional(),
  });

export declare namespace TestCaseV2 {
  interface Raw {
    metadata: serializers.v2.v3.problem.TestCaseMetadata.Raw;
    implementation: serializers.v2.v3.problem.TestCaseImplementationReference.Raw;
    arguments: Record<serializers.v2.v3.problem.ParameterId.Raw, serializers.commons.VariableValue.Raw>;
    expects?: serializers.v2.v3.problem.TestCaseExpects.Raw | null;
  }
}
",
                                    "name": "TestCaseV2.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const TestCaseWithActualResultImplementation: core.schemas.ObjectSchema<
  TestCaseWithActualResultImplementation.Raw,
  TraceMyApi.v2.v3.problem.TestCaseWithActualResultImplementation
> = core.schemas.object({
  getActualResult: core.schemas.lazyObject(() => serializers.v2.v3.problem.NonVoidFunctionDefinition),
  assertCorrectnessCheck: core.schemas.lazy(() => serializers.v2.v3.problem.AssertCorrectnessCheck),
});

export declare namespace TestCaseWithActualResultImplementation {
  interface Raw {
    getActualResult: serializers.v2.v3.problem.NonVoidFunctionDefinition.Raw;
    assertCorrectnessCheck: serializers.v2.v3.problem.AssertCorrectnessCheck.Raw;
  }
}
",
                                    "name": "TestCaseWithActualResultImplementation.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const VoidFunctionDefinition: core.schemas.ObjectSchema<
  VoidFunctionDefinition.Raw,
  TraceMyApi.v2.v3.problem.VoidFunctionDefinition
> = core.schemas.object({
  parameters: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.v3.problem.Parameter)),
  code: core.schemas.lazyObject(() => serializers.v2.v3.problem.FunctionImplementationForMultipleLanguages),
});

export declare namespace VoidFunctionDefinition {
  interface Raw {
    parameters: serializers.v2.v3.problem.Parameter.Raw[];
    code: serializers.v2.v3.problem.FunctionImplementationForMultipleLanguages.Raw;
  }
}
",
                                    "name": "VoidFunctionDefinition.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const VoidFunctionDefinitionThatTakesActualResult: core.schemas.ObjectSchema<
  VoidFunctionDefinitionThatTakesActualResult.Raw,
  TraceMyApi.v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult
> = core.schemas.object({
  additionalParameters: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.v3.problem.Parameter)),
  code: core.schemas.lazyObject(() => serializers.v2.v3.problem.FunctionImplementationForMultipleLanguages),
});

export declare namespace VoidFunctionDefinitionThatTakesActualResult {
  interface Raw {
    additionalParameters: serializers.v2.v3.problem.Parameter.Raw[];
    code: serializers.v2.v3.problem.FunctionImplementationForMultipleLanguages.Raw;
  }
}
",
                                    "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const VoidFunctionSignature: core.schemas.ObjectSchema<
  VoidFunctionSignature.Raw,
  TraceMyApi.v2.v3.problem.VoidFunctionSignature
> = core.schemas.object({
  parameters: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.v3.problem.Parameter)),
});

export declare namespace VoidFunctionSignature {
  interface Raw {
    parameters: serializers.v2.v3.problem.Parameter.Raw[];
  }
}
",
                                    "name": "VoidFunctionSignature.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceMyApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const VoidFunctionSignatureThatTakesActualResult: core.schemas.ObjectSchema<
  VoidFunctionSignatureThatTakesActualResult.Raw,
  TraceMyApi.v2.v3.problem.VoidFunctionSignatureThatTakesActualResult
> = core.schemas.object({
  parameters: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.v3.problem.Parameter)),
  actualResultType: core.schemas.lazy(() => serializers.commons.VariableType),
});

export declare namespace VoidFunctionSignatureThatTakesActualResult {
  interface Raw {
    parameters: serializers.v2.v3.problem.Parameter.Raw[];
    actualResultType: serializers.commons.VariableType.Raw;
  }
}
",
                                    "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                                    "name": "index.ts",
                                    "type": "file",
                                  },
                                ],
                                "name": "types",
                                "type": "directory",
                              },
                            ],
                            "name": "problem",
                            "type": "directory",
                          },
                        ],
                        "name": "resources",
                        "type": "directory",
                      },
                    ],
                    "name": "v3",
                    "type": "directory",
                  },
                ],
                "name": "resources",
                "type": "directory",
              },
            ],
            "name": "v2",
            "type": "directory",
          },
        ],
        "name": "serialization",
        "type": "directory",
      },
    ],
    "name": "src",
    "type": "directory",
  },
  Object {
    "contents": "{
    \\"compilerOptions\\": {
        \\"strict\\": true,
        \\"target\\": \\"esnext\\",
        \\"moduleResolution\\": \\"node\\",
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"sourceMap\\": true,
        \\"emitDeclarationOnly\\": true,
        \\"esModuleInterop\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true,
        \\"declarationDir\\": \\".\\",
        \\"rootDir\\": \\"src\\"
    },
    \\"include\\": [
        \\"src\\"
    ],
    \\"exclude\\": []
}",
    "name": "tsconfig.json",
    "type": "file",
  },
]
`;
