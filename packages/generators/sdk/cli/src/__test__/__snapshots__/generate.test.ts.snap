// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`runGenerator trace 1`] = `
Array [
  Object {
    "contents": "tsconfig.json
.pnp.*
.yarn
yarn.lock
*.ts
!*.d.ts",
    "name": ".npmignore",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "import { BearerToken, BasicAuth } from \\"@fern-typescript/service-utils\\";
import { Client as AdminServiceClient } from \\"./admin/client/Client\\";
import urlJoin from \\"url-join\\";
import { Client as HomepageProblemServiceClient } from \\"./homepage/client/Client\\";
import { Client as MigrationInfoServiceClient } from \\"./migration/client/Client\\";
import { Client as PlaylistCrudServiceClient } from \\"./playlist/client/Client\\";
import { Client as ProblemCrudServiceClient } from \\"./problem/client/Client\\";
import { Client as ExecutionSesssionManagementServiceClient } from \\"./submission/client/Client\\";
import { Client as SysPropCrudServiceClient } from \\"./sysprop/client/Client\\";
import { Wrapper as V2Wrapper } from \\"./v2/Wrapper\\";

export namespace Client {
    export interface Options {
        _origin: string;
        _token?: BearerToken;
        _credentials?: BasicAuth;
        xApiKey?: string;
    }
}

export class Client {
    constructor(private readonly options: Client.Options) {
    }

    #admin: AdminServiceClient | undefined;

    public get admin(): AdminServiceClient {
        return (this.#admin ??= new AdminServiceClient({
            _basePath: urlJoin(this.options._origin, \\"/admin\\"),
            _token: this.options._token,
            _credentials: this.options._credentials,
            xApiKey: this.options.xApiKey
        }));
    }

    #homepage: HomepageProblemServiceClient | undefined;

    public get homepage(): HomepageProblemServiceClient {
        return (this.#homepage ??= new HomepageProblemServiceClient({
            _basePath: urlJoin(this.options._origin, \\"/homepage-problems\\"),
            _token: this.options._token,
            _credentials: this.options._credentials,
            xApiKey: this.options.xApiKey
        }));
    }

    #migration: MigrationInfoServiceClient | undefined;

    public get migration(): MigrationInfoServiceClient {
        return (this.#migration ??= new MigrationInfoServiceClient({
            _basePath: urlJoin(this.options._origin, \\"/migration-info\\"),
            _token: this.options._token,
            _credentials: this.options._credentials,
            xApiKey: this.options.xApiKey
        }));
    }

    #playlist: PlaylistCrudServiceClient | undefined;

    public get playlist(): PlaylistCrudServiceClient {
        return (this.#playlist ??= new PlaylistCrudServiceClient({
            _basePath: urlJoin(this.options._origin, \\"/v2/playlist\\"),
            _token: this.options._token,
            _credentials: this.options._credentials,
            xApiKey: this.options.xApiKey
        }));
    }

    #problem: ProblemCrudServiceClient | undefined;

    public get problem(): ProblemCrudServiceClient {
        return (this.#problem ??= new ProblemCrudServiceClient({
            _basePath: urlJoin(this.options._origin, \\"/problem-crud\\"),
            _token: this.options._token,
            _credentials: this.options._credentials,
            xApiKey: this.options.xApiKey
        }));
    }

    #submission: ExecutionSesssionManagementServiceClient | undefined;

    public get submission(): ExecutionSesssionManagementServiceClient {
        return (this.#submission ??= new ExecutionSesssionManagementServiceClient({
            _basePath: urlJoin(this.options._origin, \\"/sessions\\"),
            _token: this.options._token,
            _credentials: this.options._credentials,
            xApiKey: this.options.xApiKey
        }));
    }

    #sysprop: SysPropCrudServiceClient | undefined;

    public get sysprop(): SysPropCrudServiceClient {
        return (this.#sysprop ??= new SysPropCrudServiceClient({
            _basePath: urlJoin(this.options._origin, \\"/sysprop\\"),
            _token: this.options._token,
            _credentials: this.options._credentials,
            xApiKey: this.options.xApiKey
        }));
    }

    #v2: V2Wrapper | undefined;

    public get v2(): V2Wrapper {
        return (this.#v2 ??= new V2Wrapper(this.options));
    }
}
",
        "name": "Client.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "import { BearerToken, BasicAuth, _NetworkError, _UnknownError, ErrorDetails, _Response, defaultFetcherV2 } from \\"@fern-typescript/service-utils\\";
import { MyApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";

export interface Client {
    updateTestSubmissionStatus(request: MyApi.admin.updateTestSubmissionStatus.Request): Promise<_Response<void, MyApi.admin.updateTestSubmissionStatus.Error>>;
    sendTestSubmissionUpdate(request: MyApi.admin.sendTestSubmissionUpdate.Request): Promise<_Response<void, MyApi.admin.sendTestSubmissionUpdate.Error>>;
    updateWorkspaceSubmissionStatus(request: MyApi.admin.updateWorkspaceSubmissionStatus.Request): Promise<_Response<void, MyApi.admin.updateWorkspaceSubmissionStatus.Error>>;
    sendWorkspaceSubmissionUpdate(request: MyApi.admin.sendWorkspaceSubmissionUpdate.Request): Promise<_Response<void, MyApi.admin.sendWorkspaceSubmissionUpdate.Error>>;
    storeTracedTestCase(request: MyApi.admin.storeTracedTestCase.Request): Promise<_Response<void, MyApi.admin.storeTracedTestCase.Error>>;
    storeTracedTestCaseV2(request: MyApi.admin.storeTracedTestCaseV2.Request): Promise<_Response<void, MyApi.admin.storeTracedTestCaseV2.Error>>;
    storeTracedWorkspace(request: MyApi.admin.storeTracedWorkspace.Request): Promise<_Response<void, MyApi.admin.storeTracedWorkspace.Error>>;
    storeTracedWorkspaceV2(request: MyApi.admin.storeTracedWorkspaceV2.Request): Promise<_Response<void, MyApi.admin.storeTracedWorkspaceV2.Error>>;
}

export declare namespace Client {
    interface Options {
        _basePath: string;
        _token?: BearerToken;
        _credentials?: BasicAuth;
        xApiKey?: string;
    }
}

export class Client implements Client {
    constructor(private readonly options: Client.Options) {
    }

    public async updateTestSubmissionStatus(request: MyApi.admin.updateTestSubmissionStatus.Request): Promise<_Response<void, MyApi.admin.updateTestSubmissionStatus.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/store-test-submission-status/\${request.submissionId}\`),
                method: \\"POST\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                },
                body: request.body
            });

        if (response.ok) {
            return {
                ok: true,
                body: undefined
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async sendTestSubmissionUpdate(request: MyApi.admin.sendTestSubmissionUpdate.Request): Promise<_Response<void, MyApi.admin.sendTestSubmissionUpdate.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/store-test-submission-status-v2/\${request.submissionId}\`),
                method: \\"POST\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                },
                body: request.body
            });

        if (response.ok) {
            return {
                ok: true,
                body: undefined
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async updateWorkspaceSubmissionStatus(request: MyApi.admin.updateWorkspaceSubmissionStatus.Request): Promise<_Response<void, MyApi.admin.updateWorkspaceSubmissionStatus.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/store-workspace-submission-status/\${request.submissionId}\`),
                method: \\"POST\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                },
                body: request.body
            });

        if (response.ok) {
            return {
                ok: true,
                body: undefined
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async sendWorkspaceSubmissionUpdate(request: MyApi.admin.sendWorkspaceSubmissionUpdate.Request): Promise<_Response<void, MyApi.admin.sendWorkspaceSubmissionUpdate.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/store-workspace-submission-status-v2/\${request.submissionId}\`),
                method: \\"POST\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                },
                body: request.body
            });

        if (response.ok) {
            return {
                ok: true,
                body: undefined
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async storeTracedTestCase(request: MyApi.admin.storeTracedTestCase.Request): Promise<_Response<void, MyApi.admin.storeTracedTestCase.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/store-test-trace/submission/\${request.submissionId}/testCase/\${request.testCaseId}\`),
                method: \\"POST\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                },
                body: request.body
            });

        if (response.ok) {
            return {
                ok: true,
                body: undefined
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async storeTracedTestCaseV2(request: MyApi.admin.storeTracedTestCaseV2.Request): Promise<_Response<void, MyApi.admin.storeTracedTestCaseV2.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/store-test-trace-v2/submission/\${request.submissionId}/testCase/\${request.testCaseId}\`),
                method: \\"POST\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                },
                body: request.body
            });

        if (response.ok) {
            return {
                ok: true,
                body: undefined
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async storeTracedWorkspace(request: MyApi.admin.storeTracedWorkspace.Request): Promise<_Response<void, MyApi.admin.storeTracedWorkspace.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/store-workspace-trace/submission/\${request.submissionId}\`),
                method: \\"POST\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                },
                body: request.body
            });

        if (response.ok) {
            return {
                ok: true,
                body: undefined
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async storeTracedWorkspaceV2(request: MyApi.admin.storeTracedWorkspaceV2.Request): Promise<_Response<void, MyApi.admin.storeTracedWorkspaceV2.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/store-workspace-trace-v2/submission/\${request.submissionId}\`),
                method: \\"POST\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                },
                body: request.body
            });

        if (response.ok) {
            return {
                ok: true,
                body: undefined
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }
}

export namespace updateTestSubmissionStatus {
    export interface Request {
        submissionId: MyApi.submission.SubmissionId;
        body: MyApi.submission.TestSubmissionStatus;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.admin.updateTestSubmissionStatus.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace sendTestSubmissionUpdate {
    export interface Request {
        submissionId: MyApi.submission.SubmissionId;
        body: MyApi.submission.TestSubmissionUpdate;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.admin.sendTestSubmissionUpdate.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace updateWorkspaceSubmissionStatus {
    export interface Request {
        submissionId: MyApi.submission.SubmissionId;
        body: MyApi.submission.WorkspaceSubmissionStatus;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.admin.updateWorkspaceSubmissionStatus.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace sendWorkspaceSubmissionUpdate {
    export interface Request {
        submissionId: MyApi.submission.SubmissionId;
        body: MyApi.submission.WorkspaceSubmissionUpdate;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.admin.sendWorkspaceSubmissionUpdate.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace storeTracedTestCase {
    export interface Request {
        submissionId: MyApi.submission.SubmissionId;
        testCaseId: string;
        body: MyApi.admin.StoreTracedTestCaseRequest;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.admin.storeTracedTestCase.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace storeTracedTestCaseV2 {
    export interface Request {
        submissionId: MyApi.submission.SubmissionId;
        testCaseId: MyApi.v2.problem.TestCaseId;
        body: MyApi.submission.TraceResponseV2[];
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.admin.storeTracedTestCaseV2.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace storeTracedWorkspace {
    export interface Request {
        submissionId: MyApi.submission.SubmissionId;
        body: MyApi.admin.StoreTracedWorkspaceRequest;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.admin.storeTracedWorkspace.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace storeTracedWorkspaceV2 {
    export interface Request {
        submissionId: MyApi.submission.SubmissionId;
        body: MyApi.submission.TraceResponseV2[];
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.admin.storeTracedWorkspaceV2.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}
",
                "name": "Client.ts",
                "type": "file",
              },
              Object {
                "contents": "export { updateTestSubmissionStatus, sendTestSubmissionUpdate, updateWorkspaceSubmissionStatus, sendWorkspaceSubmissionUpdate, storeTracedTestCase, storeTracedTestCaseV2, storeTracedWorkspace, storeTracedWorkspaceV2 } from \\"./Client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface StoreTracedTestCaseRequest {
    result: MyApi.submission.TestCaseResultWithStdout;
    traceResponses: MyApi.submission.TraceResponse[];
}
",
                "name": "StoreTracedTestCaseRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface StoreTracedWorkspaceRequest {
    workspaceRunDetails: MyApi.submission.WorkspaceRunDetails;
    traceResponses: MyApi.submission.TraceResponse[];
}
",
                "name": "StoreTracedWorkspaceRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./StoreTracedTestCaseRequest\\";
export * from \\"./StoreTracedWorkspaceRequest\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "admin",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface BinaryTreeNodeAndTreeValue {
    nodeId: MyApi.commons.NodeId;
    fullTree: MyApi.commons.BinaryTreeValue;
}
",
                "name": "BinaryTreeNodeAndTreeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface BinaryTreeNodeValue {
    nodeId: MyApi.commons.NodeId;
    val: number;
    right?: MyApi.commons.NodeId;
    left?: MyApi.commons.NodeId;
}
",
                "name": "BinaryTreeNodeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface BinaryTreeValue {
    root?: MyApi.commons.NodeId;
    nodes: Record<string, MyApi.commons.BinaryTreeNodeValue>;
}
",
                "name": "BinaryTreeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface DebugKeyValuePairs {
    key: MyApi.commons.DebugVariableValue;
    value: MyApi.commons.DebugVariableValue;
}
",
                "name": "DebugKeyValuePairs.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface DebugMapValue {
    keyValuePairs: MyApi.commons.DebugKeyValuePairs[];
}
",
                "name": "DebugMapValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type DebugVariableValue = 
    | DebugVariableValue.IntegerValue
    | DebugVariableValue.BooleanValue
    | DebugVariableValue.DoubleValue
    | DebugVariableValue.StringValue
    | DebugVariableValue.CharValue
    | DebugVariableValue.MapValue
    | DebugVariableValue.ListValue
    | DebugVariableValue.BinaryTreeNodeValue
    | DebugVariableValue.SinglyLinkedListNodeValue
    | DebugVariableValue.DoublyLinkedListNodeValue
    | DebugVariableValue.UndefinedValue
    | DebugVariableValue.NullValue
    | DebugVariableValue.GenericValue
    | DebugVariableValue._Unknown;

export declare namespace DebugVariableValue {
    interface IntegerValue extends _Utils {
        type: \\"integerValue\\";
        value: number;
    }

    interface BooleanValue extends _Utils {
        type: \\"booleanValue\\";
        value: boolean;
    }

    interface DoubleValue extends _Utils {
        type: \\"doubleValue\\";
        value: number;
    }

    interface StringValue extends _Utils {
        type: \\"stringValue\\";
        value: string;
    }

    interface CharValue extends _Utils {
        type: \\"charValue\\";
        value: string;
    }

    interface MapValue extends MyApi.commons.DebugMapValue, _Utils {
        type: \\"mapValue\\";
    }

    interface ListValue extends _Utils {
        type: \\"listValue\\";
        value: MyApi.commons.DebugVariableValue[];
    }

    interface BinaryTreeNodeValue extends MyApi.commons.BinaryTreeNodeAndTreeValue, _Utils {
        type: \\"binaryTreeNodeValue\\";
    }

    interface SinglyLinkedListNodeValue extends MyApi.commons.SinglyLinkedListNodeAndListValue, _Utils {
        type: \\"singlyLinkedListNodeValue\\";
    }

    interface DoublyLinkedListNodeValue extends MyApi.commons.DoublyLinkedListNodeAndListValue, _Utils {
        type: \\"doublyLinkedListNodeValue\\";
    }

    interface UndefinedValue extends _Utils {
        type: \\"undefinedValue\\";
    }

    interface NullValue extends _Utils {
        type: \\"nullValue\\";
    }

    interface GenericValue extends MyApi.commons.GenericValue, _Utils {
        type: \\"genericValue\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: DebugVariableValue._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        integerValue: (value: number) => Result;
        booleanValue: (value: boolean) => Result;
        doubleValue: (value: number) => Result;
        stringValue: (value: string) => Result;
        charValue: (value: string) => Result;
        mapValue: (value: MyApi.commons.DebugMapValue) => Result;
        listValue: (value: MyApi.commons.DebugVariableValue[]) => Result;
        binaryTreeNodeValue: (value: MyApi.commons.BinaryTreeNodeAndTreeValue) => Result;
        singlyLinkedListNodeValue: (value: MyApi.commons.SinglyLinkedListNodeAndListValue) => Result;
        doublyLinkedListNodeValue: (value: MyApi.commons.DoublyLinkedListNodeAndListValue) => Result;
        undefinedValue: () => Result;
        nullValue: () => Result;
        genericValue: (value: MyApi.commons.GenericValue) => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const DebugVariableValue = {
        IntegerValue: (value: number): DebugVariableValue.IntegerValue => ({
            value: value,
            type: \\"integerValue\\",
            _visit: visitor => visitor.integerValue(value)
        }),

        BooleanValue: (value: boolean): DebugVariableValue.BooleanValue => ({
            value: value,
            type: \\"booleanValue\\",
            _visit: visitor => visitor.booleanValue(value)
        }),

        DoubleValue: (value: number): DebugVariableValue.DoubleValue => ({
            value: value,
            type: \\"doubleValue\\",
            _visit: visitor => visitor.doubleValue(value)
        }),

        StringValue: (value: string): DebugVariableValue.StringValue => ({
            value: value,
            type: \\"stringValue\\",
            _visit: visitor => visitor.stringValue(value)
        }),

        CharValue: (value: string): DebugVariableValue.CharValue => ({
            value: value,
            type: \\"charValue\\",
            _visit: visitor => visitor.charValue(value)
        }),

        MapValue: (value: MyApi.commons.DebugMapValue): DebugVariableValue.MapValue => ({
            ...value,
            type: \\"mapValue\\",
            _visit: visitor => visitor.mapValue(value)
        }),

        ListValue: (value: MyApi.commons.DebugVariableValue[]): DebugVariableValue.ListValue => ({
            value: value,
            type: \\"listValue\\",
            _visit: visitor => visitor.listValue(value)
        }),

        BinaryTreeNodeValue: (value: MyApi.commons.BinaryTreeNodeAndTreeValue): DebugVariableValue.BinaryTreeNodeValue => ({
            ...value,
            type: \\"binaryTreeNodeValue\\",
            _visit: visitor => visitor.binaryTreeNodeValue(value)
        }),

        SinglyLinkedListNodeValue: (value: MyApi.commons.SinglyLinkedListNodeAndListValue): DebugVariableValue.SinglyLinkedListNodeValue => ({
            ...value,
            type: \\"singlyLinkedListNodeValue\\",
            _visit: visitor => visitor.singlyLinkedListNodeValue(value)
        }),

        DoublyLinkedListNodeValue: (value: MyApi.commons.DoublyLinkedListNodeAndListValue): DebugVariableValue.DoublyLinkedListNodeValue => ({
            ...value,
            type: \\"doublyLinkedListNodeValue\\",
            _visit: visitor => visitor.doublyLinkedListNodeValue(value)
        }),

        UndefinedValue: (): DebugVariableValue.UndefinedValue => ({
            type: \\"undefinedValue\\",
            _visit: visitor => visitor.undefinedValue()
        }),

        NullValue: (): DebugVariableValue.NullValue => ({
            type: \\"nullValue\\",
            _visit: visitor => visitor.nullValue()
        }),

        GenericValue: (value: MyApi.commons.GenericValue): DebugVariableValue.GenericValue => ({
            ...value,
            type: \\"genericValue\\",
            _visit: visitor => visitor.genericValue(value)
        }),

    } as const;
",
                "name": "DebugVariableValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface DoublyLinkedListNodeAndListValue {
    nodeId: MyApi.commons.NodeId;
    fullList: MyApi.commons.DoublyLinkedListValue;
}
",
                "name": "DoublyLinkedListNodeAndListValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface DoublyLinkedListNodeValue {
    nodeId: MyApi.commons.NodeId;
    val: number;
    next?: MyApi.commons.NodeId;
    prev?: MyApi.commons.NodeId;
}
",
                "name": "DoublyLinkedListNodeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface DoublyLinkedListValue {
    head?: MyApi.commons.NodeId;
    nodes: Record<string, MyApi.commons.DoublyLinkedListNodeValue>;
}
",
                "name": "DoublyLinkedListValue.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface FileInfo {
    filename: string;
    contents: string;
}
",
                "name": "FileInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface GenericValue {
    stringifiedType?: string;
    stringifiedValue: string;
}
",
                "name": "GenericValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface KeyValuePair {
    key: MyApi.commons.VariableValue;
    value: MyApi.commons.VariableValue;
}
",
                "name": "KeyValuePair.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface Language<RawValue extends Language.RawValue = Language.RawValue> {
    get: () => RawValue;
    visit: <Result>(visitor: Language._Visitor<Result>) => Result;
}

export const Language = {
        Java: (): Language<\\"JAVA\\"> => ({
            get: () => \\"JAVA\\",
            visit: visitor => visitor.java()
        }),
        Javascript: (): Language<\\"JAVASCRIPT\\"> => ({
            get: () => \\"JAVASCRIPT\\",
            visit: visitor => visitor.javascript()
        }),
        Python: (): Language<\\"PYTHON\\"> => ({
            get: () => \\"PYTHON\\",
            visit: visitor => visitor.python()
        }),
    } as const;

export declare namespace Language {
    type RawValue = \\"JAVA\\" | \\"JAVASCRIPT\\" | \\"PYTHON\\" | string;

    interface _Visitor<Result> {
        java: () => Result;
        javascript: () => Result;
        python: () => Result;
        _unknown: (value: string) => Result;
    }
}
",
                "name": "Language.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface ListType {
    valueType: MyApi.commons.VariableType;
    /** Whether this list is fixed-size (for languages that supports fixed-size lists). Defaults to false. */
    isFixedLength?: boolean;
}
",
                "name": "ListType.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface MapType {
    keyType: MyApi.commons.VariableType;
    valueType: MyApi.commons.VariableType;
}
",
                "name": "MapType.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface MapValue {
    keyValuePairs: MyApi.commons.KeyValuePair[];
}
",
                "name": "MapValue.ts",
                "type": "file",
              },
              Object {
                "contents": "export type NodeId = string;
",
                "name": "NodeId.ts",
                "type": "file",
              },
              Object {
                "contents": "export type ProblemId = string;
",
                "name": "ProblemId.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface SinglyLinkedListNodeAndListValue {
    nodeId: MyApi.commons.NodeId;
    fullList: MyApi.commons.SinglyLinkedListValue;
}
",
                "name": "SinglyLinkedListNodeAndListValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface SinglyLinkedListNodeValue {
    nodeId: MyApi.commons.NodeId;
    val: number;
    next?: MyApi.commons.NodeId;
}
",
                "name": "SinglyLinkedListNodeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface SinglyLinkedListValue {
    head?: MyApi.commons.NodeId;
    nodes: Record<string, MyApi.commons.SinglyLinkedListNodeValue>;
}
",
                "name": "SinglyLinkedListValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface TestCase {
    id: string;
    params: MyApi.commons.VariableValue[];
}
",
                "name": "TestCase.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface TestCaseWithExpectedResult {
    testCase: MyApi.commons.TestCase;
    expectedResult: MyApi.commons.VariableValue;
}
",
                "name": "TestCaseWithExpectedResult.ts",
                "type": "file",
              },
              Object {
                "contents": "export type UserId = string;
",
                "name": "UserId.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type VariableType = 
    | VariableType.IntegerType
    | VariableType.DoubleType
    | VariableType.BooleanType
    | VariableType.StringType
    | VariableType.CharType
    | VariableType.ListType
    | VariableType.MapType
    | VariableType.BinaryTreeType
    | VariableType.SinglyLinkedListType
    | VariableType.DoublyLinkedListType
    | VariableType._Unknown;

export declare namespace VariableType {
    interface IntegerType extends _Utils {
        type: \\"integerType\\";
    }

    interface DoubleType extends _Utils {
        type: \\"doubleType\\";
    }

    interface BooleanType extends _Utils {
        type: \\"booleanType\\";
    }

    interface StringType extends _Utils {
        type: \\"stringType\\";
    }

    interface CharType extends _Utils {
        type: \\"charType\\";
    }

    interface ListType extends MyApi.commons.ListType, _Utils {
        type: \\"listType\\";
    }

    interface MapType extends MyApi.commons.MapType, _Utils {
        type: \\"mapType\\";
    }

    interface BinaryTreeType extends _Utils {
        type: \\"binaryTreeType\\";
    }

    interface SinglyLinkedListType extends _Utils {
        type: \\"singlyLinkedListType\\";
    }

    interface DoublyLinkedListType extends _Utils {
        type: \\"doublyLinkedListType\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: VariableType._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        integerType: () => Result;
        doubleType: () => Result;
        booleanType: () => Result;
        stringType: () => Result;
        charType: () => Result;
        listType: (value: MyApi.commons.ListType) => Result;
        mapType: (value: MyApi.commons.MapType) => Result;
        binaryTreeType: () => Result;
        singlyLinkedListType: () => Result;
        doublyLinkedListType: () => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const VariableType = {
        IntegerType: (): VariableType.IntegerType => ({
            type: \\"integerType\\",
            _visit: visitor => visitor.integerType()
        }),

        DoubleType: (): VariableType.DoubleType => ({
            type: \\"doubleType\\",
            _visit: visitor => visitor.doubleType()
        }),

        BooleanType: (): VariableType.BooleanType => ({
            type: \\"booleanType\\",
            _visit: visitor => visitor.booleanType()
        }),

        StringType: (): VariableType.StringType => ({
            type: \\"stringType\\",
            _visit: visitor => visitor.stringType()
        }),

        CharType: (): VariableType.CharType => ({
            type: \\"charType\\",
            _visit: visitor => visitor.charType()
        }),

        ListType: (value: MyApi.commons.ListType): VariableType.ListType => ({
            ...value,
            type: \\"listType\\",
            _visit: visitor => visitor.listType(value)
        }),

        MapType: (value: MyApi.commons.MapType): VariableType.MapType => ({
            ...value,
            type: \\"mapType\\",
            _visit: visitor => visitor.mapType(value)
        }),

        BinaryTreeType: (): VariableType.BinaryTreeType => ({
            type: \\"binaryTreeType\\",
            _visit: visitor => visitor.binaryTreeType()
        }),

        SinglyLinkedListType: (): VariableType.SinglyLinkedListType => ({
            type: \\"singlyLinkedListType\\",
            _visit: visitor => visitor.singlyLinkedListType()
        }),

        DoublyLinkedListType: (): VariableType.DoublyLinkedListType => ({
            type: \\"doublyLinkedListType\\",
            _visit: visitor => visitor.doublyLinkedListType()
        }),

    } as const;
",
                "name": "VariableType.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type VariableValue = 
    | VariableValue.IntegerValue
    | VariableValue.BooleanValue
    | VariableValue.DoubleValue
    | VariableValue.StringValue
    | VariableValue.CharValue
    | VariableValue.MapValue
    | VariableValue.ListValue
    | VariableValue.BinaryTreeValue
    | VariableValue.SinglyLinkedListValue
    | VariableValue.DoublyLinkedListValue
    | VariableValue.NullValue
    | VariableValue._Unknown;

export declare namespace VariableValue {
    interface IntegerValue extends _Utils {
        type: \\"integerValue\\";
        value: number;
    }

    interface BooleanValue extends _Utils {
        type: \\"booleanValue\\";
        value: boolean;
    }

    interface DoubleValue extends _Utils {
        type: \\"doubleValue\\";
        value: number;
    }

    interface StringValue extends _Utils {
        type: \\"stringValue\\";
        value: string;
    }

    interface CharValue extends _Utils {
        type: \\"charValue\\";
        value: string;
    }

    interface MapValue extends MyApi.commons.MapValue, _Utils {
        type: \\"mapValue\\";
    }

    interface ListValue extends _Utils {
        type: \\"listValue\\";
        value: MyApi.commons.VariableValue[];
    }

    interface BinaryTreeValue extends MyApi.commons.BinaryTreeValue, _Utils {
        type: \\"binaryTreeValue\\";
    }

    interface SinglyLinkedListValue extends MyApi.commons.SinglyLinkedListValue, _Utils {
        type: \\"singlyLinkedListValue\\";
    }

    interface DoublyLinkedListValue extends MyApi.commons.DoublyLinkedListValue, _Utils {
        type: \\"doublyLinkedListValue\\";
    }

    interface NullValue extends _Utils {
        type: \\"nullValue\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: VariableValue._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        integerValue: (value: number) => Result;
        booleanValue: (value: boolean) => Result;
        doubleValue: (value: number) => Result;
        stringValue: (value: string) => Result;
        charValue: (value: string) => Result;
        mapValue: (value: MyApi.commons.MapValue) => Result;
        listValue: (value: MyApi.commons.VariableValue[]) => Result;
        binaryTreeValue: (value: MyApi.commons.BinaryTreeValue) => Result;
        singlyLinkedListValue: (value: MyApi.commons.SinglyLinkedListValue) => Result;
        doublyLinkedListValue: (value: MyApi.commons.DoublyLinkedListValue) => Result;
        nullValue: () => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const VariableValue = {
        IntegerValue: (value: number): VariableValue.IntegerValue => ({
            value: value,
            type: \\"integerValue\\",
            _visit: visitor => visitor.integerValue(value)
        }),

        BooleanValue: (value: boolean): VariableValue.BooleanValue => ({
            value: value,
            type: \\"booleanValue\\",
            _visit: visitor => visitor.booleanValue(value)
        }),

        DoubleValue: (value: number): VariableValue.DoubleValue => ({
            value: value,
            type: \\"doubleValue\\",
            _visit: visitor => visitor.doubleValue(value)
        }),

        StringValue: (value: string): VariableValue.StringValue => ({
            value: value,
            type: \\"stringValue\\",
            _visit: visitor => visitor.stringValue(value)
        }),

        CharValue: (value: string): VariableValue.CharValue => ({
            value: value,
            type: \\"charValue\\",
            _visit: visitor => visitor.charValue(value)
        }),

        MapValue: (value: MyApi.commons.MapValue): VariableValue.MapValue => ({
            ...value,
            type: \\"mapValue\\",
            _visit: visitor => visitor.mapValue(value)
        }),

        ListValue: (value: MyApi.commons.VariableValue[]): VariableValue.ListValue => ({
            value: value,
            type: \\"listValue\\",
            _visit: visitor => visitor.listValue(value)
        }),

        BinaryTreeValue: (value: MyApi.commons.BinaryTreeValue): VariableValue.BinaryTreeValue => ({
            ...value,
            type: \\"binaryTreeValue\\",
            _visit: visitor => visitor.binaryTreeValue(value)
        }),

        SinglyLinkedListValue: (value: MyApi.commons.SinglyLinkedListValue): VariableValue.SinglyLinkedListValue => ({
            ...value,
            type: \\"singlyLinkedListValue\\",
            _visit: visitor => visitor.singlyLinkedListValue(value)
        }),

        DoublyLinkedListValue: (value: MyApi.commons.DoublyLinkedListValue): VariableValue.DoublyLinkedListValue => ({
            ...value,
            type: \\"doublyLinkedListValue\\",
            _visit: visitor => visitor.doublyLinkedListValue(value)
        }),

        NullValue: (): VariableValue.NullValue => ({
            type: \\"nullValue\\",
            _visit: visitor => visitor.nullValue()
        }),

    } as const;
",
                "name": "VariableValue.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./UserId\\";
export * from \\"./ProblemId\\";
export * from \\"./NodeId\\";
export * from \\"./VariableType\\";
export * from \\"./ListType\\";
export * from \\"./MapType\\";
export * from \\"./VariableValue\\";
export * from \\"./DebugVariableValue\\";
export * from \\"./GenericValue\\";
export * from \\"./MapValue\\";
export * from \\"./KeyValuePair\\";
export * from \\"./BinaryTreeValue\\";
export * from \\"./BinaryTreeNodeValue\\";
export * from \\"./BinaryTreeNodeAndTreeValue\\";
export * from \\"./SinglyLinkedListValue\\";
export * from \\"./SinglyLinkedListNodeValue\\";
export * from \\"./SinglyLinkedListNodeAndListValue\\";
export * from \\"./DoublyLinkedListValue\\";
export * from \\"./DoublyLinkedListNodeValue\\";
export * from \\"./DoublyLinkedListNodeAndListValue\\";
export * from \\"./DebugMapValue\\";
export * from \\"./DebugKeyValuePairs\\";
export * from \\"./TestCase\\";
export * from \\"./TestCaseWithExpectedResult\\";
export * from \\"./FileInfo\\";
export * from \\"./Language\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "commons",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "import { BearerToken, BasicAuth, _NetworkError, _UnknownError, ErrorDetails, _Response, defaultFetcherV2 } from \\"@fern-typescript/service-utils\\";
import { MyApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";

export interface Client {
    getHomepageProblems(): Promise<_Response<MyApi.commons.ProblemId[], MyApi.homepage.getHomepageProblems.Error>>;
    setHomepageProblems(request: MyApi.commons.ProblemId[]): Promise<_Response<void, MyApi.homepage.setHomepageProblems.Error>>;
}

export declare namespace Client {
    interface Options {
        _basePath: string;
        _token?: BearerToken;
        _credentials?: BasicAuth;
        xApiKey?: string;
    }
}

export class Client implements Client {
    constructor(private readonly options: Client.Options) {
    }

    public async getHomepageProblems(): Promise<_Response<MyApi.commons.ProblemId[], MyApi.homepage.getHomepageProblems.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \\"/\\"),
                method: \\"GET\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.commons.ProblemId[]
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async setHomepageProblems(request: MyApi.commons.ProblemId[]): Promise<_Response<void, MyApi.homepage.setHomepageProblems.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \\"/\\"),
                method: \\"POST\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                },
                body: request
            });

        if (response.ok) {
            return {
                ok: true,
                body: undefined
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }
}

export namespace getHomepageProblems {
    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.homepage.getHomepageProblems.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace setHomepageProblems {
    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.homepage.setHomepageProblems.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}
",
                "name": "Client.ts",
                "type": "file",
              },
              Object {
                "contents": "export { getHomepageProblems, setHomepageProblems } from \\"./Client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "homepage",
        "type": "directory",
      },
      Object {
        "contents": "export * as admin from \\"./admin\\";
export * from \\"./admin/types\\";
export * as commons from \\"./commons\\";
export * from \\"./commons/types\\";
export * as langServer from \\"./lang-server\\";
export * from \\"./lang-server/types\\";
export * as migration from \\"./migration\\";
export * from \\"./migration/types\\";
export * as playlist from \\"./playlist\\";
export * from \\"./playlist/types\\";
export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as submission from \\"./submission\\";
export * from \\"./submission/types\\";
export * as v2 from \\"./v2\\";
export * from \\"./playlist/errors\\";
export * as homepage from \\"./homepage\\";
export * as sysprop from \\"./sysprop\\";
export * from \\"./Client\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export interface LangServerRequest {
    request?: unknown;
}
",
                "name": "LangServerRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface LangServerResponse {
    response?: unknown;
}
",
                "name": "LangServerResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./LangServerRequest\\";
export * from \\"./LangServerResponse\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "lang-server",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "import { BearerToken, BasicAuth, _NetworkError, _UnknownError, ErrorDetails, _Response, defaultFetcherV2 } from \\"@fern-typescript/service-utils\\";
import { MyApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";

export interface Client {
    getAttemptedMigrations(): Promise<_Response<MyApi.migration.Migration[], MyApi.migration.getAttemptedMigrations.Error>>;
}

export declare namespace Client {
    interface Options {
        _basePath: string;
        _token?: BearerToken;
        _credentials?: BasicAuth;
        xApiKey?: string;
    }
}

export class Client implements Client {
    constructor(private readonly options: Client.Options) {
    }

    public async getAttemptedMigrations(): Promise<_Response<MyApi.migration.Migration[], MyApi.migration.getAttemptedMigrations.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \\"/all\\"),
                method: \\"GET\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.migration.Migration[]
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }
}

export namespace getAttemptedMigrations {
    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.migration.getAttemptedMigrations.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}
",
                "name": "Client.ts",
                "type": "file",
              },
              Object {
                "contents": "export { getAttemptedMigrations } from \\"./Client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface Migration {
    name: string;
    status: MyApi.migration.MigrationStatus;
}
",
                "name": "Migration.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface MigrationStatus<RawValue extends MigrationStatus.RawValue = MigrationStatus.RawValue> {
    get: () => RawValue;
    visit: <Result>(visitor: MigrationStatus._Visitor<Result>) => Result;
}

export const MigrationStatus = {
        Running: (): MigrationStatus<\\"RUNNING\\"> => ({
            get: () => \\"RUNNING\\",
            visit: visitor => visitor.running()
        }),
        Failed: (): MigrationStatus<\\"FAILED\\"> => ({
            get: () => \\"FAILED\\",
            visit: visitor => visitor.failed()
        }),
        Finished: (): MigrationStatus<\\"FINISHED\\"> => ({
            get: () => \\"FINISHED\\",
            visit: visitor => visitor.finished()
        }),
    } as const;

export declare namespace MigrationStatus {
    type RawValue = \\"RUNNING\\" | \\"FAILED\\" | \\"FINISHED\\" | string;

    interface _Visitor<Result> {
        running: () => Result;
        failed: () => Result;
        finished: () => Result;
        _unknown: (value: string) => Result;
    }
}
",
                "name": "MigrationStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./MigrationStatus\\";
export * from \\"./Migration\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "migration",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "import { BearerToken, BasicAuth, _NetworkError, _UnknownError, ErrorDetails, _Response, defaultFetcherV2 } from \\"@fern-typescript/service-utils\\";
import { MyApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";

export interface Client {
    createPlaylist(request: MyApi.playlist.PlaylistCreateRequest): Promise<_Response<MyApi.playlist.Playlist, MyApi.playlist.createPlaylist.Error>>;
    getPlaylists(request: MyApi.playlist.getPlaylists.Request): Promise<_Response<MyApi.playlist.Playlist[], MyApi.playlist.getPlaylists.Error>>;
    getPlaylist(request: MyApi.playlist.getPlaylist.Request): Promise<_Response<MyApi.playlist.Playlist, MyApi.playlist.getPlaylist.Error>>;
    updatePlaylist(request: MyApi.playlist.updatePlaylist.Request): Promise<_Response<MyApi.playlist.Playlist | undefined, MyApi.playlist.updatePlaylist.Error>>;
    deletePlaylist(request: MyApi.playlist.deletePlaylist.Request): Promise<_Response<void, MyApi.playlist.deletePlaylist.Error>>;
}

export declare namespace Client {
    interface Options {
        _basePath: string;
        _token?: BearerToken;
        _credentials?: BasicAuth;
        xApiKey?: string;
    }
}

export class Client implements Client {
    constructor(private readonly options: Client.Options) {
    }

    public async createPlaylist(request: MyApi.playlist.PlaylistCreateRequest): Promise<_Response<MyApi.playlist.Playlist, MyApi.playlist.createPlaylist.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \\"/create\\"),
                method: \\"POST\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                },
                body: request
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.playlist.Playlist
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async getPlaylists(request: MyApi.playlist.getPlaylists.Request): Promise<_Response<MyApi.playlist.Playlist[], MyApi.playlist.getPlaylists.Error>> {
        const queryParameters = new URLSearchParams();
        if (request.limit != null) {
            queryParameters.append(\\"limit\\", request.limit.toString());
        }

        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \\"/all\\"),
                method: \\"GET\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                },
                queryParameters
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.playlist.Playlist[]
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async getPlaylist(request: MyApi.playlist.getPlaylist.Request): Promise<_Response<MyApi.playlist.Playlist, MyApi.playlist.getPlaylist.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/\${request.playlistId}\`),
                method: \\"GET\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.playlist.Playlist
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        switch ((response.body as MyApi.playlist.getPlaylist.ErrorBody)?._error) {
            case \\"PlaylistIdNotFoundError\\":
            case \\"UnauthorizedError\\": return {
                ok: false,
                error: MyApi.playlist.getPlaylist.Error(response.body as MyApi.playlist.getPlaylist.ErrorBody)
            };
            default: return {
                ok: false,
                error: {
                    body: response.body as _UnknownError,
                    _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
                }
            };
        }
    }

    public async updatePlaylist(request: MyApi.playlist.updatePlaylist.Request): Promise<_Response<MyApi.playlist.Playlist | undefined, MyApi.playlist.updatePlaylist.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/\${request.playlistId}\`),
                method: \\"PUT\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                },
                body: request.body
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.playlist.Playlist | undefined
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        switch ((response.body as MyApi.playlist.updatePlaylist.ErrorBody)?._error) {
            case \\"PlaylistIdNotFoundError\\": return {
                ok: false,
                error: MyApi.playlist.updatePlaylist.Error(response.body as MyApi.playlist.updatePlaylist.ErrorBody)
            };
            default: return {
                ok: false,
                error: {
                    body: response.body as _UnknownError,
                    _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
                }
            };
        }
    }

    public async deletePlaylist(request: MyApi.playlist.deletePlaylist.Request): Promise<_Response<void, MyApi.playlist.deletePlaylist.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/\${request.playlistId}\`),
                method: \\"DELETE\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: undefined
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }
}

export namespace createPlaylist {
    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.playlist.createPlaylist.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace getPlaylists {
    export interface Request {
        limit?: number;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.playlist.getPlaylists.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace getPlaylist {
    export interface Request {
        playlistId: MyApi.playlist.PlaylistId;
    }

    export interface Error {
        body: 
            | MyApi.playlist.getPlaylist.ErrorBody
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.playlist.getPlaylist.ErrorVisitor<Result>) => Result;
    }

    export type ErrorBody = 
        | MyApi.playlist.PlaylistIdNotFoundError
        | MyApi.playlist.UnauthorizedError;

    export interface ErrorVisitor<Result> {
        playlistIdNotFoundError: (value: MyApi.playlist.PlaylistIdNotFoundError) => Result;
        unauthorizedError: (value: MyApi.playlist.UnauthorizedError) => Result;
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export const getPlaylist = {
        Error: (value: MyApi.playlist.getPlaylist.ErrorBody): MyApi.playlist.getPlaylist.Error => ({
            body: value,
            _visit: visitor => {
                switch (value._error) {
                    case \\"PlaylistIdNotFoundError\\": return visitor.playlistIdNotFoundError(value as MyApi.playlist.PlaylistIdNotFoundError);
                    case \\"UnauthorizedError\\": return visitor.unauthorizedError(value as MyApi.playlist.UnauthorizedError);
                }
            }
        })
    };

export namespace updatePlaylist {
    export interface Request {
        playlistId: MyApi.playlist.PlaylistId;
        body?: MyApi.playlist.UpdatePlaylistRequest;
    }

    export interface Error {
        body: 
            | MyApi.playlist.updatePlaylist.ErrorBody
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.playlist.updatePlaylist.ErrorVisitor<Result>) => Result;
    }

    export type ErrorBody = 
        | MyApi.playlist.PlaylistIdNotFoundError;

    export interface ErrorVisitor<Result> {
        playlistIdNotFoundError: (value: MyApi.playlist.PlaylistIdNotFoundError) => Result;
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export const updatePlaylist = {
        Error: (value: MyApi.playlist.updatePlaylist.ErrorBody): MyApi.playlist.updatePlaylist.Error => ({
            body: value,
            _visit: visitor => {
                switch (value._error) {
                    case \\"PlaylistIdNotFoundError\\": return visitor.playlistIdNotFoundError(value as MyApi.playlist.PlaylistIdNotFoundError);
                }
            }
        })
    };

export namespace deletePlaylist {
    export interface Request {
        playlistId: MyApi.playlist.PlaylistId;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.playlist.deletePlaylist.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}
",
                "name": "Client.ts",
                "type": "file",
              },
              Object {
                "contents": "export { createPlaylist, getPlaylists, getPlaylist, updatePlaylist, deletePlaylist } from \\"./Client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface PlaylistIdNotFoundError {
    _error: \\"PlaylistIdNotFoundError\\";
    playlistId: MyApi.playlist.PlaylistId;
}
",
                "name": "PlaylistIdNotFoundError.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface UnauthorizedError {
    _error: \\"UnauthorizedError\\";
}
",
                "name": "UnauthorizedError.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./PlaylistIdNotFoundError\\";
export * from \\"./UnauthorizedError\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "errors",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./errors\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface Playlist {
    playlistId: MyApi.playlist.PlaylistId;
    name: string;
    problems: MyApi.commons.ProblemId[];
    ownerId: MyApi.commons.UserId;
}
",
                "name": "Playlist.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface PlaylistCreateRequest {
    name: string;
    problems: MyApi.commons.ProblemId[];
}
",
                "name": "PlaylistCreateRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "export type PlaylistId = string;
",
                "name": "PlaylistId.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface UpdatePlaylistRequest {
    name: string;
    problems: MyApi.commons.ProblemId[];
}
",
                "name": "UpdatePlaylistRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./PlaylistId\\";
export * from \\"./Playlist\\";
export * from \\"./PlaylistCreateRequest\\";
export * from \\"./UpdatePlaylistRequest\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "playlist",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "import { BearerToken, BasicAuth, _NetworkError, _UnknownError, ErrorDetails, _Response, defaultFetcherV2 } from \\"@fern-typescript/service-utils\\";
import { MyApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";

export interface Client {
    createProblem(request: MyApi.problem.CreateProblemRequest): Promise<_Response<MyApi.problem.CreateProblemResponse, MyApi.problem.createProblem.Error>>;
    updateProblem(request: MyApi.problem.updateProblem.Request): Promise<_Response<MyApi.problem.UpdateProblemResponse, MyApi.problem.updateProblem.Error>>;
    deleteProblem(request: MyApi.problem.deleteProblem.Request): Promise<_Response<void, MyApi.problem.deleteProblem.Error>>;
    getDefaultStarterFiles(request: MyApi.problem.GetDefaultStarterFilesRequest): Promise<_Response<MyApi.problem.GetDefaultStarterFilesResponse, MyApi.problem.getDefaultStarterFiles.Error>>;
}

export declare namespace Client {
    interface Options {
        _basePath: string;
        _token?: BearerToken;
        _credentials?: BasicAuth;
        xApiKey?: string;
    }
}

export class Client implements Client {
    constructor(private readonly options: Client.Options) {
    }

    public async createProblem(request: MyApi.problem.CreateProblemRequest): Promise<_Response<MyApi.problem.CreateProblemResponse, MyApi.problem.createProblem.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \\"/create\\"),
                method: \\"POST\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                },
                body: request
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.problem.CreateProblemResponse
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async updateProblem(request: MyApi.problem.updateProblem.Request): Promise<_Response<MyApi.problem.UpdateProblemResponse, MyApi.problem.updateProblem.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/update/\${request.problemId}\`),
                method: \\"POST\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                },
                body: request.body
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.problem.UpdateProblemResponse
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async deleteProblem(request: MyApi.problem.deleteProblem.Request): Promise<_Response<void, MyApi.problem.deleteProblem.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/delete/\${request.problemId}\`),
                method: \\"DELETE\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: undefined
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async getDefaultStarterFiles(request: MyApi.problem.GetDefaultStarterFilesRequest): Promise<_Response<MyApi.problem.GetDefaultStarterFilesResponse, MyApi.problem.getDefaultStarterFiles.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \\"/default-starter-files\\"),
                method: \\"POST\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                },
                body: request
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.problem.GetDefaultStarterFilesResponse
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }
}

export namespace createProblem {
    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.problem.createProblem.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace updateProblem {
    export interface Request {
        problemId: MyApi.commons.ProblemId;
        body: MyApi.problem.CreateProblemRequest;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.problem.updateProblem.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace deleteProblem {
    export interface Request {
        problemId: MyApi.commons.ProblemId;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.problem.deleteProblem.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace getDefaultStarterFiles {
    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.problem.getDefaultStarterFiles.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}
",
                "name": "Client.ts",
                "type": "file",
              },
              Object {
                "contents": "export { createProblem, updateProblem, deleteProblem, getDefaultStarterFiles } from \\"./Client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type CreateProblemError = 
    | CreateProblemError.Generic
    | CreateProblemError._Unknown;

export declare namespace CreateProblemError {
    interface Generic extends MyApi.problem.GenericCreateProblemError, _Utils {
        errorType: \\"generic\\";
    }

    interface _Unknown extends _Utils {
        errorType: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: CreateProblemError._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        generic: (value: MyApi.problem.GenericCreateProblemError) => Result;
        _unknown: (value: {
                errorType: string;
            }) => Result;
    }
}

export const CreateProblemError = {
        Generic: (value: MyApi.problem.GenericCreateProblemError): CreateProblemError.Generic => ({
            ...value,
            errorType: \\"generic\\",
            _visit: visitor => visitor.generic(value)
        }),

    } as const;
",
                "name": "CreateProblemError.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface CreateProblemRequest {
    problemName: string;
    problemDescription: MyApi.problem.ProblemDescription;
    files: Record<MyApi.commons.Language.RawValue, MyApi.problem.ProblemFiles>;
    inputParams: MyApi.problem.VariableTypeAndName[];
    outputType: MyApi.commons.VariableType;
    testcases: MyApi.commons.TestCaseWithExpectedResult[];
    methodName: string;
}
",
                "name": "CreateProblemRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type CreateProblemResponse = 
    | CreateProblemResponse.Success
    | CreateProblemResponse.Error
    | CreateProblemResponse._Unknown;

export declare namespace CreateProblemResponse {
    interface Success extends _Utils {
        type: \\"success\\";
        value: MyApi.commons.ProblemId;
    }

    interface Error extends _Utils {
        type: \\"error\\";
        value: MyApi.problem.CreateProblemError;
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: CreateProblemResponse._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        success: (value: MyApi.commons.ProblemId) => Result;
        error: (value: MyApi.problem.CreateProblemError) => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const CreateProblemResponse = {
        Success: (value: MyApi.commons.ProblemId): CreateProblemResponse.Success => ({
            value: value,
            type: \\"success\\",
            _visit: visitor => visitor.success(value)
        }),

        Error: (value: MyApi.problem.CreateProblemError): CreateProblemResponse.Error => ({
            value: value,
            type: \\"error\\",
            _visit: visitor => visitor.error(value)
        }),

    } as const;
",
                "name": "CreateProblemResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface GenericCreateProblemError {
    message: string;
    type: string;
    stacktrace: string;
}
",
                "name": "GenericCreateProblemError.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface GetDefaultStarterFilesRequest {
    inputParams: MyApi.problem.VariableTypeAndName[];
    outputType: MyApi.commons.VariableType;
    methodName: string;
}
",
                "name": "GetDefaultStarterFilesRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface GetDefaultStarterFilesResponse {
    files: Record<MyApi.commons.Language.RawValue, MyApi.problem.ProblemFiles>;
}
",
                "name": "GetDefaultStarterFilesResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface ProblemDescription {
    boards: MyApi.problem.ProblemDescriptionBoard[];
}
",
                "name": "ProblemDescription.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type ProblemDescriptionBoard = 
    | ProblemDescriptionBoard.Html
    | ProblemDescriptionBoard.Variable
    | ProblemDescriptionBoard.TestCaseId
    | ProblemDescriptionBoard._Unknown;

export declare namespace ProblemDescriptionBoard {
    interface Html extends _Utils {
        type: \\"html\\";
        value: string;
    }

    interface Variable extends _Utils {
        type: \\"variable\\";
        value: MyApi.commons.VariableValue;
    }

    interface TestCaseId extends _Utils {
        type: \\"testCaseId\\";
        value: string;
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: ProblemDescriptionBoard._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        html: (value: string) => Result;
        variable: (value: MyApi.commons.VariableValue) => Result;
        testCaseId: (value: string) => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const ProblemDescriptionBoard = {
        Html: (value: string): ProblemDescriptionBoard.Html => ({
            value: value,
            type: \\"html\\",
            _visit: visitor => visitor.html(value)
        }),

        Variable: (value: MyApi.commons.VariableValue): ProblemDescriptionBoard.Variable => ({
            value: value,
            type: \\"variable\\",
            _visit: visitor => visitor.variable(value)
        }),

        TestCaseId: (value: string): ProblemDescriptionBoard.TestCaseId => ({
            value: value,
            type: \\"testCaseId\\",
            _visit: visitor => visitor.testCaseId(value)
        }),

    } as const;
",
                "name": "ProblemDescriptionBoard.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface ProblemFiles {
    solutionFile: MyApi.commons.FileInfo;
    readOnlyFiles: MyApi.commons.FileInfo[];
}
",
                "name": "ProblemFiles.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface ProblemInfo {
    problemId: MyApi.commons.ProblemId;
    problemDescription: MyApi.problem.ProblemDescription;
    problemName: string;
    problemVersion: number;
    files: Record<MyApi.commons.Language.RawValue, MyApi.problem.ProblemFiles>;
    inputParams: MyApi.problem.VariableTypeAndName[];
    outputType: MyApi.commons.VariableType;
    testcases: MyApi.commons.TestCaseWithExpectedResult[];
    methodName: string;
    supportsCustomTestCases: boolean;
}
",
                "name": "ProblemInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface UpdateProblemResponse {
    problemVersion: number;
}
",
                "name": "UpdateProblemResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface VariableTypeAndName {
    variableType: MyApi.commons.VariableType;
    name: string;
}
",
                "name": "VariableTypeAndName.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./ProblemInfo\\";
export * from \\"./ProblemDescription\\";
export * from \\"./ProblemDescriptionBoard\\";
export * from \\"./ProblemFiles\\";
export * from \\"./VariableTypeAndName\\";
export * from \\"./CreateProblemRequest\\";
export * from \\"./CreateProblemResponse\\";
export * from \\"./UpdateProblemResponse\\";
export * from \\"./CreateProblemError\\";
export * from \\"./GenericCreateProblemError\\";
export * from \\"./GetDefaultStarterFilesRequest\\";
export * from \\"./GetDefaultStarterFilesResponse\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "problem",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "import { BearerToken, BasicAuth, _NetworkError, _UnknownError, ErrorDetails, _Response, defaultFetcherV2 } from \\"@fern-typescript/service-utils\\";
import { MyApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";

export interface Client {
    createExecutionSession(request: MyApi.submission.createExecutionSession.Request): Promise<_Response<MyApi.submission.ExecutionSessionResponse, MyApi.submission.createExecutionSession.Error>>;
    getExecutionSession(request: MyApi.submission.getExecutionSession.Request): Promise<_Response<MyApi.submission.ExecutionSessionResponse | undefined, MyApi.submission.getExecutionSession.Error>>;
    stopExecutionSession(request: MyApi.submission.stopExecutionSession.Request): Promise<_Response<void, MyApi.submission.stopExecutionSession.Error>>;
    getExecutionSessionsState(): Promise<_Response<MyApi.submission.GetExecutionSessionStateResponse, MyApi.submission.getExecutionSessionsState.Error>>;
}

export declare namespace Client {
    interface Options {
        _basePath: string;
        _token?: BearerToken;
        _credentials?: BasicAuth;
        xApiKey?: string;
    }
}

/**
 * Responsible for spinning up and spinning down execution.
 */
export class Client implements Client {
    constructor(private readonly options: Client.Options) {
    }

    public async createExecutionSession(request: MyApi.submission.createExecutionSession.Request): Promise<_Response<MyApi.submission.ExecutionSessionResponse, MyApi.submission.createExecutionSession.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/create-session/\${request.language}\`),
                method: \\"POST\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.submission.ExecutionSessionResponse
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async getExecutionSession(request: MyApi.submission.getExecutionSession.Request): Promise<_Response<MyApi.submission.ExecutionSessionResponse | undefined, MyApi.submission.getExecutionSession.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/\${request.sessionId}\`),
                method: \\"GET\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.submission.ExecutionSessionResponse | undefined
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async stopExecutionSession(request: MyApi.submission.stopExecutionSession.Request): Promise<_Response<void, MyApi.submission.stopExecutionSession.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/stop/\${request.sessionId}\`),
                method: \\"DELETE\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: undefined
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async getExecutionSessionsState(): Promise<_Response<MyApi.submission.GetExecutionSessionStateResponse, MyApi.submission.getExecutionSessionsState.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \\"/execution-sessions-state\\"),
                method: \\"GET\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.submission.GetExecutionSessionStateResponse
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }
}

export namespace createExecutionSession {
    export interface Request {
        language: MyApi.commons.Language;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.submission.createExecutionSession.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace getExecutionSession {
    export interface Request {
        sessionId: string;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.submission.getExecutionSession.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace stopExecutionSession {
    export interface Request {
        sessionId: string;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.submission.stopExecutionSession.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace getExecutionSessionsState {
    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.submission.getExecutionSessionsState.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}
",
                "name": "Client.ts",
                "type": "file",
              },
              Object {
                "contents": "export { createExecutionSession, getExecutionSession, stopExecutionSession, getExecutionSessionsState } from \\"./Client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type ActualResult = 
    | ActualResult.Value
    | ActualResult.Exception
    | ActualResult.ExceptionV2
    | ActualResult._Unknown;

export declare namespace ActualResult {
    interface Value extends _Utils {
        type: \\"value\\";
        value: MyApi.commons.VariableValue;
    }

    interface Exception extends MyApi.submission.ExceptionInfo, _Utils {
        type: \\"exception\\";
    }

    interface ExceptionV2 extends _Utils {
        type: \\"exceptionV2\\";
        value: MyApi.submission.ExceptionV2;
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: ActualResult._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        value: (value: MyApi.commons.VariableValue) => Result;
        exception: (value: MyApi.submission.ExceptionInfo) => Result;
        exceptionV2: (value: MyApi.submission.ExceptionV2) => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const ActualResult = {
        Value: (value: MyApi.commons.VariableValue): ActualResult.Value => ({
            value: value,
            type: \\"value\\",
            _visit: visitor => visitor.value(value)
        }),

        Exception: (value: MyApi.submission.ExceptionInfo): ActualResult.Exception => ({
            ...value,
            type: \\"exception\\",
            _visit: visitor => visitor.exception(value)
        }),

        ExceptionV2: (value: MyApi.submission.ExceptionV2): ActualResult.ExceptionV2 => ({
            value: value,
            type: \\"exceptionV2\\",
            _visit: visitor => visitor.exceptionV2(value)
        }),

    } as const;
",
                "name": "ActualResult.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface BuildingExecutorResponse {
    submissionId: MyApi.submission.SubmissionId;
    status: MyApi.submission.ExecutionSessionStatus;
}
",
                "name": "BuildingExecutorResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type CodeExecutionUpdate = 
    /**
     * Statuses if an executor for the session isn't ready (Before RunningResponse). */
    | CodeExecutionUpdate.BuildingExecutor
    /**
     * Sent once a test submission is executing. */
    | CodeExecutionUpdate.Running
    /**
     * Sent if a submission cannot be run (i.e. Compile Error). */
    | CodeExecutionUpdate.Errored
    /**
     * Sent if a submission is stopped. */
    | CodeExecutionUpdate.Stopped
    /**
     * Graded testcases without trace information. */
    | CodeExecutionUpdate.Graded
    /**
     * Graded submission for v2 problems. */
    | CodeExecutionUpdate.GradedV2
    /**
     * Workspace run without trace information. */
    | CodeExecutionUpdate.WorkspaceRan
    /**
     * Gives progress about what is being recorded. */
    | CodeExecutionUpdate.Recording
    /**
     * Graded testcases with trace information. */
    | CodeExecutionUpdate.Recorded
    /**
     * Sent if an invalid request is sent for a submission. */
    | CodeExecutionUpdate.InvalidRequest
    /**
     * Sent once a submission is graded and fully recorded. */
    | CodeExecutionUpdate.Finished
    | CodeExecutionUpdate._Unknown;

export declare namespace CodeExecutionUpdate {
    interface BuildingExecutor extends MyApi.submission.BuildingExecutorResponse, _Utils {
        type: \\"buildingExecutor\\";
    }

    interface Running extends MyApi.submission.RunningResponse, _Utils {
        type: \\"running\\";
    }

    interface Errored extends MyApi.submission.ErroredResponse, _Utils {
        type: \\"errored\\";
    }

    interface Stopped extends MyApi.submission.StoppedResponse, _Utils {
        type: \\"stopped\\";
    }

    interface Graded extends MyApi.submission.GradedResponse, _Utils {
        type: \\"graded\\";
    }

    interface GradedV2 extends MyApi.submission.GradedResponseV2, _Utils {
        type: \\"gradedV2\\";
    }

    interface WorkspaceRan extends MyApi.submission.WorkspaceRanResponse, _Utils {
        type: \\"workspaceRan\\";
    }

    interface Recording extends MyApi.submission.RecordingResponseNotification, _Utils {
        type: \\"recording\\";
    }

    interface Recorded extends MyApi.submission.RecordedResponseNotification, _Utils {
        type: \\"recorded\\";
    }

    interface InvalidRequest extends MyApi.submission.InvalidRequestResponse, _Utils {
        type: \\"invalidRequest\\";
    }

    interface Finished extends MyApi.submission.FinishedResponse, _Utils {
        type: \\"finished\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: CodeExecutionUpdate._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        buildingExecutor: (value: MyApi.submission.BuildingExecutorResponse) => Result;
        running: (value: MyApi.submission.RunningResponse) => Result;
        errored: (value: MyApi.submission.ErroredResponse) => Result;
        stopped: (value: MyApi.submission.StoppedResponse) => Result;
        graded: (value: MyApi.submission.GradedResponse) => Result;
        gradedV2: (value: MyApi.submission.GradedResponseV2) => Result;
        workspaceRan: (value: MyApi.submission.WorkspaceRanResponse) => Result;
        recording: (value: MyApi.submission.RecordingResponseNotification) => Result;
        recorded: (value: MyApi.submission.RecordedResponseNotification) => Result;
        invalidRequest: (value: MyApi.submission.InvalidRequestResponse) => Result;
        finished: (value: MyApi.submission.FinishedResponse) => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const CodeExecutionUpdate = {
        BuildingExecutor: (value: MyApi.submission.BuildingExecutorResponse): CodeExecutionUpdate.BuildingExecutor => ({
            ...value,
            type: \\"buildingExecutor\\",
            _visit: visitor => visitor.buildingExecutor(value)
        }),

        Running: (value: MyApi.submission.RunningResponse): CodeExecutionUpdate.Running => ({
            ...value,
            type: \\"running\\",
            _visit: visitor => visitor.running(value)
        }),

        Errored: (value: MyApi.submission.ErroredResponse): CodeExecutionUpdate.Errored => ({
            ...value,
            type: \\"errored\\",
            _visit: visitor => visitor.errored(value)
        }),

        Stopped: (value: MyApi.submission.StoppedResponse): CodeExecutionUpdate.Stopped => ({
            ...value,
            type: \\"stopped\\",
            _visit: visitor => visitor.stopped(value)
        }),

        Graded: (value: MyApi.submission.GradedResponse): CodeExecutionUpdate.Graded => ({
            ...value,
            type: \\"graded\\",
            _visit: visitor => visitor.graded(value)
        }),

        GradedV2: (value: MyApi.submission.GradedResponseV2): CodeExecutionUpdate.GradedV2 => ({
            ...value,
            type: \\"gradedV2\\",
            _visit: visitor => visitor.gradedV2(value)
        }),

        WorkspaceRan: (value: MyApi.submission.WorkspaceRanResponse): CodeExecutionUpdate.WorkspaceRan => ({
            ...value,
            type: \\"workspaceRan\\",
            _visit: visitor => visitor.workspaceRan(value)
        }),

        Recording: (value: MyApi.submission.RecordingResponseNotification): CodeExecutionUpdate.Recording => ({
            ...value,
            type: \\"recording\\",
            _visit: visitor => visitor.recording(value)
        }),

        Recorded: (value: MyApi.submission.RecordedResponseNotification): CodeExecutionUpdate.Recorded => ({
            ...value,
            type: \\"recorded\\",
            _visit: visitor => visitor.recorded(value)
        }),

        InvalidRequest: (value: MyApi.submission.InvalidRequestResponse): CodeExecutionUpdate.InvalidRequest => ({
            ...value,
            type: \\"invalidRequest\\",
            _visit: visitor => visitor.invalidRequest(value)
        }),

        Finished: (value: MyApi.submission.FinishedResponse): CodeExecutionUpdate.Finished => ({
            ...value,
            type: \\"finished\\",
            _visit: visitor => visitor.finished(value)
        }),

    } as const;
",
                "name": "CodeExecutionUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface CompileError {
    message: string;
}
",
                "name": "CompileError.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface CustomTestCasesUnsupported {
    problemId: MyApi.commons.ProblemId;
    submissionId: MyApi.submission.SubmissionId;
}
",
                "name": "CustomTestCasesUnsupported.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type ErrorInfo = 
    | ErrorInfo.CompileError
    /**
     * If the submission cannot be executed and throws a runtime error before getting to any of the testcases.
     *  */
    | ErrorInfo.RuntimeError
    /**
     * If the trace backend encounters an unexpected error.
     *  */
    | ErrorInfo.InternalError
    | ErrorInfo._Unknown;

export declare namespace ErrorInfo {
    interface CompileError extends MyApi.submission.CompileError, _Utils {
        type: \\"compileError\\";
    }

    interface RuntimeError extends MyApi.submission.RuntimeError, _Utils {
        type: \\"runtimeError\\";
    }

    interface InternalError extends MyApi.submission.InternalError, _Utils {
        type: \\"internalError\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: ErrorInfo._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        compileError: (value: MyApi.submission.CompileError) => Result;
        runtimeError: (value: MyApi.submission.RuntimeError) => Result;
        internalError: (value: MyApi.submission.InternalError) => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const ErrorInfo = {
        CompileError: (value: MyApi.submission.CompileError): ErrorInfo.CompileError => ({
            ...value,
            type: \\"compileError\\",
            _visit: visitor => visitor.compileError(value)
        }),

        RuntimeError: (value: MyApi.submission.RuntimeError): ErrorInfo.RuntimeError => ({
            ...value,
            type: \\"runtimeError\\",
            _visit: visitor => visitor.runtimeError(value)
        }),

        InternalError: (value: MyApi.submission.InternalError): ErrorInfo.InternalError => ({
            ...value,
            type: \\"internalError\\",
            _visit: visitor => visitor.internalError(value)
        }),

    } as const;
",
                "name": "ErrorInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface ErroredResponse {
    submissionId: MyApi.submission.SubmissionId;
    errorInfo: MyApi.submission.ErrorInfo;
}
",
                "name": "ErroredResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface ExceptionInfo {
    exceptionType: string;
    exceptionMessage: string;
    exceptionStacktrace: string;
}
",
                "name": "ExceptionInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type ExceptionV2 = 
    | ExceptionV2.Generic
    | ExceptionV2.Timeout
    | ExceptionV2._Unknown;

export declare namespace ExceptionV2 {
    interface Generic extends MyApi.submission.ExceptionInfo, _Utils {
        type: \\"generic\\";
    }

    interface Timeout extends _Utils {
        type: \\"timeout\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: ExceptionV2._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        generic: (value: MyApi.submission.ExceptionInfo) => Result;
        timeout: () => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const ExceptionV2 = {
        Generic: (value: MyApi.submission.ExceptionInfo): ExceptionV2.Generic => ({
            ...value,
            type: \\"generic\\",
            _visit: visitor => visitor.generic(value)
        }),

        Timeout: (): ExceptionV2.Timeout => ({
            type: \\"timeout\\",
            _visit: visitor => visitor.timeout()
        }),

    } as const;
",
                "name": "ExceptionV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface ExecutionSessionResponse {
    sessionId: string;
    executionSessionUrl?: string;
    language: MyApi.commons.Language;
    status: MyApi.submission.ExecutionSessionStatus;
}
",
                "name": "ExecutionSessionResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface ExecutionSessionState {
    lastTimeContacted?: string;
    sessionId: string;
    isWarmInstance: boolean;
    awsTaskId?: string;
    language: MyApi.commons.Language;
    status: MyApi.submission.ExecutionSessionStatus;
}
",
                "name": "ExecutionSessionState.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface ExecutionSessionStatus<RawValue extends ExecutionSessionStatus.RawValue = ExecutionSessionStatus.RawValue> {
    get: () => RawValue;
    visit: <Result>(visitor: ExecutionSessionStatus._Visitor<Result>) => Result;
}

export const ExecutionSessionStatus = {
        CreatingContainer: (): ExecutionSessionStatus<\\"CREATING_CONTAINER\\"> => ({
            get: () => \\"CREATING_CONTAINER\\",
            visit: visitor => visitor.creatingContainer()
        }),
        ProvisioningContainer: (): ExecutionSessionStatus<\\"PROVISIONING_CONTAINER\\"> => ({
            get: () => \\"PROVISIONING_CONTAINER\\",
            visit: visitor => visitor.provisioningContainer()
        }),
        PendingContainer: (): ExecutionSessionStatus<\\"PENDING_CONTAINER\\"> => ({
            get: () => \\"PENDING_CONTAINER\\",
            visit: visitor => visitor.pendingContainer()
        }),
        RunningContainer: (): ExecutionSessionStatus<\\"RUNNING_CONTAINER\\"> => ({
            get: () => \\"RUNNING_CONTAINER\\",
            visit: visitor => visitor.runningContainer()
        }),
        LiveContainer: (): ExecutionSessionStatus<\\"LIVE_CONTAINER\\"> => ({
            get: () => \\"LIVE_CONTAINER\\",
            visit: visitor => visitor.liveContainer()
        }),
        FailedToLaunch: (): ExecutionSessionStatus<\\"FAILED_TO_LAUNCH\\"> => ({
            get: () => \\"FAILED_TO_LAUNCH\\",
            visit: visitor => visitor.failedToLaunch()
        }),
    } as const;

export declare namespace ExecutionSessionStatus {
    type RawValue = \\"CREATING_CONTAINER\\" | \\"PROVISIONING_CONTAINER\\" | \\"PENDING_CONTAINER\\" | \\"RUNNING_CONTAINER\\" | \\"LIVE_CONTAINER\\" | \\"FAILED_TO_LAUNCH\\" | string;

    interface _Visitor<Result> {
        creatingContainer: () => Result;
        provisioningContainer: () => Result;
        pendingContainer: () => Result;
        runningContainer: () => Result;
        liveContainer: () => Result;
        failedToLaunch: () => Result;
        _unknown: (value: string) => Result;
    }
}
",
                "name": "ExecutionSessionStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface ExistingSubmissionExecuting {
    submissionId: MyApi.submission.SubmissionId;
}
",
                "name": "ExistingSubmissionExecuting.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface ExpressionLocation {
    start: number;
    offset: number;
}
",
                "name": "ExpressionLocation.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface FinishedResponse {
    submissionId: MyApi.submission.SubmissionId;
}
",
                "name": "FinishedResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface GetExecutionSessionStateResponse {
    states: Record<string, MyApi.submission.ExecutionSessionState>;
    numWarmingInstances?: number;
    warmingSessionIds: string[];
}
",
                "name": "GetExecutionSessionStateResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface GetSubmissionStateResponse {
    timeSubmitted?: string;
    submission: string;
    language: MyApi.commons.Language;
    submissionTypeState: MyApi.submission.SubmissionTypeState;
}
",
                "name": "GetSubmissionStateResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface GetTraceResponsesPageRequest {
    offset?: number;
}
",
                "name": "GetTraceResponsesPageRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface GradedResponse {
    submissionId: MyApi.submission.SubmissionId;
    testCases: Record<string, MyApi.submission.TestCaseResultWithStdout>;
}
",
                "name": "GradedResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface GradedResponseV2 {
    submissionId: MyApi.submission.SubmissionId;
    testCases: Record<string, MyApi.submission.TestCaseGrade>;
}
",
                "name": "GradedResponseV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface GradedTestCaseUpdate {
    testCaseId: MyApi.v2.problem.TestCaseId;
    grade: MyApi.submission.TestCaseGrade;
}
",
                "name": "GradedTestCaseUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface InitializeProblemRequest {
    problemId: MyApi.commons.ProblemId;
    problemVersion?: number;
}
",
                "name": "InitializeProblemRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface InternalError {
    exceptionInfo: MyApi.submission.ExceptionInfo;
}
",
                "name": "InternalError.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type InvalidRequestCause = 
    /**
     * The submission request references a submission id that doesn't exist. */
    | InvalidRequestCause.SubmissionIdNotFound
    | InvalidRequestCause.CustomTestCasesUnsupported
    /**
     * The submission request was routed to an incorrect language executor. */
    | InvalidRequestCause.UnexpectedLanguage
    | InvalidRequestCause._Unknown;

export declare namespace InvalidRequestCause {
    interface SubmissionIdNotFound extends MyApi.submission.SubmissionIdNotFound, _Utils {
        type: \\"submissionIdNotFound\\";
    }

    interface CustomTestCasesUnsupported extends MyApi.submission.CustomTestCasesUnsupported, _Utils {
        type: \\"customTestCasesUnsupported\\";
    }

    interface UnexpectedLanguage extends MyApi.submission.UnexpectedLanguageError, _Utils {
        type: \\"unexpectedLanguage\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: InvalidRequestCause._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        submissionIdNotFound: (value: MyApi.submission.SubmissionIdNotFound) => Result;
        customTestCasesUnsupported: (value: MyApi.submission.CustomTestCasesUnsupported) => Result;
        unexpectedLanguage: (value: MyApi.submission.UnexpectedLanguageError) => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const InvalidRequestCause = {
        SubmissionIdNotFound: (value: MyApi.submission.SubmissionIdNotFound): InvalidRequestCause.SubmissionIdNotFound => ({
            ...value,
            type: \\"submissionIdNotFound\\",
            _visit: visitor => visitor.submissionIdNotFound(value)
        }),

        CustomTestCasesUnsupported: (value: MyApi.submission.CustomTestCasesUnsupported): InvalidRequestCause.CustomTestCasesUnsupported => ({
            ...value,
            type: \\"customTestCasesUnsupported\\",
            _visit: visitor => visitor.customTestCasesUnsupported(value)
        }),

        UnexpectedLanguage: (value: MyApi.submission.UnexpectedLanguageError): InvalidRequestCause.UnexpectedLanguage => ({
            ...value,
            type: \\"unexpectedLanguage\\",
            _visit: visitor => visitor.unexpectedLanguage(value)
        }),

    } as const;
",
                "name": "InvalidRequestCause.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface InvalidRequestResponse {
    request: MyApi.submission.SubmissionRequest;
    cause: MyApi.submission.InvalidRequestCause;
}
",
                "name": "InvalidRequestResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface LightweightStackframeInformation {
    numStackFrames: number;
    topStackFrameMethodName: string;
}
",
                "name": "LightweightStackframeInformation.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface RecordedResponseNotification {
    submissionId: MyApi.submission.SubmissionId;
    traceResponsesSize: number;
    testCaseId?: string;
}
",
                "name": "RecordedResponseNotification.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface RecordedTestCaseUpdate {
    testCaseId: MyApi.v2.problem.TestCaseId;
    traceResponsesSize: number;
}
",
                "name": "RecordedTestCaseUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface RecordingResponseNotification {
    submissionId: MyApi.submission.SubmissionId;
    testCaseId?: string;
    lineNumber: number;
    lightweightStackInfo: MyApi.submission.LightweightStackframeInformation;
    tracedFile?: MyApi.submission.TracedFile;
}
",
                "name": "RecordingResponseNotification.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface RunningResponse {
    submissionId: MyApi.submission.SubmissionId;
    state: MyApi.submission.RunningSubmissionState;
}
",
                "name": "RunningResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface RunningSubmissionState<RawValue extends RunningSubmissionState.RawValue = RunningSubmissionState.RawValue> {
    get: () => RawValue;
    visit: <Result>(visitor: RunningSubmissionState._Visitor<Result>) => Result;
}

export const RunningSubmissionState = {
        QueueingSubmission: (): RunningSubmissionState<\\"QUEUEING_SUBMISSION\\"> => ({
            get: () => \\"QUEUEING_SUBMISSION\\",
            visit: visitor => visitor.queueingSubmission()
        }),
        KillingHistoricalSubmissions: (): RunningSubmissionState<\\"KILLING_HISTORICAL_SUBMISSIONS\\"> => ({
            get: () => \\"KILLING_HISTORICAL_SUBMISSIONS\\",
            visit: visitor => visitor.killingHistoricalSubmissions()
        }),
        WritingSubmissionToFile: (): RunningSubmissionState<\\"WRITING_SUBMISSION_TO_FILE\\"> => ({
            get: () => \\"WRITING_SUBMISSION_TO_FILE\\",
            visit: visitor => visitor.writingSubmissionToFile()
        }),
        CompilingSubmission: (): RunningSubmissionState<\\"COMPILING_SUBMISSION\\"> => ({
            get: () => \\"COMPILING_SUBMISSION\\",
            visit: visitor => visitor.compilingSubmission()
        }),
        RunningSubmission: (): RunningSubmissionState<\\"RUNNING_SUBMISSION\\"> => ({
            get: () => \\"RUNNING_SUBMISSION\\",
            visit: visitor => visitor.runningSubmission()
        }),
    } as const;

export declare namespace RunningSubmissionState {
    type RawValue = \\"QUEUEING_SUBMISSION\\" | \\"KILLING_HISTORICAL_SUBMISSIONS\\" | \\"WRITING_SUBMISSION_TO_FILE\\" | \\"COMPILING_SUBMISSION\\" | \\"RUNNING_SUBMISSION\\" | string;

    interface _Visitor<Result> {
        queueingSubmission: () => Result;
        killingHistoricalSubmissions: () => Result;
        writingSubmissionToFile: () => Result;
        compilingSubmission: () => Result;
        runningSubmission: () => Result;
        _unknown: (value: string) => Result;
    }
}
",
                "name": "RunningSubmissionState.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface RuntimeError {
    message: string;
}
",
                "name": "RuntimeError.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface Scope {
    variables: Record<string, MyApi.commons.DebugVariableValue>;
}
",
                "name": "Scope.ts",
                "type": "file",
              },
              Object {
                "contents": "export type ShareId = string;
",
                "name": "ShareId.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface StackFrame {
    methodName: string;
    lineNumber: number;
    scopes: MyApi.submission.Scope[];
}
",
                "name": "StackFrame.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface StackInformation {
    numStackFrames: number;
    topStackFrame?: MyApi.submission.StackFrame;
}
",
                "name": "StackInformation.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface StderrResponse {
    submissionId: MyApi.submission.SubmissionId;
    stderr: string;
}
",
                "name": "StderrResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface StdoutResponse {
    submissionId: MyApi.submission.SubmissionId;
    stdout: string;
}
",
                "name": "StdoutResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface StopRequest {
    submissionId: MyApi.submission.SubmissionId;
}
",
                "name": "StopRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface StoppedResponse {
    submissionId: MyApi.submission.SubmissionId;
}
",
                "name": "StoppedResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface SubmissionFileInfo {
    directory: string;
    filename: string;
    contents: string;
}
",
                "name": "SubmissionFileInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "export type SubmissionId = string;
",
                "name": "SubmissionId.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface SubmissionIdNotFound {
    missingSubmissionId: MyApi.submission.SubmissionId;
}
",
                "name": "SubmissionIdNotFound.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type SubmissionRequest = 
    | SubmissionRequest.InitializeProblemRequest
    | SubmissionRequest.InitializeWorkspaceRequest
    | SubmissionRequest.SubmitV2
    | SubmissionRequest.WorkspaceSubmit
    | SubmissionRequest.Stop
    | SubmissionRequest._Unknown;

export declare namespace SubmissionRequest {
    interface InitializeProblemRequest extends MyApi.submission.InitializeProblemRequest, _Utils {
        type: \\"initializeProblemRequest\\";
    }

    interface InitializeWorkspaceRequest extends _Utils {
        type: \\"initializeWorkspaceRequest\\";
    }

    interface SubmitV2 extends MyApi.submission.SubmitRequestV2, _Utils {
        type: \\"submitV2\\";
    }

    interface WorkspaceSubmit extends MyApi.submission.WorkspaceSubmitRequest, _Utils {
        type: \\"workspaceSubmit\\";
    }

    interface Stop extends MyApi.submission.StopRequest, _Utils {
        type: \\"stop\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: SubmissionRequest._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        initializeProblemRequest: (value: MyApi.submission.InitializeProblemRequest) => Result;
        initializeWorkspaceRequest: () => Result;
        submitV2: (value: MyApi.submission.SubmitRequestV2) => Result;
        workspaceSubmit: (value: MyApi.submission.WorkspaceSubmitRequest) => Result;
        stop: (value: MyApi.submission.StopRequest) => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const SubmissionRequest = {
        InitializeProblemRequest: (value: MyApi.submission.InitializeProblemRequest): SubmissionRequest.InitializeProblemRequest => ({
            ...value,
            type: \\"initializeProblemRequest\\",
            _visit: visitor => visitor.initializeProblemRequest(value)
        }),

        InitializeWorkspaceRequest: (): SubmissionRequest.InitializeWorkspaceRequest => ({
            type: \\"initializeWorkspaceRequest\\",
            _visit: visitor => visitor.initializeWorkspaceRequest()
        }),

        SubmitV2: (value: MyApi.submission.SubmitRequestV2): SubmissionRequest.SubmitV2 => ({
            ...value,
            type: \\"submitV2\\",
            _visit: visitor => visitor.submitV2(value)
        }),

        WorkspaceSubmit: (value: MyApi.submission.WorkspaceSubmitRequest): SubmissionRequest.WorkspaceSubmit => ({
            ...value,
            type: \\"workspaceSubmit\\",
            _visit: visitor => visitor.workspaceSubmit(value)
        }),

        Stop: (value: MyApi.submission.StopRequest): SubmissionRequest.Stop => ({
            ...value,
            type: \\"stop\\",
            _visit: visitor => visitor.stop(value)
        }),

    } as const;
",
                "name": "SubmissionRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type SubmissionResponse = 
    | SubmissionResponse.ServerInitialized
    | SubmissionResponse.ProblemInitialized
    | SubmissionResponse.WorkspaceInitialized
    | SubmissionResponse.ServerErrored
    | SubmissionResponse.CodeExecutionUpdate
    | SubmissionResponse.Terminated
    | SubmissionResponse._Unknown;

export declare namespace SubmissionResponse {
    interface ServerInitialized extends _Utils {
        type: \\"serverInitialized\\";
    }

    interface ProblemInitialized extends _Utils {
        type: \\"problemInitialized\\";
        value: MyApi.commons.ProblemId;
    }

    interface WorkspaceInitialized extends _Utils {
        type: \\"workspaceInitialized\\";
    }

    interface ServerErrored extends MyApi.submission.ExceptionInfo, _Utils {
        type: \\"serverErrored\\";
    }

    interface CodeExecutionUpdate extends _Utils {
        type: \\"codeExecutionUpdate\\";
        value: MyApi.submission.CodeExecutionUpdate;
    }

    interface Terminated extends MyApi.submission.TerminatedResponse, _Utils {
        type: \\"terminated\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: SubmissionResponse._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        serverInitialized: () => Result;
        problemInitialized: (value: MyApi.commons.ProblemId) => Result;
        workspaceInitialized: () => Result;
        serverErrored: (value: MyApi.submission.ExceptionInfo) => Result;
        codeExecutionUpdate: (value: MyApi.submission.CodeExecutionUpdate) => Result;
        terminated: (value: MyApi.submission.TerminatedResponse) => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const SubmissionResponse = {
        ServerInitialized: (): SubmissionResponse.ServerInitialized => ({
            type: \\"serverInitialized\\",
            _visit: visitor => visitor.serverInitialized()
        }),

        ProblemInitialized: (value: MyApi.commons.ProblemId): SubmissionResponse.ProblemInitialized => ({
            value: value,
            type: \\"problemInitialized\\",
            _visit: visitor => visitor.problemInitialized(value)
        }),

        WorkspaceInitialized: (): SubmissionResponse.WorkspaceInitialized => ({
            type: \\"workspaceInitialized\\",
            _visit: visitor => visitor.workspaceInitialized()
        }),

        ServerErrored: (value: MyApi.submission.ExceptionInfo): SubmissionResponse.ServerErrored => ({
            ...value,
            type: \\"serverErrored\\",
            _visit: visitor => visitor.serverErrored(value)
        }),

        CodeExecutionUpdate: (value: MyApi.submission.CodeExecutionUpdate): SubmissionResponse.CodeExecutionUpdate => ({
            value: value,
            type: \\"codeExecutionUpdate\\",
            _visit: visitor => visitor.codeExecutionUpdate(value)
        }),

        Terminated: (value: MyApi.submission.TerminatedResponse): SubmissionResponse.Terminated => ({
            ...value,
            type: \\"terminated\\",
            _visit: visitor => visitor.terminated(value)
        }),

    } as const;
",
                "name": "SubmissionResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type SubmissionStatusForTestCase = 
    | SubmissionStatusForTestCase.Graded
    | SubmissionStatusForTestCase.GradedV2
    | SubmissionStatusForTestCase.Traced
    | SubmissionStatusForTestCase._Unknown;

export declare namespace SubmissionStatusForTestCase {
    interface Graded extends MyApi.submission.TestCaseResultWithStdout, _Utils {
        type: \\"graded\\";
    }

    interface GradedV2 extends _Utils {
        type: \\"gradedV2\\";
        value: MyApi.submission.TestCaseGrade;
    }

    interface Traced extends MyApi.submission.TracedTestCase, _Utils {
        type: \\"traced\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: SubmissionStatusForTestCase._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        graded: (value: MyApi.submission.TestCaseResultWithStdout) => Result;
        gradedV2: (value: MyApi.submission.TestCaseGrade) => Result;
        traced: (value: MyApi.submission.TracedTestCase) => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const SubmissionStatusForTestCase = {
        Graded: (value: MyApi.submission.TestCaseResultWithStdout): SubmissionStatusForTestCase.Graded => ({
            ...value,
            type: \\"graded\\",
            _visit: visitor => visitor.graded(value)
        }),

        GradedV2: (value: MyApi.submission.TestCaseGrade): SubmissionStatusForTestCase.GradedV2 => ({
            value: value,
            type: \\"gradedV2\\",
            _visit: visitor => visitor.gradedV2(value)
        }),

        Traced: (value: MyApi.submission.TracedTestCase): SubmissionStatusForTestCase.Traced => ({
            ...value,
            type: \\"traced\\",
            _visit: visitor => visitor.traced(value)
        }),

    } as const;
",
                "name": "SubmissionStatusForTestCase.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type SubmissionStatusV2 = 
    | SubmissionStatusV2.Test
    | SubmissionStatusV2.Workspace
    | SubmissionStatusV2._Unknown;

export declare namespace SubmissionStatusV2 {
    interface Test extends MyApi.submission.TestSubmissionStatusV2, _Utils {
        type: \\"test\\";
    }

    interface Workspace extends MyApi.submission.WorkspaceSubmissionStatusV2, _Utils {
        type: \\"workspace\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: SubmissionStatusV2._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        test: (value: MyApi.submission.TestSubmissionStatusV2) => Result;
        workspace: (value: MyApi.submission.WorkspaceSubmissionStatusV2) => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const SubmissionStatusV2 = {
        Test: (value: MyApi.submission.TestSubmissionStatusV2): SubmissionStatusV2.Test => ({
            ...value,
            type: \\"test\\",
            _visit: visitor => visitor.test(value)
        }),

        Workspace: (value: MyApi.submission.WorkspaceSubmissionStatusV2): SubmissionStatusV2.Workspace => ({
            ...value,
            type: \\"workspace\\",
            _visit: visitor => visitor.workspace(value)
        }),

    } as const;
",
                "name": "SubmissionStatusV2.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * Keep in sync with SubmissionType.
 */
export interface SubmissionTypeEnum<RawValue extends SubmissionTypeEnum.RawValue = SubmissionTypeEnum.RawValue> {
    get: () => RawValue;
    visit: <Result>(visitor: SubmissionTypeEnum._Visitor<Result>) => Result;
}

export const SubmissionTypeEnum = {
        Test: (): SubmissionTypeEnum<\\"TEST\\"> => ({
            get: () => \\"TEST\\",
            visit: visitor => visitor.test()
        }),
    } as const;

export declare namespace SubmissionTypeEnum {
    type RawValue = \\"TEST\\" | string;

    interface _Visitor<Result> {
        test: () => Result;
        _unknown: (value: string) => Result;
    }
}
",
                "name": "SubmissionTypeEnum.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type SubmissionTypeState = 
    | SubmissionTypeState.Test
    | SubmissionTypeState.Workspace
    | SubmissionTypeState._Unknown;

export declare namespace SubmissionTypeState {
    interface Test extends MyApi.submission.TestSubmissionState, _Utils {
        type: \\"test\\";
    }

    interface Workspace extends MyApi.submission.WorkspaceSubmissionState, _Utils {
        type: \\"workspace\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: SubmissionTypeState._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        test: (value: MyApi.submission.TestSubmissionState) => Result;
        workspace: (value: MyApi.submission.WorkspaceSubmissionState) => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const SubmissionTypeState = {
        Test: (value: MyApi.submission.TestSubmissionState): SubmissionTypeState.Test => ({
            ...value,
            type: \\"test\\",
            _visit: visitor => visitor.test(value)
        }),

        Workspace: (value: MyApi.submission.WorkspaceSubmissionState): SubmissionTypeState.Workspace => ({
            ...value,
            type: \\"workspace\\",
            _visit: visitor => visitor.workspace(value)
        }),

    } as const;
",
                "name": "SubmissionTypeState.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface SubmitRequestV2 {
    submissionId: MyApi.submission.SubmissionId;
    language: MyApi.commons.Language;
    submissionFiles: MyApi.submission.SubmissionFileInfo[];
    problemId: MyApi.commons.ProblemId;
    problemVersion?: number;
    userId?: string;
}
",
                "name": "SubmitRequestV2.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface TerminatedResponse {
}
",
                "name": "TerminatedResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type TestCaseGrade = 
    | TestCaseGrade.Hidden
    | TestCaseGrade.NonHidden
    | TestCaseGrade._Unknown;

export declare namespace TestCaseGrade {
    interface Hidden extends MyApi.submission.TestCaseHiddenGrade, _Utils {
        type: \\"hidden\\";
    }

    interface NonHidden extends MyApi.submission.TestCaseNonHiddenGrade, _Utils {
        type: \\"nonHidden\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: TestCaseGrade._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        hidden: (value: MyApi.submission.TestCaseHiddenGrade) => Result;
        nonHidden: (value: MyApi.submission.TestCaseNonHiddenGrade) => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const TestCaseGrade = {
        Hidden: (value: MyApi.submission.TestCaseHiddenGrade): TestCaseGrade.Hidden => ({
            ...value,
            type: \\"hidden\\",
            _visit: visitor => visitor.hidden(value)
        }),

        NonHidden: (value: MyApi.submission.TestCaseNonHiddenGrade): TestCaseGrade.NonHidden => ({
            ...value,
            type: \\"nonHidden\\",
            _visit: visitor => visitor.nonHidden(value)
        }),

    } as const;
",
                "name": "TestCaseGrade.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface TestCaseHiddenGrade {
    passed: boolean;
}
",
                "name": "TestCaseHiddenGrade.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface TestCaseNonHiddenGrade {
    passed: boolean;
    actualResult?: MyApi.commons.VariableValue;
    exception?: MyApi.submission.ExceptionV2;
    stdout: string;
}
",
                "name": "TestCaseNonHiddenGrade.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface TestCaseResult {
    expectedResult: MyApi.commons.VariableValue;
    actualResult: MyApi.submission.ActualResult;
    passed: boolean;
}
",
                "name": "TestCaseResult.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface TestCaseResultWithStdout {
    result: MyApi.submission.TestCaseResult;
    stdout: string;
}
",
                "name": "TestCaseResultWithStdout.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface TestSubmissionState {
    problemId: MyApi.commons.ProblemId;
    defaultTestCases: MyApi.commons.TestCase[];
    customTestCases: MyApi.commons.TestCase[];
    status: MyApi.submission.TestSubmissionStatus;
}
",
                "name": "TestSubmissionState.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type TestSubmissionStatus = 
    | TestSubmissionStatus.Stopped
    | TestSubmissionStatus.Errored
    | TestSubmissionStatus.Running
    | TestSubmissionStatus.TestCaseIdToState
    | TestSubmissionStatus._Unknown;

export declare namespace TestSubmissionStatus {
    interface Stopped extends _Utils {
        type: \\"stopped\\";
    }

    interface Errored extends _Utils {
        type: \\"errored\\";
        value: MyApi.submission.ErrorInfo;
    }

    interface Running extends _Utils {
        type: \\"running\\";
        value: MyApi.submission.RunningSubmissionState;
    }

    interface TestCaseIdToState extends _Utils {
        type: \\"testCaseIdToState\\";
        value: Record<string, MyApi.submission.SubmissionStatusForTestCase>;
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: TestSubmissionStatus._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        stopped: () => Result;
        errored: (value: MyApi.submission.ErrorInfo) => Result;
        running: (value: MyApi.submission.RunningSubmissionState) => Result;
        testCaseIdToState: (value: Record<string, MyApi.submission.SubmissionStatusForTestCase>) => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const TestSubmissionStatus = {
        Stopped: (): TestSubmissionStatus.Stopped => ({
            type: \\"stopped\\",
            _visit: visitor => visitor.stopped()
        }),

        Errored: (value: MyApi.submission.ErrorInfo): TestSubmissionStatus.Errored => ({
            value: value,
            type: \\"errored\\",
            _visit: visitor => visitor.errored(value)
        }),

        Running: (value: MyApi.submission.RunningSubmissionState): TestSubmissionStatus.Running => ({
            value: value,
            type: \\"running\\",
            _visit: visitor => visitor.running(value)
        }),

        TestCaseIdToState: (value: Record<string, MyApi.submission.SubmissionStatusForTestCase>): TestSubmissionStatus.TestCaseIdToState => ({
            value: value,
            type: \\"testCaseIdToState\\",
            _visit: visitor => visitor.testCaseIdToState(value)
        }),

    } as const;
",
                "name": "TestSubmissionStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface TestSubmissionStatusV2 {
    updates: MyApi.submission.TestSubmissionUpdate[];
    problemId: MyApi.commons.ProblemId;
    problemVersion: number;
    problemInfo: MyApi.v2.problem.ProblemInfoV2;
}
",
                "name": "TestSubmissionStatusV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface TestSubmissionUpdate {
    updateTime: string;
    updateInfo: MyApi.submission.TestSubmissionUpdateInfo;
}
",
                "name": "TestSubmissionUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type TestSubmissionUpdateInfo = 
    | TestSubmissionUpdateInfo.Running
    | TestSubmissionUpdateInfo.Stopped
    | TestSubmissionUpdateInfo.Errored
    | TestSubmissionUpdateInfo.GradedTestCase
    | TestSubmissionUpdateInfo.RecordedTestCase
    | TestSubmissionUpdateInfo.Finished
    | TestSubmissionUpdateInfo._Unknown;

export declare namespace TestSubmissionUpdateInfo {
    interface Running extends _Utils {
        type: \\"running\\";
        value: MyApi.submission.RunningSubmissionState;
    }

    interface Stopped extends _Utils {
        type: \\"stopped\\";
    }

    interface Errored extends _Utils {
        type: \\"errored\\";
        value: MyApi.submission.ErrorInfo;
    }

    interface GradedTestCase extends MyApi.submission.GradedTestCaseUpdate, _Utils {
        type: \\"gradedTestCase\\";
    }

    interface RecordedTestCase extends MyApi.submission.RecordedTestCaseUpdate, _Utils {
        type: \\"recordedTestCase\\";
    }

    interface Finished extends _Utils {
        type: \\"finished\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: TestSubmissionUpdateInfo._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        running: (value: MyApi.submission.RunningSubmissionState) => Result;
        stopped: () => Result;
        errored: (value: MyApi.submission.ErrorInfo) => Result;
        gradedTestCase: (value: MyApi.submission.GradedTestCaseUpdate) => Result;
        recordedTestCase: (value: MyApi.submission.RecordedTestCaseUpdate) => Result;
        finished: () => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const TestSubmissionUpdateInfo = {
        Running: (value: MyApi.submission.RunningSubmissionState): TestSubmissionUpdateInfo.Running => ({
            value: value,
            type: \\"running\\",
            _visit: visitor => visitor.running(value)
        }),

        Stopped: (): TestSubmissionUpdateInfo.Stopped => ({
            type: \\"stopped\\",
            _visit: visitor => visitor.stopped()
        }),

        Errored: (value: MyApi.submission.ErrorInfo): TestSubmissionUpdateInfo.Errored => ({
            value: value,
            type: \\"errored\\",
            _visit: visitor => visitor.errored(value)
        }),

        GradedTestCase: (value: MyApi.submission.GradedTestCaseUpdate): TestSubmissionUpdateInfo.GradedTestCase => ({
            ...value,
            type: \\"gradedTestCase\\",
            _visit: visitor => visitor.gradedTestCase(value)
        }),

        RecordedTestCase: (value: MyApi.submission.RecordedTestCaseUpdate): TestSubmissionUpdateInfo.RecordedTestCase => ({
            ...value,
            type: \\"recordedTestCase\\",
            _visit: visitor => visitor.recordedTestCase(value)
        }),

        Finished: (): TestSubmissionUpdateInfo.Finished => ({
            type: \\"finished\\",
            _visit: visitor => visitor.finished()
        }),

    } as const;
",
                "name": "TestSubmissionUpdateInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface TraceResponse {
    submissionId: MyApi.submission.SubmissionId;
    lineNumber: number;
    returnValue?: MyApi.commons.DebugVariableValue;
    expressionLocation?: MyApi.submission.ExpressionLocation;
    stack: MyApi.submission.StackInformation;
    stdout?: string;
}
",
                "name": "TraceResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface TraceResponseV2 {
    submissionId: MyApi.submission.SubmissionId;
    lineNumber: number;
    file: MyApi.submission.TracedFile;
    returnValue?: MyApi.commons.DebugVariableValue;
    expressionLocation?: MyApi.submission.ExpressionLocation;
    stack: MyApi.submission.StackInformation;
    stdout?: string;
}
",
                "name": "TraceResponseV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface TraceResponsesPage {
    /**
     * If present, use this to load subseqent pages.
     * The offset is the id of the next trace response to load.
     *
     */
    offset?: number;
    traceResponses: MyApi.submission.TraceResponse[];
}
",
                "name": "TraceResponsesPage.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface TraceResponsesPageV2 {
    /**
     * If present, use this to load subseqent pages.
     * The offset is the id of the next trace response to load.
     *
     */
    offset?: number;
    traceResponses: MyApi.submission.TraceResponseV2[];
}
",
                "name": "TraceResponsesPageV2.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface TracedFile {
    filename: string;
    directory: string;
}
",
                "name": "TracedFile.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface TracedTestCase {
    result: MyApi.submission.TestCaseResultWithStdout;
    traceResponsesSize: number;
}
",
                "name": "TracedTestCase.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface UnexpectedLanguageError {
    expectedLanguage: MyApi.commons.Language;
    actualLanguage: MyApi.commons.Language;
}
",
                "name": "UnexpectedLanguageError.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface WorkspaceFiles {
    mainFile: MyApi.commons.FileInfo;
    readOnlyFiles: MyApi.commons.FileInfo[];
}
",
                "name": "WorkspaceFiles.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface WorkspaceRanResponse {
    submissionId: MyApi.submission.SubmissionId;
    runDetails: MyApi.submission.WorkspaceRunDetails;
}
",
                "name": "WorkspaceRanResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface WorkspaceRunDetails {
    exceptionV2?: MyApi.submission.ExceptionV2;
    exception?: MyApi.submission.ExceptionInfo;
    stdout: string;
}
",
                "name": "WorkspaceRunDetails.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface WorkspaceStarterFilesResponse {
    files: Record<MyApi.commons.Language.RawValue, MyApi.submission.WorkspaceFiles>;
}
",
                "name": "WorkspaceStarterFilesResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface WorkspaceStarterFilesResponseV2 {
    filesByLanguage: Record<MyApi.commons.Language.RawValue, MyApi.v2.problem.Files>;
}
",
                "name": "WorkspaceStarterFilesResponseV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface WorkspaceSubmissionState {
    status: MyApi.submission.WorkspaceSubmissionStatus;
}
",
                "name": "WorkspaceSubmissionState.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type WorkspaceSubmissionStatus = 
    | WorkspaceSubmissionStatus.Stopped
    | WorkspaceSubmissionStatus.Errored
    | WorkspaceSubmissionStatus.Running
    | WorkspaceSubmissionStatus.Ran
    | WorkspaceSubmissionStatus.Traced
    | WorkspaceSubmissionStatus._Unknown;

export declare namespace WorkspaceSubmissionStatus {
    interface Stopped extends _Utils {
        type: \\"stopped\\";
    }

    interface Errored extends _Utils {
        type: \\"errored\\";
        value: MyApi.submission.ErrorInfo;
    }

    interface Running extends _Utils {
        type: \\"running\\";
        value: MyApi.submission.RunningSubmissionState;
    }

    interface Ran extends MyApi.submission.WorkspaceRunDetails, _Utils {
        type: \\"ran\\";
    }

    interface Traced extends MyApi.submission.WorkspaceRunDetails, _Utils {
        type: \\"traced\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: WorkspaceSubmissionStatus._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        stopped: () => Result;
        errored: (value: MyApi.submission.ErrorInfo) => Result;
        running: (value: MyApi.submission.RunningSubmissionState) => Result;
        ran: (value: MyApi.submission.WorkspaceRunDetails) => Result;
        traced: (value: MyApi.submission.WorkspaceRunDetails) => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const WorkspaceSubmissionStatus = {
        Stopped: (): WorkspaceSubmissionStatus.Stopped => ({
            type: \\"stopped\\",
            _visit: visitor => visitor.stopped()
        }),

        Errored: (value: MyApi.submission.ErrorInfo): WorkspaceSubmissionStatus.Errored => ({
            value: value,
            type: \\"errored\\",
            _visit: visitor => visitor.errored(value)
        }),

        Running: (value: MyApi.submission.RunningSubmissionState): WorkspaceSubmissionStatus.Running => ({
            value: value,
            type: \\"running\\",
            _visit: visitor => visitor.running(value)
        }),

        Ran: (value: MyApi.submission.WorkspaceRunDetails): WorkspaceSubmissionStatus.Ran => ({
            ...value,
            type: \\"ran\\",
            _visit: visitor => visitor.ran(value)
        }),

        Traced: (value: MyApi.submission.WorkspaceRunDetails): WorkspaceSubmissionStatus.Traced => ({
            ...value,
            type: \\"traced\\",
            _visit: visitor => visitor.traced(value)
        }),

    } as const;
",
                "name": "WorkspaceSubmissionStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface WorkspaceSubmissionStatusV2 {
    updates: MyApi.submission.WorkspaceSubmissionUpdate[];
}
",
                "name": "WorkspaceSubmissionStatusV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface WorkspaceSubmissionUpdate {
    updateTime: string;
    updateInfo: MyApi.submission.WorkspaceSubmissionUpdateInfo;
}
",
                "name": "WorkspaceSubmissionUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type WorkspaceSubmissionUpdateInfo = 
    | WorkspaceSubmissionUpdateInfo.Running
    | WorkspaceSubmissionUpdateInfo.Ran
    | WorkspaceSubmissionUpdateInfo.Stopped
    | WorkspaceSubmissionUpdateInfo.Traced
    | WorkspaceSubmissionUpdateInfo.TracedV2
    | WorkspaceSubmissionUpdateInfo.Errored
    | WorkspaceSubmissionUpdateInfo.Finished
    | WorkspaceSubmissionUpdateInfo._Unknown;

export declare namespace WorkspaceSubmissionUpdateInfo {
    interface Running extends _Utils {
        type: \\"running\\";
        value: MyApi.submission.RunningSubmissionState;
    }

    interface Ran extends MyApi.submission.WorkspaceRunDetails, _Utils {
        type: \\"ran\\";
    }

    interface Stopped extends _Utils {
        type: \\"stopped\\";
    }

    interface Traced extends _Utils {
        type: \\"traced\\";
    }

    interface TracedV2 extends MyApi.submission.WorkspaceTracedUpdate, _Utils {
        type: \\"tracedV2\\";
    }

    interface Errored extends _Utils {
        type: \\"errored\\";
        value: MyApi.submission.ErrorInfo;
    }

    interface Finished extends _Utils {
        type: \\"finished\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: WorkspaceSubmissionUpdateInfo._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        running: (value: MyApi.submission.RunningSubmissionState) => Result;
        ran: (value: MyApi.submission.WorkspaceRunDetails) => Result;
        stopped: () => Result;
        traced: () => Result;
        tracedV2: (value: MyApi.submission.WorkspaceTracedUpdate) => Result;
        errored: (value: MyApi.submission.ErrorInfo) => Result;
        finished: () => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const WorkspaceSubmissionUpdateInfo = {
        Running: (value: MyApi.submission.RunningSubmissionState): WorkspaceSubmissionUpdateInfo.Running => ({
            value: value,
            type: \\"running\\",
            _visit: visitor => visitor.running(value)
        }),

        Ran: (value: MyApi.submission.WorkspaceRunDetails): WorkspaceSubmissionUpdateInfo.Ran => ({
            ...value,
            type: \\"ran\\",
            _visit: visitor => visitor.ran(value)
        }),

        Stopped: (): WorkspaceSubmissionUpdateInfo.Stopped => ({
            type: \\"stopped\\",
            _visit: visitor => visitor.stopped()
        }),

        Traced: (): WorkspaceSubmissionUpdateInfo.Traced => ({
            type: \\"traced\\",
            _visit: visitor => visitor.traced()
        }),

        TracedV2: (value: MyApi.submission.WorkspaceTracedUpdate): WorkspaceSubmissionUpdateInfo.TracedV2 => ({
            ...value,
            type: \\"tracedV2\\",
            _visit: visitor => visitor.tracedV2(value)
        }),

        Errored: (value: MyApi.submission.ErrorInfo): WorkspaceSubmissionUpdateInfo.Errored => ({
            value: value,
            type: \\"errored\\",
            _visit: visitor => visitor.errored(value)
        }),

        Finished: (): WorkspaceSubmissionUpdateInfo.Finished => ({
            type: \\"finished\\",
            _visit: visitor => visitor.finished()
        }),

    } as const;
",
                "name": "WorkspaceSubmissionUpdateInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface WorkspaceSubmitRequest {
    submissionId: MyApi.submission.SubmissionId;
    language: MyApi.commons.Language;
    submissionFiles: MyApi.submission.SubmissionFileInfo[];
    userId?: string;
}
",
                "name": "WorkspaceSubmitRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface WorkspaceTracedUpdate {
    traceResponsesSize: number;
}
",
                "name": "WorkspaceTracedUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./SubmissionId\\";
export * from \\"./ShareId\\";
export * from \\"./SubmissionRequest\\";
export * from \\"./InitializeProblemRequest\\";
export * from \\"./SubmitRequestV2\\";
export * from \\"./WorkspaceSubmitRequest\\";
export * from \\"./SubmissionFileInfo\\";
export * from \\"./SubmissionTypeEnum\\";
export * from \\"./StopRequest\\";
export * from \\"./SubmissionResponse\\";
export * from \\"./CodeExecutionUpdate\\";
export * from \\"./BuildingExecutorResponse\\";
export * from \\"./RunningResponse\\";
export * from \\"./RunningSubmissionState\\";
export * from \\"./ErroredResponse\\";
export * from \\"./ErrorInfo\\";
export * from \\"./CompileError\\";
export * from \\"./RuntimeError\\";
export * from \\"./InternalError\\";
export * from \\"./StoppedResponse\\";
export * from \\"./WorkspaceRanResponse\\";
export * from \\"./WorkspaceRunDetails\\";
export * from \\"./GradedResponse\\";
export * from \\"./GradedResponseV2\\";
export * from \\"./TestCaseGrade\\";
export * from \\"./TestCaseHiddenGrade\\";
export * from \\"./TestCaseNonHiddenGrade\\";
export * from \\"./RecordedResponseNotification\\";
export * from \\"./RecordingResponseNotification\\";
export * from \\"./LightweightStackframeInformation\\";
export * from \\"./TestCaseResultWithStdout\\";
export * from \\"./TestCaseResult\\";
export * from \\"./ActualResult\\";
export * from \\"./ExceptionV2\\";
export * from \\"./ExceptionInfo\\";
export * from \\"./InvalidRequestResponse\\";
export * from \\"./InvalidRequestCause\\";
export * from \\"./ExistingSubmissionExecuting\\";
export * from \\"./SubmissionIdNotFound\\";
export * from \\"./CustomTestCasesUnsupported\\";
export * from \\"./UnexpectedLanguageError\\";
export * from \\"./TerminatedResponse\\";
export * from \\"./FinishedResponse\\";
export * from \\"./StdoutResponse\\";
export * from \\"./StderrResponse\\";
export * from \\"./TraceResponse\\";
export * from \\"./TraceResponseV2\\";
export * from \\"./TracedFile\\";
export * from \\"./ExpressionLocation\\";
export * from \\"./StackInformation\\";
export * from \\"./StackFrame\\";
export * from \\"./Scope\\";
export * from \\"./ExecutionSessionResponse\\";
export * from \\"./ExecutionSessionStatus\\";
export * from \\"./SubmissionStatusV2\\";
export * from \\"./TestSubmissionStatusV2\\";
export * from \\"./WorkspaceSubmissionStatusV2\\";
export * from \\"./TestSubmissionUpdate\\";
export * from \\"./TestSubmissionUpdateInfo\\";
export * from \\"./WorkspaceSubmissionUpdate\\";
export * from \\"./WorkspaceSubmissionUpdateInfo\\";
export * from \\"./GradedTestCaseUpdate\\";
export * from \\"./RecordedTestCaseUpdate\\";
export * from \\"./WorkspaceTracedUpdate\\";
export * from \\"./SubmissionTypeState\\";
export * from \\"./WorkspaceSubmissionState\\";
export * from \\"./WorkspaceSubmissionStatus\\";
export * from \\"./TestSubmissionState\\";
export * from \\"./TestSubmissionStatus\\";
export * from \\"./SubmissionStatusForTestCase\\";
export * from \\"./TracedTestCase\\";
export * from \\"./TraceResponsesPage\\";
export * from \\"./TraceResponsesPageV2\\";
export * from \\"./GetTraceResponsesPageRequest\\";
export * from \\"./WorkspaceStarterFilesResponse\\";
export * from \\"./WorkspaceStarterFilesResponseV2\\";
export * from \\"./WorkspaceFiles\\";
export * from \\"./ExecutionSessionState\\";
export * from \\"./GetExecutionSessionStateResponse\\";
export * from \\"./GetSubmissionStateResponse\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "submission",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "import { BearerToken, BasicAuth, _NetworkError, _UnknownError, ErrorDetails, _Response, defaultFetcherV2 } from \\"@fern-typescript/service-utils\\";
import { MyApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";

export interface Client {
    setNumWarmInstances(request: MyApi.sysprop.setNumWarmInstances.Request): Promise<_Response<void, MyApi.sysprop.setNumWarmInstances.Error>>;
    getNumWarmInstances(): Promise<_Response<Record<MyApi.commons.Language.RawValue, number>, MyApi.sysprop.getNumWarmInstances.Error>>;
}

export declare namespace Client {
    interface Options {
        _basePath: string;
        _token?: BearerToken;
        _credentials?: BasicAuth;
        xApiKey?: string;
    }
}

export class Client implements Client {
    constructor(private readonly options: Client.Options) {
    }

    public async setNumWarmInstances(request: MyApi.sysprop.setNumWarmInstances.Request): Promise<_Response<void, MyApi.sysprop.setNumWarmInstances.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/num-warm-instances/\${request.language}/\${request.numWarmInstances}\`),
                method: \\"PUT\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: undefined
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async getNumWarmInstances(): Promise<_Response<Record<MyApi.commons.Language.RawValue, number>, MyApi.sysprop.getNumWarmInstances.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \\"/num-warm-instances\\"),
                method: \\"GET\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as Record<MyApi.commons.Language.RawValue, number>
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }
}

export namespace setNumWarmInstances {
    export interface Request {
        language: MyApi.commons.Language;
        numWarmInstances: number;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.sysprop.setNumWarmInstances.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace getNumWarmInstances {
    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.sysprop.getNumWarmInstances.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}
",
                "name": "Client.ts",
                "type": "file",
              },
              Object {
                "contents": "export { setNumWarmInstances, getNumWarmInstances } from \\"./Client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "sysprop",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "import { BearerToken, BasicAuth } from \\"@fern-typescript/service-utils\\";
import { Client as ProblemInfoServicV2Client } from \\"./problem/client/Client\\";
import urlJoin from \\"url-join\\";
import { Wrapper as V3Wrapper } from \\"./v3/Wrapper\\";

export namespace Wrapper {
    export interface Options {
        _origin: string;
        _token?: BearerToken;
        _credentials?: BasicAuth;
        xApiKey?: string;
    }
}

export class Wrapper {
    constructor(private readonly options: Wrapper.Options) {
    }

    #problem: ProblemInfoServicV2Client | undefined;

    public get problem(): ProblemInfoServicV2Client {
        return (this.#problem ??= new ProblemInfoServicV2Client({
            _basePath: urlJoin(this.options._origin, \\"/problems-v2\\"),
            _token: this.options._token,
            _credentials: this.options._credentials,
            xApiKey: this.options.xApiKey
        }));
    }

    #v3: V3Wrapper | undefined;

    public get v3(): V3Wrapper {
        return (this.#v3 ??= new V3Wrapper(this.options));
    }
}
",
            "name": "Wrapper.ts",
            "type": "file",
          },
          Object {
            "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as v3 from \\"./v3\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { BearerToken, BasicAuth, _NetworkError, _UnknownError, ErrorDetails, _Response, defaultFetcherV2 } from \\"@fern-typescript/service-utils\\";
import { MyApi } from \\"../../../..\\";
import urlJoin from \\"url-join\\";

export interface Client {
    getLightweightProblems(): Promise<_Response<MyApi.v2.problem.LightweightProblemInfoV2[], MyApi.v2.problem.getLightweightProblems.Error>>;
    getProblems(): Promise<_Response<MyApi.v2.problem.ProblemInfoV2[], MyApi.v2.problem.getProblems.Error>>;
    getLatestProblem(request: MyApi.v2.problem.getLatestProblem.Request): Promise<_Response<MyApi.v2.problem.ProblemInfoV2, MyApi.v2.problem.getLatestProblem.Error>>;
    getProblemVersion(request: MyApi.v2.problem.getProblemVersion.Request): Promise<_Response<MyApi.v2.problem.ProblemInfoV2, MyApi.v2.problem.getProblemVersion.Error>>;
}

export declare namespace Client {
    interface Options {
        _basePath: string;
        _token?: BearerToken;
        _credentials?: BasicAuth;
        xApiKey?: string;
    }
}

export class Client implements Client {
    constructor(private readonly options: Client.Options) {
    }

    public async getLightweightProblems(): Promise<_Response<MyApi.v2.problem.LightweightProblemInfoV2[], MyApi.v2.problem.getLightweightProblems.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \\"/lightweight-problem-info\\"),
                method: \\"GET\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.v2.problem.LightweightProblemInfoV2[]
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async getProblems(): Promise<_Response<MyApi.v2.problem.ProblemInfoV2[], MyApi.v2.problem.getProblems.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \\"/problem-info\\"),
                method: \\"GET\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.v2.problem.ProblemInfoV2[]
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async getLatestProblem(request: MyApi.v2.problem.getLatestProblem.Request): Promise<_Response<MyApi.v2.problem.ProblemInfoV2, MyApi.v2.problem.getLatestProblem.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/problem-info/\${request.problemId}\`),
                method: \\"GET\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.v2.problem.ProblemInfoV2
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async getProblemVersion(request: MyApi.v2.problem.getProblemVersion.Request): Promise<_Response<MyApi.v2.problem.ProblemInfoV2, MyApi.v2.problem.getProblemVersion.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/problem-info/\${request.problemId}/version/\${request.problemVersion}\`),
                method: \\"GET\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.v2.problem.ProblemInfoV2
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }
}

export namespace getLightweightProblems {
    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.v2.problem.getLightweightProblems.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace getProblems {
    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.v2.problem.getProblems.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace getLatestProblem {
    export interface Request {
        problemId: MyApi.commons.ProblemId;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.v2.problem.getLatestProblem.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace getProblemVersion {
    export interface Request {
        problemId: MyApi.commons.ProblemId;
        problemVersion: number;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.v2.problem.getProblemVersion.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { getLightweightProblems, getProblems, getLatestProblem, getProblemVersion } from \\"./Client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export type AssertCorrectnessCheck = 
    | AssertCorrectnessCheck.DeepEquality
    | AssertCorrectnessCheck.Custom
    | AssertCorrectnessCheck._Unknown;

export declare namespace AssertCorrectnessCheck {
    interface DeepEquality extends MyApi.v2.problem.DeepEqualityCorrectnessCheck, _Utils {
        type: \\"deepEquality\\";
    }

    interface Custom extends MyApi.v2.problem.VoidFunctionDefinitionThatTakesActualResult, _Utils {
        type: \\"custom\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: AssertCorrectnessCheck._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        deepEquality: (value: MyApi.v2.problem.DeepEqualityCorrectnessCheck) => Result;
        custom: (value: MyApi.v2.problem.VoidFunctionDefinitionThatTakesActualResult) => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const AssertCorrectnessCheck = {
        DeepEquality: (value: MyApi.v2.problem.DeepEqualityCorrectnessCheck): AssertCorrectnessCheck.DeepEquality => ({
            ...value,
            type: \\"deepEquality\\",
            _visit: visitor => visitor.deepEquality(value)
        }),

        Custom: (value: MyApi.v2.problem.VoidFunctionDefinitionThatTakesActualResult): AssertCorrectnessCheck.Custom => ({
            ...value,
            type: \\"custom\\",
            _visit: visitor => visitor.custom(value)
        }),

    } as const;
",
                    "name": "AssertCorrectnessCheck.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface BasicCustomFiles {
    methodName: string;
    signature: MyApi.v2.problem.NonVoidFunctionSignature;
    additionalFiles: Record<MyApi.commons.Language.RawValue, MyApi.v2.problem.Files>;
    basicTestCaseTemplate: MyApi.v2.problem.BasicTestCaseTemplate;
}
",
                    "name": "BasicCustomFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface BasicTestCaseTemplate {
    templateId: MyApi.v2.problem.TestCaseTemplateId;
    name: string;
    description: MyApi.v2.problem.TestCaseImplementationDescription;
    expectedValueParameterId: MyApi.v2.problem.ParameterId;
}
",
                    "name": "BasicTestCaseTemplate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface CreateProblemRequestV2 {
    problemName: string;
    problemDescription: MyApi.problem.ProblemDescription;
    customFiles: MyApi.v2.problem.CustomFiles;
    customTestCaseTemplates: MyApi.v2.problem.TestCaseTemplate[];
    testcases: MyApi.v2.problem.TestCaseV2[];
    supportedLanguages: MyApi.commons.Language[];
    isPublic: boolean;
}
",
                    "name": "CreateProblemRequestV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export type CustomFiles = 
    | CustomFiles.Basic
    | CustomFiles.Custom
    | CustomFiles._Unknown;

export declare namespace CustomFiles {
    interface Basic extends MyApi.v2.problem.BasicCustomFiles, _Utils {
        type: \\"basic\\";
    }

    interface Custom extends _Utils {
        type: \\"custom\\";
        value: Record<MyApi.commons.Language.RawValue, MyApi.v2.problem.Files>;
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: CustomFiles._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        basic: (value: MyApi.v2.problem.BasicCustomFiles) => Result;
        custom: (value: Record<MyApi.commons.Language.RawValue, MyApi.v2.problem.Files>) => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const CustomFiles = {
        Basic: (value: MyApi.v2.problem.BasicCustomFiles): CustomFiles.Basic => ({
            ...value,
            type: \\"basic\\",
            _visit: visitor => visitor.basic(value)
        }),

        Custom: (value: Record<MyApi.commons.Language.RawValue, MyApi.v2.problem.Files>): CustomFiles.Custom => ({
            value: value,
            type: \\"custom\\",
            _visit: visitor => visitor.custom(value)
        }),

    } as const;
",
                    "name": "CustomFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface DeepEqualityCorrectnessCheck {
    expectedValueParameterId: MyApi.v2.problem.ParameterId;
}
",
                    "name": "DeepEqualityCorrectnessCheck.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface DefaultProvidedFile {
    file: MyApi.v2.problem.FileInfoV2;
    relatedTypes: MyApi.commons.VariableType[];
}
",
                    "name": "DefaultProvidedFile.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface FileInfoV2 {
    filename: string;
    directory: string;
    contents: string;
    editable: boolean;
}
",
                    "name": "FileInfoV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface Files {
    files: MyApi.v2.problem.FileInfoV2[];
}
",
                    "name": "Files.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface FunctionImplementation {
    impl: string;
    imports?: string;
}
",
                    "name": "FunctionImplementation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface FunctionImplementationForMultipleLanguages {
    codeByLanguage: Record<MyApi.commons.Language.RawValue, MyApi.v2.problem.FunctionImplementation>;
}
",
                    "name": "FunctionImplementationForMultipleLanguages.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export type FunctionSignature = 
    | FunctionSignature.Void
    | FunctionSignature.NonVoid
    /**
     * Useful when specifying custom grading for a testcase where actualResult is defined. */
    | FunctionSignature.VoidThatTakesActualResult
    | FunctionSignature._Unknown;

export declare namespace FunctionSignature {
    interface Void extends MyApi.v2.problem.VoidFunctionSignature, _Utils {
        type: \\"void\\";
    }

    interface NonVoid extends MyApi.v2.problem.NonVoidFunctionSignature, _Utils {
        type: \\"nonVoid\\";
    }

    interface VoidThatTakesActualResult extends MyApi.v2.problem.VoidFunctionSignatureThatTakesActualResult, _Utils {
        type: \\"voidThatTakesActualResult\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: FunctionSignature._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        void: (value: MyApi.v2.problem.VoidFunctionSignature) => Result;
        nonVoid: (value: MyApi.v2.problem.NonVoidFunctionSignature) => Result;
        voidThatTakesActualResult: (value: MyApi.v2.problem.VoidFunctionSignatureThatTakesActualResult) => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const FunctionSignature = {
        Void: (value: MyApi.v2.problem.VoidFunctionSignature): FunctionSignature.Void => ({
            ...value,
            type: \\"void\\",
            _visit: visitor => visitor.void(value)
        }),

        NonVoid: (value: MyApi.v2.problem.NonVoidFunctionSignature): FunctionSignature.NonVoid => ({
            ...value,
            type: \\"nonVoid\\",
            _visit: visitor => visitor.nonVoid(value)
        }),

        VoidThatTakesActualResult: (value: MyApi.v2.problem.VoidFunctionSignatureThatTakesActualResult): FunctionSignature.VoidThatTakesActualResult => ({
            ...value,
            type: \\"voidThatTakesActualResult\\",
            _visit: visitor => visitor.voidThatTakesActualResult(value)
        }),

    } as const;
",
                    "name": "FunctionSignature.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface GeneratedFiles {
    generatedTestCaseFiles: Record<MyApi.commons.Language.RawValue, MyApi.v2.problem.Files>;
    generatedTemplateFiles: Record<MyApi.commons.Language.RawValue, MyApi.v2.problem.Files>;
    other: Record<MyApi.commons.Language.RawValue, MyApi.v2.problem.Files>;
}
",
                    "name": "GeneratedFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface GetBasicSolutionFileRequest {
    methodName: string;
    signature: MyApi.v2.problem.NonVoidFunctionSignature;
}
",
                    "name": "GetBasicSolutionFileRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface GetBasicSolutionFileResponse {
    solutionFileByLanguage: Record<MyApi.commons.Language.RawValue, MyApi.v2.problem.FileInfoV2>;
}
",
                    "name": "GetBasicSolutionFileResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface GetFunctionSignatureRequest {
    functionSignature: MyApi.v2.problem.FunctionSignature;
}
",
                    "name": "GetFunctionSignatureRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface GetFunctionSignatureResponse {
    functionByLanguage: Record<MyApi.commons.Language.RawValue, string>;
}
",
                    "name": "GetFunctionSignatureResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface GetGeneratedTestCaseFileRequest {
    template?: MyApi.v2.problem.TestCaseTemplate;
    testCase: MyApi.v2.problem.TestCaseV2;
}
",
                    "name": "GetGeneratedTestCaseFileRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface GetGeneratedTestCaseTemplateFileRequest {
    template: MyApi.v2.problem.TestCaseTemplate;
}
",
                    "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface LightweightProblemInfoV2 {
    problemId: MyApi.commons.ProblemId;
    problemName: string;
    problemVersion: number;
    variableTypes: MyApi.commons.VariableType[];
}
",
                    "name": "LightweightProblemInfoV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface NonVoidFunctionDefinition {
    signature: MyApi.v2.problem.NonVoidFunctionSignature;
    code: MyApi.v2.problem.FunctionImplementationForMultipleLanguages;
}
",
                    "name": "NonVoidFunctionDefinition.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface NonVoidFunctionSignature {
    parameters: MyApi.v2.problem.Parameter[];
    returnType: MyApi.commons.VariableType;
}
",
                    "name": "NonVoidFunctionSignature.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface Parameter {
    parameterId: MyApi.v2.problem.ParameterId;
    name: string;
    variableType: MyApi.commons.VariableType;
}
",
                    "name": "Parameter.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type ParameterId = string;
",
                    "name": "ParameterId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface ProblemInfoV2 {
    problemId: MyApi.commons.ProblemId;
    problemDescription: MyApi.problem.ProblemDescription;
    problemName: string;
    problemVersion: number;
    supportedLanguages: MyApi.commons.Language[];
    customFiles: MyApi.v2.problem.CustomFiles;
    generatedFiles: MyApi.v2.problem.GeneratedFiles;
    customTestCaseTemplates: MyApi.v2.problem.TestCaseTemplate[];
    testcases: MyApi.v2.problem.TestCaseV2[];
    isPublic: boolean;
}
",
                    "name": "ProblemInfoV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface TestCaseExpects {
    expectedStdout?: string;
}
",
                    "name": "TestCaseExpects.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export type TestCaseFunction = 
    | TestCaseFunction.WithActualResult
    | TestCaseFunction.Custom
    | TestCaseFunction._Unknown;

export declare namespace TestCaseFunction {
    interface WithActualResult extends MyApi.v2.problem.TestCaseWithActualResultImplementation, _Utils {
        type: \\"withActualResult\\";
    }

    interface Custom extends MyApi.v2.problem.VoidFunctionDefinition, _Utils {
        type: \\"custom\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: TestCaseFunction._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        withActualResult: (value: MyApi.v2.problem.TestCaseWithActualResultImplementation) => Result;
        custom: (value: MyApi.v2.problem.VoidFunctionDefinition) => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const TestCaseFunction = {
        WithActualResult: (value: MyApi.v2.problem.TestCaseWithActualResultImplementation): TestCaseFunction.WithActualResult => ({
            ...value,
            type: \\"withActualResult\\",
            _visit: visitor => visitor.withActualResult(value)
        }),

        Custom: (value: MyApi.v2.problem.VoidFunctionDefinition): TestCaseFunction.Custom => ({
            ...value,
            type: \\"custom\\",
            _visit: visitor => visitor.custom(value)
        }),

    } as const;
",
                    "name": "TestCaseFunction.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type TestCaseId = string;
",
                    "name": "TestCaseId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface TestCaseImplementation {
    description: MyApi.v2.problem.TestCaseImplementationDescription;
    function: MyApi.v2.problem.TestCaseFunction;
}
",
                    "name": "TestCaseImplementation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface TestCaseImplementationDescription {
    boards: MyApi.v2.problem.TestCaseImplementationDescriptionBoard[];
}
",
                    "name": "TestCaseImplementationDescription.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export type TestCaseImplementationDescriptionBoard = 
    | TestCaseImplementationDescriptionBoard.Html
    | TestCaseImplementationDescriptionBoard.ParamId
    | TestCaseImplementationDescriptionBoard._Unknown;

export declare namespace TestCaseImplementationDescriptionBoard {
    interface Html extends _Utils {
        type: \\"html\\";
        value: string;
    }

    interface ParamId extends _Utils {
        type: \\"paramId\\";
        value: MyApi.v2.problem.ParameterId;
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: TestCaseImplementationDescriptionBoard._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        html: (value: string) => Result;
        paramId: (value: MyApi.v2.problem.ParameterId) => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const TestCaseImplementationDescriptionBoard = {
        Html: (value: string): TestCaseImplementationDescriptionBoard.Html => ({
            value: value,
            type: \\"html\\",
            _visit: visitor => visitor.html(value)
        }),

        ParamId: (value: MyApi.v2.problem.ParameterId): TestCaseImplementationDescriptionBoard.ParamId => ({
            value: value,
            type: \\"paramId\\",
            _visit: visitor => visitor.paramId(value)
        }),

    } as const;
",
                    "name": "TestCaseImplementationDescriptionBoard.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export type TestCaseImplementationReference = 
    | TestCaseImplementationReference.TemplateId
    | TestCaseImplementationReference.Implementation
    | TestCaseImplementationReference._Unknown;

export declare namespace TestCaseImplementationReference {
    interface TemplateId extends _Utils {
        type: \\"templateId\\";
        value: MyApi.v2.problem.TestCaseTemplateId;
    }

    interface Implementation extends MyApi.v2.problem.TestCaseImplementation, _Utils {
        type: \\"implementation\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: TestCaseImplementationReference._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        templateId: (value: MyApi.v2.problem.TestCaseTemplateId) => Result;
        implementation: (value: MyApi.v2.problem.TestCaseImplementation) => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const TestCaseImplementationReference = {
        TemplateId: (value: MyApi.v2.problem.TestCaseTemplateId): TestCaseImplementationReference.TemplateId => ({
            value: value,
            type: \\"templateId\\",
            _visit: visitor => visitor.templateId(value)
        }),

        Implementation: (value: MyApi.v2.problem.TestCaseImplementation): TestCaseImplementationReference.Implementation => ({
            ...value,
            type: \\"implementation\\",
            _visit: visitor => visitor.implementation(value)
        }),

    } as const;
",
                    "name": "TestCaseImplementationReference.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface TestCaseMetadata {
    id: MyApi.v2.problem.TestCaseId;
    name: string;
    hidden: boolean;
}
",
                    "name": "TestCaseMetadata.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface TestCaseTemplate {
    templateId: MyApi.v2.problem.TestCaseTemplateId;
    name: string;
    implementation: MyApi.v2.problem.TestCaseImplementation;
}
",
                    "name": "TestCaseTemplate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type TestCaseTemplateId = string;
",
                    "name": "TestCaseTemplateId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface TestCaseV2 {
    metadata: MyApi.v2.problem.TestCaseMetadata;
    implementation: MyApi.v2.problem.TestCaseImplementationReference;
    arguments: Record<string, MyApi.commons.VariableValue>;
    expects?: MyApi.v2.problem.TestCaseExpects;
}
",
                    "name": "TestCaseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface TestCaseWithActualResultImplementation {
    getActualResult: MyApi.v2.problem.NonVoidFunctionDefinition;
    assertCorrectnessCheck: MyApi.v2.problem.AssertCorrectnessCheck;
}
",
                    "name": "TestCaseWithActualResultImplementation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface VoidFunctionDefinition {
    parameters: MyApi.v2.problem.Parameter[];
    code: MyApi.v2.problem.FunctionImplementationForMultipleLanguages;
}
",
                    "name": "VoidFunctionDefinition.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

/**
 * The generated signature will include an additional param, actualResult
 */
export interface VoidFunctionDefinitionThatTakesActualResult {
    additionalParameters: MyApi.v2.problem.Parameter[];
    code: MyApi.v2.problem.FunctionImplementationForMultipleLanguages;
}
",
                    "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface VoidFunctionSignature {
    parameters: MyApi.v2.problem.Parameter[];
}
",
                    "name": "VoidFunctionSignature.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface VoidFunctionSignatureThatTakesActualResult {
    parameters: MyApi.v2.problem.Parameter[];
    actualResultType: MyApi.commons.VariableType;
}
",
                    "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "problem",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { BearerToken, BasicAuth } from \\"@fern-typescript/service-utils\\";
import { Client as ProblemInfoServicV2Client } from \\"./problem/client/Client\\";
import urlJoin from \\"url-join\\";

export namespace Wrapper {
    export interface Options {
        _origin: string;
        _token?: BearerToken;
        _credentials?: BasicAuth;
        xApiKey?: string;
    }
}

export class Wrapper {
    constructor(private readonly options: Wrapper.Options) {
    }

    #problem: ProblemInfoServicV2Client | undefined;

    public get problem(): ProblemInfoServicV2Client {
        return (this.#problem ??= new ProblemInfoServicV2Client({
            _basePath: urlJoin(this.options._origin, \\"/problems-v2\\"),
            _token: this.options._token,
            _credentials: this.options._credentials,
            xApiKey: this.options.xApiKey
        }));
    }
}
",
                "name": "Wrapper.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BearerToken, BasicAuth, _NetworkError, _UnknownError, ErrorDetails, _Response, defaultFetcherV2 } from \\"@fern-typescript/service-utils\\";
import { MyApi } from \\"../../../../..\\";
import urlJoin from \\"url-join\\";

export interface Client {
    getLightweightProblems(): Promise<_Response<MyApi.v2.v3.problem.LightweightProblemInfoV2[], MyApi.v2.v3.problem.getLightweightProblems.Error>>;
    getProblems(): Promise<_Response<MyApi.v2.v3.problem.ProblemInfoV2[], MyApi.v2.v3.problem.getProblems.Error>>;
    getLatestProblem(request: MyApi.v2.v3.problem.getLatestProblem.Request): Promise<_Response<MyApi.v2.v3.problem.ProblemInfoV2, MyApi.v2.v3.problem.getLatestProblem.Error>>;
    getProblemVersion(request: MyApi.v2.v3.problem.getProblemVersion.Request): Promise<_Response<MyApi.v2.v3.problem.ProblemInfoV2, MyApi.v2.v3.problem.getProblemVersion.Error>>;
}

export declare namespace Client {
    interface Options {
        _basePath: string;
        _token?: BearerToken;
        _credentials?: BasicAuth;
        xApiKey?: string;
    }
}

export class Client implements Client {
    constructor(private readonly options: Client.Options) {
    }

    public async getLightweightProblems(): Promise<_Response<MyApi.v2.v3.problem.LightweightProblemInfoV2[], MyApi.v2.v3.problem.getLightweightProblems.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \\"/lightweight-problem-info\\"),
                method: \\"GET\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.v2.v3.problem.LightweightProblemInfoV2[]
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async getProblems(): Promise<_Response<MyApi.v2.v3.problem.ProblemInfoV2[], MyApi.v2.v3.problem.getProblems.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \\"/problem-info\\"),
                method: \\"GET\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.v2.v3.problem.ProblemInfoV2[]
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async getLatestProblem(request: MyApi.v2.v3.problem.getLatestProblem.Request): Promise<_Response<MyApi.v2.v3.problem.ProblemInfoV2, MyApi.v2.v3.problem.getLatestProblem.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/problem-info/\${request.problemId}\`),
                method: \\"GET\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.v2.v3.problem.ProblemInfoV2
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }

    public async getProblemVersion(request: MyApi.v2.v3.problem.getProblemVersion.Request): Promise<_Response<MyApi.v2.v3.problem.ProblemInfoV2, MyApi.v2.v3.problem.getProblemVersion.Error>> {
        const response = await defaultFetcherV2({
                url: urlJoin(this.options._basePath, \`/problem-info/\${request.problemId}/version/\${request.problemVersion}\`),
                method: \\"GET\\",
                headers: {
                    \\"Authorization\\": this.options._token != null ? BearerToken.toAuthorizationHeader(this.options._token) : this.options._credentials != null ? BasicAuth.toAuthorizationHeader(this.options._credentials) : undefined,
                    \\"X-API-Key\\": this.options.xApiKey
                }
            });

        if (response.ok) {
            return {
                ok: true,
                body: response.body as MyApi.v2.v3.problem.ProblemInfoV2
            };
        }

        if (response.type === \\"networkError\\") {
            return {
                ok: false,
                error: {
                    body: { _error: \\"_NetworkError\\" },
                    _visit: visitor => visitor._network()
                }
            };
        }

        return {
            ok: false,
            error: {
                body: response.body as _UnknownError,
                _visit: visitor => visitor._unknown({ statusCode: response.statusCode })
            }
        };
    }
}

export namespace getLightweightProblems {
    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.v2.v3.problem.getLightweightProblems.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace getProblems {
    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.v2.v3.problem.getProblems.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace getLatestProblem {
    export interface Request {
        problemId: MyApi.commons.ProblemId;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.v2.v3.problem.getLatestProblem.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}

export namespace getProblemVersion {
    export interface Request {
        problemId: MyApi.commons.ProblemId;
        problemVersion: number;
    }

    export interface Error {
        body: 
            | _NetworkError
            | _UnknownError;
        _visit: <Result>(visitor: MyApi.v2.v3.problem.getProblemVersion.ErrorVisitor<Result>) => Result;
    }

    export interface ErrorVisitor<Result> {
        _network: () => Result;
        _unknown: (details: ErrorDetails) => Result;
    }
}
",
                        "name": "Client.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getLightweightProblems, getProblems, getLatestProblem, getProblemVersion } from \\"./Client\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export type AssertCorrectnessCheck = 
    | AssertCorrectnessCheck.DeepEquality
    | AssertCorrectnessCheck.Custom
    | AssertCorrectnessCheck._Unknown;

export declare namespace AssertCorrectnessCheck {
    interface DeepEquality extends MyApi.v2.v3.problem.DeepEqualityCorrectnessCheck, _Utils {
        type: \\"deepEquality\\";
    }

    interface Custom extends MyApi.v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult, _Utils {
        type: \\"custom\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: AssertCorrectnessCheck._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        deepEquality: (value: MyApi.v2.v3.problem.DeepEqualityCorrectnessCheck) => Result;
        custom: (value: MyApi.v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult) => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const AssertCorrectnessCheck = {
        DeepEquality: (value: MyApi.v2.v3.problem.DeepEqualityCorrectnessCheck): AssertCorrectnessCheck.DeepEquality => ({
            ...value,
            type: \\"deepEquality\\",
            _visit: visitor => visitor.deepEquality(value)
        }),

        Custom: (value: MyApi.v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult): AssertCorrectnessCheck.Custom => ({
            ...value,
            type: \\"custom\\",
            _visit: visitor => visitor.custom(value)
        }),

    } as const;
",
                        "name": "AssertCorrectnessCheck.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface BasicCustomFiles {
    methodName: string;
    signature: MyApi.v2.v3.problem.NonVoidFunctionSignature;
    additionalFiles: Record<MyApi.commons.Language.RawValue, MyApi.v2.v3.problem.Files>;
    basicTestCaseTemplate: MyApi.v2.v3.problem.BasicTestCaseTemplate;
}
",
                        "name": "BasicCustomFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface BasicTestCaseTemplate {
    templateId: MyApi.v2.v3.problem.TestCaseTemplateId;
    name: string;
    description: MyApi.v2.v3.problem.TestCaseImplementationDescription;
    expectedValueParameterId: MyApi.v2.v3.problem.ParameterId;
}
",
                        "name": "BasicTestCaseTemplate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface CreateProblemRequestV2 {
    problemName: string;
    problemDescription: MyApi.problem.ProblemDescription;
    customFiles: MyApi.v2.v3.problem.CustomFiles;
    customTestCaseTemplates: MyApi.v2.v3.problem.TestCaseTemplate[];
    testcases: MyApi.v2.v3.problem.TestCaseV2[];
    supportedLanguages: MyApi.commons.Language[];
    isPublic: boolean;
}
",
                        "name": "CreateProblemRequestV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export type CustomFiles = 
    | CustomFiles.Basic
    | CustomFiles.Custom
    | CustomFiles._Unknown;

export declare namespace CustomFiles {
    interface Basic extends MyApi.v2.v3.problem.BasicCustomFiles, _Utils {
        type: \\"basic\\";
    }

    interface Custom extends _Utils {
        type: \\"custom\\";
        value: Record<MyApi.commons.Language.RawValue, MyApi.v2.v3.problem.Files>;
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: CustomFiles._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        basic: (value: MyApi.v2.v3.problem.BasicCustomFiles) => Result;
        custom: (value: Record<MyApi.commons.Language.RawValue, MyApi.v2.v3.problem.Files>) => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const CustomFiles = {
        Basic: (value: MyApi.v2.v3.problem.BasicCustomFiles): CustomFiles.Basic => ({
            ...value,
            type: \\"basic\\",
            _visit: visitor => visitor.basic(value)
        }),

        Custom: (value: Record<MyApi.commons.Language.RawValue, MyApi.v2.v3.problem.Files>): CustomFiles.Custom => ({
            value: value,
            type: \\"custom\\",
            _visit: visitor => visitor.custom(value)
        }),

    } as const;
",
                        "name": "CustomFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface DeepEqualityCorrectnessCheck {
    expectedValueParameterId: MyApi.v2.v3.problem.ParameterId;
}
",
                        "name": "DeepEqualityCorrectnessCheck.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface DefaultProvidedFile {
    file: MyApi.v2.v3.problem.FileInfoV2;
    relatedTypes: MyApi.commons.VariableType[];
}
",
                        "name": "DefaultProvidedFile.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface FileInfoV2 {
    filename: string;
    directory: string;
    contents: string;
    editable: boolean;
}
",
                        "name": "FileInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface Files {
    files: MyApi.v2.v3.problem.FileInfoV2[];
}
",
                        "name": "Files.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface FunctionImplementation {
    impl: string;
    imports?: string;
}
",
                        "name": "FunctionImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface FunctionImplementationForMultipleLanguages {
    codeByLanguage: Record<MyApi.commons.Language.RawValue, MyApi.v2.v3.problem.FunctionImplementation>;
}
",
                        "name": "FunctionImplementationForMultipleLanguages.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export type FunctionSignature = 
    | FunctionSignature.Void
    | FunctionSignature.NonVoid
    /**
     * Useful when specifying custom grading for a testcase where actualResult is defined. */
    | FunctionSignature.VoidThatTakesActualResult
    | FunctionSignature._Unknown;

export declare namespace FunctionSignature {
    interface Void extends MyApi.v2.v3.problem.VoidFunctionSignature, _Utils {
        type: \\"void\\";
    }

    interface NonVoid extends MyApi.v2.v3.problem.NonVoidFunctionSignature, _Utils {
        type: \\"nonVoid\\";
    }

    interface VoidThatTakesActualResult extends MyApi.v2.v3.problem.VoidFunctionSignatureThatTakesActualResult, _Utils {
        type: \\"voidThatTakesActualResult\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: FunctionSignature._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        void: (value: MyApi.v2.v3.problem.VoidFunctionSignature) => Result;
        nonVoid: (value: MyApi.v2.v3.problem.NonVoidFunctionSignature) => Result;
        voidThatTakesActualResult: (value: MyApi.v2.v3.problem.VoidFunctionSignatureThatTakesActualResult) => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const FunctionSignature = {
        Void: (value: MyApi.v2.v3.problem.VoidFunctionSignature): FunctionSignature.Void => ({
            ...value,
            type: \\"void\\",
            _visit: visitor => visitor.void(value)
        }),

        NonVoid: (value: MyApi.v2.v3.problem.NonVoidFunctionSignature): FunctionSignature.NonVoid => ({
            ...value,
            type: \\"nonVoid\\",
            _visit: visitor => visitor.nonVoid(value)
        }),

        VoidThatTakesActualResult: (value: MyApi.v2.v3.problem.VoidFunctionSignatureThatTakesActualResult): FunctionSignature.VoidThatTakesActualResult => ({
            ...value,
            type: \\"voidThatTakesActualResult\\",
            _visit: visitor => visitor.voidThatTakesActualResult(value)
        }),

    } as const;
",
                        "name": "FunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface GeneratedFiles {
    generatedTestCaseFiles: Record<MyApi.commons.Language.RawValue, MyApi.v2.v3.problem.Files>;
    generatedTemplateFiles: Record<MyApi.commons.Language.RawValue, MyApi.v2.v3.problem.Files>;
    other: Record<MyApi.commons.Language.RawValue, MyApi.v2.v3.problem.Files>;
}
",
                        "name": "GeneratedFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface GetBasicSolutionFileRequest {
    methodName: string;
    signature: MyApi.v2.v3.problem.NonVoidFunctionSignature;
}
",
                        "name": "GetBasicSolutionFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface GetBasicSolutionFileResponse {
    solutionFileByLanguage: Record<MyApi.commons.Language.RawValue, MyApi.v2.v3.problem.FileInfoV2>;
}
",
                        "name": "GetBasicSolutionFileResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface GetFunctionSignatureRequest {
    functionSignature: MyApi.v2.v3.problem.FunctionSignature;
}
",
                        "name": "GetFunctionSignatureRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface GetFunctionSignatureResponse {
    functionByLanguage: Record<MyApi.commons.Language.RawValue, string>;
}
",
                        "name": "GetFunctionSignatureResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface GetGeneratedTestCaseFileRequest {
    template?: MyApi.v2.v3.problem.TestCaseTemplate;
    testCase: MyApi.v2.v3.problem.TestCaseV2;
}
",
                        "name": "GetGeneratedTestCaseFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface GetGeneratedTestCaseTemplateFileRequest {
    template: MyApi.v2.v3.problem.TestCaseTemplate;
}
",
                        "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface LightweightProblemInfoV2 {
    problemId: MyApi.commons.ProblemId;
    problemName: string;
    problemVersion: number;
    variableTypes: MyApi.commons.VariableType[];
}
",
                        "name": "LightweightProblemInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface NonVoidFunctionDefinition {
    signature: MyApi.v2.v3.problem.NonVoidFunctionSignature;
    code: MyApi.v2.v3.problem.FunctionImplementationForMultipleLanguages;
}
",
                        "name": "NonVoidFunctionDefinition.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface NonVoidFunctionSignature {
    parameters: MyApi.v2.v3.problem.Parameter[];
    returnType: MyApi.commons.VariableType;
}
",
                        "name": "NonVoidFunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface Parameter {
    parameterId: MyApi.v2.v3.problem.ParameterId;
    name: string;
    variableType: MyApi.commons.VariableType;
}
",
                        "name": "Parameter.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type ParameterId = string;
",
                        "name": "ParameterId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface ProblemInfoV2 {
    problemId: MyApi.commons.ProblemId;
    problemDescription: MyApi.problem.ProblemDescription;
    problemName: string;
    problemVersion: number;
    supportedLanguages: MyApi.commons.Language[];
    customFiles: MyApi.v2.v3.problem.CustomFiles;
    generatedFiles: MyApi.v2.v3.problem.GeneratedFiles;
    customTestCaseTemplates: MyApi.v2.v3.problem.TestCaseTemplate[];
    testcases: MyApi.v2.v3.problem.TestCaseV2[];
    isPublic: boolean;
}
",
                        "name": "ProblemInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface TestCaseExpects {
    expectedStdout?: string;
}
",
                        "name": "TestCaseExpects.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export type TestCaseFunction = 
    | TestCaseFunction.WithActualResult
    | TestCaseFunction.Custom
    | TestCaseFunction._Unknown;

export declare namespace TestCaseFunction {
    interface WithActualResult extends MyApi.v2.v3.problem.TestCaseWithActualResultImplementation, _Utils {
        type: \\"withActualResult\\";
    }

    interface Custom extends MyApi.v2.v3.problem.VoidFunctionDefinition, _Utils {
        type: \\"custom\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: TestCaseFunction._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        withActualResult: (value: MyApi.v2.v3.problem.TestCaseWithActualResultImplementation) => Result;
        custom: (value: MyApi.v2.v3.problem.VoidFunctionDefinition) => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const TestCaseFunction = {
        WithActualResult: (value: MyApi.v2.v3.problem.TestCaseWithActualResultImplementation): TestCaseFunction.WithActualResult => ({
            ...value,
            type: \\"withActualResult\\",
            _visit: visitor => visitor.withActualResult(value)
        }),

        Custom: (value: MyApi.v2.v3.problem.VoidFunctionDefinition): TestCaseFunction.Custom => ({
            ...value,
            type: \\"custom\\",
            _visit: visitor => visitor.custom(value)
        }),

    } as const;
",
                        "name": "TestCaseFunction.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type TestCaseId = string;
",
                        "name": "TestCaseId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface TestCaseImplementation {
    description: MyApi.v2.v3.problem.TestCaseImplementationDescription;
    function: MyApi.v2.v3.problem.TestCaseFunction;
}
",
                        "name": "TestCaseImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface TestCaseImplementationDescription {
    boards: MyApi.v2.v3.problem.TestCaseImplementationDescriptionBoard[];
}
",
                        "name": "TestCaseImplementationDescription.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export type TestCaseImplementationDescriptionBoard = 
    | TestCaseImplementationDescriptionBoard.Html
    | TestCaseImplementationDescriptionBoard.ParamId
    | TestCaseImplementationDescriptionBoard._Unknown;

export declare namespace TestCaseImplementationDescriptionBoard {
    interface Html extends _Utils {
        type: \\"html\\";
        value: string;
    }

    interface ParamId extends _Utils {
        type: \\"paramId\\";
        value: MyApi.v2.v3.problem.ParameterId;
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: TestCaseImplementationDescriptionBoard._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        html: (value: string) => Result;
        paramId: (value: MyApi.v2.v3.problem.ParameterId) => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const TestCaseImplementationDescriptionBoard = {
        Html: (value: string): TestCaseImplementationDescriptionBoard.Html => ({
            value: value,
            type: \\"html\\",
            _visit: visitor => visitor.html(value)
        }),

        ParamId: (value: MyApi.v2.v3.problem.ParameterId): TestCaseImplementationDescriptionBoard.ParamId => ({
            value: value,
            type: \\"paramId\\",
            _visit: visitor => visitor.paramId(value)
        }),

    } as const;
",
                        "name": "TestCaseImplementationDescriptionBoard.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export type TestCaseImplementationReference = 
    | TestCaseImplementationReference.TemplateId
    | TestCaseImplementationReference.Implementation
    | TestCaseImplementationReference._Unknown;

export declare namespace TestCaseImplementationReference {
    interface TemplateId extends _Utils {
        type: \\"templateId\\";
        value: MyApi.v2.v3.problem.TestCaseTemplateId;
    }

    interface Implementation extends MyApi.v2.v3.problem.TestCaseImplementation, _Utils {
        type: \\"implementation\\";
    }

    interface _Unknown extends _Utils {
        type: void;
    }

    interface _Utils {
        _visit: <Result>(visitor: TestCaseImplementationReference._Visitor<Result>) => Result;
    }

    interface _Visitor<Result> {
        templateId: (value: MyApi.v2.v3.problem.TestCaseTemplateId) => Result;
        implementation: (value: MyApi.v2.v3.problem.TestCaseImplementation) => Result;
        _unknown: (value: {
                type: string;
            }) => Result;
    }
}

export const TestCaseImplementationReference = {
        TemplateId: (value: MyApi.v2.v3.problem.TestCaseTemplateId): TestCaseImplementationReference.TemplateId => ({
            value: value,
            type: \\"templateId\\",
            _visit: visitor => visitor.templateId(value)
        }),

        Implementation: (value: MyApi.v2.v3.problem.TestCaseImplementation): TestCaseImplementationReference.Implementation => ({
            ...value,
            type: \\"implementation\\",
            _visit: visitor => visitor.implementation(value)
        }),

    } as const;
",
                        "name": "TestCaseImplementationReference.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface TestCaseMetadata {
    id: MyApi.v2.v3.problem.TestCaseId;
    name: string;
    hidden: boolean;
}
",
                        "name": "TestCaseMetadata.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface TestCaseTemplate {
    templateId: MyApi.v2.v3.problem.TestCaseTemplateId;
    name: string;
    implementation: MyApi.v2.v3.problem.TestCaseImplementation;
}
",
                        "name": "TestCaseTemplate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type TestCaseTemplateId = string;
",
                        "name": "TestCaseTemplateId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface TestCaseV2 {
    metadata: MyApi.v2.v3.problem.TestCaseMetadata;
    implementation: MyApi.v2.v3.problem.TestCaseImplementationReference;
    arguments: Record<string, MyApi.commons.VariableValue>;
    expects?: MyApi.v2.v3.problem.TestCaseExpects;
}
",
                        "name": "TestCaseV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface TestCaseWithActualResultImplementation {
    getActualResult: MyApi.v2.v3.problem.NonVoidFunctionDefinition;
    assertCorrectnessCheck: MyApi.v2.v3.problem.AssertCorrectnessCheck;
}
",
                        "name": "TestCaseWithActualResultImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface VoidFunctionDefinition {
    parameters: MyApi.v2.v3.problem.Parameter[];
    code: MyApi.v2.v3.problem.FunctionImplementationForMultipleLanguages;
}
",
                        "name": "VoidFunctionDefinition.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

/**
 * The generated signature will include an additional param, actualResult
 */
export interface VoidFunctionDefinitionThatTakesActualResult {
    additionalParameters: MyApi.v2.v3.problem.Parameter[];
    code: MyApi.v2.v3.problem.FunctionImplementationForMultipleLanguages;
}
",
                        "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface VoidFunctionSignature {
    parameters: MyApi.v2.v3.problem.Parameter[];
}
",
                        "name": "VoidFunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface VoidFunctionSignatureThatTakesActualResult {
    parameters: MyApi.v2.v3.problem.Parameter[];
    actualResultType: MyApi.commons.VariableType;
}
",
                        "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "problem",
                "type": "directory",
              },
            ],
            "name": "v3",
            "type": "directory",
          },
        ],
        "name": "v2",
        "type": "directory",
      },
    ],
    "name": "api",
    "type": "directory",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "export * as schemas from \\"./schemas\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "import { SchemaUtils } from \\"./builders\\";

export type Schema<Raw = unknown, Parsed = unknown> = BaseSchema<Raw, Parsed> & SchemaUtils<Raw, Parsed>;

export type inferRaw<S extends Schema> = S extends Schema<infer Raw, any> ? Raw : never;
export type inferParsed<S extends Schema> = S extends Schema<any, infer Parsed> ? Parsed : never;

export interface BaseSchema<Raw, Parsed> {
    parse: (raw: Raw, opts?: SchemaOptions) => Parsed;
    json: (parsed: Parsed, opts?: SchemaOptions) => Raw;
}

export interface SchemaOptions {
    /**
     * @default false
     */
    skipUnknownKeysOnParse?: boolean;

    /**
     * @default false
     */
    includeUnknownKeysOnJson?: boolean;
}
",
            "name": "Schema.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function enum_<U extends string, E extends Readonly<[U, ...U[]]>>(_values: E): Schema<E[number], E[number]> {
    return createIdentitySchemaCreator<E[number]>()();
}
",
                    "name": "enum.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { enum_ } from \\"./enum\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "enum",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
import { identity } from \\"./identity\\";

export function createIdentitySchemaCreator<T>(): () => Schema<T, T> {
    return <T>() => identity<T>();
}
",
                    "name": "createIdentitySchemaCreator.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function identity<T>(): Schema<T, T> {
    const baseSchema: BaseSchema<T, T> = {
        parse: (raw) => raw,
        json: (parsed) => parsed,
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}
",
                    "name": "identity.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { createIdentitySchemaCreator } from \\"./createIdentitySchemaCreator\\";
export { identity } from \\"./identity\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "identity",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./enum\\";
export * from \\"./identity\\";
export * from \\"./lazy\\";
export * from \\"./list\\";
export * from \\"./literals\\";
export * from \\"./object\\";
export * from \\"./object-like\\";
export * from \\"./primitives\\";
export * from \\"./record\\";
export * from \\"./schema-utils\\";
export * from \\"./set\\";
export * from \\"./union\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { lazy } from \\"./lazy\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function lazy<Raw, Parsed>(getter: () => Schema<Raw, Parsed>): Schema<Raw, Parsed> {
    const baseSchema: BaseSchema<Raw, Parsed> = {
        parse: (raw) => getter().parse(raw),
        json: (parsed) => getter().json(parsed),
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}
",
                    "name": "lazy.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { getObjectUtils, PropertySchemas } from \\"../object\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import {
    BaseObjectSchema,
    inferObjectSchemaFromPropertySchemas,
    inferParsedObjectFromPropertySchemas,
    inferRawObjectFromPropertySchemas,
} from \\"../object/types\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function lazyObject<T extends PropertySchemas<keyof T>>(
    getter: () => inferObjectSchemaFromPropertySchemas<T>
): inferObjectSchemaFromPropertySchemas<T> {
    const baseSchema: BaseObjectSchema<
        inferRawObjectFromPropertySchemas<T>,
        inferParsedObjectFromPropertySchemas<T>
    > = {
        ...OBJECT_LIKE_BRAND,
        parse: (raw, opts) => getter().parse(raw, opts),
        json: (parsed, opts) => getter().json(parsed, opts),
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
    };
}
",
                    "name": "lazyObject.ts",
                    "type": "file",
                  },
                ],
                "name": "lazy",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { list } from \\"./list\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function list<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Parsed[]> {
    const baseSchema: BaseSchema<Raw[], Parsed[]> = {
        parse: (raw, opts) => raw.map((item) => schema.parse(item, opts)),
        json: (parsed, opts) => parsed.map((item) => schema.json(item, opts)),
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}
",
                    "name": "list.ts",
                    "type": "file",
                  },
                ],
                "name": "list",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { stringLiteral } from \\"./stringLiteral\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function stringLiteral<V extends string>(_value: V): Schema<V, V> {
    return createIdentitySchemaCreator<V>()();
}
",
                    "name": "stringLiteral.ts",
                    "type": "file",
                  },
                ],
                "name": "literals",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { getObjectUtils, object } from \\"./object\\";
export { isProperty, property, type Property } from \\"./property\\";
export {
    type BaseObjectSchema,
    type inferObjectSchemaFromPropertySchemas,
    type inferParsedObject,
    type inferParsedObjectFromPropertySchemas,
    type inferParsedPropertySchema,
    type inferRawKey,
    type inferRawObject,
    type inferRawObjectFromPropertySchemas,
    type inferRawPropertySchema,
    type ObjectSchema,
    type ObjectUtils,
    type PropertySchemas,
} from \\"./types\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { isProperty } from \\"./property\\";
import {
    BaseObjectSchema,
    inferObjectSchemaFromPropertySchemas,
    inferParsedObjectFromPropertySchemas,
    inferRawObjectFromPropertySchemas,
    ObjectUtils,
    PropertySchemas,
} from \\"./types\\";

interface ObjectPropertyWithRawKey {
    rawKey: string;
    parsedKey: string | number | symbol;
    valueSchema: Schema<any, any>;
}

export function object<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(
    schemas: T
): inferObjectSchemaFromPropertySchemas<T> {
    const baseSchema: BaseObjectSchema<
        inferRawObjectFromPropertySchemas<T>,
        inferParsedObjectFromPropertySchemas<T>
    > = {
        ...OBJECT_LIKE_BRAND,

        parse: (raw, { skipUnknownKeysOnParse = false } = {}) => {
            const rawKeyToProperty: Record<string, ObjectPropertyWithRawKey> = {};

            for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
                const rawKey = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;

                const property: ObjectPropertyWithRawKey = {
                    rawKey,
                    parsedKey,
                    valueSchema: isProperty(schemaOrObjectProperty)
                        ? schemaOrObjectProperty.valueSchema
                        : schemaOrObjectProperty,
                };

                rawKeyToProperty[rawKey] = property;
            }

            const parsed: Record<string | number | symbol, any> = {};

            for (const [rawKey, rawPropertyValue] of Object.entries(raw)) {
                const property = rawKeyToProperty[rawKey];

                if (property != null) {
                    const value = property.valueSchema.parse(rawPropertyValue);
                    if (value != null) {
                        parsed[property.parsedKey] = value;
                    }
                } else if (!skipUnknownKeysOnParse && rawPropertyValue != null) {
                    parsed[rawKey] = rawPropertyValue;
                }
            }

            return parsed as inferParsedObjectFromPropertySchemas<T>;
        },

        json: (parsed, { includeUnknownKeysOnJson = false } = {}) => {
            const raw: Record<string | number | symbol, any> = {};

            for (const [parsedKey, parsedPropertyValue] of entries(parsed)) {
                const schemaOrObjectProperty = schemas[parsedKey as keyof T];
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                if (schemaOrObjectProperty != null) {
                    if (isProperty(schemaOrObjectProperty)) {
                        const value = schemaOrObjectProperty.valueSchema.json(parsedPropertyValue);
                        if (value != null) {
                            raw[schemaOrObjectProperty.rawKey] = value;
                        }
                    } else {
                        const value = schemaOrObjectProperty.json(parsedPropertyValue);
                        if (value != null) {
                            raw[parsedKey] = value;
                        }
                    }
                } else if (includeUnknownKeysOnJson && parsedPropertyValue != null) {
                    raw[parsedKey] = parsedPropertyValue;
                }
            }

            return raw as inferRawObjectFromPropertySchemas<T>;
        },
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
    };
}

export function getObjectUtils<Raw, Parsed>(schema: BaseObjectSchema<Raw, Parsed>): ObjectUtils<Raw, Parsed> {
    return {
        extend: <U extends PropertySchemas<keyof U>>(extension: U) => {
            const baseSchema: BaseObjectSchema<
                Raw & inferRawObjectFromPropertySchemas<U>,
                Parsed & inferParsedObjectFromPropertySchemas<U>
            > = {
                ...OBJECT_LIKE_BRAND,
                parse: (raw, opts) => ({
                    ...schema.parse(raw, opts),
                    ...object(extension).parse(raw, opts),
                }),
                json: (parsed, opts) => ({
                    ...schema.json(parsed, opts),
                    ...object(extension).json(parsed, opts),
                }),
            };

            return {
                ...baseSchema,
                ...getSchemaUtils(baseSchema),
                ...getObjectLikeUtils(baseSchema),
                ...getObjectUtils(baseSchema),
            };
        },
    };
}
",
                    "name": "object.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";

export function property<RawKey extends string, RawValue, ParsedValue>(
    rawKey: RawKey,
    valueSchema: Schema<RawValue, ParsedValue>
): Property<RawKey, RawValue, ParsedValue> {
    return {
        rawKey,
        valueSchema,
        isProperty: true,
    };
}

export interface Property<RawKey extends string, RawValue, ParsedValue> {
    rawKey: RawKey;
    valueSchema: Schema<RawValue, ParsedValue>;
    isProperty: true;
}

export function isProperty<O extends Property<any, any, any>>(maybeProperty: unknown): maybeProperty is O {
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    return (maybeProperty as O).isProperty;
}
",
                    "name": "property.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { inferParsed, inferRaw, Schema } from \\"../../Schema\\";
import { addQuestionMarksToNullableProperties } from \\"../../utils/addQuestionMarksToNullableProperties\\";
import { BaseObjectLikeSchema, ObjectLikeSchema } from \\"../object-like\\";
import { Property } from \\"./property\\";

export type ObjectSchema<Raw, Parsed> = BaseObjectSchema<Raw, Parsed> &
    ObjectLikeSchema<Raw, Parsed> &
    ObjectUtils<Raw, Parsed>;

export type BaseObjectSchema<Raw, Parsed> = BaseObjectLikeSchema<Raw, Parsed>;

export interface ObjectUtils<Raw, Parsed> {
    extend: <U extends PropertySchemas<keyof U>>(
        schemas: U
    ) => ObjectSchema<Raw & inferRawObjectFromPropertySchemas<U>, Parsed & inferParsedObjectFromPropertySchemas<U>>;
}

export type inferRawObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<infer Raw, any> ? Raw : never;

export type inferParsedObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<any, infer Parsed>
    ? Parsed
    : never;

export type inferObjectSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> = ObjectSchema<
    inferRawObjectFromPropertySchemas<T>,
    inferParsedObjectFromPropertySchemas<T>
>;

export type inferRawObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
    addQuestionMarksToNullableProperties<{
        [ParsedKey in keyof T as inferRawKey<ParsedKey, T[ParsedKey]>]: inferRawPropertySchema<T[ParsedKey]>;
    }>;

export type inferParsedObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
    addQuestionMarksToNullableProperties<{
        [K in keyof T]: inferParsedPropertySchema<T[K]>;
    }>;

export type PropertySchemas<ParsedKeys extends string | number | symbol> = Record<
    ParsedKeys,
    Property<any, any, any> | Schema<any, any>
>;

export type inferRawPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
    any,
    infer Raw,
    any
>
    ? Raw
    : P extends Schema<any, any>
    ? inferRaw<P>
    : never;

export type inferParsedPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
    any,
    any,
    infer Parsed
>
    ? Parsed
    : P extends Schema<any, any>
    ? inferParsed<P>
    : never;

export type inferRawKey<
    ParsedKey extends string | number | symbol,
    P extends Property<any, any, any> | Schema<any, any>
> = P extends Property<infer Raw, any, any> ? Raw : ParsedKey;
",
                    "name": "types.ts",
                    "type": "file",
                  },
                ],
                "name": "object",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { BaseObjectLikeSchema, ObjectLikeUtils } from \\"./types\\";
import { withProperties } from \\"./withProperties\\";

export function getObjectLikeUtils<Raw, Parsed>(
    schema: BaseObjectLikeSchema<Raw, Parsed>
): ObjectLikeUtils<Raw, Parsed> {
    return {
        withProperties: (properties) => withProperties(schema, properties),
    };
}
",
                    "name": "getObjectLikeUtils.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { getObjectLikeUtils } from \\"./getObjectLikeUtils\\";
export { OBJECT_LIKE_BRAND, type BaseObjectLikeSchema, type ObjectLikeSchema, type ObjectLikeUtils } from \\"./types\\";
export { withProperties } from \\"./withProperties\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";

export type ObjectLikeSchema<Raw, Parsed> = Schema<Raw, Parsed> &
    BaseObjectLikeSchema<Raw, Parsed> &
    ObjectLikeUtils<Raw, Parsed>;

export type BaseObjectLikeSchema<Raw, Parsed> = BaseSchema<Raw, Parsed> & {
    _objectLike: void;
};

export interface ObjectLikeUtils<Raw, Parsed> {
    withProperties: <T extends Record<string, any>>(properties: {
        [K in keyof T]: T[K] | ((parsed: Parsed) => T[K]);
    }) => ObjectLikeSchema<Raw, Parsed & T>;
}

export const OBJECT_LIKE_BRAND = undefined as unknown as { _objectLike: void };
",
                    "name": "types.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { getSchemaUtils } from \\"../schema-utils\\";
import { getObjectLikeUtils } from \\"./getObjectLikeUtils\\";
import { BaseObjectLikeSchema, ObjectLikeSchema, OBJECT_LIKE_BRAND } from \\"./types\\";

export function withProperties<RawObjectShape, ParsedObjectShape, Properties>(
    objectLike: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape>,
    properties: { [K in keyof Properties]: Properties[K] | ((parsed: ParsedObjectShape) => Properties[K]) }
): ObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> {
    const objectSchema: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> = {
        ...OBJECT_LIKE_BRAND,
        parse: (raw, opts) => {
            const parsedObject = objectLike.parse(raw, opts);
            const additionalProperties = Object.entries(properties).reduce<Record<string, any>>(
                (processed, [key, value]) => {
                    return {
                        ...processed,
                        [key]: typeof value === \\"function\\" ? value(parsedObject) : value,
                    };
                },
                {}
            );

            return {
                ...parsedObject,
                ...(additionalProperties as Properties),
            };
        },
        json: (parsed, opts) => {
            // strip out added properties
            const addedPropertyKeys = new Set(Object.keys(properties));
            const parsedWithoutAddedProperties = Object.entries(parsed).reduce<Record<string, any>>(
                (filtered, [key, value]) => {
                    if (!addedPropertyKeys.has(key)) {
                        filtered[key] = value;
                    }
                    return filtered;
                },
                {}
            );

            return objectLike.json(parsedWithoutAddedProperties as ParsedObjectShape, opts);
        },
    };

    return {
        ...objectSchema,
        ...getSchemaUtils(objectSchema),
        ...getObjectLikeUtils(objectSchema),
    };
}
",
                    "name": "withProperties.ts",
                    "type": "file",
                  },
                ],
                "name": "object-like",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const any = createIdentitySchemaCreator<any>();
",
                    "name": "any.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const boolean = createIdentitySchemaCreator<boolean>();
",
                    "name": "boolean.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { any } from \\"./any\\";
export { boolean } from \\"./boolean\\";
export { number } from \\"./number\\";
export { string } from \\"./string\\";
export { unknown } from \\"./unknown\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const number = createIdentitySchemaCreator<number>();
",
                    "name": "number.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const string = createIdentitySchemaCreator<string>();
",
                    "name": "string.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const unknown = createIdentitySchemaCreator<unknown>();
",
                    "name": "unknown.ts",
                    "type": "file",
                  },
                ],
                "name": "primitives",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { record } from \\"./record\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function record<RawKey extends string | number, ParsedKey extends string | number, RawValue, ParsedValue>(
    keySchema: Schema<RawKey, ParsedKey>,
    valueSchema: Schema<RawValue, ParsedValue>
): Schema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> {
    const baseSchema: BaseSchema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> = {
        parse: (raw, opts) => {
            return entries(raw).reduce(
                (parsed, [key, value]) => {
                    parsed[keySchema.parse(key, opts)] = valueSchema.parse(value, opts);
                    return parsed;
                },
                // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
                {} as Record<ParsedKey, ParsedValue>
            );
        },
        json: (parsed, opts) => {
            return entries(parsed).reduce(
                (raw, [key, value]) => {
                    raw[keySchema.json(key, opts)] = valueSchema.json(value, opts);
                    return raw;
                },
                // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
                {} as Record<RawKey, RawValue>
            );
        },
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}
",
                    "name": "record.ts",
                    "type": "file",
                  },
                ],
                "name": "record",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { OptionalSchema, OPTIONAL_BRAND } from \\"./types\\";

export interface SchemaUtils<Raw, Parsed> {
    optional: () => OptionalSchema<Raw, Parsed>;
    transform: <PostTransform>(transformer: BaseSchema<Parsed, PostTransform>) => Schema<Raw, PostTransform>;
}

export function getSchemaUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): SchemaUtils<Raw, Parsed> {
    return {
        optional: () => optional(schema),
        transform: (transformer) => transform(schema, transformer),
    };
}

/**
 * schema utils are defined in one file to resolve issues with circular imports
 */

export function optional<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): OptionalSchema<Raw, Parsed> {
    const baseSchema: BaseSchema<Raw | null | undefined, Parsed | undefined> = {
        parse: (raw, opts) => (raw != null ? schema.parse(raw, opts) : undefined),
        json: (parsed, opts) => (parsed != null ? schema.json(parsed, opts) : undefined),
    };

    return {
        ...OPTIONAL_BRAND,
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}

export function transform<PreTransformRaw, PreTransformParsed, PostTransform>(
    schema: BaseSchema<PreTransformRaw, PreTransformParsed>,
    transformer: BaseSchema<PreTransformParsed, PostTransform>
): Schema<PreTransformRaw, PostTransform> {
    const baseSchema: BaseSchema<PreTransformRaw, PostTransform> = {
        parse: (raw, opts) => {
            const postTransformParsed = schema.parse(raw, opts);
            return transformer.parse(postTransformParsed, opts);
        },
        json: (parsed, opts) => {
            const preTransformParsed = transformer.json(parsed, opts);
            return schema.json(preTransformParsed, opts);
        },
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}
",
                    "name": "getSchemaUtils.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { getSchemaUtils, optional, transform, type SchemaUtils } from \\"./getSchemaUtils\\";
export { OPTIONAL_BRAND, type OptionalSchema } from \\"./types\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";

export const OPTIONAL_BRAND = undefined as unknown as { _isOptional: void };

export type OptionalSchema<Raw, Parsed> = Schema<Raw | null | undefined, Parsed | undefined> & {
    _isOptional: void;
};
",
                    "name": "types.ts",
                    "type": "file",
                  },
                ],
                "name": "schema-utils",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { set } from \\"./set\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function set<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Set<Parsed>> {
    const baseSchema: BaseSchema<Raw[], Set<Parsed>> = {
        parse: (raw, opts) => new Set(raw.map((item) => schema.parse(item, opts))),
        json: (parsed, opts) => [...parsed].map((item) => schema.json(item, opts)),
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
    };
}
",
                    "name": "set.ts",
                    "type": "file",
                  },
                ],
                "name": "set",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export function discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string>(
    parsedDiscriminant: ParsedDiscriminant,
    rawDiscriminant: RawDiscriminant
): Discriminant<RawDiscriminant, ParsedDiscriminant> {
    return {
        parsedDiscriminant,
        rawDiscriminant,
    };
}

export interface Discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string> {
    parsedDiscriminant: ParsedDiscriminant;
    rawDiscriminant: RawDiscriminant;
}
",
                    "name": "discriminant.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { discriminant, type Discriminant } from \\"./discriminant\\";
export {
    type inferParsedDiscriminant,
    type inferParsedUnion,
    type inferRawDiscriminant,
    type inferRawUnion,
    type UnionSubtypes,
} from \\"./types\\";
export { union } from \\"./union\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { inferParsedObject, inferRawObject, ObjectSchema } from \\"../object\\";
import { Discriminant } from \\"./discriminant\\";

export type UnionSubtypes<DiscriminantValues extends string | number | symbol> = {
    [K in DiscriminantValues]: ObjectSchema<any, any>;
};

export type inferRawUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
    [K in keyof U]: Record<inferRawDiscriminant<D>, K> & inferRawObject<U[K]>;
}[keyof U];

export type inferParsedUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
    [K in keyof U]: Record<inferParsedDiscriminant<D>, K> & inferParsedObject<U[K]>;
}[keyof U];

export type inferRawDiscriminant<D extends string | Discriminant<any, any>> = D extends string
    ? D
    : D extends Discriminant<infer Raw, any>
    ? Raw
    : never;

export type inferParsedDiscriminant<D extends string | Discriminant<any, any>> = D extends string
    ? D
    : D extends Discriminant<any, infer Parsed>
    ? Parsed
    : never;
",
                    "name": "types.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseObjectLikeSchema, getObjectLikeUtils, ObjectLikeSchema, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { Discriminant } from \\"./discriminant\\";
import { inferParsedDiscriminant, inferParsedUnion, inferRawDiscriminant, inferRawUnion, UnionSubtypes } from \\"./types\\";

export function union<D extends string | Discriminant<any, any>, U extends UnionSubtypes<any>>(
    discriminant: D,
    union: U
): ObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> {
    const rawDiscriminant =
        typeof discriminant === \\"string\\" ? discriminant : (discriminant.rawDiscriminant as inferRawDiscriminant<D>);
    const parsedDiscriminant =
        typeof discriminant === \\"string\\"
            ? discriminant
            : (discriminant.parsedDiscriminant as inferParsedDiscriminant<D>);

    const baseSchema: BaseObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> = {
        ...OBJECT_LIKE_BRAND,

        parse: (raw, opts) => {
            const { [rawDiscriminant]: discriminantValue, ...additionalProperties } = raw;
            const additionalPropertySchemas = union[discriminantValue];

            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            if (additionalPropertySchemas == null) {
                return {
                    ...additionalProperties,
                    [parsedDiscriminant]: discriminantValue,
                } as inferParsedUnion<D, U>;
            }

            return {
                ...additionalPropertySchemas.parse(additionalProperties as any, opts),
                [parsedDiscriminant]: discriminantValue,
            } as inferParsedUnion<D, U>;
        },

        json: (parsed, opts) => {
            const { [parsedDiscriminant]: discriminantValue, ...additionalProperties } = parsed;
            const additionalPropertySchemas = union[discriminantValue];

            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            if (additionalPropertySchemas == null) {
                return {
                    ...additionalProperties,
                    [rawDiscriminant]: discriminantValue,
                } as unknown as inferRawUnion<D, U>;
            }

            return {
                ...additionalPropertySchemas.json(additionalProperties as any, opts),
                [rawDiscriminant]: discriminantValue,
            } as inferRawUnion<D, U>;
        },
    };

    return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
    };
}
",
                    "name": "union.ts",
                    "type": "file",
                  },
                ],
                "name": "union",
                "type": "directory",
              },
            ],
            "name": "builders",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./builders\\";
export { type inferParsed, type inferRaw, type Schema, type SchemaOptions } from \\"./Schema\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export type addQuestionMarksToNullableProperties<T> = {
    [K in OptionalKeys<T>]?: undefined extends T[K] ? T[K] : never;
} & Pick<T, RequiredKeys<T>>;

export type OptionalKeys<T> = {
    [K in keyof T]: undefined extends T[K] ? K : never;
}[keyof T];

export type RequiredKeys<T> = {
    [K in keyof T]: undefined extends T[K] ? never : K;
}[keyof T];
",
                "name": "addQuestionMarksToNullableProperties.ts",
                "type": "file",
              },
              Object {
                "contents": "export function entries<T>(object: T): [keyof T, T[keyof T]][] {
    return Object.entries(object) as [keyof T, T[keyof T]][];
}
",
                "name": "entries.ts",
                "type": "file",
              },
              Object {
                "contents": "export function keys<T>(object: T): (keyof T)[] {
    return Object.keys(object) as (keyof T)[];
}
",
                "name": "keys.ts",
                "type": "file",
              },
            ],
            "name": "utils",
            "type": "directory",
          },
        ],
        "name": "schemas",
        "type": "directory",
      },
    ],
    "name": "core",
    "type": "directory",
  },
  Object {
    "contents": "export * as MyApi from \\"./api\\";
",
    "name": "index.ts",
    "type": "file",
  },
  Object {
    "contents": "{
    \\"name\\": \\"@fern-api/my-api-client\\",
    \\"main\\": \\"./index.js\\",
    \\"types\\": \\"./index.d.ts\\",
    \\"scripts\\": {
        \\"build\\": \\"esbuild $(find . -name '*.ts' -not -path './node_modules/*') --format=cjs --sourcemap --outdir=. && tsc\\"
    },
    \\"dependencies\\": {
        \\"@fern-typescript/service-utils\\": \\"0.0.0\\",
        \\"url-join\\": \\"4.0.1\\",
        \\"@types/url-join\\": \\"4.0.1\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"esbuild\\": \\"0.14.47\\",
        \\"typescript\\": \\"4.6.4\\"
    }
}",
    "name": "package.json",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const StoreTracedTestCaseRequest: core.schemas.ObjectSchema<StoreTracedTestCaseRequest.Raw, MyApi.admin.StoreTracedTestCaseRequest> = core.schemas.object({
        result: schemas.submission.TestCaseResultWithStdout,
        traceResponses: core.schemas.list(schemas.submission.TraceResponse)
    });

export declare namespace StoreTracedTestCaseRequest {
    interface Raw {
        \\"result\\": schemas.submission.TestCaseResultWithStdout.Raw;
        \\"traceResponses\\": schemas.submission.TraceResponse.Raw[];
    }
}
",
                "name": "StoreTracedTestCaseRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const StoreTracedWorkspaceRequest: core.schemas.ObjectSchema<StoreTracedWorkspaceRequest.Raw, MyApi.admin.StoreTracedWorkspaceRequest> = core.schemas.object({
        workspaceRunDetails: schemas.submission.WorkspaceRunDetails,
        traceResponses: core.schemas.list(schemas.submission.TraceResponse)
    });

export declare namespace StoreTracedWorkspaceRequest {
    interface Raw {
        \\"workspaceRunDetails\\": schemas.submission.WorkspaceRunDetails.Raw;
        \\"traceResponses\\": schemas.submission.TraceResponse.Raw[];
    }
}
",
                "name": "StoreTracedWorkspaceRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./StoreTracedTestCaseRequest\\";
export * from \\"./StoreTracedWorkspaceRequest\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "admin",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const BinaryTreeNodeAndTreeValue: core.schemas.ObjectSchema<BinaryTreeNodeAndTreeValue.Raw, MyApi.commons.BinaryTreeNodeAndTreeValue> = core.schemas.object({
        nodeId: schemas.commons.NodeId,
        fullTree: schemas.commons.BinaryTreeValue
    });

export declare namespace BinaryTreeNodeAndTreeValue {
    interface Raw {
        \\"nodeId\\": schemas.commons.NodeId.Raw;
        \\"fullTree\\": schemas.commons.BinaryTreeValue.Raw;
    }
}
",
                "name": "BinaryTreeNodeAndTreeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const BinaryTreeNodeValue: core.schemas.ObjectSchema<BinaryTreeNodeValue.Raw, MyApi.commons.BinaryTreeNodeValue> = core.schemas.object({
        nodeId: schemas.commons.NodeId,
        val: core.schemas.number(),
        right: schemas.commons.NodeId.optional(),
        left: schemas.commons.NodeId.optional()
    });

export declare namespace BinaryTreeNodeValue {
    interface Raw {
        \\"nodeId\\": schemas.commons.NodeId.Raw;
        \\"val\\": number;
        \\"right\\"?: schemas.commons.NodeId.Raw | null;
        \\"left\\"?: schemas.commons.NodeId.Raw | null;
    }
}
",
                "name": "BinaryTreeNodeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const BinaryTreeValue: core.schemas.ObjectSchema<BinaryTreeValue.Raw, MyApi.commons.BinaryTreeValue> = core.schemas.object({
        root: schemas.commons.NodeId.optional(),
        nodes: core.schemas.record(core.schemas.string(), schemas.commons.BinaryTreeNodeValue)
    });

export declare namespace BinaryTreeValue {
    interface Raw {
        \\"root\\"?: schemas.commons.NodeId.Raw | null;
        \\"nodes\\": Record<schemas.commons.NodeId.Raw, schemas.commons.BinaryTreeNodeValue.Raw>;
    }
}
",
                "name": "BinaryTreeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const DebugKeyValuePairs: core.schemas.ObjectSchema<DebugKeyValuePairs.Raw, MyApi.commons.DebugKeyValuePairs> = core.schemas.object({
        key: schemas.commons.DebugVariableValue,
        value: schemas.commons.DebugVariableValue
    });

export declare namespace DebugKeyValuePairs {
    interface Raw {
        \\"key\\": schemas.commons.DebugVariableValue.Raw;
        \\"value\\": schemas.commons.DebugVariableValue.Raw;
    }
}
",
                "name": "DebugKeyValuePairs.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const DebugMapValue: core.schemas.ObjectSchema<DebugMapValue.Raw, MyApi.commons.DebugMapValue> = core.schemas.object({
        keyValuePairs: core.schemas.list(schemas.commons.DebugKeyValuePairs)
    });

export declare namespace DebugMapValue {
    interface Raw {
        \\"keyValuePairs\\": schemas.commons.DebugKeyValuePairs.Raw[];
    }
}
",
                "name": "DebugMapValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";

export const DebugVariableValue: core.schemas.Schema<DebugVariableValue.Raw, MyApi.commons.DebugVariableValue> = core.schemas.union(\\"type\\", {
        integerValue: core.schemas.object({
            value: core.schemas.property(\\"integerValue\\", core.schemas.number())
        }),
        booleanValue: core.schemas.object({
            value: core.schemas.property(\\"booleanValue\\", core.schemas.boolean())
        }),
        doubleValue: core.schemas.object({
            value: core.schemas.property(\\"doubleValue\\", core.schemas.number())
        }),
        stringValue: core.schemas.object({
            value: core.schemas.property(\\"stringValue\\", core.schemas.string())
        }),
        charValue: core.schemas.object({
            value: core.schemas.property(\\"charValue\\", core.schemas.string())
        }),
        mapValue: schemas.commons.DebugMapValue,
        listValue: core.schemas.object({
            value: core.schemas.property(\\"listValue\\", core.schemas.list(schemas.commons.DebugVariableValue))
        }),
        binaryTreeNodeValue: schemas.commons.BinaryTreeNodeAndTreeValue,
        singlyLinkedListNodeValue: schemas.commons.SinglyLinkedListNodeAndListValue,
        doublyLinkedListNodeValue: schemas.commons.DoublyLinkedListNodeAndListValue,
        undefinedValue: core.schemas.object({}),
        nullValue: core.schemas.object({}),
        genericValue: schemas.commons.GenericValue
    }).transform<MyApi.commons.DebugVariableValue>({
        parse: value => {
            switch (value.type) {
                case \\"integerValue\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.integerValue(value.value)
                    };
                }
                case \\"booleanValue\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.booleanValue(value.value)
                    };
                }
                case \\"doubleValue\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.doubleValue(value.value)
                    };
                }
                case \\"stringValue\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.stringValue(value.value)
                    };
                }
                case \\"charValue\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.charValue(value.value)
                    };
                }
                case \\"mapValue\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.mapValue(value)
                    };
                }
                case \\"listValue\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.listValue(value.value)
                    };
                }
                case \\"binaryTreeNodeValue\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.binaryTreeNodeValue(value)
                    };
                }
                case \\"singlyLinkedListNodeValue\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.singlyLinkedListNodeValue(value)
                    };
                }
                case \\"doublyLinkedListNodeValue\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.doublyLinkedListNodeValue(value)
                    };
                }
                case \\"undefinedValue\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.undefinedValue()
                    };
                }
                case \\"nullValue\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.nullValue()
                    };
                }
                case \\"genericValue\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.genericValue(value)
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace DebugVariableValue {
    type Raw = DebugVariableValue.IntegerValue | DebugVariableValue.BooleanValue | DebugVariableValue.DoubleValue | DebugVariableValue.StringValue | DebugVariableValue.CharValue | DebugVariableValue.MapValue | DebugVariableValue.ListValue | DebugVariableValue.BinaryTreeNodeValue | DebugVariableValue.SinglyLinkedListNodeValue | DebugVariableValue.DoublyLinkedListNodeValue | DebugVariableValue.UndefinedValue | DebugVariableValue.NullValue | DebugVariableValue.GenericValue;

    interface IntegerValue {
        type: \\"integerValue\\";
        integerValue: number;
    }

    interface BooleanValue {
        type: \\"booleanValue\\";
        booleanValue: boolean;
    }

    interface DoubleValue {
        type: \\"doubleValue\\";
        doubleValue: number;
    }

    interface StringValue {
        type: \\"stringValue\\";
        stringValue: string;
    }

    interface CharValue {
        type: \\"charValue\\";
        charValue: string;
    }

    interface MapValue extends schemas.commons.DebugMapValue.Raw {
        type: \\"mapValue\\";
    }

    interface ListValue {
        type: \\"listValue\\";
        listValue: schemas.commons.DebugVariableValue.Raw[];
    }

    interface BinaryTreeNodeValue extends schemas.commons.BinaryTreeNodeAndTreeValue.Raw {
        type: \\"binaryTreeNodeValue\\";
    }

    interface SinglyLinkedListNodeValue extends schemas.commons.SinglyLinkedListNodeAndListValue.Raw {
        type: \\"singlyLinkedListNodeValue\\";
    }

    interface DoublyLinkedListNodeValue extends schemas.commons.DoublyLinkedListNodeAndListValue.Raw {
        type: \\"doublyLinkedListNodeValue\\";
    }

    interface UndefinedValue {
        type: \\"undefinedValue\\";
    }

    interface NullValue {
        type: \\"nullValue\\";
    }

    interface GenericValue extends schemas.commons.GenericValue.Raw {
        type: \\"genericValue\\";
    }
}
",
                "name": "DebugVariableValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const DoublyLinkedListNodeAndListValue: core.schemas.ObjectSchema<DoublyLinkedListNodeAndListValue.Raw, MyApi.commons.DoublyLinkedListNodeAndListValue> = core.schemas.object({
        nodeId: schemas.commons.NodeId,
        fullList: schemas.commons.DoublyLinkedListValue
    });

export declare namespace DoublyLinkedListNodeAndListValue {
    interface Raw {
        \\"nodeId\\": schemas.commons.NodeId.Raw;
        \\"fullList\\": schemas.commons.DoublyLinkedListValue.Raw;
    }
}
",
                "name": "DoublyLinkedListNodeAndListValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const DoublyLinkedListNodeValue: core.schemas.ObjectSchema<DoublyLinkedListNodeValue.Raw, MyApi.commons.DoublyLinkedListNodeValue> = core.schemas.object({
        nodeId: schemas.commons.NodeId,
        val: core.schemas.number(),
        next: schemas.commons.NodeId.optional(),
        prev: schemas.commons.NodeId.optional()
    });

export declare namespace DoublyLinkedListNodeValue {
    interface Raw {
        \\"nodeId\\": schemas.commons.NodeId.Raw;
        \\"val\\": number;
        \\"next\\"?: schemas.commons.NodeId.Raw | null;
        \\"prev\\"?: schemas.commons.NodeId.Raw | null;
    }
}
",
                "name": "DoublyLinkedListNodeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const DoublyLinkedListValue: core.schemas.ObjectSchema<DoublyLinkedListValue.Raw, MyApi.commons.DoublyLinkedListValue> = core.schemas.object({
        head: schemas.commons.NodeId.optional(),
        nodes: core.schemas.record(core.schemas.string(), schemas.commons.DoublyLinkedListNodeValue)
    });

export declare namespace DoublyLinkedListValue {
    interface Raw {
        \\"head\\"?: schemas.commons.NodeId.Raw | null;
        \\"nodes\\": Record<schemas.commons.NodeId.Raw, schemas.commons.DoublyLinkedListNodeValue.Raw>;
    }
}
",
                "name": "DoublyLinkedListValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const FileInfo: core.schemas.ObjectSchema<FileInfo.Raw, MyApi.commons.FileInfo> = core.schemas.object({
        filename: core.schemas.string(),
        contents: core.schemas.string()
    });

export declare namespace FileInfo {
    interface Raw {
        \\"filename\\": string;
        \\"contents\\": string;
    }
}
",
                "name": "FileInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const GenericValue: core.schemas.ObjectSchema<GenericValue.Raw, MyApi.commons.GenericValue> = core.schemas.object({
        stringifiedType: core.schemas.string().optional(),
        stringifiedValue: core.schemas.string()
    });

export declare namespace GenericValue {
    interface Raw {
        \\"stringifiedType\\"?: string | null;
        \\"stringifiedValue\\": string;
    }
}
",
                "name": "GenericValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const KeyValuePair: core.schemas.ObjectSchema<KeyValuePair.Raw, MyApi.commons.KeyValuePair> = core.schemas.object({
        key: schemas.commons.VariableValue,
        value: schemas.commons.VariableValue
    });

export declare namespace KeyValuePair {
    interface Raw {
        \\"key\\": schemas.commons.VariableValue.Raw;
        \\"value\\": schemas.commons.VariableValue.Raw;
    }
}
",
                "name": "KeyValuePair.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Language: core.schemas.Schema<Language.Raw, MyApi.commons.Language> = core.schemas.string().transform<MyApi.commons.Language>({
        parse: value => {
            switch (value) {
                case \\"JAVA\\": {
                    return MyApi.commons.Language.Java();
                }
                case \\"JAVASCRIPT\\": {
                    return MyApi.commons.Language.Javascript();
                }
                case \\"PYTHON\\": {
                    return MyApi.commons.Language.Python();
                }
                default: {
                    return {
                        get: () => value,
                        visit: visitor => visitor._unknown(value)
                    };
                }
            }
        },
        json: value => value.get()
    });

export declare namespace Language {
    type Raw = string;
}
",
                "name": "Language.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const ListType: core.schemas.ObjectSchema<ListType.Raw, MyApi.commons.ListType> = core.schemas.object({
        valueType: schemas.commons.VariableType,
        isFixedLength: core.schemas.boolean().optional()
    });

export declare namespace ListType {
    interface Raw {
        \\"valueType\\": schemas.commons.VariableType.Raw;
        \\"isFixedLength\\"?: boolean | null;
    }
}
",
                "name": "ListType.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const MapType: core.schemas.ObjectSchema<MapType.Raw, MyApi.commons.MapType> = core.schemas.object({
        keyType: schemas.commons.VariableType,
        valueType: schemas.commons.VariableType
    });

export declare namespace MapType {
    interface Raw {
        \\"keyType\\": schemas.commons.VariableType.Raw;
        \\"valueType\\": schemas.commons.VariableType.Raw;
    }
}
",
                "name": "MapType.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const MapValue: core.schemas.ObjectSchema<MapValue.Raw, MyApi.commons.MapValue> = core.schemas.object({
        keyValuePairs: core.schemas.list(schemas.commons.KeyValuePair)
    });

export declare namespace MapValue {
    interface Raw {
        \\"keyValuePairs\\": schemas.commons.KeyValuePair.Raw[];
    }
}
",
                "name": "MapValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const NodeId: core.schemas.Schema<NodeId.Raw, MyApi.commons.NodeId> = core.schemas.string();

export declare namespace NodeId {
    type Raw = string;
}
",
                "name": "NodeId.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const ProblemId: core.schemas.Schema<ProblemId.Raw, MyApi.commons.ProblemId> = core.schemas.string();

export declare namespace ProblemId {
    type Raw = string;
}
",
                "name": "ProblemId.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const SinglyLinkedListNodeAndListValue: core.schemas.ObjectSchema<SinglyLinkedListNodeAndListValue.Raw, MyApi.commons.SinglyLinkedListNodeAndListValue> = core.schemas.object({
        nodeId: schemas.commons.NodeId,
        fullList: schemas.commons.SinglyLinkedListValue
    });

export declare namespace SinglyLinkedListNodeAndListValue {
    interface Raw {
        \\"nodeId\\": schemas.commons.NodeId.Raw;
        \\"fullList\\": schemas.commons.SinglyLinkedListValue.Raw;
    }
}
",
                "name": "SinglyLinkedListNodeAndListValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const SinglyLinkedListNodeValue: core.schemas.ObjectSchema<SinglyLinkedListNodeValue.Raw, MyApi.commons.SinglyLinkedListNodeValue> = core.schemas.object({
        nodeId: schemas.commons.NodeId,
        val: core.schemas.number(),
        next: schemas.commons.NodeId.optional()
    });

export declare namespace SinglyLinkedListNodeValue {
    interface Raw {
        \\"nodeId\\": schemas.commons.NodeId.Raw;
        \\"val\\": number;
        \\"next\\"?: schemas.commons.NodeId.Raw | null;
    }
}
",
                "name": "SinglyLinkedListNodeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const SinglyLinkedListValue: core.schemas.ObjectSchema<SinglyLinkedListValue.Raw, MyApi.commons.SinglyLinkedListValue> = core.schemas.object({
        head: schemas.commons.NodeId.optional(),
        nodes: core.schemas.record(core.schemas.string(), schemas.commons.SinglyLinkedListNodeValue)
    });

export declare namespace SinglyLinkedListValue {
    interface Raw {
        \\"head\\"?: schemas.commons.NodeId.Raw | null;
        \\"nodes\\": Record<schemas.commons.NodeId.Raw, schemas.commons.SinglyLinkedListNodeValue.Raw>;
    }
}
",
                "name": "SinglyLinkedListValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";

export const TestCase: core.schemas.ObjectSchema<TestCase.Raw, MyApi.commons.TestCase> = core.schemas.object({
        id: core.schemas.string(),
        params: core.schemas.list(schemas.commons.VariableValue)
    });

export declare namespace TestCase {
    interface Raw {
        \\"id\\": string;
        \\"params\\": schemas.commons.VariableValue.Raw[];
    }
}
",
                "name": "TestCase.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const TestCaseWithExpectedResult: core.schemas.ObjectSchema<TestCaseWithExpectedResult.Raw, MyApi.commons.TestCaseWithExpectedResult> = core.schemas.object({
        testCase: schemas.commons.TestCase,
        expectedResult: schemas.commons.VariableValue
    });

export declare namespace TestCaseWithExpectedResult {
    interface Raw {
        \\"testCase\\": schemas.commons.TestCase.Raw;
        \\"expectedResult\\": schemas.commons.VariableValue.Raw;
    }
}
",
                "name": "TestCaseWithExpectedResult.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const UserId: core.schemas.Schema<UserId.Raw, MyApi.commons.UserId> = core.schemas.string();

export declare namespace UserId {
    type Raw = string;
}
",
                "name": "UserId.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const VariableType: core.schemas.Schema<VariableType.Raw, MyApi.commons.VariableType> = core.schemas.union(\\"type\\", {
        integerType: core.schemas.object({}),
        doubleType: core.schemas.object({}),
        booleanType: core.schemas.object({}),
        stringType: core.schemas.object({}),
        charType: core.schemas.object({}),
        listType: schemas.commons.ListType,
        mapType: schemas.commons.MapType,
        binaryTreeType: core.schemas.object({}),
        singlyLinkedListType: core.schemas.object({}),
        doublyLinkedListType: core.schemas.object({})
    }).transform<MyApi.commons.VariableType>({
        parse: value => {
            switch (value.type) {
                case \\"integerType\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.integerType()
                    };
                }
                case \\"doubleType\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.doubleType()
                    };
                }
                case \\"booleanType\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.booleanType()
                    };
                }
                case \\"stringType\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.stringType()
                    };
                }
                case \\"charType\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.charType()
                    };
                }
                case \\"listType\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.listType(value)
                    };
                }
                case \\"mapType\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.mapType(value)
                    };
                }
                case \\"binaryTreeType\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.binaryTreeType()
                    };
                }
                case \\"singlyLinkedListType\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.singlyLinkedListType()
                    };
                }
                case \\"doublyLinkedListType\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.doublyLinkedListType()
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace VariableType {
    type Raw = VariableType.IntegerType | VariableType.DoubleType | VariableType.BooleanType | VariableType.StringType | VariableType.CharType | VariableType.ListType | VariableType.MapType | VariableType.BinaryTreeType | VariableType.SinglyLinkedListType | VariableType.DoublyLinkedListType;

    interface IntegerType {
        type: \\"integerType\\";
    }

    interface DoubleType {
        type: \\"doubleType\\";
    }

    interface BooleanType {
        type: \\"booleanType\\";
    }

    interface StringType {
        type: \\"stringType\\";
    }

    interface CharType {
        type: \\"charType\\";
    }

    interface ListType extends schemas.commons.ListType.Raw {
        type: \\"listType\\";
    }

    interface MapType extends schemas.commons.MapType.Raw {
        type: \\"mapType\\";
    }

    interface BinaryTreeType {
        type: \\"binaryTreeType\\";
    }

    interface SinglyLinkedListType {
        type: \\"singlyLinkedListType\\";
    }

    interface DoublyLinkedListType {
        type: \\"doublyLinkedListType\\";
    }
}
",
                "name": "VariableType.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";

export const VariableValue: core.schemas.Schema<VariableValue.Raw, MyApi.commons.VariableValue> = core.schemas.union(\\"type\\", {
        integerValue: core.schemas.object({
            value: core.schemas.property(\\"integerValue\\", core.schemas.number())
        }),
        booleanValue: core.schemas.object({
            value: core.schemas.property(\\"booleanValue\\", core.schemas.boolean())
        }),
        doubleValue: core.schemas.object({
            value: core.schemas.property(\\"doubleValue\\", core.schemas.number())
        }),
        stringValue: core.schemas.object({
            value: core.schemas.property(\\"stringValue\\", core.schemas.string())
        }),
        charValue: core.schemas.object({
            value: core.schemas.property(\\"charValue\\", core.schemas.string())
        }),
        mapValue: schemas.commons.MapValue,
        listValue: core.schemas.object({
            value: core.schemas.property(\\"listValue\\", core.schemas.list(schemas.commons.VariableValue))
        }),
        binaryTreeValue: schemas.commons.BinaryTreeValue,
        singlyLinkedListValue: schemas.commons.SinglyLinkedListValue,
        doublyLinkedListValue: schemas.commons.DoublyLinkedListValue,
        nullValue: core.schemas.object({})
    }).transform<MyApi.commons.VariableValue>({
        parse: value => {
            switch (value.type) {
                case \\"integerValue\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.integerValue(value.value)
                    };
                }
                case \\"booleanValue\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.booleanValue(value.value)
                    };
                }
                case \\"doubleValue\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.doubleValue(value.value)
                    };
                }
                case \\"stringValue\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.stringValue(value.value)
                    };
                }
                case \\"charValue\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.charValue(value.value)
                    };
                }
                case \\"mapValue\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.mapValue(value)
                    };
                }
                case \\"listValue\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.listValue(value.value)
                    };
                }
                case \\"binaryTreeValue\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.binaryTreeValue(value)
                    };
                }
                case \\"singlyLinkedListValue\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.singlyLinkedListValue(value)
                    };
                }
                case \\"doublyLinkedListValue\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.doublyLinkedListValue(value)
                    };
                }
                case \\"nullValue\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.nullValue()
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace VariableValue {
    type Raw = VariableValue.IntegerValue | VariableValue.BooleanValue | VariableValue.DoubleValue | VariableValue.StringValue | VariableValue.CharValue | VariableValue.MapValue | VariableValue.ListValue | VariableValue.BinaryTreeValue | VariableValue.SinglyLinkedListValue | VariableValue.DoublyLinkedListValue | VariableValue.NullValue;

    interface IntegerValue {
        type: \\"integerValue\\";
        integerValue: number;
    }

    interface BooleanValue {
        type: \\"booleanValue\\";
        booleanValue: boolean;
    }

    interface DoubleValue {
        type: \\"doubleValue\\";
        doubleValue: number;
    }

    interface StringValue {
        type: \\"stringValue\\";
        stringValue: string;
    }

    interface CharValue {
        type: \\"charValue\\";
        charValue: string;
    }

    interface MapValue extends schemas.commons.MapValue.Raw {
        type: \\"mapValue\\";
    }

    interface ListValue {
        type: \\"listValue\\";
        listValue: schemas.commons.VariableValue.Raw[];
    }

    interface BinaryTreeValue extends schemas.commons.BinaryTreeValue.Raw {
        type: \\"binaryTreeValue\\";
    }

    interface SinglyLinkedListValue extends schemas.commons.SinglyLinkedListValue.Raw {
        type: \\"singlyLinkedListValue\\";
    }

    interface DoublyLinkedListValue extends schemas.commons.DoublyLinkedListValue.Raw {
        type: \\"doublyLinkedListValue\\";
    }

    interface NullValue {
        type: \\"nullValue\\";
    }
}
",
                "name": "VariableValue.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./UserId\\";
export * from \\"./ProblemId\\";
export * from \\"./NodeId\\";
export * from \\"./VariableType\\";
export * from \\"./ListType\\";
export * from \\"./MapType\\";
export * from \\"./VariableValue\\";
export * from \\"./DebugVariableValue\\";
export * from \\"./GenericValue\\";
export * from \\"./MapValue\\";
export * from \\"./KeyValuePair\\";
export * from \\"./BinaryTreeValue\\";
export * from \\"./BinaryTreeNodeValue\\";
export * from \\"./BinaryTreeNodeAndTreeValue\\";
export * from \\"./SinglyLinkedListValue\\";
export * from \\"./SinglyLinkedListNodeValue\\";
export * from \\"./SinglyLinkedListNodeAndListValue\\";
export * from \\"./DoublyLinkedListValue\\";
export * from \\"./DoublyLinkedListNodeValue\\";
export * from \\"./DoublyLinkedListNodeAndListValue\\";
export * from \\"./DebugMapValue\\";
export * from \\"./DebugKeyValuePairs\\";
export * from \\"./TestCase\\";
export * from \\"./TestCaseWithExpectedResult\\";
export * from \\"./FileInfo\\";
export * from \\"./Language\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "commons",
        "type": "directory",
      },
      Object {
        "contents": "export * as admin from \\"./admin\\";
export * as commons from \\"./commons\\";
export * as langServer from \\"./lang-server\\";
export * as migration from \\"./migration\\";
export * as playlist from \\"./playlist\\";
export * as problem from \\"./problem\\";
export * as submission from \\"./submission\\";
export * as v2 from \\"./v2\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const LangServerRequest: core.schemas.ObjectSchema<LangServerRequest.Raw, MyApi.langServer.LangServerRequest> = core.schemas.object({
        request: core.schemas.unknown()
    });

export declare namespace LangServerRequest {
    interface Raw {
        \\"request\\"?: unknown | null;
    }
}
",
                "name": "LangServerRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const LangServerResponse: core.schemas.ObjectSchema<LangServerResponse.Raw, MyApi.langServer.LangServerResponse> = core.schemas.object({
        response: core.schemas.unknown()
    });

export declare namespace LangServerResponse {
    interface Raw {
        \\"response\\"?: unknown | null;
    }
}
",
                "name": "LangServerResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./LangServerRequest\\";
export * from \\"./LangServerResponse\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "lang-server",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";

export const Migration: core.schemas.ObjectSchema<Migration.Raw, MyApi.migration.Migration> = core.schemas.object({
        name: core.schemas.string(),
        status: schemas.migration.MigrationStatus
    });

export declare namespace Migration {
    interface Raw {
        \\"name\\": string;
        \\"status\\": schemas.migration.MigrationStatus.Raw;
    }
}
",
                "name": "Migration.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const MigrationStatus: core.schemas.Schema<MigrationStatus.Raw, MyApi.migration.MigrationStatus> = core.schemas.string().transform<MyApi.migration.MigrationStatus>({
        parse: value => {
            switch (value) {
                case \\"RUNNING\\": {
                    return MyApi.migration.MigrationStatus.Running();
                }
                case \\"FAILED\\": {
                    return MyApi.migration.MigrationStatus.Failed();
                }
                case \\"FINISHED\\": {
                    return MyApi.migration.MigrationStatus.Finished();
                }
                default: {
                    return {
                        get: () => value,
                        visit: visitor => visitor._unknown(value)
                    };
                }
            }
        },
        json: value => value.get()
    });

export declare namespace MigrationStatus {
    type Raw = string;
}
",
                "name": "MigrationStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./MigrationStatus\\";
export * from \\"./Migration\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "migration",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";

export const PlaylistIdNotFoundError: core.schemas.ObjectSchema<PlaylistIdNotFoundError.Raw, MyApi.playlist.PlaylistIdNotFoundError> = core.schemas.object({
        _error: core.schemas.stringLiteral(\\"PlaylistIdNotFoundError\\"),
        playlistId: schemas.playlist.PlaylistId
    });

export declare namespace PlaylistIdNotFoundError {
    interface Raw {
        \\"_error\\": \\"PlaylistIdNotFoundError\\";
        \\"playlistId\\": schemas.playlist.PlaylistId.Raw;
    }
}
",
                "name": "PlaylistIdNotFoundError.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const UnauthorizedError: core.schemas.ObjectSchema<UnauthorizedError.Raw, MyApi.playlist.UnauthorizedError> = core.schemas.object({
        _error: core.schemas.stringLiteral(\\"UnauthorizedError\\")
    });

export declare namespace UnauthorizedError {
    interface Raw {
        \\"_error\\": \\"UnauthorizedError\\";
    }
}
",
                "name": "UnauthorizedError.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./PlaylistIdNotFoundError\\";
export * from \\"./UnauthorizedError\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "errors",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./errors\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const Playlist: core.schemas.ObjectSchema<Playlist.Raw, MyApi.playlist.Playlist> = core.schemas.object({
        playlistId: core.schemas.property(\\"playlist_id\\", schemas.playlist.PlaylistId),
        name: core.schemas.string(),
        problems: core.schemas.list(schemas.commons.ProblemId),
        ownerId: core.schemas.property(\\"owner-id\\", schemas.commons.UserId)
    });

export declare namespace Playlist {
    interface Raw {
        \\"playlist_id\\": schemas.playlist.PlaylistId.Raw;
        \\"name\\": string;
        \\"problems\\": schemas.commons.ProblemId.Raw[];
        \\"owner-id\\": schemas.commons.UserId.Raw;
    }
}
",
                "name": "Playlist.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";

export const PlaylistCreateRequest: core.schemas.ObjectSchema<PlaylistCreateRequest.Raw, MyApi.playlist.PlaylistCreateRequest> = core.schemas.object({
        name: core.schemas.string(),
        problems: core.schemas.list(schemas.commons.ProblemId)
    });

export declare namespace PlaylistCreateRequest {
    interface Raw {
        \\"name\\": string;
        \\"problems\\": schemas.commons.ProblemId.Raw[];
    }
}
",
                "name": "PlaylistCreateRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const PlaylistId: core.schemas.Schema<PlaylistId.Raw, MyApi.playlist.PlaylistId> = core.schemas.string();

export declare namespace PlaylistId {
    type Raw = string;
}
",
                "name": "PlaylistId.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";

export const UpdatePlaylistRequest: core.schemas.ObjectSchema<UpdatePlaylistRequest.Raw, MyApi.playlist.UpdatePlaylistRequest> = core.schemas.object({
        name: core.schemas.string(),
        problems: core.schemas.list(schemas.commons.ProblemId)
    });

export declare namespace UpdatePlaylistRequest {
    interface Raw {
        \\"name\\": string;
        \\"problems\\": schemas.commons.ProblemId.Raw[];
    }
}
",
                "name": "UpdatePlaylistRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./PlaylistId\\";
export * from \\"./Playlist\\";
export * from \\"./PlaylistCreateRequest\\";
export * from \\"./UpdatePlaylistRequest\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "playlist",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const CreateProblemError: core.schemas.Schema<CreateProblemError.Raw, MyApi.problem.CreateProblemError> = core.schemas.union(core.schemas.discriminant(\\"errorType\\", \\"_type\\"), {
        generic: schemas.problem.GenericCreateProblemError
    }).transform<MyApi.problem.CreateProblemError>({
        parse: value => {
            switch (value.errorType) {
                case \\"generic\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.generic(value)
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            errorType: void;
        }>
    });

export declare namespace CreateProblemError {
    type Raw = CreateProblemError.Generic;

    interface Generic extends schemas.problem.GenericCreateProblemError.Raw {
        _type: \\"generic\\";
    }
}
",
                "name": "CreateProblemError.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";

export const CreateProblemRequest: core.schemas.ObjectSchema<CreateProblemRequest.Raw, MyApi.problem.CreateProblemRequest> = core.schemas.object({
        problemName: core.schemas.string(),
        problemDescription: schemas.problem.ProblemDescription,
        files: core.schemas.record(core.schemas.string(), schemas.problem.ProblemFiles),
        inputParams: core.schemas.list(schemas.problem.VariableTypeAndName),
        outputType: schemas.commons.VariableType,
        testcases: core.schemas.list(schemas.commons.TestCaseWithExpectedResult),
        methodName: core.schemas.string()
    });

export declare namespace CreateProblemRequest {
    interface Raw {
        \\"problemName\\": string;
        \\"problemDescription\\": schemas.problem.ProblemDescription.Raw;
        \\"files\\": Record<schemas.commons.Language.Raw, schemas.problem.ProblemFiles.Raw>;
        \\"inputParams\\": schemas.problem.VariableTypeAndName.Raw[];
        \\"outputType\\": schemas.commons.VariableType.Raw;
        \\"testcases\\": schemas.commons.TestCaseWithExpectedResult.Raw[];
        \\"methodName\\": string;
    }
}
",
                "name": "CreateProblemRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const CreateProblemResponse: core.schemas.Schema<CreateProblemResponse.Raw, MyApi.problem.CreateProblemResponse> = core.schemas.union(\\"type\\", {
        success: core.schemas.object({
            value: core.schemas.property(\\"success\\", schemas.commons.ProblemId)
        }),
        error: core.schemas.object({
            value: core.schemas.property(\\"error\\", schemas.problem.CreateProblemError)
        })
    }).transform<MyApi.problem.CreateProblemResponse>({
        parse: value => {
            switch (value.type) {
                case \\"success\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.success(value.value)
                    };
                }
                case \\"error\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.error(value.value)
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace CreateProblemResponse {
    type Raw = CreateProblemResponse.Success | CreateProblemResponse.Error;

    interface Success {
        type: \\"success\\";
        success: schemas.commons.ProblemId.Raw;
    }

    interface Error {
        type: \\"error\\";
        error: schemas.problem.CreateProblemError.Raw;
    }
}
",
                "name": "CreateProblemResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const GenericCreateProblemError: core.schemas.ObjectSchema<GenericCreateProblemError.Raw, MyApi.problem.GenericCreateProblemError> = core.schemas.object({
        message: core.schemas.string(),
        type: core.schemas.string(),
        stacktrace: core.schemas.string()
    });

export declare namespace GenericCreateProblemError {
    interface Raw {
        \\"message\\": string;
        \\"type\\": string;
        \\"stacktrace\\": string;
    }
}
",
                "name": "GenericCreateProblemError.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const GetDefaultStarterFilesRequest: core.schemas.ObjectSchema<GetDefaultStarterFilesRequest.Raw, MyApi.problem.GetDefaultStarterFilesRequest> = core.schemas.object({
        inputParams: core.schemas.list(schemas.problem.VariableTypeAndName),
        outputType: schemas.commons.VariableType,
        methodName: core.schemas.string()
    });

export declare namespace GetDefaultStarterFilesRequest {
    interface Raw {
        \\"inputParams\\": schemas.problem.VariableTypeAndName.Raw[];
        \\"outputType\\": schemas.commons.VariableType.Raw;
        \\"methodName\\": string;
    }
}
",
                "name": "GetDefaultStarterFilesRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";

export const GetDefaultStarterFilesResponse: core.schemas.ObjectSchema<GetDefaultStarterFilesResponse.Raw, MyApi.problem.GetDefaultStarterFilesResponse> = core.schemas.object({
        files: core.schemas.record(core.schemas.string(), schemas.problem.ProblemFiles)
    });

export declare namespace GetDefaultStarterFilesResponse {
    interface Raw {
        \\"files\\": Record<schemas.commons.Language.Raw, schemas.problem.ProblemFiles.Raw>;
    }
}
",
                "name": "GetDefaultStarterFilesResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const ProblemDescription: core.schemas.ObjectSchema<ProblemDescription.Raw, MyApi.problem.ProblemDescription> = core.schemas.object({
        boards: core.schemas.list(schemas.problem.ProblemDescriptionBoard)
    });

export declare namespace ProblemDescription {
    interface Raw {
        \\"boards\\": schemas.problem.ProblemDescriptionBoard.Raw[];
    }
}
",
                "name": "ProblemDescription.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";

export const ProblemDescriptionBoard: core.schemas.Schema<ProblemDescriptionBoard.Raw, MyApi.problem.ProblemDescriptionBoard> = core.schemas.union(\\"type\\", {
        html: core.schemas.object({
            value: core.schemas.property(\\"html\\", core.schemas.string())
        }),
        variable: core.schemas.object({
            value: core.schemas.property(\\"variable\\", schemas.commons.VariableValue)
        }),
        testCaseId: core.schemas.object({
            value: core.schemas.property(\\"testCaseId\\", core.schemas.string())
        })
    }).transform<MyApi.problem.ProblemDescriptionBoard>({
        parse: value => {
            switch (value.type) {
                case \\"html\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.html(value.value)
                    };
                }
                case \\"variable\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.variable(value.value)
                    };
                }
                case \\"testCaseId\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.testCaseId(value.value)
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace ProblemDescriptionBoard {
    type Raw = ProblemDescriptionBoard.Html | ProblemDescriptionBoard.Variable | ProblemDescriptionBoard.TestCaseId;

    interface Html {
        type: \\"html\\";
        html: string;
    }

    interface Variable {
        type: \\"variable\\";
        variable: schemas.commons.VariableValue.Raw;
    }

    interface TestCaseId {
        type: \\"testCaseId\\";
        testCaseId: string;
    }
}
",
                "name": "ProblemDescriptionBoard.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const ProblemFiles: core.schemas.ObjectSchema<ProblemFiles.Raw, MyApi.problem.ProblemFiles> = core.schemas.object({
        solutionFile: schemas.commons.FileInfo,
        readOnlyFiles: core.schemas.list(schemas.commons.FileInfo)
    });

export declare namespace ProblemFiles {
    interface Raw {
        \\"solutionFile\\": schemas.commons.FileInfo.Raw;
        \\"readOnlyFiles\\": schemas.commons.FileInfo.Raw[];
    }
}
",
                "name": "ProblemFiles.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const ProblemInfo: core.schemas.ObjectSchema<ProblemInfo.Raw, MyApi.problem.ProblemInfo> = core.schemas.object({
        problemId: schemas.commons.ProblemId,
        problemDescription: schemas.problem.ProblemDescription,
        problemName: core.schemas.string(),
        problemVersion: core.schemas.number(),
        files: core.schemas.record(core.schemas.string(), schemas.problem.ProblemFiles),
        inputParams: core.schemas.list(schemas.problem.VariableTypeAndName),
        outputType: schemas.commons.VariableType,
        testcases: core.schemas.list(schemas.commons.TestCaseWithExpectedResult),
        methodName: core.schemas.string(),
        supportsCustomTestCases: core.schemas.boolean()
    });

export declare namespace ProblemInfo {
    interface Raw {
        \\"problemId\\": schemas.commons.ProblemId.Raw;
        \\"problemDescription\\": schemas.problem.ProblemDescription.Raw;
        \\"problemName\\": string;
        \\"problemVersion\\": number;
        \\"files\\": Record<schemas.commons.Language.Raw, schemas.problem.ProblemFiles.Raw>;
        \\"inputParams\\": schemas.problem.VariableTypeAndName.Raw[];
        \\"outputType\\": schemas.commons.VariableType.Raw;
        \\"testcases\\": schemas.commons.TestCaseWithExpectedResult.Raw[];
        \\"methodName\\": string;
        \\"supportsCustomTestCases\\": boolean;
    }
}
",
                "name": "ProblemInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const UpdateProblemResponse: core.schemas.ObjectSchema<UpdateProblemResponse.Raw, MyApi.problem.UpdateProblemResponse> = core.schemas.object({
        problemVersion: core.schemas.number()
    });

export declare namespace UpdateProblemResponse {
    interface Raw {
        \\"problemVersion\\": number;
    }
}
",
                "name": "UpdateProblemResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const VariableTypeAndName: core.schemas.ObjectSchema<VariableTypeAndName.Raw, MyApi.problem.VariableTypeAndName> = core.schemas.object({
        variableType: schemas.commons.VariableType,
        name: core.schemas.string()
    });

export declare namespace VariableTypeAndName {
    interface Raw {
        \\"variableType\\": schemas.commons.VariableType.Raw;
        \\"name\\": string;
    }
}
",
                "name": "VariableTypeAndName.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./ProblemInfo\\";
export * from \\"./ProblemDescription\\";
export * from \\"./ProblemDescriptionBoard\\";
export * from \\"./ProblemFiles\\";
export * from \\"./VariableTypeAndName\\";
export * from \\"./CreateProblemRequest\\";
export * from \\"./CreateProblemResponse\\";
export * from \\"./UpdateProblemResponse\\";
export * from \\"./CreateProblemError\\";
export * from \\"./GenericCreateProblemError\\";
export * from \\"./GetDefaultStarterFilesRequest\\";
export * from \\"./GetDefaultStarterFilesResponse\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "problem",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const ActualResult: core.schemas.Schema<ActualResult.Raw, MyApi.submission.ActualResult> = core.schemas.union(\\"type\\", {
        value: core.schemas.object({
            value: schemas.commons.VariableValue
        }),
        exception: schemas.submission.ExceptionInfo,
        exceptionV2: core.schemas.object({
            value: core.schemas.property(\\"exceptionV2\\", schemas.submission.ExceptionV2)
        })
    }).transform<MyApi.submission.ActualResult>({
        parse: value => {
            switch (value.type) {
                case \\"value\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.value(value.value)
                    };
                }
                case \\"exception\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.exception(value)
                    };
                }
                case \\"exceptionV2\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.exceptionV2(value.value)
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace ActualResult {
    type Raw = ActualResult.Value | ActualResult.Exception | ActualResult.ExceptionV2;

    interface Value {
        type: \\"value\\";
        value: schemas.commons.VariableValue.Raw;
    }

    interface Exception extends schemas.submission.ExceptionInfo.Raw {
        type: \\"exception\\";
    }

    interface ExceptionV2 {
        type: \\"exceptionV2\\";
        exceptionV2: schemas.submission.ExceptionV2.Raw;
    }
}
",
                "name": "ActualResult.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const BuildingExecutorResponse: core.schemas.ObjectSchema<BuildingExecutorResponse.Raw, MyApi.submission.BuildingExecutorResponse> = core.schemas.object({
        submissionId: schemas.submission.SubmissionId,
        status: schemas.submission.ExecutionSessionStatus
    });

export declare namespace BuildingExecutorResponse {
    interface Raw {
        \\"submissionId\\": schemas.submission.SubmissionId.Raw;
        \\"status\\": schemas.submission.ExecutionSessionStatus.Raw;
    }
}
",
                "name": "BuildingExecutorResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const CodeExecutionUpdate: core.schemas.Schema<CodeExecutionUpdate.Raw, MyApi.submission.CodeExecutionUpdate> = core.schemas.union(\\"type\\", {
        buildingExecutor: schemas.submission.BuildingExecutorResponse,
        running: schemas.submission.RunningResponse,
        errored: schemas.submission.ErroredResponse,
        stopped: schemas.submission.StoppedResponse,
        graded: schemas.submission.GradedResponse,
        gradedV2: schemas.submission.GradedResponseV2,
        workspaceRan: schemas.submission.WorkspaceRanResponse,
        recording: schemas.submission.RecordingResponseNotification,
        recorded: schemas.submission.RecordedResponseNotification,
        invalidRequest: schemas.submission.InvalidRequestResponse,
        finished: schemas.submission.FinishedResponse
    }).transform<MyApi.submission.CodeExecutionUpdate>({
        parse: value => {
            switch (value.type) {
                case \\"buildingExecutor\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.buildingExecutor(value)
                    };
                }
                case \\"running\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.running(value)
                    };
                }
                case \\"errored\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.errored(value)
                    };
                }
                case \\"stopped\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.stopped(value)
                    };
                }
                case \\"graded\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.graded(value)
                    };
                }
                case \\"gradedV2\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.gradedV2(value)
                    };
                }
                case \\"workspaceRan\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.workspaceRan(value)
                    };
                }
                case \\"recording\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.recording(value)
                    };
                }
                case \\"recorded\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.recorded(value)
                    };
                }
                case \\"invalidRequest\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.invalidRequest(value)
                    };
                }
                case \\"finished\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.finished(value)
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace CodeExecutionUpdate {
    type Raw = CodeExecutionUpdate.BuildingExecutor | CodeExecutionUpdate.Running | CodeExecutionUpdate.Errored | CodeExecutionUpdate.Stopped | CodeExecutionUpdate.Graded | CodeExecutionUpdate.GradedV2 | CodeExecutionUpdate.WorkspaceRan | CodeExecutionUpdate.Recording | CodeExecutionUpdate.Recorded | CodeExecutionUpdate.InvalidRequest | CodeExecutionUpdate.Finished;

    interface BuildingExecutor extends schemas.submission.BuildingExecutorResponse.Raw {
        type: \\"buildingExecutor\\";
    }

    interface Running extends schemas.submission.RunningResponse.Raw {
        type: \\"running\\";
    }

    interface Errored extends schemas.submission.ErroredResponse.Raw {
        type: \\"errored\\";
    }

    interface Stopped extends schemas.submission.StoppedResponse.Raw {
        type: \\"stopped\\";
    }

    interface Graded extends schemas.submission.GradedResponse.Raw {
        type: \\"graded\\";
    }

    interface GradedV2 extends schemas.submission.GradedResponseV2.Raw {
        type: \\"gradedV2\\";
    }

    interface WorkspaceRan extends schemas.submission.WorkspaceRanResponse.Raw {
        type: \\"workspaceRan\\";
    }

    interface Recording extends schemas.submission.RecordingResponseNotification.Raw {
        type: \\"recording\\";
    }

    interface Recorded extends schemas.submission.RecordedResponseNotification.Raw {
        type: \\"recorded\\";
    }

    interface InvalidRequest extends schemas.submission.InvalidRequestResponse.Raw {
        type: \\"invalidRequest\\";
    }

    interface Finished extends schemas.submission.FinishedResponse.Raw {
        type: \\"finished\\";
    }
}
",
                "name": "CodeExecutionUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const CompileError: core.schemas.ObjectSchema<CompileError.Raw, MyApi.submission.CompileError> = core.schemas.object({
        message: core.schemas.string()
    });

export declare namespace CompileError {
    interface Raw {
        \\"message\\": string;
    }
}
",
                "name": "CompileError.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const CustomTestCasesUnsupported: core.schemas.ObjectSchema<CustomTestCasesUnsupported.Raw, MyApi.submission.CustomTestCasesUnsupported> = core.schemas.object({
        problemId: schemas.commons.ProblemId,
        submissionId: schemas.submission.SubmissionId
    });

export declare namespace CustomTestCasesUnsupported {
    interface Raw {
        \\"problemId\\": schemas.commons.ProblemId.Raw;
        \\"submissionId\\": schemas.submission.SubmissionId.Raw;
    }
}
",
                "name": "CustomTestCasesUnsupported.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const ErrorInfo: core.schemas.Schema<ErrorInfo.Raw, MyApi.submission.ErrorInfo> = core.schemas.union(\\"type\\", {
        compileError: schemas.submission.CompileError,
        runtimeError: schemas.submission.RuntimeError,
        internalError: schemas.submission.InternalError
    }).transform<MyApi.submission.ErrorInfo>({
        parse: value => {
            switch (value.type) {
                case \\"compileError\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.compileError(value)
                    };
                }
                case \\"runtimeError\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.runtimeError(value)
                    };
                }
                case \\"internalError\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.internalError(value)
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace ErrorInfo {
    type Raw = ErrorInfo.CompileError | ErrorInfo.RuntimeError | ErrorInfo.InternalError;

    interface CompileError extends schemas.submission.CompileError.Raw {
        type: \\"compileError\\";
    }

    interface RuntimeError extends schemas.submission.RuntimeError.Raw {
        type: \\"runtimeError\\";
    }

    interface InternalError extends schemas.submission.InternalError.Raw {
        type: \\"internalError\\";
    }
}
",
                "name": "ErrorInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const ErroredResponse: core.schemas.ObjectSchema<ErroredResponse.Raw, MyApi.submission.ErroredResponse> = core.schemas.object({
        submissionId: schemas.submission.SubmissionId,
        errorInfo: schemas.submission.ErrorInfo
    });

export declare namespace ErroredResponse {
    interface Raw {
        \\"submissionId\\": schemas.submission.SubmissionId.Raw;
        \\"errorInfo\\": schemas.submission.ErrorInfo.Raw;
    }
}
",
                "name": "ErroredResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const ExceptionInfo: core.schemas.ObjectSchema<ExceptionInfo.Raw, MyApi.submission.ExceptionInfo> = core.schemas.object({
        exceptionType: core.schemas.string(),
        exceptionMessage: core.schemas.string(),
        exceptionStacktrace: core.schemas.string()
    });

export declare namespace ExceptionInfo {
    interface Raw {
        \\"exceptionType\\": string;
        \\"exceptionMessage\\": string;
        \\"exceptionStacktrace\\": string;
    }
}
",
                "name": "ExceptionInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const ExceptionV2: core.schemas.Schema<ExceptionV2.Raw, MyApi.submission.ExceptionV2> = core.schemas.union(\\"type\\", {
        generic: schemas.submission.ExceptionInfo,
        timeout: core.schemas.object({})
    }).transform<MyApi.submission.ExceptionV2>({
        parse: value => {
            switch (value.type) {
                case \\"generic\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.generic(value)
                    };
                }
                case \\"timeout\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.timeout()
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace ExceptionV2 {
    type Raw = ExceptionV2.Generic | ExceptionV2.Timeout;

    interface Generic extends schemas.submission.ExceptionInfo.Raw {
        type: \\"generic\\";
    }

    interface Timeout {
        type: \\"timeout\\";
    }
}
",
                "name": "ExceptionV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";

export const ExecutionSessionResponse: core.schemas.ObjectSchema<ExecutionSessionResponse.Raw, MyApi.submission.ExecutionSessionResponse> = core.schemas.object({
        sessionId: core.schemas.string(),
        executionSessionUrl: core.schemas.string().optional(),
        language: schemas.commons.Language,
        status: schemas.submission.ExecutionSessionStatus
    });

export declare namespace ExecutionSessionResponse {
    interface Raw {
        \\"sessionId\\": string;
        \\"executionSessionUrl\\"?: string | null;
        \\"language\\": schemas.commons.Language.Raw;
        \\"status\\": schemas.submission.ExecutionSessionStatus.Raw;
    }
}
",
                "name": "ExecutionSessionResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";

export const ExecutionSessionState: core.schemas.ObjectSchema<ExecutionSessionState.Raw, MyApi.submission.ExecutionSessionState> = core.schemas.object({
        lastTimeContacted: core.schemas.string().optional(),
        sessionId: core.schemas.string(),
        isWarmInstance: core.schemas.boolean(),
        awsTaskId: core.schemas.string().optional(),
        language: schemas.commons.Language,
        status: schemas.submission.ExecutionSessionStatus
    });

export declare namespace ExecutionSessionState {
    interface Raw {
        \\"lastTimeContacted\\"?: string | null;
        \\"sessionId\\": string;
        \\"isWarmInstance\\": boolean;
        \\"awsTaskId\\"?: string | null;
        \\"language\\": schemas.commons.Language.Raw;
        \\"status\\": schemas.submission.ExecutionSessionStatus.Raw;
    }
}
",
                "name": "ExecutionSessionState.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const ExecutionSessionStatus: core.schemas.Schema<ExecutionSessionStatus.Raw, MyApi.submission.ExecutionSessionStatus> = core.schemas.string().transform<MyApi.submission.ExecutionSessionStatus>({
        parse: value => {
            switch (value) {
                case \\"CREATING_CONTAINER\\": {
                    return MyApi.submission.ExecutionSessionStatus.CreatingContainer();
                }
                case \\"PROVISIONING_CONTAINER\\": {
                    return MyApi.submission.ExecutionSessionStatus.ProvisioningContainer();
                }
                case \\"PENDING_CONTAINER\\": {
                    return MyApi.submission.ExecutionSessionStatus.PendingContainer();
                }
                case \\"RUNNING_CONTAINER\\": {
                    return MyApi.submission.ExecutionSessionStatus.RunningContainer();
                }
                case \\"LIVE_CONTAINER\\": {
                    return MyApi.submission.ExecutionSessionStatus.LiveContainer();
                }
                case \\"FAILED_TO_LAUNCH\\": {
                    return MyApi.submission.ExecutionSessionStatus.FailedToLaunch();
                }
                default: {
                    return {
                        get: () => value,
                        visit: visitor => visitor._unknown(value)
                    };
                }
            }
        },
        json: value => value.get()
    });

export declare namespace ExecutionSessionStatus {
    type Raw = string;
}
",
                "name": "ExecutionSessionStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const ExistingSubmissionExecuting: core.schemas.ObjectSchema<ExistingSubmissionExecuting.Raw, MyApi.submission.ExistingSubmissionExecuting> = core.schemas.object({
        submissionId: schemas.submission.SubmissionId
    });

export declare namespace ExistingSubmissionExecuting {
    interface Raw {
        \\"submissionId\\": schemas.submission.SubmissionId.Raw;
    }
}
",
                "name": "ExistingSubmissionExecuting.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const ExpressionLocation: core.schemas.ObjectSchema<ExpressionLocation.Raw, MyApi.submission.ExpressionLocation> = core.schemas.object({
        start: core.schemas.number(),
        offset: core.schemas.number()
    });

export declare namespace ExpressionLocation {
    interface Raw {
        \\"start\\": number;
        \\"offset\\": number;
    }
}
",
                "name": "ExpressionLocation.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const FinishedResponse: core.schemas.ObjectSchema<FinishedResponse.Raw, MyApi.submission.FinishedResponse> = core.schemas.object({
        submissionId: schemas.submission.SubmissionId
    });

export declare namespace FinishedResponse {
    interface Raw {
        \\"submissionId\\": schemas.submission.SubmissionId.Raw;
    }
}
",
                "name": "FinishedResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";

export const GetExecutionSessionStateResponse: core.schemas.ObjectSchema<GetExecutionSessionStateResponse.Raw, MyApi.submission.GetExecutionSessionStateResponse> = core.schemas.object({
        states: core.schemas.record(core.schemas.string(), schemas.submission.ExecutionSessionState),
        numWarmingInstances: core.schemas.number().optional(),
        warmingSessionIds: core.schemas.list(core.schemas.string())
    });

export declare namespace GetExecutionSessionStateResponse {
    interface Raw {
        \\"states\\": Record<string, schemas.submission.ExecutionSessionState.Raw>;
        \\"numWarmingInstances\\"?: number | null;
        \\"warmingSessionIds\\": string[];
    }
}
",
                "name": "GetExecutionSessionStateResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";

export const GetSubmissionStateResponse: core.schemas.ObjectSchema<GetSubmissionStateResponse.Raw, MyApi.submission.GetSubmissionStateResponse> = core.schemas.object({
        timeSubmitted: core.schemas.string().optional(),
        submission: core.schemas.string(),
        language: schemas.commons.Language,
        submissionTypeState: schemas.submission.SubmissionTypeState
    });

export declare namespace GetSubmissionStateResponse {
    interface Raw {
        \\"timeSubmitted\\"?: string | null;
        \\"submission\\": string;
        \\"language\\": schemas.commons.Language.Raw;
        \\"submissionTypeState\\": schemas.submission.SubmissionTypeState.Raw;
    }
}
",
                "name": "GetSubmissionStateResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const GetTraceResponsesPageRequest: core.schemas.ObjectSchema<GetTraceResponsesPageRequest.Raw, MyApi.submission.GetTraceResponsesPageRequest> = core.schemas.object({
        offset: core.schemas.number().optional()
    });

export declare namespace GetTraceResponsesPageRequest {
    interface Raw {
        \\"offset\\"?: number | null;
    }
}
",
                "name": "GetTraceResponsesPageRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const GradedResponse: core.schemas.ObjectSchema<GradedResponse.Raw, MyApi.submission.GradedResponse> = core.schemas.object({
        submissionId: schemas.submission.SubmissionId,
        testCases: core.schemas.record(core.schemas.string(), schemas.submission.TestCaseResultWithStdout)
    });

export declare namespace GradedResponse {
    interface Raw {
        \\"submissionId\\": schemas.submission.SubmissionId.Raw;
        \\"testCases\\": Record<string, schemas.submission.TestCaseResultWithStdout.Raw>;
    }
}
",
                "name": "GradedResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const GradedResponseV2: core.schemas.ObjectSchema<GradedResponseV2.Raw, MyApi.submission.GradedResponseV2> = core.schemas.object({
        submissionId: schemas.submission.SubmissionId,
        testCases: core.schemas.record(core.schemas.string(), schemas.submission.TestCaseGrade)
    });

export declare namespace GradedResponseV2 {
    interface Raw {
        \\"submissionId\\": schemas.submission.SubmissionId.Raw;
        \\"testCases\\": Record<schemas.v2.problem.TestCaseId.Raw, schemas.submission.TestCaseGrade.Raw>;
    }
}
",
                "name": "GradedResponseV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const GradedTestCaseUpdate: core.schemas.ObjectSchema<GradedTestCaseUpdate.Raw, MyApi.submission.GradedTestCaseUpdate> = core.schemas.object({
        testCaseId: schemas.v2.problem.TestCaseId,
        grade: schemas.submission.TestCaseGrade
    });

export declare namespace GradedTestCaseUpdate {
    interface Raw {
        \\"testCaseId\\": schemas.v2.problem.TestCaseId.Raw;
        \\"grade\\": schemas.submission.TestCaseGrade.Raw;
    }
}
",
                "name": "GradedTestCaseUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const InitializeProblemRequest: core.schemas.ObjectSchema<InitializeProblemRequest.Raw, MyApi.submission.InitializeProblemRequest> = core.schemas.object({
        problemId: schemas.commons.ProblemId,
        problemVersion: core.schemas.number().optional()
    });

export declare namespace InitializeProblemRequest {
    interface Raw {
        \\"problemId\\": schemas.commons.ProblemId.Raw;
        \\"problemVersion\\"?: number | null;
    }
}
",
                "name": "InitializeProblemRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const InternalError: core.schemas.ObjectSchema<InternalError.Raw, MyApi.submission.InternalError> = core.schemas.object({
        exceptionInfo: schemas.submission.ExceptionInfo
    });

export declare namespace InternalError {
    interface Raw {
        \\"exceptionInfo\\": schemas.submission.ExceptionInfo.Raw;
    }
}
",
                "name": "InternalError.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const InvalidRequestCause: core.schemas.Schema<InvalidRequestCause.Raw, MyApi.submission.InvalidRequestCause> = core.schemas.union(\\"type\\", {
        submissionIdNotFound: schemas.submission.SubmissionIdNotFound,
        customTestCasesUnsupported: schemas.submission.CustomTestCasesUnsupported,
        unexpectedLanguage: schemas.submission.UnexpectedLanguageError
    }).transform<MyApi.submission.InvalidRequestCause>({
        parse: value => {
            switch (value.type) {
                case \\"submissionIdNotFound\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.submissionIdNotFound(value)
                    };
                }
                case \\"customTestCasesUnsupported\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.customTestCasesUnsupported(value)
                    };
                }
                case \\"unexpectedLanguage\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.unexpectedLanguage(value)
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace InvalidRequestCause {
    type Raw = InvalidRequestCause.SubmissionIdNotFound | InvalidRequestCause.CustomTestCasesUnsupported | InvalidRequestCause.UnexpectedLanguage;

    interface SubmissionIdNotFound extends schemas.submission.SubmissionIdNotFound.Raw {
        type: \\"submissionIdNotFound\\";
    }

    interface CustomTestCasesUnsupported extends schemas.submission.CustomTestCasesUnsupported.Raw {
        type: \\"customTestCasesUnsupported\\";
    }

    interface UnexpectedLanguage extends schemas.submission.UnexpectedLanguageError.Raw {
        type: \\"unexpectedLanguage\\";
    }
}
",
                "name": "InvalidRequestCause.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const InvalidRequestResponse: core.schemas.ObjectSchema<InvalidRequestResponse.Raw, MyApi.submission.InvalidRequestResponse> = core.schemas.object({
        request: schemas.submission.SubmissionRequest,
        cause: schemas.submission.InvalidRequestCause
    });

export declare namespace InvalidRequestResponse {
    interface Raw {
        \\"request\\": schemas.submission.SubmissionRequest.Raw;
        \\"cause\\": schemas.submission.InvalidRequestCause.Raw;
    }
}
",
                "name": "InvalidRequestResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const LightweightStackframeInformation: core.schemas.ObjectSchema<LightweightStackframeInformation.Raw, MyApi.submission.LightweightStackframeInformation> = core.schemas.object({
        numStackFrames: core.schemas.number(),
        topStackFrameMethodName: core.schemas.string()
    });

export declare namespace LightweightStackframeInformation {
    interface Raw {
        \\"numStackFrames\\": number;
        \\"topStackFrameMethodName\\": string;
    }
}
",
                "name": "LightweightStackframeInformation.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const RecordedResponseNotification: core.schemas.ObjectSchema<RecordedResponseNotification.Raw, MyApi.submission.RecordedResponseNotification> = core.schemas.object({
        submissionId: schemas.submission.SubmissionId,
        traceResponsesSize: core.schemas.number(),
        testCaseId: core.schemas.string().optional()
    });

export declare namespace RecordedResponseNotification {
    interface Raw {
        \\"submissionId\\": schemas.submission.SubmissionId.Raw;
        \\"traceResponsesSize\\": number;
        \\"testCaseId\\"?: string | null;
    }
}
",
                "name": "RecordedResponseNotification.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const RecordedTestCaseUpdate: core.schemas.ObjectSchema<RecordedTestCaseUpdate.Raw, MyApi.submission.RecordedTestCaseUpdate> = core.schemas.object({
        testCaseId: schemas.v2.problem.TestCaseId,
        traceResponsesSize: core.schemas.number()
    });

export declare namespace RecordedTestCaseUpdate {
    interface Raw {
        \\"testCaseId\\": schemas.v2.problem.TestCaseId.Raw;
        \\"traceResponsesSize\\": number;
    }
}
",
                "name": "RecordedTestCaseUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const RecordingResponseNotification: core.schemas.ObjectSchema<RecordingResponseNotification.Raw, MyApi.submission.RecordingResponseNotification> = core.schemas.object({
        submissionId: schemas.submission.SubmissionId,
        testCaseId: core.schemas.string().optional(),
        lineNumber: core.schemas.number(),
        lightweightStackInfo: schemas.submission.LightweightStackframeInformation,
        tracedFile: schemas.submission.TracedFile.optional()
    });

export declare namespace RecordingResponseNotification {
    interface Raw {
        \\"submissionId\\": schemas.submission.SubmissionId.Raw;
        \\"testCaseId\\"?: string | null;
        \\"lineNumber\\": number;
        \\"lightweightStackInfo\\": schemas.submission.LightweightStackframeInformation.Raw;
        \\"tracedFile\\"?: schemas.submission.TracedFile.Raw | null;
    }
}
",
                "name": "RecordingResponseNotification.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const RunningResponse: core.schemas.ObjectSchema<RunningResponse.Raw, MyApi.submission.RunningResponse> = core.schemas.object({
        submissionId: schemas.submission.SubmissionId,
        state: schemas.submission.RunningSubmissionState
    });

export declare namespace RunningResponse {
    interface Raw {
        \\"submissionId\\": schemas.submission.SubmissionId.Raw;
        \\"state\\": schemas.submission.RunningSubmissionState.Raw;
    }
}
",
                "name": "RunningResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const RunningSubmissionState: core.schemas.Schema<RunningSubmissionState.Raw, MyApi.submission.RunningSubmissionState> = core.schemas.string().transform<MyApi.submission.RunningSubmissionState>({
        parse: value => {
            switch (value) {
                case \\"QUEUEING_SUBMISSION\\": {
                    return MyApi.submission.RunningSubmissionState.QueueingSubmission();
                }
                case \\"KILLING_HISTORICAL_SUBMISSIONS\\": {
                    return MyApi.submission.RunningSubmissionState.KillingHistoricalSubmissions();
                }
                case \\"WRITING_SUBMISSION_TO_FILE\\": {
                    return MyApi.submission.RunningSubmissionState.WritingSubmissionToFile();
                }
                case \\"COMPILING_SUBMISSION\\": {
                    return MyApi.submission.RunningSubmissionState.CompilingSubmission();
                }
                case \\"RUNNING_SUBMISSION\\": {
                    return MyApi.submission.RunningSubmissionState.RunningSubmission();
                }
                default: {
                    return {
                        get: () => value,
                        visit: visitor => visitor._unknown(value)
                    };
                }
            }
        },
        json: value => value.get()
    });

export declare namespace RunningSubmissionState {
    type Raw = string;
}
",
                "name": "RunningSubmissionState.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const RuntimeError: core.schemas.ObjectSchema<RuntimeError.Raw, MyApi.submission.RuntimeError> = core.schemas.object({
        message: core.schemas.string()
    });

export declare namespace RuntimeError {
    interface Raw {
        \\"message\\": string;
    }
}
",
                "name": "RuntimeError.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";

export const Scope: core.schemas.ObjectSchema<Scope.Raw, MyApi.submission.Scope> = core.schemas.object({
        variables: core.schemas.record(core.schemas.string(), schemas.commons.DebugVariableValue)
    });

export declare namespace Scope {
    interface Raw {
        \\"variables\\": Record<string, schemas.commons.DebugVariableValue.Raw>;
    }
}
",
                "name": "Scope.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const ShareId: core.schemas.Schema<ShareId.Raw, MyApi.submission.ShareId> = core.schemas.string();

export declare namespace ShareId {
    type Raw = string;
}
",
                "name": "ShareId.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";

export const StackFrame: core.schemas.ObjectSchema<StackFrame.Raw, MyApi.submission.StackFrame> = core.schemas.object({
        methodName: core.schemas.string(),
        lineNumber: core.schemas.number(),
        scopes: core.schemas.list(schemas.submission.Scope)
    });

export declare namespace StackFrame {
    interface Raw {
        \\"methodName\\": string;
        \\"lineNumber\\": number;
        \\"scopes\\": schemas.submission.Scope.Raw[];
    }
}
",
                "name": "StackFrame.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";

export const StackInformation: core.schemas.ObjectSchema<StackInformation.Raw, MyApi.submission.StackInformation> = core.schemas.object({
        numStackFrames: core.schemas.number(),
        topStackFrame: schemas.submission.StackFrame.optional()
    });

export declare namespace StackInformation {
    interface Raw {
        \\"numStackFrames\\": number;
        \\"topStackFrame\\"?: schemas.submission.StackFrame.Raw | null;
    }
}
",
                "name": "StackInformation.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const StderrResponse: core.schemas.ObjectSchema<StderrResponse.Raw, MyApi.submission.StderrResponse> = core.schemas.object({
        submissionId: schemas.submission.SubmissionId,
        stderr: core.schemas.string()
    });

export declare namespace StderrResponse {
    interface Raw {
        \\"submissionId\\": schemas.submission.SubmissionId.Raw;
        \\"stderr\\": string;
    }
}
",
                "name": "StderrResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const StdoutResponse: core.schemas.ObjectSchema<StdoutResponse.Raw, MyApi.submission.StdoutResponse> = core.schemas.object({
        submissionId: schemas.submission.SubmissionId,
        stdout: core.schemas.string()
    });

export declare namespace StdoutResponse {
    interface Raw {
        \\"submissionId\\": schemas.submission.SubmissionId.Raw;
        \\"stdout\\": string;
    }
}
",
                "name": "StdoutResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const StopRequest: core.schemas.ObjectSchema<StopRequest.Raw, MyApi.submission.StopRequest> = core.schemas.object({
        submissionId: schemas.submission.SubmissionId
    });

export declare namespace StopRequest {
    interface Raw {
        \\"submissionId\\": schemas.submission.SubmissionId.Raw;
    }
}
",
                "name": "StopRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const StoppedResponse: core.schemas.ObjectSchema<StoppedResponse.Raw, MyApi.submission.StoppedResponse> = core.schemas.object({
        submissionId: schemas.submission.SubmissionId
    });

export declare namespace StoppedResponse {
    interface Raw {
        \\"submissionId\\": schemas.submission.SubmissionId.Raw;
    }
}
",
                "name": "StoppedResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const SubmissionFileInfo: core.schemas.ObjectSchema<SubmissionFileInfo.Raw, MyApi.submission.SubmissionFileInfo> = core.schemas.object({
        directory: core.schemas.string(),
        filename: core.schemas.string(),
        contents: core.schemas.string()
    });

export declare namespace SubmissionFileInfo {
    interface Raw {
        \\"directory\\": string;
        \\"filename\\": string;
        \\"contents\\": string;
    }
}
",
                "name": "SubmissionFileInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const SubmissionId: core.schemas.Schema<SubmissionId.Raw, MyApi.submission.SubmissionId> = core.schemas.string();

export declare namespace SubmissionId {
    type Raw = string;
}
",
                "name": "SubmissionId.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const SubmissionIdNotFound: core.schemas.ObjectSchema<SubmissionIdNotFound.Raw, MyApi.submission.SubmissionIdNotFound> = core.schemas.object({
        missingSubmissionId: schemas.submission.SubmissionId
    });

export declare namespace SubmissionIdNotFound {
    interface Raw {
        \\"missingSubmissionId\\": schemas.submission.SubmissionId.Raw;
    }
}
",
                "name": "SubmissionIdNotFound.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const SubmissionRequest: core.schemas.Schema<SubmissionRequest.Raw, MyApi.submission.SubmissionRequest> = core.schemas.union(\\"type\\", {
        initializeProblemRequest: schemas.submission.InitializeProblemRequest,
        initializeWorkspaceRequest: core.schemas.object({}),
        submitV2: schemas.submission.SubmitRequestV2,
        workspaceSubmit: schemas.submission.WorkspaceSubmitRequest,
        stop: schemas.submission.StopRequest
    }).transform<MyApi.submission.SubmissionRequest>({
        parse: value => {
            switch (value.type) {
                case \\"initializeProblemRequest\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.initializeProblemRequest(value)
                    };
                }
                case \\"initializeWorkspaceRequest\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.initializeWorkspaceRequest()
                    };
                }
                case \\"submitV2\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.submitV2(value)
                    };
                }
                case \\"workspaceSubmit\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.workspaceSubmit(value)
                    };
                }
                case \\"stop\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.stop(value)
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace SubmissionRequest {
    type Raw = SubmissionRequest.InitializeProblemRequest | SubmissionRequest.InitializeWorkspaceRequest | SubmissionRequest.SubmitV2 | SubmissionRequest.WorkspaceSubmit | SubmissionRequest.Stop;

    interface InitializeProblemRequest extends schemas.submission.InitializeProblemRequest.Raw {
        type: \\"initializeProblemRequest\\";
    }

    interface InitializeWorkspaceRequest {
        type: \\"initializeWorkspaceRequest\\";
    }

    interface SubmitV2 extends schemas.submission.SubmitRequestV2.Raw {
        type: \\"submitV2\\";
    }

    interface WorkspaceSubmit extends schemas.submission.WorkspaceSubmitRequest.Raw {
        type: \\"workspaceSubmit\\";
    }

    interface Stop extends schemas.submission.StopRequest.Raw {
        type: \\"stop\\";
    }
}
",
                "name": "SubmissionRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const SubmissionResponse: core.schemas.Schema<SubmissionResponse.Raw, MyApi.submission.SubmissionResponse> = core.schemas.union(\\"type\\", {
        serverInitialized: core.schemas.object({}),
        problemInitialized: core.schemas.object({
            value: core.schemas.property(\\"problemInitialized\\", schemas.commons.ProblemId)
        }),
        workspaceInitialized: core.schemas.object({}),
        serverErrored: schemas.submission.ExceptionInfo,
        codeExecutionUpdate: core.schemas.object({
            value: core.schemas.property(\\"codeExecutionUpdate\\", schemas.submission.CodeExecutionUpdate)
        }),
        terminated: schemas.submission.TerminatedResponse
    }).transform<MyApi.submission.SubmissionResponse>({
        parse: value => {
            switch (value.type) {
                case \\"serverInitialized\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.serverInitialized()
                    };
                }
                case \\"problemInitialized\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.problemInitialized(value.value)
                    };
                }
                case \\"workspaceInitialized\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.workspaceInitialized()
                    };
                }
                case \\"serverErrored\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.serverErrored(value)
                    };
                }
                case \\"codeExecutionUpdate\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.codeExecutionUpdate(value.value)
                    };
                }
                case \\"terminated\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.terminated(value)
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace SubmissionResponse {
    type Raw = SubmissionResponse.ServerInitialized | SubmissionResponse.ProblemInitialized | SubmissionResponse.WorkspaceInitialized | SubmissionResponse.ServerErrored | SubmissionResponse.CodeExecutionUpdate | SubmissionResponse.Terminated;

    interface ServerInitialized {
        type: \\"serverInitialized\\";
    }

    interface ProblemInitialized {
        type: \\"problemInitialized\\";
        problemInitialized: schemas.commons.ProblemId.Raw;
    }

    interface WorkspaceInitialized {
        type: \\"workspaceInitialized\\";
    }

    interface ServerErrored extends schemas.submission.ExceptionInfo.Raw {
        type: \\"serverErrored\\";
    }

    interface CodeExecutionUpdate {
        type: \\"codeExecutionUpdate\\";
        codeExecutionUpdate: schemas.submission.CodeExecutionUpdate.Raw;
    }

    interface Terminated extends schemas.submission.TerminatedResponse.Raw {
        type: \\"terminated\\";
    }
}
",
                "name": "SubmissionResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const SubmissionStatusForTestCase: core.schemas.Schema<SubmissionStatusForTestCase.Raw, MyApi.submission.SubmissionStatusForTestCase> = core.schemas.union(\\"type\\", {
        graded: schemas.submission.TestCaseResultWithStdout,
        gradedV2: core.schemas.object({
            value: core.schemas.property(\\"gradedV2\\", schemas.submission.TestCaseGrade)
        }),
        traced: schemas.submission.TracedTestCase
    }).transform<MyApi.submission.SubmissionStatusForTestCase>({
        parse: value => {
            switch (value.type) {
                case \\"graded\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.graded(value)
                    };
                }
                case \\"gradedV2\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.gradedV2(value.value)
                    };
                }
                case \\"traced\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.traced(value)
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace SubmissionStatusForTestCase {
    type Raw = SubmissionStatusForTestCase.Graded | SubmissionStatusForTestCase.GradedV2 | SubmissionStatusForTestCase.Traced;

    interface Graded extends schemas.submission.TestCaseResultWithStdout.Raw {
        type: \\"graded\\";
    }

    interface GradedV2 {
        type: \\"gradedV2\\";
        gradedV2: schemas.submission.TestCaseGrade.Raw;
    }

    interface Traced extends schemas.submission.TracedTestCase.Raw {
        type: \\"traced\\";
    }
}
",
                "name": "SubmissionStatusForTestCase.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const SubmissionStatusV2: core.schemas.Schema<SubmissionStatusV2.Raw, MyApi.submission.SubmissionStatusV2> = core.schemas.union(\\"type\\", {
        test: schemas.submission.TestSubmissionStatusV2,
        workspace: schemas.submission.WorkspaceSubmissionStatusV2
    }).transform<MyApi.submission.SubmissionStatusV2>({
        parse: value => {
            switch (value.type) {
                case \\"test\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.test(value)
                    };
                }
                case \\"workspace\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.workspace(value)
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace SubmissionStatusV2 {
    type Raw = SubmissionStatusV2.Test | SubmissionStatusV2.Workspace;

    interface Test extends schemas.submission.TestSubmissionStatusV2.Raw {
        type: \\"test\\";
    }

    interface Workspace extends schemas.submission.WorkspaceSubmissionStatusV2.Raw {
        type: \\"workspace\\";
    }
}
",
                "name": "SubmissionStatusV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const SubmissionTypeEnum: core.schemas.Schema<SubmissionTypeEnum.Raw, MyApi.submission.SubmissionTypeEnum> = core.schemas.string().transform<MyApi.submission.SubmissionTypeEnum>({
        parse: value => {
            switch (value) {
                case \\"TEST\\": {
                    return MyApi.submission.SubmissionTypeEnum.Test();
                }
                default: {
                    return {
                        get: () => value,
                        visit: visitor => visitor._unknown(value)
                    };
                }
            }
        },
        json: value => value.get()
    });

export declare namespace SubmissionTypeEnum {
    type Raw = string;
}
",
                "name": "SubmissionTypeEnum.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const SubmissionTypeState: core.schemas.Schema<SubmissionTypeState.Raw, MyApi.submission.SubmissionTypeState> = core.schemas.union(\\"type\\", {
        test: schemas.submission.TestSubmissionState,
        workspace: schemas.submission.WorkspaceSubmissionState
    }).transform<MyApi.submission.SubmissionTypeState>({
        parse: value => {
            switch (value.type) {
                case \\"test\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.test(value)
                    };
                }
                case \\"workspace\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.workspace(value)
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace SubmissionTypeState {
    type Raw = SubmissionTypeState.Test | SubmissionTypeState.Workspace;

    interface Test extends schemas.submission.TestSubmissionState.Raw {
        type: \\"test\\";
    }

    interface Workspace extends schemas.submission.WorkspaceSubmissionState.Raw {
        type: \\"workspace\\";
    }
}
",
                "name": "SubmissionTypeState.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const SubmitRequestV2: core.schemas.ObjectSchema<SubmitRequestV2.Raw, MyApi.submission.SubmitRequestV2> = core.schemas.object({
        submissionId: schemas.submission.SubmissionId,
        language: schemas.commons.Language,
        submissionFiles: core.schemas.list(schemas.submission.SubmissionFileInfo),
        problemId: schemas.commons.ProblemId,
        problemVersion: core.schemas.number().optional(),
        userId: core.schemas.string().optional()
    });

export declare namespace SubmitRequestV2 {
    interface Raw {
        \\"submissionId\\": schemas.submission.SubmissionId.Raw;
        \\"language\\": schemas.commons.Language.Raw;
        \\"submissionFiles\\": schemas.submission.SubmissionFileInfo.Raw[];
        \\"problemId\\": schemas.commons.ProblemId.Raw;
        \\"problemVersion\\"?: number | null;
        \\"userId\\"?: string | null;
    }
}
",
                "name": "SubmitRequestV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const TerminatedResponse: core.schemas.ObjectSchema<TerminatedResponse.Raw, MyApi.submission.TerminatedResponse> = core.schemas.object({});

export declare namespace TerminatedResponse {
    interface Raw {
    }
}
",
                "name": "TerminatedResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const TestCaseGrade: core.schemas.Schema<TestCaseGrade.Raw, MyApi.submission.TestCaseGrade> = core.schemas.union(\\"type\\", {
        hidden: schemas.submission.TestCaseHiddenGrade,
        nonHidden: schemas.submission.TestCaseNonHiddenGrade
    }).transform<MyApi.submission.TestCaseGrade>({
        parse: value => {
            switch (value.type) {
                case \\"hidden\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.hidden(value)
                    };
                }
                case \\"nonHidden\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.nonHidden(value)
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace TestCaseGrade {
    type Raw = TestCaseGrade.Hidden | TestCaseGrade.NonHidden;

    interface Hidden extends schemas.submission.TestCaseHiddenGrade.Raw {
        type: \\"hidden\\";
    }

    interface NonHidden extends schemas.submission.TestCaseNonHiddenGrade.Raw {
        type: \\"nonHidden\\";
    }
}
",
                "name": "TestCaseGrade.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const TestCaseHiddenGrade: core.schemas.ObjectSchema<TestCaseHiddenGrade.Raw, MyApi.submission.TestCaseHiddenGrade> = core.schemas.object({
        passed: core.schemas.boolean()
    });

export declare namespace TestCaseHiddenGrade {
    interface Raw {
        \\"passed\\": boolean;
    }
}
",
                "name": "TestCaseHiddenGrade.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";

export const TestCaseNonHiddenGrade: core.schemas.ObjectSchema<TestCaseNonHiddenGrade.Raw, MyApi.submission.TestCaseNonHiddenGrade> = core.schemas.object({
        passed: core.schemas.boolean(),
        actualResult: schemas.commons.VariableValue.optional(),
        exception: schemas.submission.ExceptionV2.optional(),
        stdout: core.schemas.string()
    });

export declare namespace TestCaseNonHiddenGrade {
    interface Raw {
        \\"passed\\": boolean;
        \\"actualResult\\"?: schemas.commons.VariableValue.Raw | null;
        \\"exception\\"?: schemas.submission.ExceptionV2.Raw | null;
        \\"stdout\\": string;
    }
}
",
                "name": "TestCaseNonHiddenGrade.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const TestCaseResult: core.schemas.ObjectSchema<TestCaseResult.Raw, MyApi.submission.TestCaseResult> = core.schemas.object({
        expectedResult: schemas.commons.VariableValue,
        actualResult: schemas.submission.ActualResult,
        passed: core.schemas.boolean()
    });

export declare namespace TestCaseResult {
    interface Raw {
        \\"expectedResult\\": schemas.commons.VariableValue.Raw;
        \\"actualResult\\": schemas.submission.ActualResult.Raw;
        \\"passed\\": boolean;
    }
}
",
                "name": "TestCaseResult.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const TestCaseResultWithStdout: core.schemas.ObjectSchema<TestCaseResultWithStdout.Raw, MyApi.submission.TestCaseResultWithStdout> = core.schemas.object({
        result: schemas.submission.TestCaseResult,
        stdout: core.schemas.string()
    });

export declare namespace TestCaseResultWithStdout {
    interface Raw {
        \\"result\\": schemas.submission.TestCaseResult.Raw;
        \\"stdout\\": string;
    }
}
",
                "name": "TestCaseResultWithStdout.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const TestSubmissionState: core.schemas.ObjectSchema<TestSubmissionState.Raw, MyApi.submission.TestSubmissionState> = core.schemas.object({
        problemId: schemas.commons.ProblemId,
        defaultTestCases: core.schemas.list(schemas.commons.TestCase),
        customTestCases: core.schemas.list(schemas.commons.TestCase),
        status: schemas.submission.TestSubmissionStatus
    });

export declare namespace TestSubmissionState {
    interface Raw {
        \\"problemId\\": schemas.commons.ProblemId.Raw;
        \\"defaultTestCases\\": schemas.commons.TestCase.Raw[];
        \\"customTestCases\\": schemas.commons.TestCase.Raw[];
        \\"status\\": schemas.submission.TestSubmissionStatus.Raw;
    }
}
",
                "name": "TestSubmissionState.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const TestSubmissionStatus: core.schemas.Schema<TestSubmissionStatus.Raw, MyApi.submission.TestSubmissionStatus> = core.schemas.union(\\"type\\", {
        stopped: core.schemas.object({}),
        errored: core.schemas.object({
            value: core.schemas.property(\\"errored\\", schemas.submission.ErrorInfo)
        }),
        running: core.schemas.object({
            value: core.schemas.property(\\"running\\", schemas.submission.RunningSubmissionState)
        }),
        testCaseIdToState: core.schemas.object({
            value: core.schemas.property(\\"testCaseIdToState\\", core.schemas.record(core.schemas.string(), schemas.submission.SubmissionStatusForTestCase))
        })
    }).transform<MyApi.submission.TestSubmissionStatus>({
        parse: value => {
            switch (value.type) {
                case \\"stopped\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.stopped()
                    };
                }
                case \\"errored\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.errored(value.value)
                    };
                }
                case \\"running\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.running(value.value)
                    };
                }
                case \\"testCaseIdToState\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.testCaseIdToState(value.value)
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace TestSubmissionStatus {
    type Raw = TestSubmissionStatus.Stopped | TestSubmissionStatus.Errored | TestSubmissionStatus.Running | TestSubmissionStatus.TestCaseIdToState;

    interface Stopped {
        type: \\"stopped\\";
    }

    interface Errored {
        type: \\"errored\\";
        errored: schemas.submission.ErrorInfo.Raw;
    }

    interface Running {
        type: \\"running\\";
        running: schemas.submission.RunningSubmissionState.Raw;
    }

    interface TestCaseIdToState {
        type: \\"testCaseIdToState\\";
        testCaseIdToState: Record<string, schemas.submission.SubmissionStatusForTestCase.Raw>;
    }
}
",
                "name": "TestSubmissionStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const TestSubmissionStatusV2: core.schemas.ObjectSchema<TestSubmissionStatusV2.Raw, MyApi.submission.TestSubmissionStatusV2> = core.schemas.object({
        updates: core.schemas.list(schemas.submission.TestSubmissionUpdate),
        problemId: schemas.commons.ProblemId,
        problemVersion: core.schemas.number(),
        problemInfo: schemas.v2.problem.ProblemInfoV2
    });

export declare namespace TestSubmissionStatusV2 {
    interface Raw {
        \\"updates\\": schemas.submission.TestSubmissionUpdate.Raw[];
        \\"problemId\\": schemas.commons.ProblemId.Raw;
        \\"problemVersion\\": number;
        \\"problemInfo\\": schemas.v2.problem.ProblemInfoV2.Raw;
    }
}
",
                "name": "TestSubmissionStatusV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";

export const TestSubmissionUpdate: core.schemas.ObjectSchema<TestSubmissionUpdate.Raw, MyApi.submission.TestSubmissionUpdate> = core.schemas.object({
        updateTime: core.schemas.string(),
        updateInfo: schemas.submission.TestSubmissionUpdateInfo
    });

export declare namespace TestSubmissionUpdate {
    interface Raw {
        \\"updateTime\\": string;
        \\"updateInfo\\": schemas.submission.TestSubmissionUpdateInfo.Raw;
    }
}
",
                "name": "TestSubmissionUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const TestSubmissionUpdateInfo: core.schemas.Schema<TestSubmissionUpdateInfo.Raw, MyApi.submission.TestSubmissionUpdateInfo> = core.schemas.union(\\"type\\", {
        running: core.schemas.object({
            value: core.schemas.property(\\"running\\", schemas.submission.RunningSubmissionState)
        }),
        stopped: core.schemas.object({}),
        errored: core.schemas.object({
            value: core.schemas.property(\\"errored\\", schemas.submission.ErrorInfo)
        }),
        gradedTestCase: schemas.submission.GradedTestCaseUpdate,
        recordedTestCase: schemas.submission.RecordedTestCaseUpdate,
        finished: core.schemas.object({})
    }).transform<MyApi.submission.TestSubmissionUpdateInfo>({
        parse: value => {
            switch (value.type) {
                case \\"running\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.running(value.value)
                    };
                }
                case \\"stopped\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.stopped()
                    };
                }
                case \\"errored\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.errored(value.value)
                    };
                }
                case \\"gradedTestCase\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.gradedTestCase(value)
                    };
                }
                case \\"recordedTestCase\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.recordedTestCase(value)
                    };
                }
                case \\"finished\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.finished()
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace TestSubmissionUpdateInfo {
    type Raw = TestSubmissionUpdateInfo.Running | TestSubmissionUpdateInfo.Stopped | TestSubmissionUpdateInfo.Errored | TestSubmissionUpdateInfo.GradedTestCase | TestSubmissionUpdateInfo.RecordedTestCase | TestSubmissionUpdateInfo.Finished;

    interface Running {
        type: \\"running\\";
        running: schemas.submission.RunningSubmissionState.Raw;
    }

    interface Stopped {
        type: \\"stopped\\";
    }

    interface Errored {
        type: \\"errored\\";
        errored: schemas.submission.ErrorInfo.Raw;
    }

    interface GradedTestCase extends schemas.submission.GradedTestCaseUpdate.Raw {
        type: \\"gradedTestCase\\";
    }

    interface RecordedTestCase extends schemas.submission.RecordedTestCaseUpdate.Raw {
        type: \\"recordedTestCase\\";
    }

    interface Finished {
        type: \\"finished\\";
    }
}
",
                "name": "TestSubmissionUpdateInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const TraceResponse: core.schemas.ObjectSchema<TraceResponse.Raw, MyApi.submission.TraceResponse> = core.schemas.object({
        submissionId: schemas.submission.SubmissionId,
        lineNumber: core.schemas.number(),
        returnValue: schemas.commons.DebugVariableValue.optional(),
        expressionLocation: schemas.submission.ExpressionLocation.optional(),
        stack: schemas.submission.StackInformation,
        stdout: core.schemas.string().optional()
    });

export declare namespace TraceResponse {
    interface Raw {
        \\"submissionId\\": schemas.submission.SubmissionId.Raw;
        \\"lineNumber\\": number;
        \\"returnValue\\"?: schemas.commons.DebugVariableValue.Raw | null;
        \\"expressionLocation\\"?: schemas.submission.ExpressionLocation.Raw | null;
        \\"stack\\": schemas.submission.StackInformation.Raw;
        \\"stdout\\"?: string | null;
    }
}
",
                "name": "TraceResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const TraceResponseV2: core.schemas.ObjectSchema<TraceResponseV2.Raw, MyApi.submission.TraceResponseV2> = core.schemas.object({
        submissionId: schemas.submission.SubmissionId,
        lineNumber: core.schemas.number(),
        file: schemas.submission.TracedFile,
        returnValue: schemas.commons.DebugVariableValue.optional(),
        expressionLocation: schemas.submission.ExpressionLocation.optional(),
        stack: schemas.submission.StackInformation,
        stdout: core.schemas.string().optional()
    });

export declare namespace TraceResponseV2 {
    interface Raw {
        \\"submissionId\\": schemas.submission.SubmissionId.Raw;
        \\"lineNumber\\": number;
        \\"file\\": schemas.submission.TracedFile.Raw;
        \\"returnValue\\"?: schemas.commons.DebugVariableValue.Raw | null;
        \\"expressionLocation\\"?: schemas.submission.ExpressionLocation.Raw | null;
        \\"stack\\": schemas.submission.StackInformation.Raw;
        \\"stdout\\"?: string | null;
    }
}
",
                "name": "TraceResponseV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";

export const TraceResponsesPage: core.schemas.ObjectSchema<TraceResponsesPage.Raw, MyApi.submission.TraceResponsesPage> = core.schemas.object({
        offset: core.schemas.number().optional(),
        traceResponses: core.schemas.list(schemas.submission.TraceResponse)
    });

export declare namespace TraceResponsesPage {
    interface Raw {
        \\"offset\\"?: number | null;
        \\"traceResponses\\": schemas.submission.TraceResponse.Raw[];
    }
}
",
                "name": "TraceResponsesPage.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";

export const TraceResponsesPageV2: core.schemas.ObjectSchema<TraceResponsesPageV2.Raw, MyApi.submission.TraceResponsesPageV2> = core.schemas.object({
        offset: core.schemas.number().optional(),
        traceResponses: core.schemas.list(schemas.submission.TraceResponseV2)
    });

export declare namespace TraceResponsesPageV2 {
    interface Raw {
        \\"offset\\"?: number | null;
        \\"traceResponses\\": schemas.submission.TraceResponseV2.Raw[];
    }
}
",
                "name": "TraceResponsesPageV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const TracedFile: core.schemas.ObjectSchema<TracedFile.Raw, MyApi.submission.TracedFile> = core.schemas.object({
        filename: core.schemas.string(),
        directory: core.schemas.string()
    });

export declare namespace TracedFile {
    interface Raw {
        \\"filename\\": string;
        \\"directory\\": string;
    }
}
",
                "name": "TracedFile.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const TracedTestCase: core.schemas.ObjectSchema<TracedTestCase.Raw, MyApi.submission.TracedTestCase> = core.schemas.object({
        result: schemas.submission.TestCaseResultWithStdout,
        traceResponsesSize: core.schemas.number()
    });

export declare namespace TracedTestCase {
    interface Raw {
        \\"result\\": schemas.submission.TestCaseResultWithStdout.Raw;
        \\"traceResponsesSize\\": number;
    }
}
",
                "name": "TracedTestCase.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const UnexpectedLanguageError: core.schemas.ObjectSchema<UnexpectedLanguageError.Raw, MyApi.submission.UnexpectedLanguageError> = core.schemas.object({
        expectedLanguage: schemas.commons.Language,
        actualLanguage: schemas.commons.Language
    });

export declare namespace UnexpectedLanguageError {
    interface Raw {
        \\"expectedLanguage\\": schemas.commons.Language.Raw;
        \\"actualLanguage\\": schemas.commons.Language.Raw;
    }
}
",
                "name": "UnexpectedLanguageError.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const WorkspaceFiles: core.schemas.ObjectSchema<WorkspaceFiles.Raw, MyApi.submission.WorkspaceFiles> = core.schemas.object({
        mainFile: schemas.commons.FileInfo,
        readOnlyFiles: core.schemas.list(schemas.commons.FileInfo)
    });

export declare namespace WorkspaceFiles {
    interface Raw {
        \\"mainFile\\": schemas.commons.FileInfo.Raw;
        \\"readOnlyFiles\\": schemas.commons.FileInfo.Raw[];
    }
}
",
                "name": "WorkspaceFiles.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const WorkspaceRanResponse: core.schemas.ObjectSchema<WorkspaceRanResponse.Raw, MyApi.submission.WorkspaceRanResponse> = core.schemas.object({
        submissionId: schemas.submission.SubmissionId,
        runDetails: schemas.submission.WorkspaceRunDetails
    });

export declare namespace WorkspaceRanResponse {
    interface Raw {
        \\"submissionId\\": schemas.submission.SubmissionId.Raw;
        \\"runDetails\\": schemas.submission.WorkspaceRunDetails.Raw;
    }
}
",
                "name": "WorkspaceRanResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const WorkspaceRunDetails: core.schemas.ObjectSchema<WorkspaceRunDetails.Raw, MyApi.submission.WorkspaceRunDetails> = core.schemas.object({
        exceptionV2: schemas.submission.ExceptionV2.optional(),
        exception: schemas.submission.ExceptionInfo.optional(),
        stdout: core.schemas.string()
    });

export declare namespace WorkspaceRunDetails {
    interface Raw {
        \\"exceptionV2\\"?: schemas.submission.ExceptionV2.Raw | null;
        \\"exception\\"?: schemas.submission.ExceptionInfo.Raw | null;
        \\"stdout\\": string;
    }
}
",
                "name": "WorkspaceRunDetails.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";

export const WorkspaceStarterFilesResponse: core.schemas.ObjectSchema<WorkspaceStarterFilesResponse.Raw, MyApi.submission.WorkspaceStarterFilesResponse> = core.schemas.object({
        files: core.schemas.record(core.schemas.string(), schemas.submission.WorkspaceFiles)
    });

export declare namespace WorkspaceStarterFilesResponse {
    interface Raw {
        \\"files\\": Record<schemas.commons.Language.Raw, schemas.submission.WorkspaceFiles.Raw>;
    }
}
",
                "name": "WorkspaceStarterFilesResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";

export const WorkspaceStarterFilesResponseV2: core.schemas.ObjectSchema<WorkspaceStarterFilesResponseV2.Raw, MyApi.submission.WorkspaceStarterFilesResponseV2> = core.schemas.object({
        filesByLanguage: core.schemas.record(core.schemas.string(), schemas.v2.problem.Files)
    });

export declare namespace WorkspaceStarterFilesResponseV2 {
    interface Raw {
        \\"filesByLanguage\\": Record<schemas.commons.Language.Raw, schemas.v2.problem.Files.Raw>;
    }
}
",
                "name": "WorkspaceStarterFilesResponseV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const WorkspaceSubmissionState: core.schemas.ObjectSchema<WorkspaceSubmissionState.Raw, MyApi.submission.WorkspaceSubmissionState> = core.schemas.object({
        status: schemas.submission.WorkspaceSubmissionStatus
    });

export declare namespace WorkspaceSubmissionState {
    interface Raw {
        \\"status\\": schemas.submission.WorkspaceSubmissionStatus.Raw;
    }
}
",
                "name": "WorkspaceSubmissionState.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const WorkspaceSubmissionStatus: core.schemas.Schema<WorkspaceSubmissionStatus.Raw, MyApi.submission.WorkspaceSubmissionStatus> = core.schemas.union(\\"type\\", {
        stopped: core.schemas.object({}),
        errored: core.schemas.object({
            value: core.schemas.property(\\"errored\\", schemas.submission.ErrorInfo)
        }),
        running: core.schemas.object({
            value: core.schemas.property(\\"running\\", schemas.submission.RunningSubmissionState)
        }),
        ran: schemas.submission.WorkspaceRunDetails,
        traced: schemas.submission.WorkspaceRunDetails
    }).transform<MyApi.submission.WorkspaceSubmissionStatus>({
        parse: value => {
            switch (value.type) {
                case \\"stopped\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.stopped()
                    };
                }
                case \\"errored\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.errored(value.value)
                    };
                }
                case \\"running\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.running(value.value)
                    };
                }
                case \\"ran\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.ran(value)
                    };
                }
                case \\"traced\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.traced(value)
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace WorkspaceSubmissionStatus {
    type Raw = WorkspaceSubmissionStatus.Stopped | WorkspaceSubmissionStatus.Errored | WorkspaceSubmissionStatus.Running | WorkspaceSubmissionStatus.Ran | WorkspaceSubmissionStatus.Traced;

    interface Stopped {
        type: \\"stopped\\";
    }

    interface Errored {
        type: \\"errored\\";
        errored: schemas.submission.ErrorInfo.Raw;
    }

    interface Running {
        type: \\"running\\";
        running: schemas.submission.RunningSubmissionState.Raw;
    }

    interface Ran extends schemas.submission.WorkspaceRunDetails.Raw {
        type: \\"ran\\";
    }

    interface Traced extends schemas.submission.WorkspaceRunDetails.Raw {
        type: \\"traced\\";
    }
}
",
                "name": "WorkspaceSubmissionStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const WorkspaceSubmissionStatusV2: core.schemas.ObjectSchema<WorkspaceSubmissionStatusV2.Raw, MyApi.submission.WorkspaceSubmissionStatusV2> = core.schemas.object({
        updates: core.schemas.list(schemas.submission.WorkspaceSubmissionUpdate)
    });

export declare namespace WorkspaceSubmissionStatusV2 {
    interface Raw {
        \\"updates\\": schemas.submission.WorkspaceSubmissionUpdate.Raw[];
    }
}
",
                "name": "WorkspaceSubmissionStatusV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";

export const WorkspaceSubmissionUpdate: core.schemas.ObjectSchema<WorkspaceSubmissionUpdate.Raw, MyApi.submission.WorkspaceSubmissionUpdate> = core.schemas.object({
        updateTime: core.schemas.string(),
        updateInfo: schemas.submission.WorkspaceSubmissionUpdateInfo
    });

export declare namespace WorkspaceSubmissionUpdate {
    interface Raw {
        \\"updateTime\\": string;
        \\"updateInfo\\": schemas.submission.WorkspaceSubmissionUpdateInfo.Raw;
    }
}
",
                "name": "WorkspaceSubmissionUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const WorkspaceSubmissionUpdateInfo: core.schemas.Schema<WorkspaceSubmissionUpdateInfo.Raw, MyApi.submission.WorkspaceSubmissionUpdateInfo> = core.schemas.union(\\"type\\", {
        running: core.schemas.object({
            value: core.schemas.property(\\"running\\", schemas.submission.RunningSubmissionState)
        }),
        ran: schemas.submission.WorkspaceRunDetails,
        stopped: core.schemas.object({}),
        traced: core.schemas.object({}),
        tracedV2: schemas.submission.WorkspaceTracedUpdate,
        errored: core.schemas.object({
            value: core.schemas.property(\\"errored\\", schemas.submission.ErrorInfo)
        }),
        finished: core.schemas.object({})
    }).transform<MyApi.submission.WorkspaceSubmissionUpdateInfo>({
        parse: value => {
            switch (value.type) {
                case \\"running\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.running(value.value)
                    };
                }
                case \\"ran\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.ran(value)
                    };
                }
                case \\"stopped\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.stopped()
                    };
                }
                case \\"traced\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.traced()
                    };
                }
                case \\"tracedV2\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.tracedV2(value)
                    };
                }
                case \\"errored\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.errored(value.value)
                    };
                }
                case \\"finished\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.finished()
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace WorkspaceSubmissionUpdateInfo {
    type Raw = WorkspaceSubmissionUpdateInfo.Running | WorkspaceSubmissionUpdateInfo.Ran | WorkspaceSubmissionUpdateInfo.Stopped | WorkspaceSubmissionUpdateInfo.Traced | WorkspaceSubmissionUpdateInfo.TracedV2 | WorkspaceSubmissionUpdateInfo.Errored | WorkspaceSubmissionUpdateInfo.Finished;

    interface Running {
        type: \\"running\\";
        running: schemas.submission.RunningSubmissionState.Raw;
    }

    interface Ran extends schemas.submission.WorkspaceRunDetails.Raw {
        type: \\"ran\\";
    }

    interface Stopped {
        type: \\"stopped\\";
    }

    interface Traced {
        type: \\"traced\\";
    }

    interface TracedV2 extends schemas.submission.WorkspaceTracedUpdate.Raw {
        type: \\"tracedV2\\";
    }

    interface Errored {
        type: \\"errored\\";
        errored: schemas.submission.ErrorInfo.Raw;
    }

    interface Finished {
        type: \\"finished\\";
    }
}
",
                "name": "WorkspaceSubmissionUpdateInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const WorkspaceSubmitRequest: core.schemas.ObjectSchema<WorkspaceSubmitRequest.Raw, MyApi.submission.WorkspaceSubmitRequest> = core.schemas.object({
        submissionId: schemas.submission.SubmissionId,
        language: schemas.commons.Language,
        submissionFiles: core.schemas.list(schemas.submission.SubmissionFileInfo),
        userId: core.schemas.string().optional()
    });

export declare namespace WorkspaceSubmitRequest {
    interface Raw {
        \\"submissionId\\": schemas.submission.SubmissionId.Raw;
        \\"language\\": schemas.commons.Language.Raw;
        \\"submissionFiles\\": schemas.submission.SubmissionFileInfo.Raw[];
        \\"userId\\"?: string | null;
    }
}
",
                "name": "WorkspaceSubmitRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export const WorkspaceTracedUpdate: core.schemas.ObjectSchema<WorkspaceTracedUpdate.Raw, MyApi.submission.WorkspaceTracedUpdate> = core.schemas.object({
        traceResponsesSize: core.schemas.number()
    });

export declare namespace WorkspaceTracedUpdate {
    interface Raw {
        \\"traceResponsesSize\\": number;
    }
}
",
                "name": "WorkspaceTracedUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./SubmissionId\\";
export * from \\"./ShareId\\";
export * from \\"./SubmissionRequest\\";
export * from \\"./InitializeProblemRequest\\";
export * from \\"./SubmitRequestV2\\";
export * from \\"./WorkspaceSubmitRequest\\";
export * from \\"./SubmissionFileInfo\\";
export * from \\"./SubmissionTypeEnum\\";
export * from \\"./StopRequest\\";
export * from \\"./SubmissionResponse\\";
export * from \\"./CodeExecutionUpdate\\";
export * from \\"./BuildingExecutorResponse\\";
export * from \\"./RunningResponse\\";
export * from \\"./RunningSubmissionState\\";
export * from \\"./ErroredResponse\\";
export * from \\"./ErrorInfo\\";
export * from \\"./CompileError\\";
export * from \\"./RuntimeError\\";
export * from \\"./InternalError\\";
export * from \\"./StoppedResponse\\";
export * from \\"./WorkspaceRanResponse\\";
export * from \\"./WorkspaceRunDetails\\";
export * from \\"./GradedResponse\\";
export * from \\"./GradedResponseV2\\";
export * from \\"./TestCaseGrade\\";
export * from \\"./TestCaseHiddenGrade\\";
export * from \\"./TestCaseNonHiddenGrade\\";
export * from \\"./RecordedResponseNotification\\";
export * from \\"./RecordingResponseNotification\\";
export * from \\"./LightweightStackframeInformation\\";
export * from \\"./TestCaseResultWithStdout\\";
export * from \\"./TestCaseResult\\";
export * from \\"./ActualResult\\";
export * from \\"./ExceptionV2\\";
export * from \\"./ExceptionInfo\\";
export * from \\"./InvalidRequestResponse\\";
export * from \\"./InvalidRequestCause\\";
export * from \\"./ExistingSubmissionExecuting\\";
export * from \\"./SubmissionIdNotFound\\";
export * from \\"./CustomTestCasesUnsupported\\";
export * from \\"./UnexpectedLanguageError\\";
export * from \\"./TerminatedResponse\\";
export * from \\"./FinishedResponse\\";
export * from \\"./StdoutResponse\\";
export * from \\"./StderrResponse\\";
export * from \\"./TraceResponse\\";
export * from \\"./TraceResponseV2\\";
export * from \\"./TracedFile\\";
export * from \\"./ExpressionLocation\\";
export * from \\"./StackInformation\\";
export * from \\"./StackFrame\\";
export * from \\"./Scope\\";
export * from \\"./ExecutionSessionResponse\\";
export * from \\"./ExecutionSessionStatus\\";
export * from \\"./SubmissionStatusV2\\";
export * from \\"./TestSubmissionStatusV2\\";
export * from \\"./WorkspaceSubmissionStatusV2\\";
export * from \\"./TestSubmissionUpdate\\";
export * from \\"./TestSubmissionUpdateInfo\\";
export * from \\"./WorkspaceSubmissionUpdate\\";
export * from \\"./WorkspaceSubmissionUpdateInfo\\";
export * from \\"./GradedTestCaseUpdate\\";
export * from \\"./RecordedTestCaseUpdate\\";
export * from \\"./WorkspaceTracedUpdate\\";
export * from \\"./SubmissionTypeState\\";
export * from \\"./WorkspaceSubmissionState\\";
export * from \\"./WorkspaceSubmissionStatus\\";
export * from \\"./TestSubmissionState\\";
export * from \\"./TestSubmissionStatus\\";
export * from \\"./SubmissionStatusForTestCase\\";
export * from \\"./TracedTestCase\\";
export * from \\"./TraceResponsesPage\\";
export * from \\"./TraceResponsesPageV2\\";
export * from \\"./GetTraceResponsesPageRequest\\";
export * from \\"./WorkspaceStarterFilesResponse\\";
export * from \\"./WorkspaceStarterFilesResponseV2\\";
export * from \\"./WorkspaceFiles\\";
export * from \\"./ExecutionSessionState\\";
export * from \\"./GetExecutionSessionStateResponse\\";
export * from \\"./GetSubmissionStateResponse\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "submission",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * as problem from \\"./problem\\";
export * as v3 from \\"./v3\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import * as schemas from \\"../../..\\";
import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const AssertCorrectnessCheck: core.schemas.Schema<AssertCorrectnessCheck.Raw, MyApi.v2.problem.AssertCorrectnessCheck> = core.schemas.union(\\"type\\", {
        deepEquality: schemas.v2.problem.DeepEqualityCorrectnessCheck,
        custom: schemas.v2.problem.VoidFunctionDefinitionThatTakesActualResult
    }).transform<MyApi.v2.problem.AssertCorrectnessCheck>({
        parse: value => {
            switch (value.type) {
                case \\"deepEquality\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.deepEquality(value)
                    };
                }
                case \\"custom\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.custom(value)
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace AssertCorrectnessCheck {
    type Raw = AssertCorrectnessCheck.DeepEquality | AssertCorrectnessCheck.Custom;

    interface DeepEquality extends schemas.v2.problem.DeepEqualityCorrectnessCheck.Raw {
        type: \\"deepEquality\\";
    }

    interface Custom extends schemas.v2.problem.VoidFunctionDefinitionThatTakesActualResult.Raw {
        type: \\"custom\\";
    }
}
",
                    "name": "AssertCorrectnessCheck.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";
import { MyApi } from \\"../../../..\\";

export const BasicCustomFiles: core.schemas.ObjectSchema<BasicCustomFiles.Raw, MyApi.v2.problem.BasicCustomFiles> = core.schemas.object({
        methodName: core.schemas.string(),
        signature: schemas.v2.problem.NonVoidFunctionSignature,
        additionalFiles: core.schemas.record(core.schemas.string(), schemas.v2.problem.Files),
        basicTestCaseTemplate: schemas.v2.problem.BasicTestCaseTemplate
    });

export declare namespace BasicCustomFiles {
    interface Raw {
        \\"methodName\\": string;
        \\"signature\\": schemas.v2.problem.NonVoidFunctionSignature.Raw;
        \\"additionalFiles\\": Record<schemas.commons.Language.Raw, schemas.v2.problem.Files.Raw>;
        \\"basicTestCaseTemplate\\": schemas.v2.problem.BasicTestCaseTemplate.Raw;
    }
}
",
                    "name": "BasicCustomFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as schemas from \\"../../..\\";
import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const BasicTestCaseTemplate: core.schemas.ObjectSchema<BasicTestCaseTemplate.Raw, MyApi.v2.problem.BasicTestCaseTemplate> = core.schemas.object({
        templateId: schemas.v2.problem.TestCaseTemplateId,
        name: core.schemas.string(),
        description: schemas.v2.problem.TestCaseImplementationDescription,
        expectedValueParameterId: schemas.v2.problem.ParameterId
    });

export declare namespace BasicTestCaseTemplate {
    interface Raw {
        \\"templateId\\": schemas.v2.problem.TestCaseTemplateId.Raw;
        \\"name\\": string;
        \\"description\\": schemas.v2.problem.TestCaseImplementationDescription.Raw;
        \\"expectedValueParameterId\\": schemas.v2.problem.ParameterId.Raw;
    }
}
",
                    "name": "BasicTestCaseTemplate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";
import { MyApi } from \\"../../../..\\";

export const CreateProblemRequestV2: core.schemas.ObjectSchema<CreateProblemRequestV2.Raw, MyApi.v2.problem.CreateProblemRequestV2> = core.schemas.object({
        problemName: core.schemas.string(),
        problemDescription: schemas.problem.ProblemDescription,
        customFiles: schemas.v2.problem.CustomFiles,
        customTestCaseTemplates: core.schemas.list(schemas.v2.problem.TestCaseTemplate),
        testcases: core.schemas.list(schemas.v2.problem.TestCaseV2),
        supportedLanguages: core.schemas.list(schemas.commons.Language),
        isPublic: core.schemas.boolean()
    });

export declare namespace CreateProblemRequestV2 {
    interface Raw {
        \\"problemName\\": string;
        \\"problemDescription\\": schemas.problem.ProblemDescription.Raw;
        \\"customFiles\\": schemas.v2.problem.CustomFiles.Raw;
        \\"customTestCaseTemplates\\": schemas.v2.problem.TestCaseTemplate.Raw[];
        \\"testcases\\": schemas.v2.problem.TestCaseV2.Raw[];
        \\"supportedLanguages\\": schemas.commons.Language.Raw[];
        \\"isPublic\\": boolean;
    }
}
",
                    "name": "CreateProblemRequestV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as schemas from \\"../../..\\";
import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const CustomFiles: core.schemas.Schema<CustomFiles.Raw, MyApi.v2.problem.CustomFiles> = core.schemas.union(\\"type\\", {
        basic: schemas.v2.problem.BasicCustomFiles,
        custom: core.schemas.object({
            value: core.schemas.property(\\"custom\\", core.schemas.record(core.schemas.string(), schemas.v2.problem.Files))
        })
    }).transform<MyApi.v2.problem.CustomFiles>({
        parse: value => {
            switch (value.type) {
                case \\"basic\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.basic(value)
                    };
                }
                case \\"custom\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.custom(value.value)
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace CustomFiles {
    type Raw = CustomFiles.Basic | CustomFiles.Custom;

    interface Basic extends schemas.v2.problem.BasicCustomFiles.Raw {
        type: \\"basic\\";
    }

    interface Custom {
        type: \\"custom\\";
        custom: Record<schemas.commons.Language.Raw, schemas.v2.problem.Files.Raw>;
    }
}
",
                    "name": "CustomFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as schemas from \\"../../..\\";
import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const DeepEqualityCorrectnessCheck: core.schemas.ObjectSchema<DeepEqualityCorrectnessCheck.Raw, MyApi.v2.problem.DeepEqualityCorrectnessCheck> = core.schemas.object({
        expectedValueParameterId: schemas.v2.problem.ParameterId
    });

export declare namespace DeepEqualityCorrectnessCheck {
    interface Raw {
        \\"expectedValueParameterId\\": schemas.v2.problem.ParameterId.Raw;
    }
}
",
                    "name": "DeepEqualityCorrectnessCheck.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as schemas from \\"../../..\\";
import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const DefaultProvidedFile: core.schemas.ObjectSchema<DefaultProvidedFile.Raw, MyApi.v2.problem.DefaultProvidedFile> = core.schemas.object({
        file: schemas.v2.problem.FileInfoV2,
        relatedTypes: core.schemas.list(schemas.commons.VariableType)
    });

export declare namespace DefaultProvidedFile {
    interface Raw {
        \\"file\\": schemas.v2.problem.FileInfoV2.Raw;
        \\"relatedTypes\\": schemas.commons.VariableType.Raw[];
    }
}
",
                    "name": "DefaultProvidedFile.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const FileInfoV2: core.schemas.ObjectSchema<FileInfoV2.Raw, MyApi.v2.problem.FileInfoV2> = core.schemas.object({
        filename: core.schemas.string(),
        directory: core.schemas.string(),
        contents: core.schemas.string(),
        editable: core.schemas.boolean()
    });

export declare namespace FileInfoV2 {
    interface Raw {
        \\"filename\\": string;
        \\"directory\\": string;
        \\"contents\\": string;
        \\"editable\\": boolean;
    }
}
",
                    "name": "FileInfoV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as schemas from \\"../../..\\";
import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const Files: core.schemas.ObjectSchema<Files.Raw, MyApi.v2.problem.Files> = core.schemas.object({
        files: core.schemas.list(schemas.v2.problem.FileInfoV2)
    });

export declare namespace Files {
    interface Raw {
        \\"files\\": schemas.v2.problem.FileInfoV2.Raw[];
    }
}
",
                    "name": "Files.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const FunctionImplementation: core.schemas.ObjectSchema<FunctionImplementation.Raw, MyApi.v2.problem.FunctionImplementation> = core.schemas.object({
        impl: core.schemas.string(),
        imports: core.schemas.string().optional()
    });

export declare namespace FunctionImplementation {
    interface Raw {
        \\"impl\\": string;
        \\"imports\\"?: string | null;
    }
}
",
                    "name": "FunctionImplementation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";
import { MyApi } from \\"../../../..\\";

export const FunctionImplementationForMultipleLanguages: core.schemas.ObjectSchema<FunctionImplementationForMultipleLanguages.Raw, MyApi.v2.problem.FunctionImplementationForMultipleLanguages> = core.schemas.object({
        codeByLanguage: core.schemas.record(core.schemas.string(), schemas.v2.problem.FunctionImplementation)
    });

export declare namespace FunctionImplementationForMultipleLanguages {
    interface Raw {
        \\"codeByLanguage\\": Record<schemas.commons.Language.Raw, schemas.v2.problem.FunctionImplementation.Raw>;
    }
}
",
                    "name": "FunctionImplementationForMultipleLanguages.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as schemas from \\"../../..\\";
import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const FunctionSignature: core.schemas.Schema<FunctionSignature.Raw, MyApi.v2.problem.FunctionSignature> = core.schemas.union(\\"type\\", {
        void: schemas.v2.problem.VoidFunctionSignature,
        nonVoid: schemas.v2.problem.NonVoidFunctionSignature,
        voidThatTakesActualResult: schemas.v2.problem.VoidFunctionSignatureThatTakesActualResult
    }).transform<MyApi.v2.problem.FunctionSignature>({
        parse: value => {
            switch (value.type) {
                case \\"void\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.void(value)
                    };
                }
                case \\"nonVoid\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.nonVoid(value)
                    };
                }
                case \\"voidThatTakesActualResult\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.voidThatTakesActualResult(value)
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace FunctionSignature {
    type Raw = FunctionSignature.Void | FunctionSignature.NonVoid | FunctionSignature.VoidThatTakesActualResult;

    interface Void extends schemas.v2.problem.VoidFunctionSignature.Raw {
        type: \\"void\\";
    }

    interface NonVoid extends schemas.v2.problem.NonVoidFunctionSignature.Raw {
        type: \\"nonVoid\\";
    }

    interface VoidThatTakesActualResult extends schemas.v2.problem.VoidFunctionSignatureThatTakesActualResult.Raw {
        type: \\"voidThatTakesActualResult\\";
    }
}
",
                    "name": "FunctionSignature.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";
import { MyApi } from \\"../../../..\\";

export const GeneratedFiles: core.schemas.ObjectSchema<GeneratedFiles.Raw, MyApi.v2.problem.GeneratedFiles> = core.schemas.object({
        generatedTestCaseFiles: core.schemas.record(core.schemas.string(), schemas.v2.problem.Files),
        generatedTemplateFiles: core.schemas.record(core.schemas.string(), schemas.v2.problem.Files),
        other: core.schemas.record(core.schemas.string(), schemas.v2.problem.Files)
    });

export declare namespace GeneratedFiles {
    interface Raw {
        \\"generatedTestCaseFiles\\": Record<schemas.commons.Language.Raw, schemas.v2.problem.Files.Raw>;
        \\"generatedTemplateFiles\\": Record<schemas.commons.Language.Raw, schemas.v2.problem.Files.Raw>;
        \\"other\\": Record<schemas.commons.Language.Raw, schemas.v2.problem.Files.Raw>;
    }
}
",
                    "name": "GeneratedFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";
import { MyApi } from \\"../../../..\\";

export const GetBasicSolutionFileRequest: core.schemas.ObjectSchema<GetBasicSolutionFileRequest.Raw, MyApi.v2.problem.GetBasicSolutionFileRequest> = core.schemas.object({
        methodName: core.schemas.string(),
        signature: schemas.v2.problem.NonVoidFunctionSignature
    });

export declare namespace GetBasicSolutionFileRequest {
    interface Raw {
        \\"methodName\\": string;
        \\"signature\\": schemas.v2.problem.NonVoidFunctionSignature.Raw;
    }
}
",
                    "name": "GetBasicSolutionFileRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";
import { MyApi } from \\"../../../..\\";

export const GetBasicSolutionFileResponse: core.schemas.ObjectSchema<GetBasicSolutionFileResponse.Raw, MyApi.v2.problem.GetBasicSolutionFileResponse> = core.schemas.object({
        solutionFileByLanguage: core.schemas.record(core.schemas.string(), schemas.v2.problem.FileInfoV2)
    });

export declare namespace GetBasicSolutionFileResponse {
    interface Raw {
        \\"solutionFileByLanguage\\": Record<schemas.commons.Language.Raw, schemas.v2.problem.FileInfoV2.Raw>;
    }
}
",
                    "name": "GetBasicSolutionFileResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as schemas from \\"../../..\\";
import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const GetFunctionSignatureRequest: core.schemas.ObjectSchema<GetFunctionSignatureRequest.Raw, MyApi.v2.problem.GetFunctionSignatureRequest> = core.schemas.object({
        functionSignature: schemas.v2.problem.FunctionSignature
    });

export declare namespace GetFunctionSignatureRequest {
    interface Raw {
        \\"functionSignature\\": schemas.v2.problem.FunctionSignature.Raw;
    }
}
",
                    "name": "GetFunctionSignatureRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";
import * as schemas from \\"../../..\\";

export const GetFunctionSignatureResponse: core.schemas.ObjectSchema<GetFunctionSignatureResponse.Raw, MyApi.v2.problem.GetFunctionSignatureResponse> = core.schemas.object({
        functionByLanguage: core.schemas.record(core.schemas.string(), core.schemas.string())
    });

export declare namespace GetFunctionSignatureResponse {
    interface Raw {
        \\"functionByLanguage\\": Record<schemas.commons.Language.Raw, string>;
    }
}
",
                    "name": "GetFunctionSignatureResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as schemas from \\"../../..\\";
import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const GetGeneratedTestCaseFileRequest: core.schemas.ObjectSchema<GetGeneratedTestCaseFileRequest.Raw, MyApi.v2.problem.GetGeneratedTestCaseFileRequest> = core.schemas.object({
        template: schemas.v2.problem.TestCaseTemplate.optional(),
        testCase: schemas.v2.problem.TestCaseV2
    });

export declare namespace GetGeneratedTestCaseFileRequest {
    interface Raw {
        \\"template\\"?: schemas.v2.problem.TestCaseTemplate.Raw | null;
        \\"testCase\\": schemas.v2.problem.TestCaseV2.Raw;
    }
}
",
                    "name": "GetGeneratedTestCaseFileRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as schemas from \\"../../..\\";
import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const GetGeneratedTestCaseTemplateFileRequest: core.schemas.ObjectSchema<GetGeneratedTestCaseTemplateFileRequest.Raw, MyApi.v2.problem.GetGeneratedTestCaseTemplateFileRequest> = core.schemas.object({
        template: schemas.v2.problem.TestCaseTemplate
    });

export declare namespace GetGeneratedTestCaseTemplateFileRequest {
    interface Raw {
        \\"template\\": schemas.v2.problem.TestCaseTemplate.Raw;
    }
}
",
                    "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as schemas from \\"../../..\\";
import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const LightweightProblemInfoV2: core.schemas.ObjectSchema<LightweightProblemInfoV2.Raw, MyApi.v2.problem.LightweightProblemInfoV2> = core.schemas.object({
        problemId: schemas.commons.ProblemId,
        problemName: core.schemas.string(),
        problemVersion: core.schemas.number(),
        variableTypes: core.schemas.list(schemas.commons.VariableType)
    });

export declare namespace LightweightProblemInfoV2 {
    interface Raw {
        \\"problemId\\": schemas.commons.ProblemId.Raw;
        \\"problemName\\": string;
        \\"problemVersion\\": number;
        \\"variableTypes\\": schemas.commons.VariableType.Raw[];
    }
}
",
                    "name": "LightweightProblemInfoV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as schemas from \\"../../..\\";
import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const NonVoidFunctionDefinition: core.schemas.ObjectSchema<NonVoidFunctionDefinition.Raw, MyApi.v2.problem.NonVoidFunctionDefinition> = core.schemas.object({
        signature: schemas.v2.problem.NonVoidFunctionSignature,
        code: schemas.v2.problem.FunctionImplementationForMultipleLanguages
    });

export declare namespace NonVoidFunctionDefinition {
    interface Raw {
        \\"signature\\": schemas.v2.problem.NonVoidFunctionSignature.Raw;
        \\"code\\": schemas.v2.problem.FunctionImplementationForMultipleLanguages.Raw;
    }
}
",
                    "name": "NonVoidFunctionDefinition.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as schemas from \\"../../..\\";
import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const NonVoidFunctionSignature: core.schemas.ObjectSchema<NonVoidFunctionSignature.Raw, MyApi.v2.problem.NonVoidFunctionSignature> = core.schemas.object({
        parameters: core.schemas.list(schemas.v2.problem.Parameter),
        returnType: schemas.commons.VariableType
    });

export declare namespace NonVoidFunctionSignature {
    interface Raw {
        \\"parameters\\": schemas.v2.problem.Parameter.Raw[];
        \\"returnType\\": schemas.commons.VariableType.Raw;
    }
}
",
                    "name": "NonVoidFunctionSignature.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as schemas from \\"../../..\\";
import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const Parameter: core.schemas.ObjectSchema<Parameter.Raw, MyApi.v2.problem.Parameter> = core.schemas.object({
        parameterId: schemas.v2.problem.ParameterId,
        name: core.schemas.string(),
        variableType: schemas.commons.VariableType
    });

export declare namespace Parameter {
    interface Raw {
        \\"parameterId\\": schemas.v2.problem.ParameterId.Raw;
        \\"name\\": string;
        \\"variableType\\": schemas.commons.VariableType.Raw;
    }
}
",
                    "name": "Parameter.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const ParameterId: core.schemas.Schema<ParameterId.Raw, MyApi.v2.problem.ParameterId> = core.schemas.string();

export declare namespace ParameterId {
    type Raw = string;
}
",
                    "name": "ParameterId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as schemas from \\"../../..\\";
import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const ProblemInfoV2: core.schemas.ObjectSchema<ProblemInfoV2.Raw, MyApi.v2.problem.ProblemInfoV2> = core.schemas.object({
        problemId: schemas.commons.ProblemId,
        problemDescription: schemas.problem.ProblemDescription,
        problemName: core.schemas.string(),
        problemVersion: core.schemas.number(),
        supportedLanguages: core.schemas.list(schemas.commons.Language),
        customFiles: schemas.v2.problem.CustomFiles,
        generatedFiles: schemas.v2.problem.GeneratedFiles,
        customTestCaseTemplates: core.schemas.list(schemas.v2.problem.TestCaseTemplate),
        testcases: core.schemas.list(schemas.v2.problem.TestCaseV2),
        isPublic: core.schemas.boolean()
    });

export declare namespace ProblemInfoV2 {
    interface Raw {
        \\"problemId\\": schemas.commons.ProblemId.Raw;
        \\"problemDescription\\": schemas.problem.ProblemDescription.Raw;
        \\"problemName\\": string;
        \\"problemVersion\\": number;
        \\"supportedLanguages\\": schemas.commons.Language.Raw[];
        \\"customFiles\\": schemas.v2.problem.CustomFiles.Raw;
        \\"generatedFiles\\": schemas.v2.problem.GeneratedFiles.Raw;
        \\"customTestCaseTemplates\\": schemas.v2.problem.TestCaseTemplate.Raw[];
        \\"testcases\\": schemas.v2.problem.TestCaseV2.Raw[];
        \\"isPublic\\": boolean;
    }
}
",
                    "name": "ProblemInfoV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const TestCaseExpects: core.schemas.ObjectSchema<TestCaseExpects.Raw, MyApi.v2.problem.TestCaseExpects> = core.schemas.object({
        expectedStdout: core.schemas.string().optional()
    });

export declare namespace TestCaseExpects {
    interface Raw {
        \\"expectedStdout\\"?: string | null;
    }
}
",
                    "name": "TestCaseExpects.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as schemas from \\"../../..\\";
import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const TestCaseFunction: core.schemas.Schema<TestCaseFunction.Raw, MyApi.v2.problem.TestCaseFunction> = core.schemas.union(\\"type\\", {
        withActualResult: schemas.v2.problem.TestCaseWithActualResultImplementation,
        custom: schemas.v2.problem.VoidFunctionDefinition
    }).transform<MyApi.v2.problem.TestCaseFunction>({
        parse: value => {
            switch (value.type) {
                case \\"withActualResult\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.withActualResult(value)
                    };
                }
                case \\"custom\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.custom(value)
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace TestCaseFunction {
    type Raw = TestCaseFunction.WithActualResult | TestCaseFunction.Custom;

    interface WithActualResult extends schemas.v2.problem.TestCaseWithActualResultImplementation.Raw {
        type: \\"withActualResult\\";
    }

    interface Custom extends schemas.v2.problem.VoidFunctionDefinition.Raw {
        type: \\"custom\\";
    }
}
",
                    "name": "TestCaseFunction.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const TestCaseId: core.schemas.Schema<TestCaseId.Raw, MyApi.v2.problem.TestCaseId> = core.schemas.string();

export declare namespace TestCaseId {
    type Raw = string;
}
",
                    "name": "TestCaseId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as schemas from \\"../../..\\";
import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const TestCaseImplementation: core.schemas.ObjectSchema<TestCaseImplementation.Raw, MyApi.v2.problem.TestCaseImplementation> = core.schemas.object({
        description: schemas.v2.problem.TestCaseImplementationDescription,
        function: schemas.v2.problem.TestCaseFunction
    });

export declare namespace TestCaseImplementation {
    interface Raw {
        \\"description\\": schemas.v2.problem.TestCaseImplementationDescription.Raw;
        \\"function\\": schemas.v2.problem.TestCaseFunction.Raw;
    }
}
",
                    "name": "TestCaseImplementation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as schemas from \\"../../..\\";
import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const TestCaseImplementationDescription: core.schemas.ObjectSchema<TestCaseImplementationDescription.Raw, MyApi.v2.problem.TestCaseImplementationDescription> = core.schemas.object({
        boards: core.schemas.list(schemas.v2.problem.TestCaseImplementationDescriptionBoard)
    });

export declare namespace TestCaseImplementationDescription {
    interface Raw {
        \\"boards\\": schemas.v2.problem.TestCaseImplementationDescriptionBoard.Raw[];
    }
}
",
                    "name": "TestCaseImplementationDescription.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";
import { MyApi } from \\"../../../..\\";

export const TestCaseImplementationDescriptionBoard: core.schemas.Schema<TestCaseImplementationDescriptionBoard.Raw, MyApi.v2.problem.TestCaseImplementationDescriptionBoard> = core.schemas.union(\\"type\\", {
        html: core.schemas.object({
            value: core.schemas.property(\\"html\\", core.schemas.string())
        }),
        paramId: core.schemas.object({
            value: core.schemas.property(\\"paramId\\", schemas.v2.problem.ParameterId)
        })
    }).transform<MyApi.v2.problem.TestCaseImplementationDescriptionBoard>({
        parse: value => {
            switch (value.type) {
                case \\"html\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.html(value.value)
                    };
                }
                case \\"paramId\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.paramId(value.value)
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace TestCaseImplementationDescriptionBoard {
    type Raw = TestCaseImplementationDescriptionBoard.Html | TestCaseImplementationDescriptionBoard.ParamId;

    interface Html {
        type: \\"html\\";
        html: string;
    }

    interface ParamId {
        type: \\"paramId\\";
        paramId: schemas.v2.problem.ParameterId.Raw;
    }
}
",
                    "name": "TestCaseImplementationDescriptionBoard.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as schemas from \\"../../..\\";
import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const TestCaseImplementationReference: core.schemas.Schema<TestCaseImplementationReference.Raw, MyApi.v2.problem.TestCaseImplementationReference> = core.schemas.union(\\"type\\", {
        templateId: core.schemas.object({
            value: core.schemas.property(\\"templateId\\", schemas.v2.problem.TestCaseTemplateId)
        }),
        implementation: schemas.v2.problem.TestCaseImplementation
    }).transform<MyApi.v2.problem.TestCaseImplementationReference>({
        parse: value => {
            switch (value.type) {
                case \\"templateId\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.templateId(value.value)
                    };
                }
                case \\"implementation\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.implementation(value)
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace TestCaseImplementationReference {
    type Raw = TestCaseImplementationReference.TemplateId | TestCaseImplementationReference.Implementation;

    interface TemplateId {
        type: \\"templateId\\";
        templateId: schemas.v2.problem.TestCaseTemplateId.Raw;
    }

    interface Implementation extends schemas.v2.problem.TestCaseImplementation.Raw {
        type: \\"implementation\\";
    }
}
",
                    "name": "TestCaseImplementationReference.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as schemas from \\"../../..\\";
import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const TestCaseMetadata: core.schemas.ObjectSchema<TestCaseMetadata.Raw, MyApi.v2.problem.TestCaseMetadata> = core.schemas.object({
        id: schemas.v2.problem.TestCaseId,
        name: core.schemas.string(),
        hidden: core.schemas.boolean()
    });

export declare namespace TestCaseMetadata {
    interface Raw {
        \\"id\\": schemas.v2.problem.TestCaseId.Raw;
        \\"name\\": string;
        \\"hidden\\": boolean;
    }
}
",
                    "name": "TestCaseMetadata.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as schemas from \\"../../..\\";
import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const TestCaseTemplate: core.schemas.ObjectSchema<TestCaseTemplate.Raw, MyApi.v2.problem.TestCaseTemplate> = core.schemas.object({
        templateId: schemas.v2.problem.TestCaseTemplateId,
        name: core.schemas.string(),
        implementation: schemas.v2.problem.TestCaseImplementation
    });

export declare namespace TestCaseTemplate {
    interface Raw {
        \\"templateId\\": schemas.v2.problem.TestCaseTemplateId.Raw;
        \\"name\\": string;
        \\"implementation\\": schemas.v2.problem.TestCaseImplementation.Raw;
    }
}
",
                    "name": "TestCaseTemplate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const TestCaseTemplateId: core.schemas.Schema<TestCaseTemplateId.Raw, MyApi.v2.problem.TestCaseTemplateId> = core.schemas.string();

export declare namespace TestCaseTemplateId {
    type Raw = string;
}
",
                    "name": "TestCaseTemplateId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as schemas from \\"../../..\\";
import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const TestCaseV2: core.schemas.ObjectSchema<TestCaseV2.Raw, MyApi.v2.problem.TestCaseV2> = core.schemas.object({
        metadata: schemas.v2.problem.TestCaseMetadata,
        implementation: schemas.v2.problem.TestCaseImplementationReference,
        arguments: core.schemas.record(core.schemas.string(), schemas.commons.VariableValue),
        expects: schemas.v2.problem.TestCaseExpects.optional()
    });

export declare namespace TestCaseV2 {
    interface Raw {
        \\"metadata\\": schemas.v2.problem.TestCaseMetadata.Raw;
        \\"implementation\\": schemas.v2.problem.TestCaseImplementationReference.Raw;
        \\"arguments\\": Record<schemas.v2.problem.ParameterId.Raw, schemas.commons.VariableValue.Raw>;
        \\"expects\\"?: schemas.v2.problem.TestCaseExpects.Raw | null;
    }
}
",
                    "name": "TestCaseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as schemas from \\"../../..\\";
import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const TestCaseWithActualResultImplementation: core.schemas.ObjectSchema<TestCaseWithActualResultImplementation.Raw, MyApi.v2.problem.TestCaseWithActualResultImplementation> = core.schemas.object({
        getActualResult: schemas.v2.problem.NonVoidFunctionDefinition,
        assertCorrectnessCheck: schemas.v2.problem.AssertCorrectnessCheck
    });

export declare namespace TestCaseWithActualResultImplementation {
    interface Raw {
        \\"getActualResult\\": schemas.v2.problem.NonVoidFunctionDefinition.Raw;
        \\"assertCorrectnessCheck\\": schemas.v2.problem.AssertCorrectnessCheck.Raw;
    }
}
",
                    "name": "TestCaseWithActualResultImplementation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as schemas from \\"../../..\\";
import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const VoidFunctionDefinition: core.schemas.ObjectSchema<VoidFunctionDefinition.Raw, MyApi.v2.problem.VoidFunctionDefinition> = core.schemas.object({
        parameters: core.schemas.list(schemas.v2.problem.Parameter),
        code: schemas.v2.problem.FunctionImplementationForMultipleLanguages
    });

export declare namespace VoidFunctionDefinition {
    interface Raw {
        \\"parameters\\": schemas.v2.problem.Parameter.Raw[];
        \\"code\\": schemas.v2.problem.FunctionImplementationForMultipleLanguages.Raw;
    }
}
",
                    "name": "VoidFunctionDefinition.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as schemas from \\"../../..\\";
import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const VoidFunctionDefinitionThatTakesActualResult: core.schemas.ObjectSchema<VoidFunctionDefinitionThatTakesActualResult.Raw, MyApi.v2.problem.VoidFunctionDefinitionThatTakesActualResult> = core.schemas.object({
        additionalParameters: core.schemas.list(schemas.v2.problem.Parameter),
        code: schemas.v2.problem.FunctionImplementationForMultipleLanguages
    });

export declare namespace VoidFunctionDefinitionThatTakesActualResult {
    interface Raw {
        \\"additionalParameters\\": schemas.v2.problem.Parameter.Raw[];
        \\"code\\": schemas.v2.problem.FunctionImplementationForMultipleLanguages.Raw;
    }
}
",
                    "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as schemas from \\"../../..\\";
import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const VoidFunctionSignature: core.schemas.ObjectSchema<VoidFunctionSignature.Raw, MyApi.v2.problem.VoidFunctionSignature> = core.schemas.object({
        parameters: core.schemas.list(schemas.v2.problem.Parameter)
    });

export declare namespace VoidFunctionSignature {
    interface Raw {
        \\"parameters\\": schemas.v2.problem.Parameter.Raw[];
    }
}
",
                    "name": "VoidFunctionSignature.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as schemas from \\"../../..\\";
import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export const VoidFunctionSignatureThatTakesActualResult: core.schemas.ObjectSchema<VoidFunctionSignatureThatTakesActualResult.Raw, MyApi.v2.problem.VoidFunctionSignatureThatTakesActualResult> = core.schemas.object({
        parameters: core.schemas.list(schemas.v2.problem.Parameter),
        actualResultType: schemas.commons.VariableType
    });

export declare namespace VoidFunctionSignatureThatTakesActualResult {
    interface Raw {
        \\"parameters\\": schemas.v2.problem.Parameter.Raw[];
        \\"actualResultType\\": schemas.commons.VariableType.Raw;
    }
}
",
                    "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "problem",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * as problem from \\"./problem\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export * from \\"./types\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import * as schemas from \\"../../../..\\";
import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const AssertCorrectnessCheck: core.schemas.Schema<AssertCorrectnessCheck.Raw, MyApi.v2.v3.problem.AssertCorrectnessCheck> = core.schemas.union(\\"type\\", {
        deepEquality: schemas.v2.v3.problem.DeepEqualityCorrectnessCheck,
        custom: schemas.v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult
    }).transform<MyApi.v2.v3.problem.AssertCorrectnessCheck>({
        parse: value => {
            switch (value.type) {
                case \\"deepEquality\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.deepEquality(value)
                    };
                }
                case \\"custom\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.custom(value)
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace AssertCorrectnessCheck {
    type Raw = AssertCorrectnessCheck.DeepEquality | AssertCorrectnessCheck.Custom;

    interface DeepEquality extends schemas.v2.v3.problem.DeepEqualityCorrectnessCheck.Raw {
        type: \\"deepEquality\\";
    }

    interface Custom extends schemas.v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult.Raw {
        type: \\"custom\\";
    }
}
",
                        "name": "AssertCorrectnessCheck.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";
import { MyApi } from \\"../../../../..\\";

export const BasicCustomFiles: core.schemas.ObjectSchema<BasicCustomFiles.Raw, MyApi.v2.v3.problem.BasicCustomFiles> = core.schemas.object({
        methodName: core.schemas.string(),
        signature: schemas.v2.v3.problem.NonVoidFunctionSignature,
        additionalFiles: core.schemas.record(core.schemas.string(), schemas.v2.v3.problem.Files),
        basicTestCaseTemplate: schemas.v2.v3.problem.BasicTestCaseTemplate
    });

export declare namespace BasicCustomFiles {
    interface Raw {
        \\"methodName\\": string;
        \\"signature\\": schemas.v2.v3.problem.NonVoidFunctionSignature.Raw;
        \\"additionalFiles\\": Record<schemas.commons.Language.Raw, schemas.v2.v3.problem.Files.Raw>;
        \\"basicTestCaseTemplate\\": schemas.v2.v3.problem.BasicTestCaseTemplate.Raw;
    }
}
",
                        "name": "BasicCustomFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as schemas from \\"../../../..\\";
import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const BasicTestCaseTemplate: core.schemas.ObjectSchema<BasicTestCaseTemplate.Raw, MyApi.v2.v3.problem.BasicTestCaseTemplate> = core.schemas.object({
        templateId: schemas.v2.v3.problem.TestCaseTemplateId,
        name: core.schemas.string(),
        description: schemas.v2.v3.problem.TestCaseImplementationDescription,
        expectedValueParameterId: schemas.v2.v3.problem.ParameterId
    });

export declare namespace BasicTestCaseTemplate {
    interface Raw {
        \\"templateId\\": schemas.v2.v3.problem.TestCaseTemplateId.Raw;
        \\"name\\": string;
        \\"description\\": schemas.v2.v3.problem.TestCaseImplementationDescription.Raw;
        \\"expectedValueParameterId\\": schemas.v2.v3.problem.ParameterId.Raw;
    }
}
",
                        "name": "BasicTestCaseTemplate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";
import { MyApi } from \\"../../../../..\\";

export const CreateProblemRequestV2: core.schemas.ObjectSchema<CreateProblemRequestV2.Raw, MyApi.v2.v3.problem.CreateProblemRequestV2> = core.schemas.object({
        problemName: core.schemas.string(),
        problemDescription: schemas.problem.ProblemDescription,
        customFiles: schemas.v2.v3.problem.CustomFiles,
        customTestCaseTemplates: core.schemas.list(schemas.v2.v3.problem.TestCaseTemplate),
        testcases: core.schemas.list(schemas.v2.v3.problem.TestCaseV2),
        supportedLanguages: core.schemas.list(schemas.commons.Language),
        isPublic: core.schemas.boolean()
    });

export declare namespace CreateProblemRequestV2 {
    interface Raw {
        \\"problemName\\": string;
        \\"problemDescription\\": schemas.problem.ProblemDescription.Raw;
        \\"customFiles\\": schemas.v2.v3.problem.CustomFiles.Raw;
        \\"customTestCaseTemplates\\": schemas.v2.v3.problem.TestCaseTemplate.Raw[];
        \\"testcases\\": schemas.v2.v3.problem.TestCaseV2.Raw[];
        \\"supportedLanguages\\": schemas.commons.Language.Raw[];
        \\"isPublic\\": boolean;
    }
}
",
                        "name": "CreateProblemRequestV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as schemas from \\"../../../..\\";
import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const CustomFiles: core.schemas.Schema<CustomFiles.Raw, MyApi.v2.v3.problem.CustomFiles> = core.schemas.union(\\"type\\", {
        basic: schemas.v2.v3.problem.BasicCustomFiles,
        custom: core.schemas.object({
            value: core.schemas.property(\\"custom\\", core.schemas.record(core.schemas.string(), schemas.v2.v3.problem.Files))
        })
    }).transform<MyApi.v2.v3.problem.CustomFiles>({
        parse: value => {
            switch (value.type) {
                case \\"basic\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.basic(value)
                    };
                }
                case \\"custom\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.custom(value.value)
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace CustomFiles {
    type Raw = CustomFiles.Basic | CustomFiles.Custom;

    interface Basic extends schemas.v2.v3.problem.BasicCustomFiles.Raw {
        type: \\"basic\\";
    }

    interface Custom {
        type: \\"custom\\";
        custom: Record<schemas.commons.Language.Raw, schemas.v2.v3.problem.Files.Raw>;
    }
}
",
                        "name": "CustomFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as schemas from \\"../../../..\\";
import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const DeepEqualityCorrectnessCheck: core.schemas.ObjectSchema<DeepEqualityCorrectnessCheck.Raw, MyApi.v2.v3.problem.DeepEqualityCorrectnessCheck> = core.schemas.object({
        expectedValueParameterId: schemas.v2.v3.problem.ParameterId
    });

export declare namespace DeepEqualityCorrectnessCheck {
    interface Raw {
        \\"expectedValueParameterId\\": schemas.v2.v3.problem.ParameterId.Raw;
    }
}
",
                        "name": "DeepEqualityCorrectnessCheck.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as schemas from \\"../../../..\\";
import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const DefaultProvidedFile: core.schemas.ObjectSchema<DefaultProvidedFile.Raw, MyApi.v2.v3.problem.DefaultProvidedFile> = core.schemas.object({
        file: schemas.v2.v3.problem.FileInfoV2,
        relatedTypes: core.schemas.list(schemas.commons.VariableType)
    });

export declare namespace DefaultProvidedFile {
    interface Raw {
        \\"file\\": schemas.v2.v3.problem.FileInfoV2.Raw;
        \\"relatedTypes\\": schemas.commons.VariableType.Raw[];
    }
}
",
                        "name": "DefaultProvidedFile.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const FileInfoV2: core.schemas.ObjectSchema<FileInfoV2.Raw, MyApi.v2.v3.problem.FileInfoV2> = core.schemas.object({
        filename: core.schemas.string(),
        directory: core.schemas.string(),
        contents: core.schemas.string(),
        editable: core.schemas.boolean()
    });

export declare namespace FileInfoV2 {
    interface Raw {
        \\"filename\\": string;
        \\"directory\\": string;
        \\"contents\\": string;
        \\"editable\\": boolean;
    }
}
",
                        "name": "FileInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as schemas from \\"../../../..\\";
import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const Files: core.schemas.ObjectSchema<Files.Raw, MyApi.v2.v3.problem.Files> = core.schemas.object({
        files: core.schemas.list(schemas.v2.v3.problem.FileInfoV2)
    });

export declare namespace Files {
    interface Raw {
        \\"files\\": schemas.v2.v3.problem.FileInfoV2.Raw[];
    }
}
",
                        "name": "Files.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const FunctionImplementation: core.schemas.ObjectSchema<FunctionImplementation.Raw, MyApi.v2.v3.problem.FunctionImplementation> = core.schemas.object({
        impl: core.schemas.string(),
        imports: core.schemas.string().optional()
    });

export declare namespace FunctionImplementation {
    interface Raw {
        \\"impl\\": string;
        \\"imports\\"?: string | null;
    }
}
",
                        "name": "FunctionImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";
import { MyApi } from \\"../../../../..\\";

export const FunctionImplementationForMultipleLanguages: core.schemas.ObjectSchema<FunctionImplementationForMultipleLanguages.Raw, MyApi.v2.v3.problem.FunctionImplementationForMultipleLanguages> = core.schemas.object({
        codeByLanguage: core.schemas.record(core.schemas.string(), schemas.v2.v3.problem.FunctionImplementation)
    });

export declare namespace FunctionImplementationForMultipleLanguages {
    interface Raw {
        \\"codeByLanguage\\": Record<schemas.commons.Language.Raw, schemas.v2.v3.problem.FunctionImplementation.Raw>;
    }
}
",
                        "name": "FunctionImplementationForMultipleLanguages.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as schemas from \\"../../../..\\";
import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const FunctionSignature: core.schemas.Schema<FunctionSignature.Raw, MyApi.v2.v3.problem.FunctionSignature> = core.schemas.union(\\"type\\", {
        void: schemas.v2.v3.problem.VoidFunctionSignature,
        nonVoid: schemas.v2.v3.problem.NonVoidFunctionSignature,
        voidThatTakesActualResult: schemas.v2.v3.problem.VoidFunctionSignatureThatTakesActualResult
    }).transform<MyApi.v2.v3.problem.FunctionSignature>({
        parse: value => {
            switch (value.type) {
                case \\"void\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.void(value)
                    };
                }
                case \\"nonVoid\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.nonVoid(value)
                    };
                }
                case \\"voidThatTakesActualResult\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.voidThatTakesActualResult(value)
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace FunctionSignature {
    type Raw = FunctionSignature.Void | FunctionSignature.NonVoid | FunctionSignature.VoidThatTakesActualResult;

    interface Void extends schemas.v2.v3.problem.VoidFunctionSignature.Raw {
        type: \\"void\\";
    }

    interface NonVoid extends schemas.v2.v3.problem.NonVoidFunctionSignature.Raw {
        type: \\"nonVoid\\";
    }

    interface VoidThatTakesActualResult extends schemas.v2.v3.problem.VoidFunctionSignatureThatTakesActualResult.Raw {
        type: \\"voidThatTakesActualResult\\";
    }
}
",
                        "name": "FunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";
import { MyApi } from \\"../../../../..\\";

export const GeneratedFiles: core.schemas.ObjectSchema<GeneratedFiles.Raw, MyApi.v2.v3.problem.GeneratedFiles> = core.schemas.object({
        generatedTestCaseFiles: core.schemas.record(core.schemas.string(), schemas.v2.v3.problem.Files),
        generatedTemplateFiles: core.schemas.record(core.schemas.string(), schemas.v2.v3.problem.Files),
        other: core.schemas.record(core.schemas.string(), schemas.v2.v3.problem.Files)
    });

export declare namespace GeneratedFiles {
    interface Raw {
        \\"generatedTestCaseFiles\\": Record<schemas.commons.Language.Raw, schemas.v2.v3.problem.Files.Raw>;
        \\"generatedTemplateFiles\\": Record<schemas.commons.Language.Raw, schemas.v2.v3.problem.Files.Raw>;
        \\"other\\": Record<schemas.commons.Language.Raw, schemas.v2.v3.problem.Files.Raw>;
    }
}
",
                        "name": "GeneratedFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";
import { MyApi } from \\"../../../../..\\";

export const GetBasicSolutionFileRequest: core.schemas.ObjectSchema<GetBasicSolutionFileRequest.Raw, MyApi.v2.v3.problem.GetBasicSolutionFileRequest> = core.schemas.object({
        methodName: core.schemas.string(),
        signature: schemas.v2.v3.problem.NonVoidFunctionSignature
    });

export declare namespace GetBasicSolutionFileRequest {
    interface Raw {
        \\"methodName\\": string;
        \\"signature\\": schemas.v2.v3.problem.NonVoidFunctionSignature.Raw;
    }
}
",
                        "name": "GetBasicSolutionFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";
import { MyApi } from \\"../../../../..\\";

export const GetBasicSolutionFileResponse: core.schemas.ObjectSchema<GetBasicSolutionFileResponse.Raw, MyApi.v2.v3.problem.GetBasicSolutionFileResponse> = core.schemas.object({
        solutionFileByLanguage: core.schemas.record(core.schemas.string(), schemas.v2.v3.problem.FileInfoV2)
    });

export declare namespace GetBasicSolutionFileResponse {
    interface Raw {
        \\"solutionFileByLanguage\\": Record<schemas.commons.Language.Raw, schemas.v2.v3.problem.FileInfoV2.Raw>;
    }
}
",
                        "name": "GetBasicSolutionFileResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as schemas from \\"../../../..\\";
import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const GetFunctionSignatureRequest: core.schemas.ObjectSchema<GetFunctionSignatureRequest.Raw, MyApi.v2.v3.problem.GetFunctionSignatureRequest> = core.schemas.object({
        functionSignature: schemas.v2.v3.problem.FunctionSignature
    });

export declare namespace GetFunctionSignatureRequest {
    interface Raw {
        \\"functionSignature\\": schemas.v2.v3.problem.FunctionSignature.Raw;
    }
}
",
                        "name": "GetFunctionSignatureRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";
import * as schemas from \\"../../../..\\";

export const GetFunctionSignatureResponse: core.schemas.ObjectSchema<GetFunctionSignatureResponse.Raw, MyApi.v2.v3.problem.GetFunctionSignatureResponse> = core.schemas.object({
        functionByLanguage: core.schemas.record(core.schemas.string(), core.schemas.string())
    });

export declare namespace GetFunctionSignatureResponse {
    interface Raw {
        \\"functionByLanguage\\": Record<schemas.commons.Language.Raw, string>;
    }
}
",
                        "name": "GetFunctionSignatureResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as schemas from \\"../../../..\\";
import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const GetGeneratedTestCaseFileRequest: core.schemas.ObjectSchema<GetGeneratedTestCaseFileRequest.Raw, MyApi.v2.v3.problem.GetGeneratedTestCaseFileRequest> = core.schemas.object({
        template: schemas.v2.v3.problem.TestCaseTemplate.optional(),
        testCase: schemas.v2.v3.problem.TestCaseV2
    });

export declare namespace GetGeneratedTestCaseFileRequest {
    interface Raw {
        \\"template\\"?: schemas.v2.v3.problem.TestCaseTemplate.Raw | null;
        \\"testCase\\": schemas.v2.v3.problem.TestCaseV2.Raw;
    }
}
",
                        "name": "GetGeneratedTestCaseFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as schemas from \\"../../../..\\";
import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const GetGeneratedTestCaseTemplateFileRequest: core.schemas.ObjectSchema<GetGeneratedTestCaseTemplateFileRequest.Raw, MyApi.v2.v3.problem.GetGeneratedTestCaseTemplateFileRequest> = core.schemas.object({
        template: schemas.v2.v3.problem.TestCaseTemplate
    });

export declare namespace GetGeneratedTestCaseTemplateFileRequest {
    interface Raw {
        \\"template\\": schemas.v2.v3.problem.TestCaseTemplate.Raw;
    }
}
",
                        "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as schemas from \\"../../../..\\";
import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const LightweightProblemInfoV2: core.schemas.ObjectSchema<LightweightProblemInfoV2.Raw, MyApi.v2.v3.problem.LightweightProblemInfoV2> = core.schemas.object({
        problemId: schemas.commons.ProblemId,
        problemName: core.schemas.string(),
        problemVersion: core.schemas.number(),
        variableTypes: core.schemas.list(schemas.commons.VariableType)
    });

export declare namespace LightweightProblemInfoV2 {
    interface Raw {
        \\"problemId\\": schemas.commons.ProblemId.Raw;
        \\"problemName\\": string;
        \\"problemVersion\\": number;
        \\"variableTypes\\": schemas.commons.VariableType.Raw[];
    }
}
",
                        "name": "LightweightProblemInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as schemas from \\"../../../..\\";
import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const NonVoidFunctionDefinition: core.schemas.ObjectSchema<NonVoidFunctionDefinition.Raw, MyApi.v2.v3.problem.NonVoidFunctionDefinition> = core.schemas.object({
        signature: schemas.v2.v3.problem.NonVoidFunctionSignature,
        code: schemas.v2.v3.problem.FunctionImplementationForMultipleLanguages
    });

export declare namespace NonVoidFunctionDefinition {
    interface Raw {
        \\"signature\\": schemas.v2.v3.problem.NonVoidFunctionSignature.Raw;
        \\"code\\": schemas.v2.v3.problem.FunctionImplementationForMultipleLanguages.Raw;
    }
}
",
                        "name": "NonVoidFunctionDefinition.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as schemas from \\"../../../..\\";
import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const NonVoidFunctionSignature: core.schemas.ObjectSchema<NonVoidFunctionSignature.Raw, MyApi.v2.v3.problem.NonVoidFunctionSignature> = core.schemas.object({
        parameters: core.schemas.list(schemas.v2.v3.problem.Parameter),
        returnType: schemas.commons.VariableType
    });

export declare namespace NonVoidFunctionSignature {
    interface Raw {
        \\"parameters\\": schemas.v2.v3.problem.Parameter.Raw[];
        \\"returnType\\": schemas.commons.VariableType.Raw;
    }
}
",
                        "name": "NonVoidFunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as schemas from \\"../../../..\\";
import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const Parameter: core.schemas.ObjectSchema<Parameter.Raw, MyApi.v2.v3.problem.Parameter> = core.schemas.object({
        parameterId: schemas.v2.v3.problem.ParameterId,
        name: core.schemas.string(),
        variableType: schemas.commons.VariableType
    });

export declare namespace Parameter {
    interface Raw {
        \\"parameterId\\": schemas.v2.v3.problem.ParameterId.Raw;
        \\"name\\": string;
        \\"variableType\\": schemas.commons.VariableType.Raw;
    }
}
",
                        "name": "Parameter.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const ParameterId: core.schemas.Schema<ParameterId.Raw, MyApi.v2.v3.problem.ParameterId> = core.schemas.string();

export declare namespace ParameterId {
    type Raw = string;
}
",
                        "name": "ParameterId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as schemas from \\"../../../..\\";
import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const ProblemInfoV2: core.schemas.ObjectSchema<ProblemInfoV2.Raw, MyApi.v2.v3.problem.ProblemInfoV2> = core.schemas.object({
        problemId: schemas.commons.ProblemId,
        problemDescription: schemas.problem.ProblemDescription,
        problemName: core.schemas.string(),
        problemVersion: core.schemas.number(),
        supportedLanguages: core.schemas.list(schemas.commons.Language),
        customFiles: schemas.v2.v3.problem.CustomFiles,
        generatedFiles: schemas.v2.v3.problem.GeneratedFiles,
        customTestCaseTemplates: core.schemas.list(schemas.v2.v3.problem.TestCaseTemplate),
        testcases: core.schemas.list(schemas.v2.v3.problem.TestCaseV2),
        isPublic: core.schemas.boolean()
    });

export declare namespace ProblemInfoV2 {
    interface Raw {
        \\"problemId\\": schemas.commons.ProblemId.Raw;
        \\"problemDescription\\": schemas.problem.ProblemDescription.Raw;
        \\"problemName\\": string;
        \\"problemVersion\\": number;
        \\"supportedLanguages\\": schemas.commons.Language.Raw[];
        \\"customFiles\\": schemas.v2.v3.problem.CustomFiles.Raw;
        \\"generatedFiles\\": schemas.v2.v3.problem.GeneratedFiles.Raw;
        \\"customTestCaseTemplates\\": schemas.v2.v3.problem.TestCaseTemplate.Raw[];
        \\"testcases\\": schemas.v2.v3.problem.TestCaseV2.Raw[];
        \\"isPublic\\": boolean;
    }
}
",
                        "name": "ProblemInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const TestCaseExpects: core.schemas.ObjectSchema<TestCaseExpects.Raw, MyApi.v2.v3.problem.TestCaseExpects> = core.schemas.object({
        expectedStdout: core.schemas.string().optional()
    });

export declare namespace TestCaseExpects {
    interface Raw {
        \\"expectedStdout\\"?: string | null;
    }
}
",
                        "name": "TestCaseExpects.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as schemas from \\"../../../..\\";
import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const TestCaseFunction: core.schemas.Schema<TestCaseFunction.Raw, MyApi.v2.v3.problem.TestCaseFunction> = core.schemas.union(\\"type\\", {
        withActualResult: schemas.v2.v3.problem.TestCaseWithActualResultImplementation,
        custom: schemas.v2.v3.problem.VoidFunctionDefinition
    }).transform<MyApi.v2.v3.problem.TestCaseFunction>({
        parse: value => {
            switch (value.type) {
                case \\"withActualResult\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.withActualResult(value)
                    };
                }
                case \\"custom\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.custom(value)
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace TestCaseFunction {
    type Raw = TestCaseFunction.WithActualResult | TestCaseFunction.Custom;

    interface WithActualResult extends schemas.v2.v3.problem.TestCaseWithActualResultImplementation.Raw {
        type: \\"withActualResult\\";
    }

    interface Custom extends schemas.v2.v3.problem.VoidFunctionDefinition.Raw {
        type: \\"custom\\";
    }
}
",
                        "name": "TestCaseFunction.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const TestCaseId: core.schemas.Schema<TestCaseId.Raw, MyApi.v2.v3.problem.TestCaseId> = core.schemas.string();

export declare namespace TestCaseId {
    type Raw = string;
}
",
                        "name": "TestCaseId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as schemas from \\"../../../..\\";
import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const TestCaseImplementation: core.schemas.ObjectSchema<TestCaseImplementation.Raw, MyApi.v2.v3.problem.TestCaseImplementation> = core.schemas.object({
        description: schemas.v2.v3.problem.TestCaseImplementationDescription,
        function: schemas.v2.v3.problem.TestCaseFunction
    });

export declare namespace TestCaseImplementation {
    interface Raw {
        \\"description\\": schemas.v2.v3.problem.TestCaseImplementationDescription.Raw;
        \\"function\\": schemas.v2.v3.problem.TestCaseFunction.Raw;
    }
}
",
                        "name": "TestCaseImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as schemas from \\"../../../..\\";
import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const TestCaseImplementationDescription: core.schemas.ObjectSchema<TestCaseImplementationDescription.Raw, MyApi.v2.v3.problem.TestCaseImplementationDescription> = core.schemas.object({
        boards: core.schemas.list(schemas.v2.v3.problem.TestCaseImplementationDescriptionBoard)
    });

export declare namespace TestCaseImplementationDescription {
    interface Raw {
        \\"boards\\": schemas.v2.v3.problem.TestCaseImplementationDescriptionBoard.Raw[];
    }
}
",
                        "name": "TestCaseImplementationDescription.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";
import { MyApi } from \\"../../../../..\\";

export const TestCaseImplementationDescriptionBoard: core.schemas.Schema<TestCaseImplementationDescriptionBoard.Raw, MyApi.v2.v3.problem.TestCaseImplementationDescriptionBoard> = core.schemas.union(\\"type\\", {
        html: core.schemas.object({
            value: core.schemas.property(\\"html\\", core.schemas.string())
        }),
        paramId: core.schemas.object({
            value: core.schemas.property(\\"paramId\\", schemas.v2.v3.problem.ParameterId)
        })
    }).transform<MyApi.v2.v3.problem.TestCaseImplementationDescriptionBoard>({
        parse: value => {
            switch (value.type) {
                case \\"html\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.html(value.value)
                    };
                }
                case \\"paramId\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.paramId(value.value)
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace TestCaseImplementationDescriptionBoard {
    type Raw = TestCaseImplementationDescriptionBoard.Html | TestCaseImplementationDescriptionBoard.ParamId;

    interface Html {
        type: \\"html\\";
        html: string;
    }

    interface ParamId {
        type: \\"paramId\\";
        paramId: schemas.v2.v3.problem.ParameterId.Raw;
    }
}
",
                        "name": "TestCaseImplementationDescriptionBoard.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as schemas from \\"../../../..\\";
import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const TestCaseImplementationReference: core.schemas.Schema<TestCaseImplementationReference.Raw, MyApi.v2.v3.problem.TestCaseImplementationReference> = core.schemas.union(\\"type\\", {
        templateId: core.schemas.object({
            value: core.schemas.property(\\"templateId\\", schemas.v2.v3.problem.TestCaseTemplateId)
        }),
        implementation: schemas.v2.v3.problem.TestCaseImplementation
    }).transform<MyApi.v2.v3.problem.TestCaseImplementationReference>({
        parse: value => {
            switch (value.type) {
                case \\"templateId\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.templateId(value.value)
                    };
                }
                case \\"implementation\\": {
                    return {
                        ...value,
                        _visit: visitor => visitor.implementation(value)
                    };
                }
            }
        },
        json: value => value as Exclude<typeof value, {
            type: void;
        }>
    });

export declare namespace TestCaseImplementationReference {
    type Raw = TestCaseImplementationReference.TemplateId | TestCaseImplementationReference.Implementation;

    interface TemplateId {
        type: \\"templateId\\";
        templateId: schemas.v2.v3.problem.TestCaseTemplateId.Raw;
    }

    interface Implementation extends schemas.v2.v3.problem.TestCaseImplementation.Raw {
        type: \\"implementation\\";
    }
}
",
                        "name": "TestCaseImplementationReference.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as schemas from \\"../../../..\\";
import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const TestCaseMetadata: core.schemas.ObjectSchema<TestCaseMetadata.Raw, MyApi.v2.v3.problem.TestCaseMetadata> = core.schemas.object({
        id: schemas.v2.v3.problem.TestCaseId,
        name: core.schemas.string(),
        hidden: core.schemas.boolean()
    });

export declare namespace TestCaseMetadata {
    interface Raw {
        \\"id\\": schemas.v2.v3.problem.TestCaseId.Raw;
        \\"name\\": string;
        \\"hidden\\": boolean;
    }
}
",
                        "name": "TestCaseMetadata.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as schemas from \\"../../../..\\";
import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const TestCaseTemplate: core.schemas.ObjectSchema<TestCaseTemplate.Raw, MyApi.v2.v3.problem.TestCaseTemplate> = core.schemas.object({
        templateId: schemas.v2.v3.problem.TestCaseTemplateId,
        name: core.schemas.string(),
        implementation: schemas.v2.v3.problem.TestCaseImplementation
    });

export declare namespace TestCaseTemplate {
    interface Raw {
        \\"templateId\\": schemas.v2.v3.problem.TestCaseTemplateId.Raw;
        \\"name\\": string;
        \\"implementation\\": schemas.v2.v3.problem.TestCaseImplementation.Raw;
    }
}
",
                        "name": "TestCaseTemplate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const TestCaseTemplateId: core.schemas.Schema<TestCaseTemplateId.Raw, MyApi.v2.v3.problem.TestCaseTemplateId> = core.schemas.string();

export declare namespace TestCaseTemplateId {
    type Raw = string;
}
",
                        "name": "TestCaseTemplateId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as schemas from \\"../../../..\\";
import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const TestCaseV2: core.schemas.ObjectSchema<TestCaseV2.Raw, MyApi.v2.v3.problem.TestCaseV2> = core.schemas.object({
        metadata: schemas.v2.v3.problem.TestCaseMetadata,
        implementation: schemas.v2.v3.problem.TestCaseImplementationReference,
        arguments: core.schemas.record(core.schemas.string(), schemas.commons.VariableValue),
        expects: schemas.v2.v3.problem.TestCaseExpects.optional()
    });

export declare namespace TestCaseV2 {
    interface Raw {
        \\"metadata\\": schemas.v2.v3.problem.TestCaseMetadata.Raw;
        \\"implementation\\": schemas.v2.v3.problem.TestCaseImplementationReference.Raw;
        \\"arguments\\": Record<schemas.v2.v3.problem.ParameterId.Raw, schemas.commons.VariableValue.Raw>;
        \\"expects\\"?: schemas.v2.v3.problem.TestCaseExpects.Raw | null;
    }
}
",
                        "name": "TestCaseV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as schemas from \\"../../../..\\";
import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const TestCaseWithActualResultImplementation: core.schemas.ObjectSchema<TestCaseWithActualResultImplementation.Raw, MyApi.v2.v3.problem.TestCaseWithActualResultImplementation> = core.schemas.object({
        getActualResult: schemas.v2.v3.problem.NonVoidFunctionDefinition,
        assertCorrectnessCheck: schemas.v2.v3.problem.AssertCorrectnessCheck
    });

export declare namespace TestCaseWithActualResultImplementation {
    interface Raw {
        \\"getActualResult\\": schemas.v2.v3.problem.NonVoidFunctionDefinition.Raw;
        \\"assertCorrectnessCheck\\": schemas.v2.v3.problem.AssertCorrectnessCheck.Raw;
    }
}
",
                        "name": "TestCaseWithActualResultImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as schemas from \\"../../../..\\";
import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const VoidFunctionDefinition: core.schemas.ObjectSchema<VoidFunctionDefinition.Raw, MyApi.v2.v3.problem.VoidFunctionDefinition> = core.schemas.object({
        parameters: core.schemas.list(schemas.v2.v3.problem.Parameter),
        code: schemas.v2.v3.problem.FunctionImplementationForMultipleLanguages
    });

export declare namespace VoidFunctionDefinition {
    interface Raw {
        \\"parameters\\": schemas.v2.v3.problem.Parameter.Raw[];
        \\"code\\": schemas.v2.v3.problem.FunctionImplementationForMultipleLanguages.Raw;
    }
}
",
                        "name": "VoidFunctionDefinition.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as schemas from \\"../../../..\\";
import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const VoidFunctionDefinitionThatTakesActualResult: core.schemas.ObjectSchema<VoidFunctionDefinitionThatTakesActualResult.Raw, MyApi.v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult> = core.schemas.object({
        additionalParameters: core.schemas.list(schemas.v2.v3.problem.Parameter),
        code: schemas.v2.v3.problem.FunctionImplementationForMultipleLanguages
    });

export declare namespace VoidFunctionDefinitionThatTakesActualResult {
    interface Raw {
        \\"additionalParameters\\": schemas.v2.v3.problem.Parameter.Raw[];
        \\"code\\": schemas.v2.v3.problem.FunctionImplementationForMultipleLanguages.Raw;
    }
}
",
                        "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as schemas from \\"../../../..\\";
import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const VoidFunctionSignature: core.schemas.ObjectSchema<VoidFunctionSignature.Raw, MyApi.v2.v3.problem.VoidFunctionSignature> = core.schemas.object({
        parameters: core.schemas.list(schemas.v2.v3.problem.Parameter)
    });

export declare namespace VoidFunctionSignature {
    interface Raw {
        \\"parameters\\": schemas.v2.v3.problem.Parameter.Raw[];
    }
}
",
                        "name": "VoidFunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as schemas from \\"../../../..\\";
import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export const VoidFunctionSignatureThatTakesActualResult: core.schemas.ObjectSchema<VoidFunctionSignatureThatTakesActualResult.Raw, MyApi.v2.v3.problem.VoidFunctionSignatureThatTakesActualResult> = core.schemas.object({
        parameters: core.schemas.list(schemas.v2.v3.problem.Parameter),
        actualResultType: schemas.commons.VariableType
    });

export declare namespace VoidFunctionSignatureThatTakesActualResult {
    interface Raw {
        \\"parameters\\": schemas.v2.v3.problem.Parameter.Raw[];
        \\"actualResultType\\": schemas.commons.VariableType.Raw;
    }
}
",
                        "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "problem",
                "type": "directory",
              },
            ],
            "name": "v3",
            "type": "directory",
          },
        ],
        "name": "v2",
        "type": "directory",
      },
    ],
    "name": "schemas",
    "type": "directory",
  },
  Object {
    "contents": "{
    \\"compilerOptions\\": {
        \\"strict\\": true,
        \\"target\\": \\"esnext\\",
        \\"moduleResolution\\": \\"node\\",
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"sourceMap\\": true,
        \\"emitDeclarationOnly\\": true,
        \\"esModuleInterop\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true
    }
}",
    "name": "tsconfig.json",
    "type": "file",
  },
]
`;
