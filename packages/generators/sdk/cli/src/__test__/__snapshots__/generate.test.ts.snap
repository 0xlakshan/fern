// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`runGenerator trace 1`] = `
Array [
  Object {
    "contents": ".pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions
node_modules
.DS_Store
*.d.ts
*.js
*.js.map",
    "name": ".gitignore",
    "type": "file",
  },
  Object {
    "contents": ".yarn
node_modules
.npmignore
.pnp.cjs",
    "name": ".prettierignore",
    "type": "file",
  },
  Object {
    "contents": "nodeLinker: pnp

yarnPath: .yarn/releases/yarn-3.2.3.cjs
",
    "name": ".yarnrc.yml",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "import * as core from \\"../core\\";
import { Client as AdminServiceClient } from \\"./admin/client/Client\\";
import { Client as HomepageProblemServiceClient } from \\"./homepage/client/Client\\";
import { Client as MigrationInfoServiceClient } from \\"./migration/client/Client\\";
import { Client as PlaylistCrudServiceClient } from \\"./playlist/client/Client\\";
import { Client as ProblemCrudServiceClient } from \\"./problem/client/Client\\";
import { Client as ExecutionSesssionManagementServiceClient } from \\"./submission/client/Client\\";
import { Client as SysPropCrudServiceClient } from \\"./sysprop/client/Client\\";
import { Wrapper as V2Wrapper } from \\"./v2/Wrapper\\";

export namespace Client {
  export interface Options {
    _origin: string;
    _token?: core.BearerToken;
    _credentials?: core.BasicAuth;
    xApiKey?: string;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  #admin: AdminServiceClient | undefined;

  public get admin(): AdminServiceClient {
    return (this.#admin ??= new AdminServiceClient({
      _origin: this.options._origin,
      _token: this.options._token,
      _credentials: this.options._credentials,
      xApiKey: this.options.xApiKey,
    }));
  }

  #homepage: HomepageProblemServiceClient | undefined;

  public get homepage(): HomepageProblemServiceClient {
    return (this.#homepage ??= new HomepageProblemServiceClient({
      _origin: this.options._origin,
      _token: this.options._token,
      _credentials: this.options._credentials,
      xApiKey: this.options.xApiKey,
    }));
  }

  #migration: MigrationInfoServiceClient | undefined;

  public get migration(): MigrationInfoServiceClient {
    return (this.#migration ??= new MigrationInfoServiceClient({
      _origin: this.options._origin,
      _token: this.options._token,
      _credentials: this.options._credentials,
      xApiKey: this.options.xApiKey,
    }));
  }

  #playlist: PlaylistCrudServiceClient | undefined;

  public get playlist(): PlaylistCrudServiceClient {
    return (this.#playlist ??= new PlaylistCrudServiceClient({
      _origin: this.options._origin,
      _token: this.options._token,
      _credentials: this.options._credentials,
      xApiKey: this.options.xApiKey,
    }));
  }

  #problem: ProblemCrudServiceClient | undefined;

  public get problem(): ProblemCrudServiceClient {
    return (this.#problem ??= new ProblemCrudServiceClient({
      _origin: this.options._origin,
      _token: this.options._token,
      _credentials: this.options._credentials,
      xApiKey: this.options.xApiKey,
    }));
  }

  #submission: ExecutionSesssionManagementServiceClient | undefined;

  public get submission(): ExecutionSesssionManagementServiceClient {
    return (this.#submission ??= new ExecutionSesssionManagementServiceClient({
      _origin: this.options._origin,
      _token: this.options._token,
      _credentials: this.options._credentials,
      xApiKey: this.options.xApiKey,
    }));
  }

  #sysprop: SysPropCrudServiceClient | undefined;

  public get sysprop(): SysPropCrudServiceClient {
    return (this.#sysprop ??= new SysPropCrudServiceClient({
      _origin: this.options._origin,
      _token: this.options._token,
      _credentials: this.options._credentials,
      xApiKey: this.options.xApiKey,
    }));
  }

  #v2: V2Wrapper | undefined;

  public get v2(): V2Wrapper {
    return (this.#v2 ??= new V2Wrapper(this.options));
  }
}
",
        "name": "Client.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";

export interface Client {
  updateTestSubmissionStatus(
    request: MyApi.admin.updateTestSubmissionStatus.Request
  ): Promise<MyApi.admin.updateTestSubmissionStatus.Response>;
  sendTestSubmissionUpdate(
    request: MyApi.admin.sendTestSubmissionUpdate.Request
  ): Promise<MyApi.admin.sendTestSubmissionUpdate.Response>;
  updateWorkspaceSubmissionStatus(
    request: MyApi.admin.updateWorkspaceSubmissionStatus.Request
  ): Promise<MyApi.admin.updateWorkspaceSubmissionStatus.Response>;
  sendWorkspaceSubmissionUpdate(
    request: MyApi.admin.sendWorkspaceSubmissionUpdate.Request
  ): Promise<MyApi.admin.sendWorkspaceSubmissionUpdate.Response>;
  storeTracedTestCase(
    request: MyApi.admin.storeTracedTestCase.Request
  ): Promise<MyApi.admin.storeTracedTestCase.Response>;
  storeTracedTestCaseV2(
    request: MyApi.admin.storeTracedTestCaseV2.Request
  ): Promise<MyApi.admin.storeTracedTestCaseV2.Response>;
  storeTracedWorkspace(
    request: MyApi.admin.storeTracedWorkspace.Request
  ): Promise<MyApi.admin.storeTracedWorkspace.Response>;
  storeTracedWorkspaceV2(
    request: MyApi.admin.storeTracedWorkspaceV2.Request
  ): Promise<MyApi.admin.storeTracedWorkspaceV2.Response>;
}

export declare namespace Client {
  interface Options {
    _origin: string;
    _token?: core.BearerToken;
    _credentials?: core.BasicAuth;
    xApiKey?: string;
  }
}

export class Client implements Client {
  constructor(private readonly options: Client.Options) {}

  public async updateTestSubmissionStatus(
    request: MyApi.admin.updateTestSubmissionStatus.Request
  ): Promise<MyApi.admin.updateTestSubmissionStatus.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/admin//store-test-submission-status/\${request.submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
      body: request._body,
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async sendTestSubmissionUpdate(
    request: MyApi.admin.sendTestSubmissionUpdate.Request
  ): Promise<MyApi.admin.sendTestSubmissionUpdate.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/admin//store-test-submission-status-v2/\${request.submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
      body: request._body,
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async updateWorkspaceSubmissionStatus(
    request: MyApi.admin.updateWorkspaceSubmissionStatus.Request
  ): Promise<MyApi.admin.updateWorkspaceSubmissionStatus.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/admin//store-workspace-submission-status/\${request.submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
      body: request._body,
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async sendWorkspaceSubmissionUpdate(
    request: MyApi.admin.sendWorkspaceSubmissionUpdate.Request
  ): Promise<MyApi.admin.sendWorkspaceSubmissionUpdate.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/admin//store-workspace-submission-status-v2/\${request.submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
      body: request._body,
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async storeTracedTestCase(
    request: MyApi.admin.storeTracedTestCase.Request
  ): Promise<MyApi.admin.storeTracedTestCase.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/admin//store-test-trace/submission/\${request.submissionId}/testCase/\${request.testCaseId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
      body: request._body,
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async storeTracedTestCaseV2(
    request: MyApi.admin.storeTracedTestCaseV2.Request
  ): Promise<MyApi.admin.storeTracedTestCaseV2.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/admin//store-test-trace-v2/submission/\${request.submissionId}/testCase/\${request.testCaseId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
      body: request._body,
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async storeTracedWorkspace(
    request: MyApi.admin.storeTracedWorkspace.Request
  ): Promise<MyApi.admin.storeTracedWorkspace.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/admin//store-workspace-trace/submission/\${request.submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
      body: request._body,
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async storeTracedWorkspaceV2(
    request: MyApi.admin.storeTracedWorkspaceV2.Request
  ): Promise<MyApi.admin.storeTracedWorkspaceV2.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/admin//store-workspace-trace-v2/submission/\${request.submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
      body: request._body,
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                "name": "Client.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as updateTestSubmissionStatus from \\"./updateTestSubmissionStatus\\";
export * as sendTestSubmissionUpdate from \\"./sendTestSubmissionUpdate\\";
export * as updateWorkspaceSubmissionStatus from \\"./updateWorkspaceSubmissionStatus\\";
export * as sendWorkspaceSubmissionUpdate from \\"./sendWorkspaceSubmissionUpdate\\";
export * as storeTracedTestCase from \\"./storeTracedTestCase\\";
export * as storeTracedTestCaseV2 from \\"./storeTracedTestCaseV2\\";
export * as storeTracedWorkspace from \\"./storeTracedWorkspace\\";
export * as storeTracedWorkspaceV2 from \\"./storeTracedWorkspaceV2\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  submissionId: MyApi.submission.SubmissionId;
  _body: MyApi.submission.TestSubmissionUpdate;
}

export type Response = core.APIResponse<
  void,
  MyApi.admin.sendTestSubmissionUpdate.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "sendTestSubmissionUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  submissionId: MyApi.submission.SubmissionId;
  _body: MyApi.submission.WorkspaceSubmissionUpdate;
}

export type Response = core.APIResponse<
  void,
  MyApi.admin.sendWorkspaceSubmissionUpdate.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "sendWorkspaceSubmissionUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  submissionId: MyApi.submission.SubmissionId;
  testCaseId: string;
  _body: MyApi.admin.StoreTracedTestCaseRequest;
}

export type Response = core.APIResponse<
  void,
  MyApi.admin.storeTracedTestCase.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "storeTracedTestCase.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  submissionId: MyApi.submission.SubmissionId;
  testCaseId: MyApi.v2.problem.TestCaseId;
  _body: MyApi.submission.TraceResponseV2[];
}

export type Response = core.APIResponse<
  void,
  MyApi.admin.storeTracedTestCaseV2.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "storeTracedTestCaseV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  submissionId: MyApi.submission.SubmissionId;
  _body: MyApi.admin.StoreTracedWorkspaceRequest;
}

export type Response = core.APIResponse<
  void,
  MyApi.admin.storeTracedWorkspace.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "storeTracedWorkspace.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  submissionId: MyApi.submission.SubmissionId;
  _body: MyApi.submission.TraceResponseV2[];
}

export type Response = core.APIResponse<
  void,
  MyApi.admin.storeTracedWorkspaceV2.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "storeTracedWorkspaceV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  submissionId: MyApi.submission.SubmissionId;
  _body: MyApi.submission.TestSubmissionStatus;
}

export type Response = core.APIResponse<
  void,
  MyApi.admin.updateTestSubmissionStatus.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "updateTestSubmissionStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  submissionId: MyApi.submission.SubmissionId;
  _body: MyApi.submission.WorkspaceSubmissionStatus;
}

export type Response = core.APIResponse<
  void,
  MyApi.admin.updateWorkspaceSubmissionStatus.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "updateWorkspaceSubmissionStatus.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface StoreTracedTestCaseRequest {
  result: MyApi.submission.TestCaseResultWithStdout;
  traceResponses: MyApi.submission.TraceResponse[];
}
",
                "name": "StoreTracedTestCaseRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface StoreTracedWorkspaceRequest {
  workspaceRunDetails: MyApi.submission.WorkspaceRunDetails;
  traceResponses: MyApi.submission.TraceResponse[];
}
",
                "name": "StoreTracedWorkspaceRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./StoreTracedTestCaseRequest\\";
export * from \\"./StoreTracedWorkspaceRequest\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "admin",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface BinaryTreeNodeAndTreeValue {
  nodeId: MyApi.commons.NodeId;
  fullTree: MyApi.commons.BinaryTreeValue;
}
",
                "name": "BinaryTreeNodeAndTreeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface BinaryTreeNodeValue {
  nodeId: MyApi.commons.NodeId;
  val: number;
  right?: MyApi.commons.NodeId;
  left?: MyApi.commons.NodeId;
}
",
                "name": "BinaryTreeNodeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface BinaryTreeValue {
  root?: MyApi.commons.NodeId;
  nodes: Record<string, MyApi.commons.BinaryTreeNodeValue>;
}
",
                "name": "BinaryTreeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface DebugKeyValuePairs {
  key: MyApi.commons.DebugVariableValue;
  value: MyApi.commons.DebugVariableValue;
}
",
                "name": "DebugKeyValuePairs.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface DebugMapValue {
  keyValuePairs: MyApi.commons.DebugKeyValuePairs[];
}
",
                "name": "DebugMapValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type DebugVariableValue =
  | DebugVariableValue.IntegerValue
  | DebugVariableValue.BooleanValue
  | DebugVariableValue.DoubleValue
  | DebugVariableValue.StringValue
  | DebugVariableValue.CharValue
  | DebugVariableValue.MapValue
  | DebugVariableValue.ListValue
  | DebugVariableValue.BinaryTreeNodeValue
  | DebugVariableValue.SinglyLinkedListNodeValue
  | DebugVariableValue.DoublyLinkedListNodeValue
  | DebugVariableValue.UndefinedValue
  | DebugVariableValue.NullValue
  | DebugVariableValue.GenericValue
  | DebugVariableValue._Unknown;

export declare namespace DebugVariableValue {
  interface IntegerValue extends _Utils {
    type: \\"integerValue\\";
    value: number;
  }

  interface BooleanValue extends _Utils {
    type: \\"booleanValue\\";
    value: boolean;
  }

  interface DoubleValue extends _Utils {
    type: \\"doubleValue\\";
    value: number;
  }

  interface StringValue extends _Utils {
    type: \\"stringValue\\";
    value: string;
  }

  interface CharValue extends _Utils {
    type: \\"charValue\\";
    value: string;
  }

  interface MapValue extends MyApi.commons.DebugMapValue, _Utils {
    type: \\"mapValue\\";
  }

  interface ListValue extends _Utils {
    type: \\"listValue\\";
    value: MyApi.commons.DebugVariableValue[];
  }

  interface BinaryTreeNodeValue
    extends MyApi.commons.BinaryTreeNodeAndTreeValue,
      _Utils {
    type: \\"binaryTreeNodeValue\\";
  }

  interface SinglyLinkedListNodeValue
    extends MyApi.commons.SinglyLinkedListNodeAndListValue,
      _Utils {
    type: \\"singlyLinkedListNodeValue\\";
  }

  interface DoublyLinkedListNodeValue
    extends MyApi.commons.DoublyLinkedListNodeAndListValue,
      _Utils {
    type: \\"doublyLinkedListNodeValue\\";
  }

  interface UndefinedValue extends _Utils {
    type: \\"undefinedValue\\";
  }

  interface NullValue extends _Utils {
    type: \\"nullValue\\";
  }

  interface GenericValue extends MyApi.commons.GenericValue, _Utils {
    type: \\"genericValue\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: DebugVariableValue._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    integerValue: (value: number) => Result;
    booleanValue: (value: boolean) => Result;
    doubleValue: (value: number) => Result;
    stringValue: (value: string) => Result;
    charValue: (value: string) => Result;
    mapValue: (value: MyApi.commons.DebugMapValue) => Result;
    listValue: (value: MyApi.commons.DebugVariableValue[]) => Result;
    binaryTreeNodeValue: (
      value: MyApi.commons.BinaryTreeNodeAndTreeValue
    ) => Result;
    singlyLinkedListNodeValue: (
      value: MyApi.commons.SinglyLinkedListNodeAndListValue
    ) => Result;
    doublyLinkedListNodeValue: (
      value: MyApi.commons.DoublyLinkedListNodeAndListValue
    ) => Result;
    undefinedValue: () => Result;
    nullValue: () => Result;
    genericValue: (value: MyApi.commons.GenericValue) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const DebugVariableValue = {
  integerValue: (value: number): DebugVariableValue.IntegerValue => ({
    value: value,
    type: \\"integerValue\\",
    _visit: (visitor) => visitor.integerValue(value),
  }),

  booleanValue: (value: boolean): DebugVariableValue.BooleanValue => ({
    value: value,
    type: \\"booleanValue\\",
    _visit: (visitor) => visitor.booleanValue(value),
  }),

  doubleValue: (value: number): DebugVariableValue.DoubleValue => ({
    value: value,
    type: \\"doubleValue\\",
    _visit: (visitor) => visitor.doubleValue(value),
  }),

  stringValue: (value: string): DebugVariableValue.StringValue => ({
    value: value,
    type: \\"stringValue\\",
    _visit: (visitor) => visitor.stringValue(value),
  }),

  charValue: (value: string): DebugVariableValue.CharValue => ({
    value: value,
    type: \\"charValue\\",
    _visit: (visitor) => visitor.charValue(value),
  }),

  mapValue: (
    value: MyApi.commons.DebugMapValue
  ): DebugVariableValue.MapValue => ({
    ...value,
    type: \\"mapValue\\",
    _visit: (visitor) => visitor.mapValue(value),
  }),

  listValue: (
    value: MyApi.commons.DebugVariableValue[]
  ): DebugVariableValue.ListValue => ({
    value: value,
    type: \\"listValue\\",
    _visit: (visitor) => visitor.listValue(value),
  }),

  binaryTreeNodeValue: (
    value: MyApi.commons.BinaryTreeNodeAndTreeValue
  ): DebugVariableValue.BinaryTreeNodeValue => ({
    ...value,
    type: \\"binaryTreeNodeValue\\",
    _visit: (visitor) => visitor.binaryTreeNodeValue(value),
  }),

  singlyLinkedListNodeValue: (
    value: MyApi.commons.SinglyLinkedListNodeAndListValue
  ): DebugVariableValue.SinglyLinkedListNodeValue => ({
    ...value,
    type: \\"singlyLinkedListNodeValue\\",
    _visit: (visitor) => visitor.singlyLinkedListNodeValue(value),
  }),

  doublyLinkedListNodeValue: (
    value: MyApi.commons.DoublyLinkedListNodeAndListValue
  ): DebugVariableValue.DoublyLinkedListNodeValue => ({
    ...value,
    type: \\"doublyLinkedListNodeValue\\",
    _visit: (visitor) => visitor.doublyLinkedListNodeValue(value),
  }),

  undefinedValue: (): DebugVariableValue.UndefinedValue => ({
    type: \\"undefinedValue\\",
    _visit: (visitor) => visitor.undefinedValue(),
  }),

  nullValue: (): DebugVariableValue.NullValue => ({
    type: \\"nullValue\\",
    _visit: (visitor) => visitor.nullValue(),
  }),

  genericValue: (
    value: MyApi.commons.GenericValue
  ): DebugVariableValue.GenericValue => ({
    ...value,
    type: \\"genericValue\\",
    _visit: (visitor) => visitor.genericValue(value),
  }),
} as const;
",
                "name": "DebugVariableValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface DoublyLinkedListNodeAndListValue {
  nodeId: MyApi.commons.NodeId;
  fullList: MyApi.commons.DoublyLinkedListValue;
}
",
                "name": "DoublyLinkedListNodeAndListValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface DoublyLinkedListNodeValue {
  nodeId: MyApi.commons.NodeId;
  val: number;
  next?: MyApi.commons.NodeId;
  prev?: MyApi.commons.NodeId;
}
",
                "name": "DoublyLinkedListNodeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface DoublyLinkedListValue {
  head?: MyApi.commons.NodeId;
  nodes: Record<string, MyApi.commons.DoublyLinkedListNodeValue>;
}
",
                "name": "DoublyLinkedListValue.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface FileInfo {
  filename: string;
  contents: string;
}
",
                "name": "FileInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface GenericValue {
  stringifiedType?: string;
  stringifiedValue: string;
}
",
                "name": "GenericValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface KeyValuePair {
  key: MyApi.commons.VariableValue;
  value: MyApi.commons.VariableValue;
}
",
                "name": "KeyValuePair.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface Language<
  RawValue extends Language.RawValue = Language.RawValue
> {
  get: () => RawValue;
  visit: <Result>(visitor: Language._Visitor<Result>) => Result;
}

export const Language = {
  Java: (): Language<\\"JAVA\\"> => ({
    get: () => \\"JAVA\\",
    visit: (visitor) => visitor.java(),
  }),
  Javascript: (): Language<\\"JAVASCRIPT\\"> => ({
    get: () => \\"JAVASCRIPT\\",
    visit: (visitor) => visitor.javascript(),
  }),
  Python: (): Language<\\"PYTHON\\"> => ({
    get: () => \\"PYTHON\\",
    visit: (visitor) => visitor.python(),
  }),
} as const;

export declare namespace Language {
  type RawValue = \\"JAVA\\" | \\"JAVASCRIPT\\" | \\"PYTHON\\" | string;

  interface _Visitor<Result> {
    java: () => Result;
    javascript: () => Result;
    python: () => Result;
    _other: (value: string) => Result;
  }
}
",
                "name": "Language.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface ListType {
  valueType: MyApi.commons.VariableType;
  /** Whether this list is fixed-size (for languages that supports fixed-size lists). Defaults to false. */
  isFixedLength?: boolean;
}
",
                "name": "ListType.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface MapType {
  keyType: MyApi.commons.VariableType;
  valueType: MyApi.commons.VariableType;
}
",
                "name": "MapType.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface MapValue {
  keyValuePairs: MyApi.commons.KeyValuePair[];
}
",
                "name": "MapValue.ts",
                "type": "file",
              },
              Object {
                "contents": "export type NodeId = string;
",
                "name": "NodeId.ts",
                "type": "file",
              },
              Object {
                "contents": "export type ProblemId = string;
",
                "name": "ProblemId.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface SinglyLinkedListNodeAndListValue {
  nodeId: MyApi.commons.NodeId;
  fullList: MyApi.commons.SinglyLinkedListValue;
}
",
                "name": "SinglyLinkedListNodeAndListValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface SinglyLinkedListNodeValue {
  nodeId: MyApi.commons.NodeId;
  val: number;
  next?: MyApi.commons.NodeId;
}
",
                "name": "SinglyLinkedListNodeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface SinglyLinkedListValue {
  head?: MyApi.commons.NodeId;
  nodes: Record<string, MyApi.commons.SinglyLinkedListNodeValue>;
}
",
                "name": "SinglyLinkedListValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface TestCase {
  id: string;
  params: MyApi.commons.VariableValue[];
}
",
                "name": "TestCase.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface TestCaseWithExpectedResult {
  testCase: MyApi.commons.TestCase;
  expectedResult: MyApi.commons.VariableValue;
}
",
                "name": "TestCaseWithExpectedResult.ts",
                "type": "file",
              },
              Object {
                "contents": "export type UserId = string;
",
                "name": "UserId.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type VariableType =
  | VariableType.IntegerType
  | VariableType.DoubleType
  | VariableType.BooleanType
  | VariableType.StringType
  | VariableType.CharType
  | VariableType.ListType
  | VariableType.MapType
  | VariableType.BinaryTreeType
  | VariableType.SinglyLinkedListType
  | VariableType.DoublyLinkedListType
  | VariableType._Unknown;

export declare namespace VariableType {
  interface IntegerType extends _Utils {
    type: \\"integerType\\";
  }

  interface DoubleType extends _Utils {
    type: \\"doubleType\\";
  }

  interface BooleanType extends _Utils {
    type: \\"booleanType\\";
  }

  interface StringType extends _Utils {
    type: \\"stringType\\";
  }

  interface CharType extends _Utils {
    type: \\"charType\\";
  }

  interface ListType extends MyApi.commons.ListType, _Utils {
    type: \\"listType\\";
  }

  interface MapType extends MyApi.commons.MapType, _Utils {
    type: \\"mapType\\";
  }

  interface BinaryTreeType extends _Utils {
    type: \\"binaryTreeType\\";
  }

  interface SinglyLinkedListType extends _Utils {
    type: \\"singlyLinkedListType\\";
  }

  interface DoublyLinkedListType extends _Utils {
    type: \\"doublyLinkedListType\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: VariableType._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    integerType: () => Result;
    doubleType: () => Result;
    booleanType: () => Result;
    stringType: () => Result;
    charType: () => Result;
    listType: (value: MyApi.commons.ListType) => Result;
    mapType: (value: MyApi.commons.MapType) => Result;
    binaryTreeType: () => Result;
    singlyLinkedListType: () => Result;
    doublyLinkedListType: () => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const VariableType = {
  integerType: (): VariableType.IntegerType => ({
    type: \\"integerType\\",
    _visit: (visitor) => visitor.integerType(),
  }),

  doubleType: (): VariableType.DoubleType => ({
    type: \\"doubleType\\",
    _visit: (visitor) => visitor.doubleType(),
  }),

  booleanType: (): VariableType.BooleanType => ({
    type: \\"booleanType\\",
    _visit: (visitor) => visitor.booleanType(),
  }),

  stringType: (): VariableType.StringType => ({
    type: \\"stringType\\",
    _visit: (visitor) => visitor.stringType(),
  }),

  charType: (): VariableType.CharType => ({
    type: \\"charType\\",
    _visit: (visitor) => visitor.charType(),
  }),

  listType: (value: MyApi.commons.ListType): VariableType.ListType => ({
    ...value,
    type: \\"listType\\",
    _visit: (visitor) => visitor.listType(value),
  }),

  mapType: (value: MyApi.commons.MapType): VariableType.MapType => ({
    ...value,
    type: \\"mapType\\",
    _visit: (visitor) => visitor.mapType(value),
  }),

  binaryTreeType: (): VariableType.BinaryTreeType => ({
    type: \\"binaryTreeType\\",
    _visit: (visitor) => visitor.binaryTreeType(),
  }),

  singlyLinkedListType: (): VariableType.SinglyLinkedListType => ({
    type: \\"singlyLinkedListType\\",
    _visit: (visitor) => visitor.singlyLinkedListType(),
  }),

  doublyLinkedListType: (): VariableType.DoublyLinkedListType => ({
    type: \\"doublyLinkedListType\\",
    _visit: (visitor) => visitor.doublyLinkedListType(),
  }),
} as const;
",
                "name": "VariableType.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type VariableValue =
  | VariableValue.IntegerValue
  | VariableValue.BooleanValue
  | VariableValue.DoubleValue
  | VariableValue.StringValue
  | VariableValue.CharValue
  | VariableValue.MapValue
  | VariableValue.ListValue
  | VariableValue.BinaryTreeValue
  | VariableValue.SinglyLinkedListValue
  | VariableValue.DoublyLinkedListValue
  | VariableValue.NullValue
  | VariableValue._Unknown;

export declare namespace VariableValue {
  interface IntegerValue extends _Utils {
    type: \\"integerValue\\";
    value: number;
  }

  interface BooleanValue extends _Utils {
    type: \\"booleanValue\\";
    value: boolean;
  }

  interface DoubleValue extends _Utils {
    type: \\"doubleValue\\";
    value: number;
  }

  interface StringValue extends _Utils {
    type: \\"stringValue\\";
    value: string;
  }

  interface CharValue extends _Utils {
    type: \\"charValue\\";
    value: string;
  }

  interface MapValue extends MyApi.commons.MapValue, _Utils {
    type: \\"mapValue\\";
  }

  interface ListValue extends _Utils {
    type: \\"listValue\\";
    value: MyApi.commons.VariableValue[];
  }

  interface BinaryTreeValue extends MyApi.commons.BinaryTreeValue, _Utils {
    type: \\"binaryTreeValue\\";
  }

  interface SinglyLinkedListValue
    extends MyApi.commons.SinglyLinkedListValue,
      _Utils {
    type: \\"singlyLinkedListValue\\";
  }

  interface DoublyLinkedListValue
    extends MyApi.commons.DoublyLinkedListValue,
      _Utils {
    type: \\"doublyLinkedListValue\\";
  }

  interface NullValue extends _Utils {
    type: \\"nullValue\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: VariableValue._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    integerValue: (value: number) => Result;
    booleanValue: (value: boolean) => Result;
    doubleValue: (value: number) => Result;
    stringValue: (value: string) => Result;
    charValue: (value: string) => Result;
    mapValue: (value: MyApi.commons.MapValue) => Result;
    listValue: (value: MyApi.commons.VariableValue[]) => Result;
    binaryTreeValue: (value: MyApi.commons.BinaryTreeValue) => Result;
    singlyLinkedListValue: (
      value: MyApi.commons.SinglyLinkedListValue
    ) => Result;
    doublyLinkedListValue: (
      value: MyApi.commons.DoublyLinkedListValue
    ) => Result;
    nullValue: () => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const VariableValue = {
  integerValue: (value: number): VariableValue.IntegerValue => ({
    value: value,
    type: \\"integerValue\\",
    _visit: (visitor) => visitor.integerValue(value),
  }),

  booleanValue: (value: boolean): VariableValue.BooleanValue => ({
    value: value,
    type: \\"booleanValue\\",
    _visit: (visitor) => visitor.booleanValue(value),
  }),

  doubleValue: (value: number): VariableValue.DoubleValue => ({
    value: value,
    type: \\"doubleValue\\",
    _visit: (visitor) => visitor.doubleValue(value),
  }),

  stringValue: (value: string): VariableValue.StringValue => ({
    value: value,
    type: \\"stringValue\\",
    _visit: (visitor) => visitor.stringValue(value),
  }),

  charValue: (value: string): VariableValue.CharValue => ({
    value: value,
    type: \\"charValue\\",
    _visit: (visitor) => visitor.charValue(value),
  }),

  mapValue: (value: MyApi.commons.MapValue): VariableValue.MapValue => ({
    ...value,
    type: \\"mapValue\\",
    _visit: (visitor) => visitor.mapValue(value),
  }),

  listValue: (
    value: MyApi.commons.VariableValue[]
  ): VariableValue.ListValue => ({
    value: value,
    type: \\"listValue\\",
    _visit: (visitor) => visitor.listValue(value),
  }),

  binaryTreeValue: (
    value: MyApi.commons.BinaryTreeValue
  ): VariableValue.BinaryTreeValue => ({
    ...value,
    type: \\"binaryTreeValue\\",
    _visit: (visitor) => visitor.binaryTreeValue(value),
  }),

  singlyLinkedListValue: (
    value: MyApi.commons.SinglyLinkedListValue
  ): VariableValue.SinglyLinkedListValue => ({
    ...value,
    type: \\"singlyLinkedListValue\\",
    _visit: (visitor) => visitor.singlyLinkedListValue(value),
  }),

  doublyLinkedListValue: (
    value: MyApi.commons.DoublyLinkedListValue
  ): VariableValue.DoublyLinkedListValue => ({
    ...value,
    type: \\"doublyLinkedListValue\\",
    _visit: (visitor) => visitor.doublyLinkedListValue(value),
  }),

  nullValue: (): VariableValue.NullValue => ({
    type: \\"nullValue\\",
    _visit: (visitor) => visitor.nullValue(),
  }),
} as const;
",
                "name": "VariableValue.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./UserId\\";
export * from \\"./ProblemId\\";
export * from \\"./NodeId\\";
export * from \\"./VariableType\\";
export * from \\"./ListType\\";
export * from \\"./MapType\\";
export * from \\"./VariableValue\\";
export * from \\"./DebugVariableValue\\";
export * from \\"./GenericValue\\";
export * from \\"./MapValue\\";
export * from \\"./KeyValuePair\\";
export * from \\"./BinaryTreeValue\\";
export * from \\"./BinaryTreeNodeValue\\";
export * from \\"./BinaryTreeNodeAndTreeValue\\";
export * from \\"./SinglyLinkedListValue\\";
export * from \\"./SinglyLinkedListNodeValue\\";
export * from \\"./SinglyLinkedListNodeAndListValue\\";
export * from \\"./DoublyLinkedListValue\\";
export * from \\"./DoublyLinkedListNodeValue\\";
export * from \\"./DoublyLinkedListNodeAndListValue\\";
export * from \\"./DebugMapValue\\";
export * from \\"./DebugKeyValuePairs\\";
export * from \\"./TestCase\\";
export * from \\"./TestCaseWithExpectedResult\\";
export * from \\"./FileInfo\\";
export * from \\"./Language\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "commons",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as schemas from \\"../../../schemas\\";

export interface Client {
  getHomepageProblems(): Promise<MyApi.homepage.getHomepageProblems.Response>;
  setHomepageProblems(
    request: MyApi.commons.ProblemId[]
  ): Promise<MyApi.homepage.setHomepageProblems.Response>;
}

export declare namespace Client {
  interface Options {
    _origin: string;
    _token?: core.BearerToken;
    _credentials?: core.BasicAuth;
    xApiKey?: string;
  }
}

export class Client implements Client {
  constructor(private readonly options: Client.Options) {}

  public async getHomepageProblems(): Promise<MyApi.homepage.getHomepageProblems.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/\\"),
      method: \\"GET\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.homepage.getHomepageProblems.Response.parse(
          response.body as schemas.commons.ProblemId.Raw[]
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async setHomepageProblems(
    request: MyApi.commons.ProblemId[]
  ): Promise<MyApi.homepage.setHomepageProblems.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/\\"),
      method: \\"POST\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
      body: schemas.homepage.setHomepageProblems.Request.json(request),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                "name": "Client.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  MyApi.commons.ProblemId[],
  MyApi.homepage.getHomepageProblems.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "getHomepageProblems.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as getHomepageProblems from \\"./getHomepageProblems\\";
export * as setHomepageProblems from \\"./setHomepageProblems\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  void,
  MyApi.homepage.setHomepageProblems.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "setHomepageProblems.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "homepage",
        "type": "directory",
      },
      Object {
        "contents": "export * as admin from \\"./admin\\";
export * from \\"./admin/types\\";
export * as commons from \\"./commons\\";
export * from \\"./commons/types\\";
export * as langServer from \\"./lang-server\\";
export * from \\"./lang-server/types\\";
export * as migration from \\"./migration\\";
export * from \\"./migration/types\\";
export * as playlist from \\"./playlist\\";
export * from \\"./playlist/types\\";
export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as submission from \\"./submission\\";
export * from \\"./submission/types\\";
export * as v2 from \\"./v2\\";
export * from \\"./playlist/errors\\";
export * as homepage from \\"./homepage\\";
export * as sysprop from \\"./sysprop\\";
export * from \\"./Client\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export interface LangServerRequest {
  request?: unknown;
}
",
                "name": "LangServerRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface LangServerResponse {
  response?: unknown;
}
",
                "name": "LangServerResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./LangServerRequest\\";
export * from \\"./LangServerResponse\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "lang-server",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as schemas from \\"../../../schemas\\";

export interface Client {
  getAttemptedMigrations(): Promise<MyApi.migration.getAttemptedMigrations.Response>;
}

export declare namespace Client {
  interface Options {
    _origin: string;
    _token?: core.BearerToken;
    _credentials?: core.BasicAuth;
    xApiKey?: string;
  }
}

export class Client implements Client {
  constructor(private readonly options: Client.Options) {}

  public async getAttemptedMigrations(): Promise<MyApi.migration.getAttemptedMigrations.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/all\\"),
      method: \\"GET\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.migration.getAttemptedMigrations.Response.parse(
          response.body as schemas.migration.Migration.Raw[]
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                "name": "Client.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  MyApi.migration.Migration[],
  MyApi.migration.getAttemptedMigrations.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "getAttemptedMigrations.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as getAttemptedMigrations from \\"./getAttemptedMigrations\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface Migration {
  name: string;
  status: MyApi.migration.MigrationStatus;
}
",
                "name": "Migration.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface MigrationStatus<
  RawValue extends MigrationStatus.RawValue = MigrationStatus.RawValue
> {
  get: () => RawValue;
  visit: <Result>(visitor: MigrationStatus._Visitor<Result>) => Result;
}

export const MigrationStatus = {
  Running: (): MigrationStatus<\\"RUNNING\\"> => ({
    get: () => \\"RUNNING\\",
    visit: (visitor) => visitor.running(),
  }),
  Failed: (): MigrationStatus<\\"FAILED\\"> => ({
    get: () => \\"FAILED\\",
    visit: (visitor) => visitor.failed(),
  }),
  Finished: (): MigrationStatus<\\"FINISHED\\"> => ({
    get: () => \\"FINISHED\\",
    visit: (visitor) => visitor.finished(),
  }),
} as const;

export declare namespace MigrationStatus {
  type RawValue = \\"RUNNING\\" | \\"FAILED\\" | \\"FINISHED\\" | string;

  interface _Visitor<Result> {
    running: () => Result;
    failed: () => Result;
    finished: () => Result;
    _other: (value: string) => Result;
  }
}
",
                "name": "MigrationStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./MigrationStatus\\";
export * from \\"./Migration\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "migration",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as schemas from \\"../../../schemas\\";

export interface Client {
  createPlaylist(
    request: MyApi.playlist.createPlaylist.Request
  ): Promise<MyApi.playlist.createPlaylist.Response>;
  getPlaylists(
    request: MyApi.playlist.getPlaylists.Request
  ): Promise<MyApi.playlist.getPlaylists.Response>;
  getPlaylist(
    request: MyApi.playlist.getPlaylist.Request
  ): Promise<MyApi.playlist.getPlaylist.Response>;
  updatePlaylist(
    request: MyApi.playlist.updatePlaylist.Request
  ): Promise<MyApi.playlist.updatePlaylist.Response>;
  deletePlaylist(
    request: MyApi.playlist.deletePlaylist.Request
  ): Promise<MyApi.playlist.deletePlaylist.Response>;
}

export declare namespace Client {
  interface Options {
    _origin: string;
    _token?: core.BearerToken;
    _credentials?: core.BasicAuth;
    xApiKey?: string;
  }
}

export class Client implements Client {
  constructor(private readonly options: Client.Options) {}

  public async createPlaylist(
    request: MyApi.playlist.createPlaylist.Request
  ): Promise<MyApi.playlist.createPlaylist.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/v2/playlist/\${request.serviceParam}/create\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
      body: request._body,
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.playlist.Playlist.parse(
          response.body as schemas.playlist.Playlist.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getPlaylists(
    request: MyApi.playlist.getPlaylists.Request
  ): Promise<MyApi.playlist.getPlaylists.Response> {
    const queryParameters = new URLSearchParams();
    if (request.limit != null) {
      queryParameters.append(\\"limit\\", request.limit.toString());
    }

    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/v2/playlist/\${request.serviceParam}/all\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
      queryParameters: queryParameters,
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.playlist.getPlaylists.Response.parse(
          response.body as schemas.playlist.Playlist.Raw[]
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getPlaylist(
    request: MyApi.playlist.getPlaylist.Request
  ): Promise<MyApi.playlist.getPlaylist.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/v2/playlist/\${request.serviceParam}/\${request.playlistId}\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.playlist.Playlist.parse(
          response.body as schemas.playlist.Playlist.Raw
        ),
      };
    }

    if (response.error.reason === \\"status-code\\") {
      switch (
        (response.error.body as schemas.playlist.getPlaylist.Error.Raw)
          ?.errorName
      ) {
        case \\"PlaylistIdNotFoundError\\":
        case \\"UnauthorizedError\\":
          return {
            ok: false,
            error: schemas.playlist.getPlaylist.Error.parse(
              response.error.body as schemas.playlist.getPlaylist.Error.Raw
            ),
          };
      }
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async updatePlaylist(
    request: MyApi.playlist.updatePlaylist.Request
  ): Promise<MyApi.playlist.updatePlaylist.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/v2/playlist/\${request.serviceParam}/\${request.playlistId}\`
      ),
      method: \\"PUT\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
      body: request._body,
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.playlist.updatePlaylist.Response.parse(
          response.body as schemas.playlist.Playlist.Raw | null | undefined
        ),
      };
    }

    if (response.error.reason === \\"status-code\\") {
      switch (
        (response.error.body as schemas.playlist.updatePlaylist.Error.Raw)
          ?.errorName
      ) {
        case \\"PlaylistIdNotFoundError\\":
          return {
            ok: false,
            error: schemas.playlist.updatePlaylist.Error.parse(
              response.error.body as schemas.playlist.updatePlaylist.Error.Raw
            ),
          };
      }
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async deletePlaylist(
    request: MyApi.playlist.deletePlaylist.Request
  ): Promise<MyApi.playlist.deletePlaylist.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/v2/playlist/\${request.serviceParam}/\${request.playlistId}\`
      ),
      method: \\"DELETE\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                "name": "Client.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  serviceParam: number;
  _body: MyApi.playlist.PlaylistCreateRequest;
}

export type Response = core.APIResponse<
  MyApi.playlist.Playlist,
  MyApi.playlist.createPlaylist.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "createPlaylist.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  serviceParam: number;
  playlistId: MyApi.playlist.PlaylistId;
}

export type Response = core.APIResponse<
  void,
  MyApi.playlist.deletePlaylist.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "deletePlaylist.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  serviceParam: number;
  playlistId: MyApi.playlist.PlaylistId;
}

export type Response = core.APIResponse<
  MyApi.playlist.Playlist,
  MyApi.playlist.getPlaylist.Error
>;
export type Error =
  | Error.PlaylistIdNotFoundError
  | Error.UnauthorizedError
  | Error._Unknown;

export declare namespace Error {
  interface PlaylistIdNotFoundError extends _Utils {
    errorName: \\"PlaylistIdNotFoundError\\";
    content: MyApi.playlist.PlaylistIdNotFoundError;
  }

  interface UnauthorizedError extends _Utils {
    errorName: \\"UnauthorizedError\\";
  }

  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    playlistIdNotFoundError: (
      value: MyApi.playlist.PlaylistIdNotFoundError
    ) => Result;
    unauthorizedError: () => Result;
    _other: (value: core.Fetcher.Error) => Result;
  }
}

export const Error = {
  playlistIdNotFoundError: (
    value: MyApi.playlist.PlaylistIdNotFoundError
  ): Error.PlaylistIdNotFoundError => ({
    content: value,
    errorName: \\"PlaylistIdNotFoundError\\",
    _visit: (visitor) => visitor.playlistIdNotFoundError(value),
  }),

  unauthorizedError: (): Error.UnauthorizedError => ({
    errorName: \\"UnauthorizedError\\",
    _visit: (visitor) => visitor.unauthorizedError(),
  }),
} as const;
",
                "name": "getPlaylist.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  limit?: number;
  serviceParam: number;
}

export type Response = core.APIResponse<
  MyApi.playlist.Playlist[],
  MyApi.playlist.getPlaylists.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "getPlaylists.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as createPlaylist from \\"./createPlaylist\\";
export * as getPlaylists from \\"./getPlaylists\\";
export * as getPlaylist from \\"./getPlaylist\\";
export * as updatePlaylist from \\"./updatePlaylist\\";
export * as deletePlaylist from \\"./deletePlaylist\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  serviceParam: number;
  playlistId: MyApi.playlist.PlaylistId;
  _body?: MyApi.playlist.UpdatePlaylistRequest;
}

export type Response = core.APIResponse<
  MyApi.playlist.Playlist | undefined,
  MyApi.playlist.updatePlaylist.Error
>;
export type Error = Error.PlaylistIdNotFoundError | Error._Unknown;

export declare namespace Error {
  interface PlaylistIdNotFoundError extends _Utils {
    errorName: \\"PlaylistIdNotFoundError\\";
    content: MyApi.playlist.PlaylistIdNotFoundError;
  }

  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    playlistIdNotFoundError: (
      value: MyApi.playlist.PlaylistIdNotFoundError
    ) => Result;
    _other: (value: core.Fetcher.Error) => Result;
  }
}

export const Error = {
  playlistIdNotFoundError: (
    value: MyApi.playlist.PlaylistIdNotFoundError
  ): Error.PlaylistIdNotFoundError => ({
    content: value,
    errorName: \\"PlaylistIdNotFoundError\\",
    _visit: (visitor) => visitor.playlistIdNotFoundError(value),
  }),
} as const;
",
                "name": "updatePlaylist.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type PlaylistIdNotFoundError =
  | PlaylistIdNotFoundError.PlaylistId
  | PlaylistIdNotFoundError._Unknown;

export declare namespace PlaylistIdNotFoundError {
  interface PlaylistId extends _Utils {
    type: \\"playlistId\\";
    value: MyApi.playlist.PlaylistId;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(
      visitor: PlaylistIdNotFoundError._Visitor<Result>
    ) => Result;
  }

  interface _Visitor<Result> {
    playlistId: (value: MyApi.playlist.PlaylistId) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const PlaylistIdNotFoundError = {
  playlistId: (
    value: MyApi.playlist.PlaylistId
  ): PlaylistIdNotFoundError.PlaylistId => ({
    value: value,
    type: \\"playlistId\\",
    _visit: (visitor) => visitor.playlistId(value),
  }),
} as const;
",
                "name": "PlaylistIdNotFoundError.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./PlaylistIdNotFoundError\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "errors",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./errors\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface Playlist {
  playlistId: MyApi.playlist.PlaylistId;
  name: string;
  problems: MyApi.commons.ProblemId[];
  ownerId: MyApi.commons.UserId;
}
",
                "name": "Playlist.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface PlaylistCreateRequest {
  name: string;
  problems: MyApi.commons.ProblemId[];
}
",
                "name": "PlaylistCreateRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "export type PlaylistId = string;
",
                "name": "PlaylistId.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface UpdatePlaylistRequest {
  name: string;
  problems: MyApi.commons.ProblemId[];
}
",
                "name": "UpdatePlaylistRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./PlaylistId\\";
export * from \\"./Playlist\\";
export * from \\"./PlaylistCreateRequest\\";
export * from \\"./UpdatePlaylistRequest\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "playlist",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as schemas from \\"../../../schemas\\";

export interface Client {
  createProblem(
    request: MyApi.problem.CreateProblemRequest
  ): Promise<MyApi.problem.createProblem.Response>;
  updateProblem(
    request: MyApi.problem.updateProblem.Request
  ): Promise<MyApi.problem.updateProblem.Response>;
  deleteProblem(
    request: MyApi.problem.deleteProblem.Request
  ): Promise<MyApi.problem.deleteProblem.Response>;
  getDefaultStarterFiles(
    request: MyApi.problem.GetDefaultStarterFilesRequest
  ): Promise<MyApi.problem.getDefaultStarterFiles.Response>;
}

export declare namespace Client {
  interface Options {
    _origin: string;
    _token?: core.BearerToken;
    _credentials?: core.BasicAuth;
    xApiKey?: string;
  }
}

export class Client implements Client {
  constructor(private readonly options: Client.Options) {}

  public async createProblem(
    request: MyApi.problem.CreateProblemRequest
  ): Promise<MyApi.problem.createProblem.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/create\\"),
      method: \\"POST\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
      body: schemas.problem.CreateProblemRequest.json(request),
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.problem.CreateProblemResponse.parse(
          response.body as schemas.problem.CreateProblemResponse.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async updateProblem(
    request: MyApi.problem.updateProblem.Request
  ): Promise<MyApi.problem.updateProblem.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/problem-crud//update/\${request.problemId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
      body: request._body,
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.problem.UpdateProblemResponse.parse(
          response.body as schemas.problem.UpdateProblemResponse.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async deleteProblem(
    request: MyApi.problem.deleteProblem.Request
  ): Promise<MyApi.problem.deleteProblem.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/problem-crud//delete/\${request.problemId}\`
      ),
      method: \\"DELETE\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getDefaultStarterFiles(
    request: MyApi.problem.GetDefaultStarterFilesRequest
  ): Promise<MyApi.problem.getDefaultStarterFiles.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/default-starter-files\\"),
      method: \\"POST\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
      body: schemas.problem.GetDefaultStarterFilesRequest.json(request),
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.problem.GetDefaultStarterFilesResponse.parse(
          response.body as schemas.problem.GetDefaultStarterFilesResponse.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                "name": "Client.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  MyApi.problem.CreateProblemResponse,
  MyApi.problem.createProblem.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "createProblem.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  problemId: MyApi.commons.ProblemId;
}

export type Response = core.APIResponse<
  void,
  MyApi.problem.deleteProblem.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "deleteProblem.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  MyApi.problem.GetDefaultStarterFilesResponse,
  MyApi.problem.getDefaultStarterFiles.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "getDefaultStarterFiles.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as createProblem from \\"./createProblem\\";
export * as updateProblem from \\"./updateProblem\\";
export * as deleteProblem from \\"./deleteProblem\\";
export * as getDefaultStarterFiles from \\"./getDefaultStarterFiles\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  problemId: MyApi.commons.ProblemId;
  _body: MyApi.problem.CreateProblemRequest;
}

export type Response = core.APIResponse<
  MyApi.problem.UpdateProblemResponse,
  MyApi.problem.updateProblem.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "updateProblem.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type CreateProblemError =
  | CreateProblemError.Generic
  | CreateProblemError._Unknown;

export declare namespace CreateProblemError {
  interface Generic extends MyApi.problem.GenericCreateProblemError, _Utils {
    errorType: \\"generic\\";
  }

  interface _Unknown extends _Utils {
    errorType: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: CreateProblemError._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    generic: (value: MyApi.problem.GenericCreateProblemError) => Result;
    _other: (value: { errorType: string }) => Result;
  }
}

export const CreateProblemError = {
  generic: (
    value: MyApi.problem.GenericCreateProblemError
  ): CreateProblemError.Generic => ({
    ...value,
    errorType: \\"generic\\",
    _visit: (visitor) => visitor.generic(value),
  }),
} as const;
",
                "name": "CreateProblemError.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface CreateProblemRequest {
  problemName: string;
  problemDescription: MyApi.problem.ProblemDescription;
  files: Record<MyApi.commons.Language.RawValue, MyApi.problem.ProblemFiles>;
  inputParams: MyApi.problem.VariableTypeAndName[];
  outputType: MyApi.commons.VariableType;
  testcases: MyApi.commons.TestCaseWithExpectedResult[];
  methodName: string;
}
",
                "name": "CreateProblemRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type CreateProblemResponse =
  | CreateProblemResponse.Success
  | CreateProblemResponse.Error
  | CreateProblemResponse._Unknown;

export declare namespace CreateProblemResponse {
  interface Success extends _Utils {
    type: \\"success\\";
    value: MyApi.commons.ProblemId;
  }

  interface Error extends _Utils {
    type: \\"error\\";
    value: MyApi.problem.CreateProblemError;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: CreateProblemResponse._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    success: (value: MyApi.commons.ProblemId) => Result;
    error: (value: MyApi.problem.CreateProblemError) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const CreateProblemResponse = {
  success: (value: MyApi.commons.ProblemId): CreateProblemResponse.Success => ({
    value: value,
    type: \\"success\\",
    _visit: (visitor) => visitor.success(value),
  }),

  error: (
    value: MyApi.problem.CreateProblemError
  ): CreateProblemResponse.Error => ({
    value: value,
    type: \\"error\\",
    _visit: (visitor) => visitor.error(value),
  }),
} as const;
",
                "name": "CreateProblemResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface GenericCreateProblemError {
  message: string;
  type: string;
  stacktrace: string;
}
",
                "name": "GenericCreateProblemError.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface GetDefaultStarterFilesRequest {
  inputParams: MyApi.problem.VariableTypeAndName[];
  outputType: MyApi.commons.VariableType;
  methodName: string;
}
",
                "name": "GetDefaultStarterFilesRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface GetDefaultStarterFilesResponse {
  files: Record<MyApi.commons.Language.RawValue, MyApi.problem.ProblemFiles>;
}
",
                "name": "GetDefaultStarterFilesResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface ProblemDescription {
  boards: MyApi.problem.ProblemDescriptionBoard[];
}
",
                "name": "ProblemDescription.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type ProblemDescriptionBoard =
  | ProblemDescriptionBoard.Html
  | ProblemDescriptionBoard.Variable
  | ProblemDescriptionBoard.TestCaseId
  | ProblemDescriptionBoard._Unknown;

export declare namespace ProblemDescriptionBoard {
  interface Html extends _Utils {
    type: \\"html\\";
    value: string;
  }

  interface Variable extends _Utils {
    type: \\"variable\\";
    value: MyApi.commons.VariableValue;
  }

  interface TestCaseId extends _Utils {
    type: \\"testCaseId\\";
    value: string;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(
      visitor: ProblemDescriptionBoard._Visitor<Result>
    ) => Result;
  }

  interface _Visitor<Result> {
    html: (value: string) => Result;
    variable: (value: MyApi.commons.VariableValue) => Result;
    testCaseId: (value: string) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const ProblemDescriptionBoard = {
  html: (value: string): ProblemDescriptionBoard.Html => ({
    value: value,
    type: \\"html\\",
    _visit: (visitor) => visitor.html(value),
  }),

  variable: (
    value: MyApi.commons.VariableValue
  ): ProblemDescriptionBoard.Variable => ({
    value: value,
    type: \\"variable\\",
    _visit: (visitor) => visitor.variable(value),
  }),

  testCaseId: (value: string): ProblemDescriptionBoard.TestCaseId => ({
    value: value,
    type: \\"testCaseId\\",
    _visit: (visitor) => visitor.testCaseId(value),
  }),
} as const;
",
                "name": "ProblemDescriptionBoard.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface ProblemFiles {
  solutionFile: MyApi.commons.FileInfo;
  readOnlyFiles: MyApi.commons.FileInfo[];
}
",
                "name": "ProblemFiles.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface ProblemInfo {
  problemId: MyApi.commons.ProblemId;
  problemDescription: MyApi.problem.ProblemDescription;
  problemName: string;
  problemVersion: number;
  files: Record<MyApi.commons.Language.RawValue, MyApi.problem.ProblemFiles>;
  inputParams: MyApi.problem.VariableTypeAndName[];
  outputType: MyApi.commons.VariableType;
  testcases: MyApi.commons.TestCaseWithExpectedResult[];
  methodName: string;
  supportsCustomTestCases: boolean;
}
",
                "name": "ProblemInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface UpdateProblemResponse {
  problemVersion: number;
}
",
                "name": "UpdateProblemResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface VariableTypeAndName {
  variableType: MyApi.commons.VariableType;
  name: string;
}
",
                "name": "VariableTypeAndName.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./ProblemInfo\\";
export * from \\"./ProblemDescription\\";
export * from \\"./ProblemDescriptionBoard\\";
export * from \\"./ProblemFiles\\";
export * from \\"./VariableTypeAndName\\";
export * from \\"./CreateProblemRequest\\";
export * from \\"./CreateProblemResponse\\";
export * from \\"./UpdateProblemResponse\\";
export * from \\"./CreateProblemError\\";
export * from \\"./GenericCreateProblemError\\";
export * from \\"./GetDefaultStarterFilesRequest\\";
export * from \\"./GetDefaultStarterFilesResponse\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "problem",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as schemas from \\"../../../schemas\\";

export interface Client {
  createExecutionSession(
    request: MyApi.submission.createExecutionSession.Request
  ): Promise<MyApi.submission.createExecutionSession.Response>;
  getExecutionSession(
    request: MyApi.submission.getExecutionSession.Request
  ): Promise<MyApi.submission.getExecutionSession.Response>;
  stopExecutionSession(
    request: MyApi.submission.stopExecutionSession.Request
  ): Promise<MyApi.submission.stopExecutionSession.Response>;
  getExecutionSessionsState(): Promise<MyApi.submission.getExecutionSessionsState.Response>;
}

export declare namespace Client {
  interface Options {
    _origin: string;
    _token?: core.BearerToken;
    _credentials?: core.BasicAuth;
    xApiKey?: string;
  }
}

/**
 * Responsible for spinning up and spinning down execution.
 */
export class Client implements Client {
  constructor(private readonly options: Client.Options) {}

  public async createExecutionSession(
    request: MyApi.submission.createExecutionSession.Request
  ): Promise<MyApi.submission.createExecutionSession.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/sessions//create-session/\${request.language}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.submission.ExecutionSessionResponse.parse(
          response.body as schemas.submission.ExecutionSessionResponse.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getExecutionSession(
    request: MyApi.submission.getExecutionSession.Request
  ): Promise<MyApi.submission.getExecutionSession.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \`/sessions//\${request.sessionId}\`),
      method: \\"GET\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.submission.getExecutionSession.Response.parse(
          response.body as
            | schemas.submission.ExecutionSessionResponse.Raw
            | null
            | undefined
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async stopExecutionSession(
    request: MyApi.submission.stopExecutionSession.Request
  ): Promise<MyApi.submission.stopExecutionSession.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/sessions//stop/\${request.sessionId}\`
      ),
      method: \\"DELETE\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getExecutionSessionsState(): Promise<MyApi.submission.getExecutionSessionsState.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/execution-sessions-state\\"),
      method: \\"GET\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.submission.GetExecutionSessionStateResponse.parse(
          response.body as schemas.submission.GetExecutionSessionStateResponse.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                "name": "Client.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  language: MyApi.commons.Language;
}

export type Response = core.APIResponse<
  MyApi.submission.ExecutionSessionResponse,
  MyApi.submission.createExecutionSession.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "createExecutionSession.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  sessionId: string;
}

export type Response = core.APIResponse<
  MyApi.submission.ExecutionSessionResponse | undefined,
  MyApi.submission.getExecutionSession.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "getExecutionSession.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  MyApi.submission.GetExecutionSessionStateResponse,
  MyApi.submission.getExecutionSessionsState.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "getExecutionSessionsState.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as createExecutionSession from \\"./createExecutionSession\\";
export * as getExecutionSession from \\"./getExecutionSession\\";
export * as stopExecutionSession from \\"./stopExecutionSession\\";
export * as getExecutionSessionsState from \\"./getExecutionSessionsState\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  sessionId: string;
}

export type Response = core.APIResponse<
  void,
  MyApi.submission.stopExecutionSession.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "stopExecutionSession.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type ActualResult =
  | ActualResult.Value
  | ActualResult.Exception
  | ActualResult.ExceptionV2
  | ActualResult._Unknown;

export declare namespace ActualResult {
  interface Value extends _Utils {
    type: \\"value\\";
    value: MyApi.commons.VariableValue;
  }

  interface Exception extends MyApi.submission.ExceptionInfo, _Utils {
    type: \\"exception\\";
  }

  interface ExceptionV2 extends _Utils {
    type: \\"exceptionV2\\";
    value: MyApi.submission.ExceptionV2;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: ActualResult._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    value: (value: MyApi.commons.VariableValue) => Result;
    exception: (value: MyApi.submission.ExceptionInfo) => Result;
    exceptionV2: (value: MyApi.submission.ExceptionV2) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const ActualResult = {
  value: (value: MyApi.commons.VariableValue): ActualResult.Value => ({
    value: value,
    type: \\"value\\",
    _visit: (visitor) => visitor.value(value),
  }),

  exception: (
    value: MyApi.submission.ExceptionInfo
  ): ActualResult.Exception => ({
    ...value,
    type: \\"exception\\",
    _visit: (visitor) => visitor.exception(value),
  }),

  exceptionV2: (
    value: MyApi.submission.ExceptionV2
  ): ActualResult.ExceptionV2 => ({
    value: value,
    type: \\"exceptionV2\\",
    _visit: (visitor) => visitor.exceptionV2(value),
  }),
} as const;
",
                "name": "ActualResult.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface BuildingExecutorResponse {
  submissionId: MyApi.submission.SubmissionId;
  status: MyApi.submission.ExecutionSessionStatus;
}
",
                "name": "BuildingExecutorResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type CodeExecutionUpdate =
  /**
   * Statuses if an executor for the session isn't ready (Before RunningResponse). */
  | CodeExecutionUpdate.BuildingExecutor
  /**
   * Sent once a test submission is executing. */
  | CodeExecutionUpdate.Running
  /**
   * Sent if a submission cannot be run (i.e. Compile Error). */
  | CodeExecutionUpdate.Errored
  /**
   * Sent if a submission is stopped. */
  | CodeExecutionUpdate.Stopped
  /**
   * Graded testcases without trace information. */
  | CodeExecutionUpdate.Graded
  /**
   * Graded submission for v2 problems. */
  | CodeExecutionUpdate.GradedV2
  /**
   * Workspace run without trace information. */
  | CodeExecutionUpdate.WorkspaceRan
  /**
   * Gives progress about what is being recorded. */
  | CodeExecutionUpdate.Recording
  /**
   * Graded testcases with trace information. */
  | CodeExecutionUpdate.Recorded
  /**
   * Sent if an invalid request is sent for a submission. */
  | CodeExecutionUpdate.InvalidRequest
  /**
   * Sent once a submission is graded and fully recorded. */
  | CodeExecutionUpdate.Finished
  | CodeExecutionUpdate._Unknown;

export declare namespace CodeExecutionUpdate {
  interface BuildingExecutor
    extends MyApi.submission.BuildingExecutorResponse,
      _Utils {
    type: \\"buildingExecutor\\";
  }

  interface Running extends MyApi.submission.RunningResponse, _Utils {
    type: \\"running\\";
  }

  interface Errored extends MyApi.submission.ErroredResponse, _Utils {
    type: \\"errored\\";
  }

  interface Stopped extends MyApi.submission.StoppedResponse, _Utils {
    type: \\"stopped\\";
  }

  interface Graded extends MyApi.submission.GradedResponse, _Utils {
    type: \\"graded\\";
  }

  interface GradedV2 extends MyApi.submission.GradedResponseV2, _Utils {
    type: \\"gradedV2\\";
  }

  interface WorkspaceRan extends MyApi.submission.WorkspaceRanResponse, _Utils {
    type: \\"workspaceRan\\";
  }

  interface Recording
    extends MyApi.submission.RecordingResponseNotification,
      _Utils {
    type: \\"recording\\";
  }

  interface Recorded
    extends MyApi.submission.RecordedResponseNotification,
      _Utils {
    type: \\"recorded\\";
  }

  interface InvalidRequest
    extends MyApi.submission.InvalidRequestResponse,
      _Utils {
    type: \\"invalidRequest\\";
  }

  interface Finished extends MyApi.submission.FinishedResponse, _Utils {
    type: \\"finished\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: CodeExecutionUpdate._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    buildingExecutor: (
      value: MyApi.submission.BuildingExecutorResponse
    ) => Result;
    running: (value: MyApi.submission.RunningResponse) => Result;
    errored: (value: MyApi.submission.ErroredResponse) => Result;
    stopped: (value: MyApi.submission.StoppedResponse) => Result;
    graded: (value: MyApi.submission.GradedResponse) => Result;
    gradedV2: (value: MyApi.submission.GradedResponseV2) => Result;
    workspaceRan: (value: MyApi.submission.WorkspaceRanResponse) => Result;
    recording: (
      value: MyApi.submission.RecordingResponseNotification
    ) => Result;
    recorded: (value: MyApi.submission.RecordedResponseNotification) => Result;
    invalidRequest: (value: MyApi.submission.InvalidRequestResponse) => Result;
    finished: (value: MyApi.submission.FinishedResponse) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const CodeExecutionUpdate = {
  buildingExecutor: (
    value: MyApi.submission.BuildingExecutorResponse
  ): CodeExecutionUpdate.BuildingExecutor => ({
    ...value,
    type: \\"buildingExecutor\\",
    _visit: (visitor) => visitor.buildingExecutor(value),
  }),

  running: (
    value: MyApi.submission.RunningResponse
  ): CodeExecutionUpdate.Running => ({
    ...value,
    type: \\"running\\",
    _visit: (visitor) => visitor.running(value),
  }),

  errored: (
    value: MyApi.submission.ErroredResponse
  ): CodeExecutionUpdate.Errored => ({
    ...value,
    type: \\"errored\\",
    _visit: (visitor) => visitor.errored(value),
  }),

  stopped: (
    value: MyApi.submission.StoppedResponse
  ): CodeExecutionUpdate.Stopped => ({
    ...value,
    type: \\"stopped\\",
    _visit: (visitor) => visitor.stopped(value),
  }),

  graded: (
    value: MyApi.submission.GradedResponse
  ): CodeExecutionUpdate.Graded => ({
    ...value,
    type: \\"graded\\",
    _visit: (visitor) => visitor.graded(value),
  }),

  gradedV2: (
    value: MyApi.submission.GradedResponseV2
  ): CodeExecutionUpdate.GradedV2 => ({
    ...value,
    type: \\"gradedV2\\",
    _visit: (visitor) => visitor.gradedV2(value),
  }),

  workspaceRan: (
    value: MyApi.submission.WorkspaceRanResponse
  ): CodeExecutionUpdate.WorkspaceRan => ({
    ...value,
    type: \\"workspaceRan\\",
    _visit: (visitor) => visitor.workspaceRan(value),
  }),

  recording: (
    value: MyApi.submission.RecordingResponseNotification
  ): CodeExecutionUpdate.Recording => ({
    ...value,
    type: \\"recording\\",
    _visit: (visitor) => visitor.recording(value),
  }),

  recorded: (
    value: MyApi.submission.RecordedResponseNotification
  ): CodeExecutionUpdate.Recorded => ({
    ...value,
    type: \\"recorded\\",
    _visit: (visitor) => visitor.recorded(value),
  }),

  invalidRequest: (
    value: MyApi.submission.InvalidRequestResponse
  ): CodeExecutionUpdate.InvalidRequest => ({
    ...value,
    type: \\"invalidRequest\\",
    _visit: (visitor) => visitor.invalidRequest(value),
  }),

  finished: (
    value: MyApi.submission.FinishedResponse
  ): CodeExecutionUpdate.Finished => ({
    ...value,
    type: \\"finished\\",
    _visit: (visitor) => visitor.finished(value),
  }),
} as const;
",
                "name": "CodeExecutionUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface CompileError {
  message: string;
}
",
                "name": "CompileError.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface CustomTestCasesUnsupported {
  problemId: MyApi.commons.ProblemId;
  submissionId: MyApi.submission.SubmissionId;
}
",
                "name": "CustomTestCasesUnsupported.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type ErrorInfo =
  | ErrorInfo.CompileError
  /**
   * If the submission cannot be executed and throws a runtime error before getting to any of the testcases.
   *  */
  | ErrorInfo.RuntimeError
  /**
   * If the trace backend encounters an unexpected error.
   *  */
  | ErrorInfo.InternalError
  | ErrorInfo._Unknown;

export declare namespace ErrorInfo {
  interface CompileError extends MyApi.submission.CompileError, _Utils {
    type: \\"compileError\\";
  }

  interface RuntimeError extends MyApi.submission.RuntimeError, _Utils {
    type: \\"runtimeError\\";
  }

  interface InternalError extends MyApi.submission.InternalError, _Utils {
    type: \\"internalError\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: ErrorInfo._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    compileError: (value: MyApi.submission.CompileError) => Result;
    runtimeError: (value: MyApi.submission.RuntimeError) => Result;
    internalError: (value: MyApi.submission.InternalError) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const ErrorInfo = {
  compileError: (
    value: MyApi.submission.CompileError
  ): ErrorInfo.CompileError => ({
    ...value,
    type: \\"compileError\\",
    _visit: (visitor) => visitor.compileError(value),
  }),

  runtimeError: (
    value: MyApi.submission.RuntimeError
  ): ErrorInfo.RuntimeError => ({
    ...value,
    type: \\"runtimeError\\",
    _visit: (visitor) => visitor.runtimeError(value),
  }),

  internalError: (
    value: MyApi.submission.InternalError
  ): ErrorInfo.InternalError => ({
    ...value,
    type: \\"internalError\\",
    _visit: (visitor) => visitor.internalError(value),
  }),
} as const;
",
                "name": "ErrorInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface ErroredResponse {
  submissionId: MyApi.submission.SubmissionId;
  errorInfo: MyApi.submission.ErrorInfo;
}
",
                "name": "ErroredResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface ExceptionInfo {
  exceptionType: string;
  exceptionMessage: string;
  exceptionStacktrace: string;
}
",
                "name": "ExceptionInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type ExceptionV2 =
  | ExceptionV2.Generic
  | ExceptionV2.Timeout
  | ExceptionV2._Unknown;

export declare namespace ExceptionV2 {
  interface Generic extends MyApi.submission.ExceptionInfo, _Utils {
    type: \\"generic\\";
  }

  interface Timeout extends _Utils {
    type: \\"timeout\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: ExceptionV2._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    generic: (value: MyApi.submission.ExceptionInfo) => Result;
    timeout: () => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const ExceptionV2 = {
  generic: (value: MyApi.submission.ExceptionInfo): ExceptionV2.Generic => ({
    ...value,
    type: \\"generic\\",
    _visit: (visitor) => visitor.generic(value),
  }),

  timeout: (): ExceptionV2.Timeout => ({
    type: \\"timeout\\",
    _visit: (visitor) => visitor.timeout(),
  }),
} as const;
",
                "name": "ExceptionV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface ExecutionSessionResponse {
  sessionId: string;
  executionSessionUrl?: string;
  language: MyApi.commons.Language;
  status: MyApi.submission.ExecutionSessionStatus;
}
",
                "name": "ExecutionSessionResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface ExecutionSessionState {
  lastTimeContacted?: string;
  sessionId: string;
  isWarmInstance: boolean;
  awsTaskId?: string;
  language: MyApi.commons.Language;
  status: MyApi.submission.ExecutionSessionStatus;
}
",
                "name": "ExecutionSessionState.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface ExecutionSessionStatus<
  RawValue extends ExecutionSessionStatus.RawValue = ExecutionSessionStatus.RawValue
> {
  get: () => RawValue;
  visit: <Result>(visitor: ExecutionSessionStatus._Visitor<Result>) => Result;
}

export const ExecutionSessionStatus = {
  CreatingContainer: (): ExecutionSessionStatus<\\"CREATING_CONTAINER\\"> => ({
    get: () => \\"CREATING_CONTAINER\\",
    visit: (visitor) => visitor.creatingContainer(),
  }),
  ProvisioningContainer:
    (): ExecutionSessionStatus<\\"PROVISIONING_CONTAINER\\"> => ({
      get: () => \\"PROVISIONING_CONTAINER\\",
      visit: (visitor) => visitor.provisioningContainer(),
    }),
  PendingContainer: (): ExecutionSessionStatus<\\"PENDING_CONTAINER\\"> => ({
    get: () => \\"PENDING_CONTAINER\\",
    visit: (visitor) => visitor.pendingContainer(),
  }),
  RunningContainer: (): ExecutionSessionStatus<\\"RUNNING_CONTAINER\\"> => ({
    get: () => \\"RUNNING_CONTAINER\\",
    visit: (visitor) => visitor.runningContainer(),
  }),
  LiveContainer: (): ExecutionSessionStatus<\\"LIVE_CONTAINER\\"> => ({
    get: () => \\"LIVE_CONTAINER\\",
    visit: (visitor) => visitor.liveContainer(),
  }),
  FailedToLaunch: (): ExecutionSessionStatus<\\"FAILED_TO_LAUNCH\\"> => ({
    get: () => \\"FAILED_TO_LAUNCH\\",
    visit: (visitor) => visitor.failedToLaunch(),
  }),
} as const;

export declare namespace ExecutionSessionStatus {
  type RawValue =
    | \\"CREATING_CONTAINER\\"
    | \\"PROVISIONING_CONTAINER\\"
    | \\"PENDING_CONTAINER\\"
    | \\"RUNNING_CONTAINER\\"
    | \\"LIVE_CONTAINER\\"
    | \\"FAILED_TO_LAUNCH\\"
    | string;

  interface _Visitor<Result> {
    creatingContainer: () => Result;
    provisioningContainer: () => Result;
    pendingContainer: () => Result;
    runningContainer: () => Result;
    liveContainer: () => Result;
    failedToLaunch: () => Result;
    _other: (value: string) => Result;
  }
}
",
                "name": "ExecutionSessionStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface ExistingSubmissionExecuting {
  submissionId: MyApi.submission.SubmissionId;
}
",
                "name": "ExistingSubmissionExecuting.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface ExpressionLocation {
  start: number;
  offset: number;
}
",
                "name": "ExpressionLocation.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface FinishedResponse {
  submissionId: MyApi.submission.SubmissionId;
}
",
                "name": "FinishedResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface GetExecutionSessionStateResponse {
  states: Record<string, MyApi.submission.ExecutionSessionState>;
  numWarmingInstances?: number;
  warmingSessionIds: string[];
}
",
                "name": "GetExecutionSessionStateResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface GetSubmissionStateResponse {
  timeSubmitted?: Date;
  submission: string;
  language: MyApi.commons.Language;
  submissionTypeState: MyApi.submission.SubmissionTypeState;
}
",
                "name": "GetSubmissionStateResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface GetTraceResponsesPageRequest {
  offset?: number;
}
",
                "name": "GetTraceResponsesPageRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface GradedResponse {
  submissionId: MyApi.submission.SubmissionId;
  testCases: Record<string, MyApi.submission.TestCaseResultWithStdout>;
}
",
                "name": "GradedResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface GradedResponseV2 {
  submissionId: MyApi.submission.SubmissionId;
  testCases: Record<string, MyApi.submission.TestCaseGrade>;
}
",
                "name": "GradedResponseV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface GradedTestCaseUpdate {
  testCaseId: MyApi.v2.problem.TestCaseId;
  grade: MyApi.submission.TestCaseGrade;
}
",
                "name": "GradedTestCaseUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface InitializeProblemRequest {
  problemId: MyApi.commons.ProblemId;
  problemVersion?: number;
}
",
                "name": "InitializeProblemRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface InternalError {
  exceptionInfo: MyApi.submission.ExceptionInfo;
}
",
                "name": "InternalError.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type InvalidRequestCause =
  /**
   * The submission request references a submission id that doesn't exist. */
  | InvalidRequestCause.SubmissionIdNotFound
  | InvalidRequestCause.CustomTestCasesUnsupported
  /**
   * The submission request was routed to an incorrect language executor. */
  | InvalidRequestCause.UnexpectedLanguage
  | InvalidRequestCause._Unknown;

export declare namespace InvalidRequestCause {
  interface SubmissionIdNotFound
    extends MyApi.submission.SubmissionIdNotFound,
      _Utils {
    type: \\"submissionIdNotFound\\";
  }

  interface CustomTestCasesUnsupported
    extends MyApi.submission.CustomTestCasesUnsupported,
      _Utils {
    type: \\"customTestCasesUnsupported\\";
  }

  interface UnexpectedLanguage
    extends MyApi.submission.UnexpectedLanguageError,
      _Utils {
    type: \\"unexpectedLanguage\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: InvalidRequestCause._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    submissionIdNotFound: (
      value: MyApi.submission.SubmissionIdNotFound
    ) => Result;
    customTestCasesUnsupported: (
      value: MyApi.submission.CustomTestCasesUnsupported
    ) => Result;
    unexpectedLanguage: (
      value: MyApi.submission.UnexpectedLanguageError
    ) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const InvalidRequestCause = {
  submissionIdNotFound: (
    value: MyApi.submission.SubmissionIdNotFound
  ): InvalidRequestCause.SubmissionIdNotFound => ({
    ...value,
    type: \\"submissionIdNotFound\\",
    _visit: (visitor) => visitor.submissionIdNotFound(value),
  }),

  customTestCasesUnsupported: (
    value: MyApi.submission.CustomTestCasesUnsupported
  ): InvalidRequestCause.CustomTestCasesUnsupported => ({
    ...value,
    type: \\"customTestCasesUnsupported\\",
    _visit: (visitor) => visitor.customTestCasesUnsupported(value),
  }),

  unexpectedLanguage: (
    value: MyApi.submission.UnexpectedLanguageError
  ): InvalidRequestCause.UnexpectedLanguage => ({
    ...value,
    type: \\"unexpectedLanguage\\",
    _visit: (visitor) => visitor.unexpectedLanguage(value),
  }),
} as const;
",
                "name": "InvalidRequestCause.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface InvalidRequestResponse {
  request: MyApi.submission.SubmissionRequest;
  cause: MyApi.submission.InvalidRequestCause;
}
",
                "name": "InvalidRequestResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface LightweightStackframeInformation {
  numStackFrames: number;
  topStackFrameMethodName: string;
}
",
                "name": "LightweightStackframeInformation.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface RecordedResponseNotification {
  submissionId: MyApi.submission.SubmissionId;
  traceResponsesSize: number;
  testCaseId?: string;
}
",
                "name": "RecordedResponseNotification.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface RecordedTestCaseUpdate {
  testCaseId: MyApi.v2.problem.TestCaseId;
  traceResponsesSize: number;
}
",
                "name": "RecordedTestCaseUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface RecordingResponseNotification {
  submissionId: MyApi.submission.SubmissionId;
  testCaseId?: string;
  lineNumber: number;
  lightweightStackInfo: MyApi.submission.LightweightStackframeInformation;
  tracedFile?: MyApi.submission.TracedFile;
}
",
                "name": "RecordingResponseNotification.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface RunningResponse {
  submissionId: MyApi.submission.SubmissionId;
  state: MyApi.submission.RunningSubmissionState;
}
",
                "name": "RunningResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface RunningSubmissionState<
  RawValue extends RunningSubmissionState.RawValue = RunningSubmissionState.RawValue
> {
  get: () => RawValue;
  visit: <Result>(visitor: RunningSubmissionState._Visitor<Result>) => Result;
}

export const RunningSubmissionState = {
  QueueingSubmission: (): RunningSubmissionState<\\"QUEUEING_SUBMISSION\\"> => ({
    get: () => \\"QUEUEING_SUBMISSION\\",
    visit: (visitor) => visitor.queueingSubmission(),
  }),
  KillingHistoricalSubmissions:
    (): RunningSubmissionState<\\"KILLING_HISTORICAL_SUBMISSIONS\\"> => ({
      get: () => \\"KILLING_HISTORICAL_SUBMISSIONS\\",
      visit: (visitor) => visitor.killingHistoricalSubmissions(),
    }),
  WritingSubmissionToFile:
    (): RunningSubmissionState<\\"WRITING_SUBMISSION_TO_FILE\\"> => ({
      get: () => \\"WRITING_SUBMISSION_TO_FILE\\",
      visit: (visitor) => visitor.writingSubmissionToFile(),
    }),
  CompilingSubmission: (): RunningSubmissionState<\\"COMPILING_SUBMISSION\\"> => ({
    get: () => \\"COMPILING_SUBMISSION\\",
    visit: (visitor) => visitor.compilingSubmission(),
  }),
  RunningSubmission: (): RunningSubmissionState<\\"RUNNING_SUBMISSION\\"> => ({
    get: () => \\"RUNNING_SUBMISSION\\",
    visit: (visitor) => visitor.runningSubmission(),
  }),
} as const;

export declare namespace RunningSubmissionState {
  type RawValue =
    | \\"QUEUEING_SUBMISSION\\"
    | \\"KILLING_HISTORICAL_SUBMISSIONS\\"
    | \\"WRITING_SUBMISSION_TO_FILE\\"
    | \\"COMPILING_SUBMISSION\\"
    | \\"RUNNING_SUBMISSION\\"
    | string;

  interface _Visitor<Result> {
    queueingSubmission: () => Result;
    killingHistoricalSubmissions: () => Result;
    writingSubmissionToFile: () => Result;
    compilingSubmission: () => Result;
    runningSubmission: () => Result;
    _other: (value: string) => Result;
  }
}
",
                "name": "RunningSubmissionState.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface RuntimeError {
  message: string;
}
",
                "name": "RuntimeError.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface Scope {
  variables: Record<string, MyApi.commons.DebugVariableValue>;
}
",
                "name": "Scope.ts",
                "type": "file",
              },
              Object {
                "contents": "export type ShareId = string;
",
                "name": "ShareId.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface StackFrame {
  methodName: string;
  lineNumber: number;
  scopes: MyApi.submission.Scope[];
}
",
                "name": "StackFrame.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface StackInformation {
  numStackFrames: number;
  topStackFrame?: MyApi.submission.StackFrame;
}
",
                "name": "StackInformation.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface StderrResponse {
  submissionId: MyApi.submission.SubmissionId;
  stderr: string;
}
",
                "name": "StderrResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface StdoutResponse {
  submissionId: MyApi.submission.SubmissionId;
  stdout: string;
}
",
                "name": "StdoutResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface StopRequest {
  submissionId: MyApi.submission.SubmissionId;
}
",
                "name": "StopRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface StoppedResponse {
  submissionId: MyApi.submission.SubmissionId;
}
",
                "name": "StoppedResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface SubmissionFileInfo {
  directory: string;
  filename: string;
  contents: string;
}
",
                "name": "SubmissionFileInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "export type SubmissionId = string;
",
                "name": "SubmissionId.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface SubmissionIdNotFound {
  missingSubmissionId: MyApi.submission.SubmissionId;
}
",
                "name": "SubmissionIdNotFound.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type SubmissionRequest =
  | SubmissionRequest.InitializeProblemRequest
  | SubmissionRequest.InitializeWorkspaceRequest
  | SubmissionRequest.SubmitV2
  | SubmissionRequest.WorkspaceSubmit
  | SubmissionRequest.Stop
  | SubmissionRequest._Unknown;

export declare namespace SubmissionRequest {
  interface InitializeProblemRequest
    extends MyApi.submission.InitializeProblemRequest,
      _Utils {
    type: \\"initializeProblemRequest\\";
  }

  interface InitializeWorkspaceRequest extends _Utils {
    type: \\"initializeWorkspaceRequest\\";
  }

  interface SubmitV2 extends MyApi.submission.SubmitRequestV2, _Utils {
    type: \\"submitV2\\";
  }

  interface WorkspaceSubmit
    extends MyApi.submission.WorkspaceSubmitRequest,
      _Utils {
    type: \\"workspaceSubmit\\";
  }

  interface Stop extends MyApi.submission.StopRequest, _Utils {
    type: \\"stop\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: SubmissionRequest._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    initializeProblemRequest: (
      value: MyApi.submission.InitializeProblemRequest
    ) => Result;
    initializeWorkspaceRequest: () => Result;
    submitV2: (value: MyApi.submission.SubmitRequestV2) => Result;
    workspaceSubmit: (value: MyApi.submission.WorkspaceSubmitRequest) => Result;
    stop: (value: MyApi.submission.StopRequest) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const SubmissionRequest = {
  initializeProblemRequest: (
    value: MyApi.submission.InitializeProblemRequest
  ): SubmissionRequest.InitializeProblemRequest => ({
    ...value,
    type: \\"initializeProblemRequest\\",
    _visit: (visitor) => visitor.initializeProblemRequest(value),
  }),

  initializeWorkspaceRequest:
    (): SubmissionRequest.InitializeWorkspaceRequest => ({
      type: \\"initializeWorkspaceRequest\\",
      _visit: (visitor) => visitor.initializeWorkspaceRequest(),
    }),

  submitV2: (
    value: MyApi.submission.SubmitRequestV2
  ): SubmissionRequest.SubmitV2 => ({
    ...value,
    type: \\"submitV2\\",
    _visit: (visitor) => visitor.submitV2(value),
  }),

  workspaceSubmit: (
    value: MyApi.submission.WorkspaceSubmitRequest
  ): SubmissionRequest.WorkspaceSubmit => ({
    ...value,
    type: \\"workspaceSubmit\\",
    _visit: (visitor) => visitor.workspaceSubmit(value),
  }),

  stop: (value: MyApi.submission.StopRequest): SubmissionRequest.Stop => ({
    ...value,
    type: \\"stop\\",
    _visit: (visitor) => visitor.stop(value),
  }),
} as const;
",
                "name": "SubmissionRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type SubmissionResponse =
  | SubmissionResponse.ServerInitialized
  | SubmissionResponse.ProblemInitialized
  | SubmissionResponse.WorkspaceInitialized
  | SubmissionResponse.ServerErrored
  | SubmissionResponse.CodeExecutionUpdate
  | SubmissionResponse.Terminated
  | SubmissionResponse._Unknown;

export declare namespace SubmissionResponse {
  interface ServerInitialized extends _Utils {
    type: \\"serverInitialized\\";
  }

  interface ProblemInitialized extends _Utils {
    type: \\"problemInitialized\\";
    value: MyApi.commons.ProblemId;
  }

  interface WorkspaceInitialized extends _Utils {
    type: \\"workspaceInitialized\\";
  }

  interface ServerErrored extends MyApi.submission.ExceptionInfo, _Utils {
    type: \\"serverErrored\\";
  }

  interface CodeExecutionUpdate extends _Utils {
    type: \\"codeExecutionUpdate\\";
    value: MyApi.submission.CodeExecutionUpdate;
  }

  interface Terminated extends MyApi.submission.TerminatedResponse, _Utils {
    type: \\"terminated\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: SubmissionResponse._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    serverInitialized: () => Result;
    problemInitialized: (value: MyApi.commons.ProblemId) => Result;
    workspaceInitialized: () => Result;
    serverErrored: (value: MyApi.submission.ExceptionInfo) => Result;
    codeExecutionUpdate: (
      value: MyApi.submission.CodeExecutionUpdate
    ) => Result;
    terminated: (value: MyApi.submission.TerminatedResponse) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const SubmissionResponse = {
  serverInitialized: (): SubmissionResponse.ServerInitialized => ({
    type: \\"serverInitialized\\",
    _visit: (visitor) => visitor.serverInitialized(),
  }),

  problemInitialized: (
    value: MyApi.commons.ProblemId
  ): SubmissionResponse.ProblemInitialized => ({
    value: value,
    type: \\"problemInitialized\\",
    _visit: (visitor) => visitor.problemInitialized(value),
  }),

  workspaceInitialized: (): SubmissionResponse.WorkspaceInitialized => ({
    type: \\"workspaceInitialized\\",
    _visit: (visitor) => visitor.workspaceInitialized(),
  }),

  serverErrored: (
    value: MyApi.submission.ExceptionInfo
  ): SubmissionResponse.ServerErrored => ({
    ...value,
    type: \\"serverErrored\\",
    _visit: (visitor) => visitor.serverErrored(value),
  }),

  codeExecutionUpdate: (
    value: MyApi.submission.CodeExecutionUpdate
  ): SubmissionResponse.CodeExecutionUpdate => ({
    value: value,
    type: \\"codeExecutionUpdate\\",
    _visit: (visitor) => visitor.codeExecutionUpdate(value),
  }),

  terminated: (
    value: MyApi.submission.TerminatedResponse
  ): SubmissionResponse.Terminated => ({
    ...value,
    type: \\"terminated\\",
    _visit: (visitor) => visitor.terminated(value),
  }),
} as const;
",
                "name": "SubmissionResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type SubmissionStatusForTestCase =
  | SubmissionStatusForTestCase.Graded
  | SubmissionStatusForTestCase.GradedV2
  | SubmissionStatusForTestCase.Traced
  | SubmissionStatusForTestCase._Unknown;

export declare namespace SubmissionStatusForTestCase {
  interface Graded extends MyApi.submission.TestCaseResultWithStdout, _Utils {
    type: \\"graded\\";
  }

  interface GradedV2 extends _Utils {
    type: \\"gradedV2\\";
    value: MyApi.submission.TestCaseGrade;
  }

  interface Traced extends MyApi.submission.TracedTestCase, _Utils {
    type: \\"traced\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(
      visitor: SubmissionStatusForTestCase._Visitor<Result>
    ) => Result;
  }

  interface _Visitor<Result> {
    graded: (value: MyApi.submission.TestCaseResultWithStdout) => Result;
    gradedV2: (value: MyApi.submission.TestCaseGrade) => Result;
    traced: (value: MyApi.submission.TracedTestCase) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const SubmissionStatusForTestCase = {
  graded: (
    value: MyApi.submission.TestCaseResultWithStdout
  ): SubmissionStatusForTestCase.Graded => ({
    ...value,
    type: \\"graded\\",
    _visit: (visitor) => visitor.graded(value),
  }),

  gradedV2: (
    value: MyApi.submission.TestCaseGrade
  ): SubmissionStatusForTestCase.GradedV2 => ({
    value: value,
    type: \\"gradedV2\\",
    _visit: (visitor) => visitor.gradedV2(value),
  }),

  traced: (
    value: MyApi.submission.TracedTestCase
  ): SubmissionStatusForTestCase.Traced => ({
    ...value,
    type: \\"traced\\",
    _visit: (visitor) => visitor.traced(value),
  }),
} as const;
",
                "name": "SubmissionStatusForTestCase.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type SubmissionStatusV2 =
  | SubmissionStatusV2.Test
  | SubmissionStatusV2.Workspace
  | SubmissionStatusV2._Unknown;

export declare namespace SubmissionStatusV2 {
  interface Test extends MyApi.submission.TestSubmissionStatusV2, _Utils {
    type: \\"test\\";
  }

  interface Workspace
    extends MyApi.submission.WorkspaceSubmissionStatusV2,
      _Utils {
    type: \\"workspace\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: SubmissionStatusV2._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    test: (value: MyApi.submission.TestSubmissionStatusV2) => Result;
    workspace: (value: MyApi.submission.WorkspaceSubmissionStatusV2) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const SubmissionStatusV2 = {
  test: (
    value: MyApi.submission.TestSubmissionStatusV2
  ): SubmissionStatusV2.Test => ({
    ...value,
    type: \\"test\\",
    _visit: (visitor) => visitor.test(value),
  }),

  workspace: (
    value: MyApi.submission.WorkspaceSubmissionStatusV2
  ): SubmissionStatusV2.Workspace => ({
    ...value,
    type: \\"workspace\\",
    _visit: (visitor) => visitor.workspace(value),
  }),
} as const;
",
                "name": "SubmissionStatusV2.ts",
                "type": "file",
              },
              Object {
                "contents": "/**
 * Keep in sync with SubmissionType.
 */
export interface SubmissionTypeEnum<
  RawValue extends SubmissionTypeEnum.RawValue = SubmissionTypeEnum.RawValue
> {
  get: () => RawValue;
  visit: <Result>(visitor: SubmissionTypeEnum._Visitor<Result>) => Result;
}

export const SubmissionTypeEnum = {
  Test: (): SubmissionTypeEnum<\\"TEST\\"> => ({
    get: () => \\"TEST\\",
    visit: (visitor) => visitor.test(),
  }),
} as const;

export declare namespace SubmissionTypeEnum {
  type RawValue = \\"TEST\\" | string;

  interface _Visitor<Result> {
    test: () => Result;
    _other: (value: string) => Result;
  }
}
",
                "name": "SubmissionTypeEnum.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type SubmissionTypeState =
  | SubmissionTypeState.Test
  | SubmissionTypeState.Workspace
  | SubmissionTypeState._Unknown;

export declare namespace SubmissionTypeState {
  interface Test extends MyApi.submission.TestSubmissionState, _Utils {
    type: \\"test\\";
  }

  interface Workspace
    extends MyApi.submission.WorkspaceSubmissionState,
      _Utils {
    type: \\"workspace\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: SubmissionTypeState._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    test: (value: MyApi.submission.TestSubmissionState) => Result;
    workspace: (value: MyApi.submission.WorkspaceSubmissionState) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const SubmissionTypeState = {
  test: (
    value: MyApi.submission.TestSubmissionState
  ): SubmissionTypeState.Test => ({
    ...value,
    type: \\"test\\",
    _visit: (visitor) => visitor.test(value),
  }),

  workspace: (
    value: MyApi.submission.WorkspaceSubmissionState
  ): SubmissionTypeState.Workspace => ({
    ...value,
    type: \\"workspace\\",
    _visit: (visitor) => visitor.workspace(value),
  }),
} as const;
",
                "name": "SubmissionTypeState.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface SubmitRequestV2 {
  submissionId: MyApi.submission.SubmissionId;
  language: MyApi.commons.Language;
  submissionFiles: MyApi.submission.SubmissionFileInfo[];
  problemId: MyApi.commons.ProblemId;
  problemVersion?: number;
  userId?: string;
}
",
                "name": "SubmitRequestV2.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface TerminatedResponse {}
",
                "name": "TerminatedResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type TestCaseGrade =
  | TestCaseGrade.Hidden
  | TestCaseGrade.NonHidden
  | TestCaseGrade._Unknown;

export declare namespace TestCaseGrade {
  interface Hidden extends MyApi.submission.TestCaseHiddenGrade, _Utils {
    type: \\"hidden\\";
  }

  interface NonHidden extends MyApi.submission.TestCaseNonHiddenGrade, _Utils {
    type: \\"nonHidden\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: TestCaseGrade._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    hidden: (value: MyApi.submission.TestCaseHiddenGrade) => Result;
    nonHidden: (value: MyApi.submission.TestCaseNonHiddenGrade) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const TestCaseGrade = {
  hidden: (
    value: MyApi.submission.TestCaseHiddenGrade
  ): TestCaseGrade.Hidden => ({
    ...value,
    type: \\"hidden\\",
    _visit: (visitor) => visitor.hidden(value),
  }),

  nonHidden: (
    value: MyApi.submission.TestCaseNonHiddenGrade
  ): TestCaseGrade.NonHidden => ({
    ...value,
    type: \\"nonHidden\\",
    _visit: (visitor) => visitor.nonHidden(value),
  }),
} as const;
",
                "name": "TestCaseGrade.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface TestCaseHiddenGrade {
  passed: boolean;
}
",
                "name": "TestCaseHiddenGrade.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface TestCaseNonHiddenGrade {
  passed: boolean;
  actualResult?: MyApi.commons.VariableValue;
  exception?: MyApi.submission.ExceptionV2;
  stdout: string;
}
",
                "name": "TestCaseNonHiddenGrade.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface TestCaseResult {
  expectedResult: MyApi.commons.VariableValue;
  actualResult: MyApi.submission.ActualResult;
  passed: boolean;
}
",
                "name": "TestCaseResult.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface TestCaseResultWithStdout {
  result: MyApi.submission.TestCaseResult;
  stdout: string;
}
",
                "name": "TestCaseResultWithStdout.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface TestSubmissionState {
  problemId: MyApi.commons.ProblemId;
  defaultTestCases: MyApi.commons.TestCase[];
  customTestCases: MyApi.commons.TestCase[];
  status: MyApi.submission.TestSubmissionStatus;
}
",
                "name": "TestSubmissionState.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type TestSubmissionStatus =
  | TestSubmissionStatus.Stopped
  | TestSubmissionStatus.Errored
  | TestSubmissionStatus.Running
  | TestSubmissionStatus.TestCaseIdToState
  | TestSubmissionStatus._Unknown;

export declare namespace TestSubmissionStatus {
  interface Stopped extends _Utils {
    type: \\"stopped\\";
  }

  interface Errored extends _Utils {
    type: \\"errored\\";
    value: MyApi.submission.ErrorInfo;
  }

  interface Running extends _Utils {
    type: \\"running\\";
    value: MyApi.submission.RunningSubmissionState;
  }

  interface TestCaseIdToState extends _Utils {
    type: \\"testCaseIdToState\\";
    value: Record<string, MyApi.submission.SubmissionStatusForTestCase>;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: TestSubmissionStatus._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    stopped: () => Result;
    errored: (value: MyApi.submission.ErrorInfo) => Result;
    running: (value: MyApi.submission.RunningSubmissionState) => Result;
    testCaseIdToState: (
      value: Record<string, MyApi.submission.SubmissionStatusForTestCase>
    ) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const TestSubmissionStatus = {
  stopped: (): TestSubmissionStatus.Stopped => ({
    type: \\"stopped\\",
    _visit: (visitor) => visitor.stopped(),
  }),

  errored: (
    value: MyApi.submission.ErrorInfo
  ): TestSubmissionStatus.Errored => ({
    value: value,
    type: \\"errored\\",
    _visit: (visitor) => visitor.errored(value),
  }),

  running: (
    value: MyApi.submission.RunningSubmissionState
  ): TestSubmissionStatus.Running => ({
    value: value,
    type: \\"running\\",
    _visit: (visitor) => visitor.running(value),
  }),

  testCaseIdToState: (
    value: Record<string, MyApi.submission.SubmissionStatusForTestCase>
  ): TestSubmissionStatus.TestCaseIdToState => ({
    value: value,
    type: \\"testCaseIdToState\\",
    _visit: (visitor) => visitor.testCaseIdToState(value),
  }),
} as const;
",
                "name": "TestSubmissionStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface TestSubmissionStatusV2 {
  updates: MyApi.submission.TestSubmissionUpdate[];
  problemId: MyApi.commons.ProblemId;
  problemVersion: number;
  problemInfo: MyApi.v2.problem.ProblemInfoV2;
}
",
                "name": "TestSubmissionStatusV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface TestSubmissionUpdate {
  updateTime: Date;
  updateInfo: MyApi.submission.TestSubmissionUpdateInfo;
}
",
                "name": "TestSubmissionUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type TestSubmissionUpdateInfo =
  | TestSubmissionUpdateInfo.Running
  | TestSubmissionUpdateInfo.Stopped
  | TestSubmissionUpdateInfo.Errored
  | TestSubmissionUpdateInfo.GradedTestCase
  | TestSubmissionUpdateInfo.RecordedTestCase
  | TestSubmissionUpdateInfo.Finished
  | TestSubmissionUpdateInfo._Unknown;

export declare namespace TestSubmissionUpdateInfo {
  interface Running extends _Utils {
    type: \\"running\\";
    value: MyApi.submission.RunningSubmissionState;
  }

  interface Stopped extends _Utils {
    type: \\"stopped\\";
  }

  interface Errored extends _Utils {
    type: \\"errored\\";
    value: MyApi.submission.ErrorInfo;
  }

  interface GradedTestCase
    extends MyApi.submission.GradedTestCaseUpdate,
      _Utils {
    type: \\"gradedTestCase\\";
  }

  interface RecordedTestCase
    extends MyApi.submission.RecordedTestCaseUpdate,
      _Utils {
    type: \\"recordedTestCase\\";
  }

  interface Finished extends _Utils {
    type: \\"finished\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(
      visitor: TestSubmissionUpdateInfo._Visitor<Result>
    ) => Result;
  }

  interface _Visitor<Result> {
    running: (value: MyApi.submission.RunningSubmissionState) => Result;
    stopped: () => Result;
    errored: (value: MyApi.submission.ErrorInfo) => Result;
    gradedTestCase: (value: MyApi.submission.GradedTestCaseUpdate) => Result;
    recordedTestCase: (
      value: MyApi.submission.RecordedTestCaseUpdate
    ) => Result;
    finished: () => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const TestSubmissionUpdateInfo = {
  running: (
    value: MyApi.submission.RunningSubmissionState
  ): TestSubmissionUpdateInfo.Running => ({
    value: value,
    type: \\"running\\",
    _visit: (visitor) => visitor.running(value),
  }),

  stopped: (): TestSubmissionUpdateInfo.Stopped => ({
    type: \\"stopped\\",
    _visit: (visitor) => visitor.stopped(),
  }),

  errored: (
    value: MyApi.submission.ErrorInfo
  ): TestSubmissionUpdateInfo.Errored => ({
    value: value,
    type: \\"errored\\",
    _visit: (visitor) => visitor.errored(value),
  }),

  gradedTestCase: (
    value: MyApi.submission.GradedTestCaseUpdate
  ): TestSubmissionUpdateInfo.GradedTestCase => ({
    ...value,
    type: \\"gradedTestCase\\",
    _visit: (visitor) => visitor.gradedTestCase(value),
  }),

  recordedTestCase: (
    value: MyApi.submission.RecordedTestCaseUpdate
  ): TestSubmissionUpdateInfo.RecordedTestCase => ({
    ...value,
    type: \\"recordedTestCase\\",
    _visit: (visitor) => visitor.recordedTestCase(value),
  }),

  finished: (): TestSubmissionUpdateInfo.Finished => ({
    type: \\"finished\\",
    _visit: (visitor) => visitor.finished(),
  }),
} as const;
",
                "name": "TestSubmissionUpdateInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface TraceResponse {
  submissionId: MyApi.submission.SubmissionId;
  lineNumber: number;
  returnValue?: MyApi.commons.DebugVariableValue;
  expressionLocation?: MyApi.submission.ExpressionLocation;
  stack: MyApi.submission.StackInformation;
  stdout?: string;
}
",
                "name": "TraceResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface TraceResponseV2 {
  submissionId: MyApi.submission.SubmissionId;
  lineNumber: number;
  file: MyApi.submission.TracedFile;
  returnValue?: MyApi.commons.DebugVariableValue;
  expressionLocation?: MyApi.submission.ExpressionLocation;
  stack: MyApi.submission.StackInformation;
  stdout?: string;
}
",
                "name": "TraceResponseV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface TraceResponsesPage {
  /**
   * If present, use this to load subseqent pages.
   * The offset is the id of the next trace response to load.
   *
   */
  offset?: number;
  traceResponses: MyApi.submission.TraceResponse[];
}
",
                "name": "TraceResponsesPage.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface TraceResponsesPageV2 {
  /**
   * If present, use this to load subseqent pages.
   * The offset is the id of the next trace response to load.
   *
   */
  offset?: number;
  traceResponses: MyApi.submission.TraceResponseV2[];
}
",
                "name": "TraceResponsesPageV2.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface TracedFile {
  filename: string;
  directory: string;
}
",
                "name": "TracedFile.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface TracedTestCase {
  result: MyApi.submission.TestCaseResultWithStdout;
  traceResponsesSize: number;
}
",
                "name": "TracedTestCase.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface UnexpectedLanguageError {
  expectedLanguage: MyApi.commons.Language;
  actualLanguage: MyApi.commons.Language;
}
",
                "name": "UnexpectedLanguageError.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface WorkspaceFiles {
  mainFile: MyApi.commons.FileInfo;
  readOnlyFiles: MyApi.commons.FileInfo[];
}
",
                "name": "WorkspaceFiles.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface WorkspaceRanResponse {
  submissionId: MyApi.submission.SubmissionId;
  runDetails: MyApi.submission.WorkspaceRunDetails;
}
",
                "name": "WorkspaceRanResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface WorkspaceRunDetails {
  exceptionV2?: MyApi.submission.ExceptionV2;
  exception?: MyApi.submission.ExceptionInfo;
  stdout: string;
}
",
                "name": "WorkspaceRunDetails.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface WorkspaceStarterFilesResponse {
  files: Record<
    MyApi.commons.Language.RawValue,
    MyApi.submission.WorkspaceFiles
  >;
}
",
                "name": "WorkspaceStarterFilesResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface WorkspaceStarterFilesResponseV2 {
  filesByLanguage: Record<
    MyApi.commons.Language.RawValue,
    MyApi.v2.problem.Files
  >;
}
",
                "name": "WorkspaceStarterFilesResponseV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface WorkspaceSubmissionState {
  status: MyApi.submission.WorkspaceSubmissionStatus;
}
",
                "name": "WorkspaceSubmissionState.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type WorkspaceSubmissionStatus =
  | WorkspaceSubmissionStatus.Stopped
  | WorkspaceSubmissionStatus.Errored
  | WorkspaceSubmissionStatus.Running
  | WorkspaceSubmissionStatus.Ran
  | WorkspaceSubmissionStatus.Traced
  | WorkspaceSubmissionStatus._Unknown;

export declare namespace WorkspaceSubmissionStatus {
  interface Stopped extends _Utils {
    type: \\"stopped\\";
  }

  interface Errored extends _Utils {
    type: \\"errored\\";
    value: MyApi.submission.ErrorInfo;
  }

  interface Running extends _Utils {
    type: \\"running\\";
    value: MyApi.submission.RunningSubmissionState;
  }

  interface Ran extends MyApi.submission.WorkspaceRunDetails, _Utils {
    type: \\"ran\\";
  }

  interface Traced extends MyApi.submission.WorkspaceRunDetails, _Utils {
    type: \\"traced\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(
      visitor: WorkspaceSubmissionStatus._Visitor<Result>
    ) => Result;
  }

  interface _Visitor<Result> {
    stopped: () => Result;
    errored: (value: MyApi.submission.ErrorInfo) => Result;
    running: (value: MyApi.submission.RunningSubmissionState) => Result;
    ran: (value: MyApi.submission.WorkspaceRunDetails) => Result;
    traced: (value: MyApi.submission.WorkspaceRunDetails) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const WorkspaceSubmissionStatus = {
  stopped: (): WorkspaceSubmissionStatus.Stopped => ({
    type: \\"stopped\\",
    _visit: (visitor) => visitor.stopped(),
  }),

  errored: (
    value: MyApi.submission.ErrorInfo
  ): WorkspaceSubmissionStatus.Errored => ({
    value: value,
    type: \\"errored\\",
    _visit: (visitor) => visitor.errored(value),
  }),

  running: (
    value: MyApi.submission.RunningSubmissionState
  ): WorkspaceSubmissionStatus.Running => ({
    value: value,
    type: \\"running\\",
    _visit: (visitor) => visitor.running(value),
  }),

  ran: (
    value: MyApi.submission.WorkspaceRunDetails
  ): WorkspaceSubmissionStatus.Ran => ({
    ...value,
    type: \\"ran\\",
    _visit: (visitor) => visitor.ran(value),
  }),

  traced: (
    value: MyApi.submission.WorkspaceRunDetails
  ): WorkspaceSubmissionStatus.Traced => ({
    ...value,
    type: \\"traced\\",
    _visit: (visitor) => visitor.traced(value),
  }),
} as const;
",
                "name": "WorkspaceSubmissionStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface WorkspaceSubmissionStatusV2 {
  updates: MyApi.submission.WorkspaceSubmissionUpdate[];
}
",
                "name": "WorkspaceSubmissionStatusV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface WorkspaceSubmissionUpdate {
  updateTime: Date;
  updateInfo: MyApi.submission.WorkspaceSubmissionUpdateInfo;
}
",
                "name": "WorkspaceSubmissionUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export type WorkspaceSubmissionUpdateInfo =
  | WorkspaceSubmissionUpdateInfo.Running
  | WorkspaceSubmissionUpdateInfo.Ran
  | WorkspaceSubmissionUpdateInfo.Stopped
  | WorkspaceSubmissionUpdateInfo.Traced
  | WorkspaceSubmissionUpdateInfo.TracedV2
  | WorkspaceSubmissionUpdateInfo.Errored
  | WorkspaceSubmissionUpdateInfo.Finished
  | WorkspaceSubmissionUpdateInfo._Unknown;

export declare namespace WorkspaceSubmissionUpdateInfo {
  interface Running extends _Utils {
    type: \\"running\\";
    value: MyApi.submission.RunningSubmissionState;
  }

  interface Ran extends MyApi.submission.WorkspaceRunDetails, _Utils {
    type: \\"ran\\";
  }

  interface Stopped extends _Utils {
    type: \\"stopped\\";
  }

  interface Traced extends _Utils {
    type: \\"traced\\";
  }

  interface TracedV2 extends MyApi.submission.WorkspaceTracedUpdate, _Utils {
    type: \\"tracedV2\\";
  }

  interface Errored extends _Utils {
    type: \\"errored\\";
    value: MyApi.submission.ErrorInfo;
  }

  interface Finished extends _Utils {
    type: \\"finished\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(
      visitor: WorkspaceSubmissionUpdateInfo._Visitor<Result>
    ) => Result;
  }

  interface _Visitor<Result> {
    running: (value: MyApi.submission.RunningSubmissionState) => Result;
    ran: (value: MyApi.submission.WorkspaceRunDetails) => Result;
    stopped: () => Result;
    traced: () => Result;
    tracedV2: (value: MyApi.submission.WorkspaceTracedUpdate) => Result;
    errored: (value: MyApi.submission.ErrorInfo) => Result;
    finished: () => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const WorkspaceSubmissionUpdateInfo = {
  running: (
    value: MyApi.submission.RunningSubmissionState
  ): WorkspaceSubmissionUpdateInfo.Running => ({
    value: value,
    type: \\"running\\",
    _visit: (visitor) => visitor.running(value),
  }),

  ran: (
    value: MyApi.submission.WorkspaceRunDetails
  ): WorkspaceSubmissionUpdateInfo.Ran => ({
    ...value,
    type: \\"ran\\",
    _visit: (visitor) => visitor.ran(value),
  }),

  stopped: (): WorkspaceSubmissionUpdateInfo.Stopped => ({
    type: \\"stopped\\",
    _visit: (visitor) => visitor.stopped(),
  }),

  traced: (): WorkspaceSubmissionUpdateInfo.Traced => ({
    type: \\"traced\\",
    _visit: (visitor) => visitor.traced(),
  }),

  tracedV2: (
    value: MyApi.submission.WorkspaceTracedUpdate
  ): WorkspaceSubmissionUpdateInfo.TracedV2 => ({
    ...value,
    type: \\"tracedV2\\",
    _visit: (visitor) => visitor.tracedV2(value),
  }),

  errored: (
    value: MyApi.submission.ErrorInfo
  ): WorkspaceSubmissionUpdateInfo.Errored => ({
    value: value,
    type: \\"errored\\",
    _visit: (visitor) => visitor.errored(value),
  }),

  finished: (): WorkspaceSubmissionUpdateInfo.Finished => ({
    type: \\"finished\\",
    _visit: (visitor) => visitor.finished(),
  }),
} as const;
",
                "name": "WorkspaceSubmissionUpdateInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";

export interface WorkspaceSubmitRequest {
  submissionId: MyApi.submission.SubmissionId;
  language: MyApi.commons.Language;
  submissionFiles: MyApi.submission.SubmissionFileInfo[];
  userId?: string;
}
",
                "name": "WorkspaceSubmitRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "export interface WorkspaceTracedUpdate {
  traceResponsesSize: number;
}
",
                "name": "WorkspaceTracedUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./SubmissionId\\";
export * from \\"./ShareId\\";
export * from \\"./SubmissionRequest\\";
export * from \\"./InitializeProblemRequest\\";
export * from \\"./SubmitRequestV2\\";
export * from \\"./WorkspaceSubmitRequest\\";
export * from \\"./SubmissionFileInfo\\";
export * from \\"./SubmissionTypeEnum\\";
export * from \\"./StopRequest\\";
export * from \\"./SubmissionResponse\\";
export * from \\"./CodeExecutionUpdate\\";
export * from \\"./BuildingExecutorResponse\\";
export * from \\"./RunningResponse\\";
export * from \\"./RunningSubmissionState\\";
export * from \\"./ErroredResponse\\";
export * from \\"./ErrorInfo\\";
export * from \\"./CompileError\\";
export * from \\"./RuntimeError\\";
export * from \\"./InternalError\\";
export * from \\"./StoppedResponse\\";
export * from \\"./WorkspaceRanResponse\\";
export * from \\"./WorkspaceRunDetails\\";
export * from \\"./GradedResponse\\";
export * from \\"./GradedResponseV2\\";
export * from \\"./TestCaseGrade\\";
export * from \\"./TestCaseHiddenGrade\\";
export * from \\"./TestCaseNonHiddenGrade\\";
export * from \\"./RecordedResponseNotification\\";
export * from \\"./RecordingResponseNotification\\";
export * from \\"./LightweightStackframeInformation\\";
export * from \\"./TestCaseResultWithStdout\\";
export * from \\"./TestCaseResult\\";
export * from \\"./ActualResult\\";
export * from \\"./ExceptionV2\\";
export * from \\"./ExceptionInfo\\";
export * from \\"./InvalidRequestResponse\\";
export * from \\"./InvalidRequestCause\\";
export * from \\"./ExistingSubmissionExecuting\\";
export * from \\"./SubmissionIdNotFound\\";
export * from \\"./CustomTestCasesUnsupported\\";
export * from \\"./UnexpectedLanguageError\\";
export * from \\"./TerminatedResponse\\";
export * from \\"./FinishedResponse\\";
export * from \\"./StdoutResponse\\";
export * from \\"./StderrResponse\\";
export * from \\"./TraceResponse\\";
export * from \\"./TraceResponseV2\\";
export * from \\"./TracedFile\\";
export * from \\"./ExpressionLocation\\";
export * from \\"./StackInformation\\";
export * from \\"./StackFrame\\";
export * from \\"./Scope\\";
export * from \\"./ExecutionSessionResponse\\";
export * from \\"./ExecutionSessionStatus\\";
export * from \\"./SubmissionStatusV2\\";
export * from \\"./TestSubmissionStatusV2\\";
export * from \\"./WorkspaceSubmissionStatusV2\\";
export * from \\"./TestSubmissionUpdate\\";
export * from \\"./TestSubmissionUpdateInfo\\";
export * from \\"./WorkspaceSubmissionUpdate\\";
export * from \\"./WorkspaceSubmissionUpdateInfo\\";
export * from \\"./GradedTestCaseUpdate\\";
export * from \\"./RecordedTestCaseUpdate\\";
export * from \\"./WorkspaceTracedUpdate\\";
export * from \\"./SubmissionTypeState\\";
export * from \\"./WorkspaceSubmissionState\\";
export * from \\"./WorkspaceSubmissionStatus\\";
export * from \\"./TestSubmissionState\\";
export * from \\"./TestSubmissionStatus\\";
export * from \\"./SubmissionStatusForTestCase\\";
export * from \\"./TracedTestCase\\";
export * from \\"./TraceResponsesPage\\";
export * from \\"./TraceResponsesPageV2\\";
export * from \\"./GetTraceResponsesPageRequest\\";
export * from \\"./WorkspaceStarterFilesResponse\\";
export * from \\"./WorkspaceStarterFilesResponseV2\\";
export * from \\"./WorkspaceFiles\\";
export * from \\"./ExecutionSessionState\\";
export * from \\"./GetExecutionSessionStateResponse\\";
export * from \\"./GetSubmissionStateResponse\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "submission",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as schemas from \\"../../../schemas\\";

export interface Client {
  setNumWarmInstances(
    request: MyApi.sysprop.setNumWarmInstances.Request
  ): Promise<MyApi.sysprop.setNumWarmInstances.Response>;
  getNumWarmInstances(): Promise<MyApi.sysprop.getNumWarmInstances.Response>;
}

export declare namespace Client {
  interface Options {
    _origin: string;
    _token?: core.BearerToken;
    _credentials?: core.BasicAuth;
    xApiKey?: string;
  }
}

export class Client implements Client {
  constructor(private readonly options: Client.Options) {}

  public async setNumWarmInstances(
    request: MyApi.sysprop.setNumWarmInstances.Request
  ): Promise<MyApi.sysprop.setNumWarmInstances.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/sysprop//num-warm-instances/\${request.language}/\${request.numWarmInstances}\`
      ),
      method: \\"PUT\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getNumWarmInstances(): Promise<MyApi.sysprop.getNumWarmInstances.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/num-warm-instances\\"),
      method: \\"GET\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.sysprop.getNumWarmInstances.Response.parse(
          response.body as Record<schemas.commons.Language.Raw, number>
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                "name": "Client.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  Record<MyApi.commons.Language.RawValue, number>,
  MyApi.sysprop.getNumWarmInstances.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "getNumWarmInstances.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as setNumWarmInstances from \\"./setNumWarmInstances\\";
export * as getNumWarmInstances from \\"./getNumWarmInstances\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { MyApi } from \\"../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  language: MyApi.commons.Language;
  numWarmInstances: number;
}

export type Response = core.APIResponse<
  void,
  MyApi.sysprop.setNumWarmInstances.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                "name": "setNumWarmInstances.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "sysprop",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "import * as core from \\"../../core\\";
import { Client as ProblemInfoServicV2Client } from \\"./problem/client/Client\\";
import { Wrapper as V3Wrapper } from \\"./v3/Wrapper\\";

export namespace Wrapper {
  export interface Options {
    _origin: string;
    _token?: core.BearerToken;
    _credentials?: core.BasicAuth;
    xApiKey?: string;
  }
}

export class Wrapper {
  constructor(private readonly options: Wrapper.Options) {}

  #problem: ProblemInfoServicV2Client | undefined;

  public get problem(): ProblemInfoServicV2Client {
    return (this.#problem ??= new ProblemInfoServicV2Client({
      _origin: this.options._origin,
      _token: this.options._token,
      _credentials: this.options._credentials,
      xApiKey: this.options.xApiKey,
    }));
  }

  #v3: V3Wrapper | undefined;

  public get v3(): V3Wrapper {
    return (this.#v3 ??= new V3Wrapper(this.options));
  }
}
",
            "name": "Wrapper.ts",
            "type": "file",
          },
          Object {
            "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as v3 from \\"./v3\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";
import urlJoin from \\"url-join\\";
import * as schemas from \\"../../../../schemas\\";

export interface Client {
  getLightweightProblems(): Promise<MyApi.v2.problem.getLightweightProblems.Response>;
  getProblems(): Promise<MyApi.v2.problem.getProblems.Response>;
  getLatestProblem(
    request: MyApi.v2.problem.getLatestProblem.Request
  ): Promise<MyApi.v2.problem.getLatestProblem.Response>;
  getProblemVersion(
    request: MyApi.v2.problem.getProblemVersion.Request
  ): Promise<MyApi.v2.problem.getProblemVersion.Response>;
}

export declare namespace Client {
  interface Options {
    _origin: string;
    _token?: core.BearerToken;
    _credentials?: core.BasicAuth;
    xApiKey?: string;
  }
}

export class Client implements Client {
  constructor(private readonly options: Client.Options) {}

  public async getLightweightProblems(): Promise<MyApi.v2.problem.getLightweightProblems.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/lightweight-problem-info\\"),
      method: \\"GET\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.v2.problem.getLightweightProblems.Response.parse(
          response.body as schemas.v2.problem.LightweightProblemInfoV2.Raw[]
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getProblems(): Promise<MyApi.v2.problem.getProblems.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/problem-info\\"),
      method: \\"GET\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.v2.problem.getProblems.Response.parse(
          response.body as schemas.v2.problem.ProblemInfoV2.Raw[]
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getLatestProblem(
    request: MyApi.v2.problem.getLatestProblem.Request
  ): Promise<MyApi.v2.problem.getLatestProblem.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/problems-v2//problem-info/\${request.problemId}\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.v2.problem.ProblemInfoV2.parse(
          response.body as schemas.v2.problem.ProblemInfoV2.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getProblemVersion(
    request: MyApi.v2.problem.getProblemVersion.Request
  ): Promise<MyApi.v2.problem.getProblemVersion.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/problems-v2//problem-info/\${request.problemId}/version/\${request.problemVersion}\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.v2.problem.ProblemInfoV2.parse(
          response.body as schemas.v2.problem.ProblemInfoV2.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  problemId: MyApi.commons.ProblemId;
}

export type Response = core.APIResponse<
  MyApi.v2.problem.ProblemInfoV2,
  MyApi.v2.problem.getLatestProblem.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "getLatestProblem.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export type Response = core.APIResponse<
  MyApi.v2.problem.LightweightProblemInfoV2[],
  MyApi.v2.problem.getLightweightProblems.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "getLightweightProblems.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as core from \\"../../../../core\\";
import { MyApi } from \\"../../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  problemId: MyApi.commons.ProblemId;
  problemVersion: number;
}

export type Response = core.APIResponse<
  MyApi.v2.problem.ProblemInfoV2,
  MyApi.v2.problem.getProblemVersion.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "getProblemVersion.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export type Response = core.APIResponse<
  MyApi.v2.problem.ProblemInfoV2[],
  MyApi.v2.problem.getProblems.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                    "name": "getProblems.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
export * as getLatestProblem from \\"./getLatestProblem\\";
export * as getProblemVersion from \\"./getProblemVersion\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export type AssertCorrectnessCheck =
  | AssertCorrectnessCheck.DeepEquality
  | AssertCorrectnessCheck.Custom
  | AssertCorrectnessCheck._Unknown;

export declare namespace AssertCorrectnessCheck {
  interface DeepEquality
    extends MyApi.v2.problem.DeepEqualityCorrectnessCheck,
      _Utils {
    type: \\"deepEquality\\";
  }

  interface Custom
    extends MyApi.v2.problem.VoidFunctionDefinitionThatTakesActualResult,
      _Utils {
    type: \\"custom\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(
      visitor: AssertCorrectnessCheck._Visitor<Result>
    ) => Result;
  }

  interface _Visitor<Result> {
    deepEquality: (
      value: MyApi.v2.problem.DeepEqualityCorrectnessCheck
    ) => Result;
    custom: (
      value: MyApi.v2.problem.VoidFunctionDefinitionThatTakesActualResult
    ) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const AssertCorrectnessCheck = {
  deepEquality: (
    value: MyApi.v2.problem.DeepEqualityCorrectnessCheck
  ): AssertCorrectnessCheck.DeepEquality => ({
    ...value,
    type: \\"deepEquality\\",
    _visit: (visitor) => visitor.deepEquality(value),
  }),

  custom: (
    value: MyApi.v2.problem.VoidFunctionDefinitionThatTakesActualResult
  ): AssertCorrectnessCheck.Custom => ({
    ...value,
    type: \\"custom\\",
    _visit: (visitor) => visitor.custom(value),
  }),
} as const;
",
                    "name": "AssertCorrectnessCheck.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface BasicCustomFiles {
  methodName: string;
  signature: MyApi.v2.problem.NonVoidFunctionSignature;
  additionalFiles: Record<
    MyApi.commons.Language.RawValue,
    MyApi.v2.problem.Files
  >;
  basicTestCaseTemplate: MyApi.v2.problem.BasicTestCaseTemplate;
}
",
                    "name": "BasicCustomFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface BasicTestCaseTemplate {
  templateId: MyApi.v2.problem.TestCaseTemplateId;
  name: string;
  description: MyApi.v2.problem.TestCaseImplementationDescription;
  expectedValueParameterId: MyApi.v2.problem.ParameterId;
}
",
                    "name": "BasicTestCaseTemplate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface CreateProblemRequestV2 {
  problemName: string;
  problemDescription: MyApi.problem.ProblemDescription;
  customFiles: MyApi.v2.problem.CustomFiles;
  customTestCaseTemplates: MyApi.v2.problem.TestCaseTemplate[];
  testcases: MyApi.v2.problem.TestCaseV2[];
  supportedLanguages: MyApi.commons.Language[];
  isPublic: boolean;
}
",
                    "name": "CreateProblemRequestV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export type CustomFiles =
  | CustomFiles.Basic
  | CustomFiles.Custom
  | CustomFiles._Unknown;

export declare namespace CustomFiles {
  interface Basic extends MyApi.v2.problem.BasicCustomFiles, _Utils {
    type: \\"basic\\";
  }

  interface Custom extends _Utils {
    type: \\"custom\\";
    value: Record<MyApi.commons.Language.RawValue, MyApi.v2.problem.Files>;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: CustomFiles._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    basic: (value: MyApi.v2.problem.BasicCustomFiles) => Result;
    custom: (
      value: Record<MyApi.commons.Language.RawValue, MyApi.v2.problem.Files>
    ) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const CustomFiles = {
  basic: (value: MyApi.v2.problem.BasicCustomFiles): CustomFiles.Basic => ({
    ...value,
    type: \\"basic\\",
    _visit: (visitor) => visitor.basic(value),
  }),

  custom: (
    value: Record<MyApi.commons.Language.RawValue, MyApi.v2.problem.Files>
  ): CustomFiles.Custom => ({
    value: value,
    type: \\"custom\\",
    _visit: (visitor) => visitor.custom(value),
  }),
} as const;
",
                    "name": "CustomFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface DeepEqualityCorrectnessCheck {
  expectedValueParameterId: MyApi.v2.problem.ParameterId;
}
",
                    "name": "DeepEqualityCorrectnessCheck.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface DefaultProvidedFile {
  file: MyApi.v2.problem.FileInfoV2;
  relatedTypes: MyApi.commons.VariableType[];
}
",
                    "name": "DefaultProvidedFile.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface FileInfoV2 {
  filename: string;
  directory: string;
  contents: string;
  editable: boolean;
}
",
                    "name": "FileInfoV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface Files {
  files: MyApi.v2.problem.FileInfoV2[];
}
",
                    "name": "Files.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface FunctionImplementation {
  impl: string;
  imports?: string;
}
",
                    "name": "FunctionImplementation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface FunctionImplementationForMultipleLanguages {
  codeByLanguage: Record<
    MyApi.commons.Language.RawValue,
    MyApi.v2.problem.FunctionImplementation
  >;
}
",
                    "name": "FunctionImplementationForMultipleLanguages.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export type FunctionSignature =
  | FunctionSignature.Void
  | FunctionSignature.NonVoid
  /**
   * Useful when specifying custom grading for a testcase where actualResult is defined. */
  | FunctionSignature.VoidThatTakesActualResult
  | FunctionSignature._Unknown;

export declare namespace FunctionSignature {
  interface Void extends MyApi.v2.problem.VoidFunctionSignature, _Utils {
    type: \\"void\\";
  }

  interface NonVoid extends MyApi.v2.problem.NonVoidFunctionSignature, _Utils {
    type: \\"nonVoid\\";
  }

  interface VoidThatTakesActualResult
    extends MyApi.v2.problem.VoidFunctionSignatureThatTakesActualResult,
      _Utils {
    type: \\"voidThatTakesActualResult\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: FunctionSignature._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    void: (value: MyApi.v2.problem.VoidFunctionSignature) => Result;
    nonVoid: (value: MyApi.v2.problem.NonVoidFunctionSignature) => Result;
    voidThatTakesActualResult: (
      value: MyApi.v2.problem.VoidFunctionSignatureThatTakesActualResult
    ) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const FunctionSignature = {
  void: (
    value: MyApi.v2.problem.VoidFunctionSignature
  ): FunctionSignature.Void => ({
    ...value,
    type: \\"void\\",
    _visit: (visitor) => visitor.void(value),
  }),

  nonVoid: (
    value: MyApi.v2.problem.NonVoidFunctionSignature
  ): FunctionSignature.NonVoid => ({
    ...value,
    type: \\"nonVoid\\",
    _visit: (visitor) => visitor.nonVoid(value),
  }),

  voidThatTakesActualResult: (
    value: MyApi.v2.problem.VoidFunctionSignatureThatTakesActualResult
  ): FunctionSignature.VoidThatTakesActualResult => ({
    ...value,
    type: \\"voidThatTakesActualResult\\",
    _visit: (visitor) => visitor.voidThatTakesActualResult(value),
  }),
} as const;
",
                    "name": "FunctionSignature.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface GeneratedFiles {
  generatedTestCaseFiles: Record<
    MyApi.commons.Language.RawValue,
    MyApi.v2.problem.Files
  >;
  generatedTemplateFiles: Record<
    MyApi.commons.Language.RawValue,
    MyApi.v2.problem.Files
  >;
  other: Record<MyApi.commons.Language.RawValue, MyApi.v2.problem.Files>;
}
",
                    "name": "GeneratedFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface GetBasicSolutionFileRequest {
  methodName: string;
  signature: MyApi.v2.problem.NonVoidFunctionSignature;
}
",
                    "name": "GetBasicSolutionFileRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface GetBasicSolutionFileResponse {
  solutionFileByLanguage: Record<
    MyApi.commons.Language.RawValue,
    MyApi.v2.problem.FileInfoV2
  >;
}
",
                    "name": "GetBasicSolutionFileResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface GetFunctionSignatureRequest {
  functionSignature: MyApi.v2.problem.FunctionSignature;
}
",
                    "name": "GetFunctionSignatureRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface GetFunctionSignatureResponse {
  functionByLanguage: Record<MyApi.commons.Language.RawValue, string>;
}
",
                    "name": "GetFunctionSignatureResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface GetGeneratedTestCaseFileRequest {
  template?: MyApi.v2.problem.TestCaseTemplate;
  testCase: MyApi.v2.problem.TestCaseV2;
}
",
                    "name": "GetGeneratedTestCaseFileRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface GetGeneratedTestCaseTemplateFileRequest {
  template: MyApi.v2.problem.TestCaseTemplate;
}
",
                    "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface LightweightProblemInfoV2 {
  problemId: MyApi.commons.ProblemId;
  problemName: string;
  problemVersion: number;
  variableTypes: MyApi.commons.VariableType[];
}
",
                    "name": "LightweightProblemInfoV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface NonVoidFunctionDefinition {
  signature: MyApi.v2.problem.NonVoidFunctionSignature;
  code: MyApi.v2.problem.FunctionImplementationForMultipleLanguages;
}
",
                    "name": "NonVoidFunctionDefinition.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface NonVoidFunctionSignature {
  parameters: MyApi.v2.problem.Parameter[];
  returnType: MyApi.commons.VariableType;
}
",
                    "name": "NonVoidFunctionSignature.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface Parameter {
  parameterId: MyApi.v2.problem.ParameterId;
  name: string;
  variableType: MyApi.commons.VariableType;
}
",
                    "name": "Parameter.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type ParameterId = string;
",
                    "name": "ParameterId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface ProblemInfoV2 {
  problemId: MyApi.commons.ProblemId;
  problemDescription: MyApi.problem.ProblemDescription;
  problemName: string;
  problemVersion: number;
  supportedLanguages: MyApi.commons.Language[];
  customFiles: MyApi.v2.problem.CustomFiles;
  generatedFiles: MyApi.v2.problem.GeneratedFiles;
  customTestCaseTemplates: MyApi.v2.problem.TestCaseTemplate[];
  testcases: MyApi.v2.problem.TestCaseV2[];
  isPublic: boolean;
}
",
                    "name": "ProblemInfoV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export interface TestCaseExpects {
  expectedStdout?: string;
}
",
                    "name": "TestCaseExpects.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export type TestCaseFunction =
  | TestCaseFunction.WithActualResult
  | TestCaseFunction.Custom
  | TestCaseFunction._Unknown;

export declare namespace TestCaseFunction {
  interface WithActualResult
    extends MyApi.v2.problem.TestCaseWithActualResultImplementation,
      _Utils {
    type: \\"withActualResult\\";
  }

  interface Custom extends MyApi.v2.problem.VoidFunctionDefinition, _Utils {
    type: \\"custom\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: TestCaseFunction._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    withActualResult: (
      value: MyApi.v2.problem.TestCaseWithActualResultImplementation
    ) => Result;
    custom: (value: MyApi.v2.problem.VoidFunctionDefinition) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const TestCaseFunction = {
  withActualResult: (
    value: MyApi.v2.problem.TestCaseWithActualResultImplementation
  ): TestCaseFunction.WithActualResult => ({
    ...value,
    type: \\"withActualResult\\",
    _visit: (visitor) => visitor.withActualResult(value),
  }),

  custom: (
    value: MyApi.v2.problem.VoidFunctionDefinition
  ): TestCaseFunction.Custom => ({
    ...value,
    type: \\"custom\\",
    _visit: (visitor) => visitor.custom(value),
  }),
} as const;
",
                    "name": "TestCaseFunction.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type TestCaseId = string;
",
                    "name": "TestCaseId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface TestCaseImplementation {
  description: MyApi.v2.problem.TestCaseImplementationDescription;
  function: MyApi.v2.problem.TestCaseFunction;
}
",
                    "name": "TestCaseImplementation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface TestCaseImplementationDescription {
  boards: MyApi.v2.problem.TestCaseImplementationDescriptionBoard[];
}
",
                    "name": "TestCaseImplementationDescription.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export type TestCaseImplementationDescriptionBoard =
  | TestCaseImplementationDescriptionBoard.Html
  | TestCaseImplementationDescriptionBoard.ParamId
  | TestCaseImplementationDescriptionBoard._Unknown;

export declare namespace TestCaseImplementationDescriptionBoard {
  interface Html extends _Utils {
    type: \\"html\\";
    value: string;
  }

  interface ParamId extends _Utils {
    type: \\"paramId\\";
    value: MyApi.v2.problem.ParameterId;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(
      visitor: TestCaseImplementationDescriptionBoard._Visitor<Result>
    ) => Result;
  }

  interface _Visitor<Result> {
    html: (value: string) => Result;
    paramId: (value: MyApi.v2.problem.ParameterId) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const TestCaseImplementationDescriptionBoard = {
  html: (value: string): TestCaseImplementationDescriptionBoard.Html => ({
    value: value,
    type: \\"html\\",
    _visit: (visitor) => visitor.html(value),
  }),

  paramId: (
    value: MyApi.v2.problem.ParameterId
  ): TestCaseImplementationDescriptionBoard.ParamId => ({
    value: value,
    type: \\"paramId\\",
    _visit: (visitor) => visitor.paramId(value),
  }),
} as const;
",
                    "name": "TestCaseImplementationDescriptionBoard.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export type TestCaseImplementationReference =
  | TestCaseImplementationReference.TemplateId
  | TestCaseImplementationReference.Implementation
  | TestCaseImplementationReference._Unknown;

export declare namespace TestCaseImplementationReference {
  interface TemplateId extends _Utils {
    type: \\"templateId\\";
    value: MyApi.v2.problem.TestCaseTemplateId;
  }

  interface Implementation
    extends MyApi.v2.problem.TestCaseImplementation,
      _Utils {
    type: \\"implementation\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(
      visitor: TestCaseImplementationReference._Visitor<Result>
    ) => Result;
  }

  interface _Visitor<Result> {
    templateId: (value: MyApi.v2.problem.TestCaseTemplateId) => Result;
    implementation: (value: MyApi.v2.problem.TestCaseImplementation) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const TestCaseImplementationReference = {
  templateId: (
    value: MyApi.v2.problem.TestCaseTemplateId
  ): TestCaseImplementationReference.TemplateId => ({
    value: value,
    type: \\"templateId\\",
    _visit: (visitor) => visitor.templateId(value),
  }),

  implementation: (
    value: MyApi.v2.problem.TestCaseImplementation
  ): TestCaseImplementationReference.Implementation => ({
    ...value,
    type: \\"implementation\\",
    _visit: (visitor) => visitor.implementation(value),
  }),
} as const;
",
                    "name": "TestCaseImplementationReference.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface TestCaseMetadata {
  id: MyApi.v2.problem.TestCaseId;
  name: string;
  hidden: boolean;
}
",
                    "name": "TestCaseMetadata.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface TestCaseTemplate {
  templateId: MyApi.v2.problem.TestCaseTemplateId;
  name: string;
  implementation: MyApi.v2.problem.TestCaseImplementation;
}
",
                    "name": "TestCaseTemplate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export type TestCaseTemplateId = string;
",
                    "name": "TestCaseTemplateId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface TestCaseV2 {
  metadata: MyApi.v2.problem.TestCaseMetadata;
  implementation: MyApi.v2.problem.TestCaseImplementationReference;
  arguments: Record<string, MyApi.commons.VariableValue>;
  expects?: MyApi.v2.problem.TestCaseExpects;
}
",
                    "name": "TestCaseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface TestCaseWithActualResultImplementation {
  getActualResult: MyApi.v2.problem.NonVoidFunctionDefinition;
  assertCorrectnessCheck: MyApi.v2.problem.AssertCorrectnessCheck;
}
",
                    "name": "TestCaseWithActualResultImplementation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface VoidFunctionDefinition {
  parameters: MyApi.v2.problem.Parameter[];
  code: MyApi.v2.problem.FunctionImplementationForMultipleLanguages;
}
",
                    "name": "VoidFunctionDefinition.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

/**
 * The generated signature will include an additional param, actualResult
 */
export interface VoidFunctionDefinitionThatTakesActualResult {
  additionalParameters: MyApi.v2.problem.Parameter[];
  code: MyApi.v2.problem.FunctionImplementationForMultipleLanguages;
}
",
                    "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface VoidFunctionSignature {
  parameters: MyApi.v2.problem.Parameter[];
}
",
                    "name": "VoidFunctionSignature.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";

export interface VoidFunctionSignatureThatTakesActualResult {
  parameters: MyApi.v2.problem.Parameter[];
  actualResultType: MyApi.commons.VariableType;
}
",
                    "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "problem",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import * as core from \\"../../../core\\";
import { Client as ProblemInfoServicV2Client } from \\"./problem/client/Client\\";

export namespace Wrapper {
  export interface Options {
    _origin: string;
    _token?: core.BearerToken;
    _credentials?: core.BasicAuth;
    xApiKey?: string;
  }
}

export class Wrapper {
  constructor(private readonly options: Wrapper.Options) {}

  #problem: ProblemInfoServicV2Client | undefined;

  public get problem(): ProblemInfoServicV2Client {
    return (this.#problem ??= new ProblemInfoServicV2Client({
      _origin: this.options._origin,
      _token: this.options._token,
      _credentials: this.options._credentials,
      xApiKey: this.options.xApiKey,
    }));
  }
}
",
                "name": "Wrapper.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";
import urlJoin from \\"url-join\\";
import * as schemas from \\"../../../../../schemas\\";

export interface Client {
  getLightweightProblems(): Promise<MyApi.v2.v3.problem.getLightweightProblems.Response>;
  getProblems(): Promise<MyApi.v2.v3.problem.getProblems.Response>;
  getLatestProblem(
    request: MyApi.v2.v3.problem.getLatestProblem.Request
  ): Promise<MyApi.v2.v3.problem.getLatestProblem.Response>;
  getProblemVersion(
    request: MyApi.v2.v3.problem.getProblemVersion.Request
  ): Promise<MyApi.v2.v3.problem.getProblemVersion.Response>;
}

export declare namespace Client {
  interface Options {
    _origin: string;
    _token?: core.BearerToken;
    _credentials?: core.BasicAuth;
    xApiKey?: string;
  }
}

export class Client implements Client {
  constructor(private readonly options: Client.Options) {}

  public async getLightweightProblems(): Promise<MyApi.v2.v3.problem.getLightweightProblems.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/lightweight-problem-info\\"),
      method: \\"GET\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.v2.v3.problem.getLightweightProblems.Response.parse(
          response.body as schemas.v2.v3.problem.LightweightProblemInfoV2.Raw[]
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getProblems(): Promise<MyApi.v2.v3.problem.getProblems.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options._origin, \\"/problem-info\\"),
      method: \\"GET\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.v2.v3.problem.getProblems.Response.parse(
          response.body as schemas.v2.v3.problem.ProblemInfoV2.Raw[]
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getLatestProblem(
    request: MyApi.v2.v3.problem.getLatestProblem.Request
  ): Promise<MyApi.v2.v3.problem.getLatestProblem.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/problems-v2//problem-info/\${request.problemId}\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.v2.v3.problem.ProblemInfoV2.parse(
          response.body as schemas.v2.v3.problem.ProblemInfoV2.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getProblemVersion(
    request: MyApi.v2.v3.problem.getProblemVersion.Request
  ): Promise<MyApi.v2.v3.problem.getProblemVersion.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options._origin,
        \`/problems-v2//problem-info/\${request.problemId}/version/\${request.problemVersion}\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization:
          this.options._token != null
            ? core.BearerToken.toAuthorizationHeader(this.options._token)
            : this.options._credentials != null
            ? core.BasicAuth.toAuthorizationHeader(this.options._credentials)
            : undefined,
        \\"X-API-Key\\": this.options.xApiKey,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: schemas.v2.v3.problem.ProblemInfoV2.parse(
          response.body as schemas.v2.v3.problem.ProblemInfoV2.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                        "name": "Client.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  problemId: MyApi.commons.ProblemId;
}

export type Response = core.APIResponse<
  MyApi.v2.v3.problem.ProblemInfoV2,
  MyApi.v2.v3.problem.getLatestProblem.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                        "name": "getLatestProblem.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export type Response = core.APIResponse<
  MyApi.v2.v3.problem.LightweightProblemInfoV2[],
  MyApi.v2.v3.problem.getLightweightProblems.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                        "name": "getLightweightProblems.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as core from \\"../../../../../core\\";
import { MyApi } from \\"../../../../..\\";

export interface Request {
  _token?: core.BearerToken;
  _credentials?: core.BasicAuth;
  xApiKey?: string;
  problemId: MyApi.commons.ProblemId;
  problemVersion: number;
}

export type Response = core.APIResponse<
  MyApi.v2.v3.problem.ProblemInfoV2,
  MyApi.v2.v3.problem.getProblemVersion.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                        "name": "getProblemVersion.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export type Response = core.APIResponse<
  MyApi.v2.v3.problem.ProblemInfoV2[],
  MyApi.v2.v3.problem.getProblems.Error
>;
export type Error = Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <Result>(visitor: Error._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    _other: (value: core.Fetcher.Error) => Result;
  }
}
",
                        "name": "getProblems.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
export * as getLatestProblem from \\"./getLatestProblem\\";
export * as getProblemVersion from \\"./getProblemVersion\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export type AssertCorrectnessCheck =
  | AssertCorrectnessCheck.DeepEquality
  | AssertCorrectnessCheck.Custom
  | AssertCorrectnessCheck._Unknown;

export declare namespace AssertCorrectnessCheck {
  interface DeepEquality
    extends MyApi.v2.v3.problem.DeepEqualityCorrectnessCheck,
      _Utils {
    type: \\"deepEquality\\";
  }

  interface Custom
    extends MyApi.v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult,
      _Utils {
    type: \\"custom\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(
      visitor: AssertCorrectnessCheck._Visitor<Result>
    ) => Result;
  }

  interface _Visitor<Result> {
    deepEquality: (
      value: MyApi.v2.v3.problem.DeepEqualityCorrectnessCheck
    ) => Result;
    custom: (
      value: MyApi.v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult
    ) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const AssertCorrectnessCheck = {
  deepEquality: (
    value: MyApi.v2.v3.problem.DeepEqualityCorrectnessCheck
  ): AssertCorrectnessCheck.DeepEquality => ({
    ...value,
    type: \\"deepEquality\\",
    _visit: (visitor) => visitor.deepEquality(value),
  }),

  custom: (
    value: MyApi.v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult
  ): AssertCorrectnessCheck.Custom => ({
    ...value,
    type: \\"custom\\",
    _visit: (visitor) => visitor.custom(value),
  }),
} as const;
",
                        "name": "AssertCorrectnessCheck.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface BasicCustomFiles {
  methodName: string;
  signature: MyApi.v2.v3.problem.NonVoidFunctionSignature;
  additionalFiles: Record<
    MyApi.commons.Language.RawValue,
    MyApi.v2.v3.problem.Files
  >;
  basicTestCaseTemplate: MyApi.v2.v3.problem.BasicTestCaseTemplate;
}
",
                        "name": "BasicCustomFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface BasicTestCaseTemplate {
  templateId: MyApi.v2.v3.problem.TestCaseTemplateId;
  name: string;
  description: MyApi.v2.v3.problem.TestCaseImplementationDescription;
  expectedValueParameterId: MyApi.v2.v3.problem.ParameterId;
}
",
                        "name": "BasicTestCaseTemplate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface CreateProblemRequestV2 {
  problemName: string;
  problemDescription: MyApi.problem.ProblemDescription;
  customFiles: MyApi.v2.v3.problem.CustomFiles;
  customTestCaseTemplates: MyApi.v2.v3.problem.TestCaseTemplate[];
  testcases: MyApi.v2.v3.problem.TestCaseV2[];
  supportedLanguages: MyApi.commons.Language[];
  isPublic: boolean;
}
",
                        "name": "CreateProblemRequestV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export type CustomFiles =
  | CustomFiles.Basic
  | CustomFiles.Custom
  | CustomFiles._Unknown;

export declare namespace CustomFiles {
  interface Basic extends MyApi.v2.v3.problem.BasicCustomFiles, _Utils {
    type: \\"basic\\";
  }

  interface Custom extends _Utils {
    type: \\"custom\\";
    value: Record<MyApi.commons.Language.RawValue, MyApi.v2.v3.problem.Files>;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: CustomFiles._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    basic: (value: MyApi.v2.v3.problem.BasicCustomFiles) => Result;
    custom: (
      value: Record<MyApi.commons.Language.RawValue, MyApi.v2.v3.problem.Files>
    ) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const CustomFiles = {
  basic: (value: MyApi.v2.v3.problem.BasicCustomFiles): CustomFiles.Basic => ({
    ...value,
    type: \\"basic\\",
    _visit: (visitor) => visitor.basic(value),
  }),

  custom: (
    value: Record<MyApi.commons.Language.RawValue, MyApi.v2.v3.problem.Files>
  ): CustomFiles.Custom => ({
    value: value,
    type: \\"custom\\",
    _visit: (visitor) => visitor.custom(value),
  }),
} as const;
",
                        "name": "CustomFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface DeepEqualityCorrectnessCheck {
  expectedValueParameterId: MyApi.v2.v3.problem.ParameterId;
}
",
                        "name": "DeepEqualityCorrectnessCheck.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface DefaultProvidedFile {
  file: MyApi.v2.v3.problem.FileInfoV2;
  relatedTypes: MyApi.commons.VariableType[];
}
",
                        "name": "DefaultProvidedFile.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface FileInfoV2 {
  filename: string;
  directory: string;
  contents: string;
  editable: boolean;
}
",
                        "name": "FileInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface Files {
  files: MyApi.v2.v3.problem.FileInfoV2[];
}
",
                        "name": "Files.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface FunctionImplementation {
  impl: string;
  imports?: string;
}
",
                        "name": "FunctionImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface FunctionImplementationForMultipleLanguages {
  codeByLanguage: Record<
    MyApi.commons.Language.RawValue,
    MyApi.v2.v3.problem.FunctionImplementation
  >;
}
",
                        "name": "FunctionImplementationForMultipleLanguages.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export type FunctionSignature =
  | FunctionSignature.Void
  | FunctionSignature.NonVoid
  /**
   * Useful when specifying custom grading for a testcase where actualResult is defined. */
  | FunctionSignature.VoidThatTakesActualResult
  | FunctionSignature._Unknown;

export declare namespace FunctionSignature {
  interface Void extends MyApi.v2.v3.problem.VoidFunctionSignature, _Utils {
    type: \\"void\\";
  }

  interface NonVoid
    extends MyApi.v2.v3.problem.NonVoidFunctionSignature,
      _Utils {
    type: \\"nonVoid\\";
  }

  interface VoidThatTakesActualResult
    extends MyApi.v2.v3.problem.VoidFunctionSignatureThatTakesActualResult,
      _Utils {
    type: \\"voidThatTakesActualResult\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: FunctionSignature._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    void: (value: MyApi.v2.v3.problem.VoidFunctionSignature) => Result;
    nonVoid: (value: MyApi.v2.v3.problem.NonVoidFunctionSignature) => Result;
    voidThatTakesActualResult: (
      value: MyApi.v2.v3.problem.VoidFunctionSignatureThatTakesActualResult
    ) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const FunctionSignature = {
  void: (
    value: MyApi.v2.v3.problem.VoidFunctionSignature
  ): FunctionSignature.Void => ({
    ...value,
    type: \\"void\\",
    _visit: (visitor) => visitor.void(value),
  }),

  nonVoid: (
    value: MyApi.v2.v3.problem.NonVoidFunctionSignature
  ): FunctionSignature.NonVoid => ({
    ...value,
    type: \\"nonVoid\\",
    _visit: (visitor) => visitor.nonVoid(value),
  }),

  voidThatTakesActualResult: (
    value: MyApi.v2.v3.problem.VoidFunctionSignatureThatTakesActualResult
  ): FunctionSignature.VoidThatTakesActualResult => ({
    ...value,
    type: \\"voidThatTakesActualResult\\",
    _visit: (visitor) => visitor.voidThatTakesActualResult(value),
  }),
} as const;
",
                        "name": "FunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface GeneratedFiles {
  generatedTestCaseFiles: Record<
    MyApi.commons.Language.RawValue,
    MyApi.v2.v3.problem.Files
  >;
  generatedTemplateFiles: Record<
    MyApi.commons.Language.RawValue,
    MyApi.v2.v3.problem.Files
  >;
  other: Record<MyApi.commons.Language.RawValue, MyApi.v2.v3.problem.Files>;
}
",
                        "name": "GeneratedFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface GetBasicSolutionFileRequest {
  methodName: string;
  signature: MyApi.v2.v3.problem.NonVoidFunctionSignature;
}
",
                        "name": "GetBasicSolutionFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface GetBasicSolutionFileResponse {
  solutionFileByLanguage: Record<
    MyApi.commons.Language.RawValue,
    MyApi.v2.v3.problem.FileInfoV2
  >;
}
",
                        "name": "GetBasicSolutionFileResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface GetFunctionSignatureRequest {
  functionSignature: MyApi.v2.v3.problem.FunctionSignature;
}
",
                        "name": "GetFunctionSignatureRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface GetFunctionSignatureResponse {
  functionByLanguage: Record<MyApi.commons.Language.RawValue, string>;
}
",
                        "name": "GetFunctionSignatureResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface GetGeneratedTestCaseFileRequest {
  template?: MyApi.v2.v3.problem.TestCaseTemplate;
  testCase: MyApi.v2.v3.problem.TestCaseV2;
}
",
                        "name": "GetGeneratedTestCaseFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface GetGeneratedTestCaseTemplateFileRequest {
  template: MyApi.v2.v3.problem.TestCaseTemplate;
}
",
                        "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface LightweightProblemInfoV2 {
  problemId: MyApi.commons.ProblemId;
  problemName: string;
  problemVersion: number;
  variableTypes: MyApi.commons.VariableType[];
}
",
                        "name": "LightweightProblemInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface NonVoidFunctionDefinition {
  signature: MyApi.v2.v3.problem.NonVoidFunctionSignature;
  code: MyApi.v2.v3.problem.FunctionImplementationForMultipleLanguages;
}
",
                        "name": "NonVoidFunctionDefinition.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface NonVoidFunctionSignature {
  parameters: MyApi.v2.v3.problem.Parameter[];
  returnType: MyApi.commons.VariableType;
}
",
                        "name": "NonVoidFunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface Parameter {
  parameterId: MyApi.v2.v3.problem.ParameterId;
  name: string;
  variableType: MyApi.commons.VariableType;
}
",
                        "name": "Parameter.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type ParameterId = string;
",
                        "name": "ParameterId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface ProblemInfoV2 {
  problemId: MyApi.commons.ProblemId;
  problemDescription: MyApi.problem.ProblemDescription;
  problemName: string;
  problemVersion: number;
  supportedLanguages: MyApi.commons.Language[];
  customFiles: MyApi.v2.v3.problem.CustomFiles;
  generatedFiles: MyApi.v2.v3.problem.GeneratedFiles;
  customTestCaseTemplates: MyApi.v2.v3.problem.TestCaseTemplate[];
  testcases: MyApi.v2.v3.problem.TestCaseV2[];
  isPublic: boolean;
}
",
                        "name": "ProblemInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export interface TestCaseExpects {
  expectedStdout?: string;
}
",
                        "name": "TestCaseExpects.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export type TestCaseFunction =
  | TestCaseFunction.WithActualResult
  | TestCaseFunction.Custom
  | TestCaseFunction._Unknown;

export declare namespace TestCaseFunction {
  interface WithActualResult
    extends MyApi.v2.v3.problem.TestCaseWithActualResultImplementation,
      _Utils {
    type: \\"withActualResult\\";
  }

  interface Custom extends MyApi.v2.v3.problem.VoidFunctionDefinition, _Utils {
    type: \\"custom\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(visitor: TestCaseFunction._Visitor<Result>) => Result;
  }

  interface _Visitor<Result> {
    withActualResult: (
      value: MyApi.v2.v3.problem.TestCaseWithActualResultImplementation
    ) => Result;
    custom: (value: MyApi.v2.v3.problem.VoidFunctionDefinition) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const TestCaseFunction = {
  withActualResult: (
    value: MyApi.v2.v3.problem.TestCaseWithActualResultImplementation
  ): TestCaseFunction.WithActualResult => ({
    ...value,
    type: \\"withActualResult\\",
    _visit: (visitor) => visitor.withActualResult(value),
  }),

  custom: (
    value: MyApi.v2.v3.problem.VoidFunctionDefinition
  ): TestCaseFunction.Custom => ({
    ...value,
    type: \\"custom\\",
    _visit: (visitor) => visitor.custom(value),
  }),
} as const;
",
                        "name": "TestCaseFunction.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type TestCaseId = string;
",
                        "name": "TestCaseId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface TestCaseImplementation {
  description: MyApi.v2.v3.problem.TestCaseImplementationDescription;
  function: MyApi.v2.v3.problem.TestCaseFunction;
}
",
                        "name": "TestCaseImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface TestCaseImplementationDescription {
  boards: MyApi.v2.v3.problem.TestCaseImplementationDescriptionBoard[];
}
",
                        "name": "TestCaseImplementationDescription.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export type TestCaseImplementationDescriptionBoard =
  | TestCaseImplementationDescriptionBoard.Html
  | TestCaseImplementationDescriptionBoard.ParamId
  | TestCaseImplementationDescriptionBoard._Unknown;

export declare namespace TestCaseImplementationDescriptionBoard {
  interface Html extends _Utils {
    type: \\"html\\";
    value: string;
  }

  interface ParamId extends _Utils {
    type: \\"paramId\\";
    value: MyApi.v2.v3.problem.ParameterId;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(
      visitor: TestCaseImplementationDescriptionBoard._Visitor<Result>
    ) => Result;
  }

  interface _Visitor<Result> {
    html: (value: string) => Result;
    paramId: (value: MyApi.v2.v3.problem.ParameterId) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const TestCaseImplementationDescriptionBoard = {
  html: (value: string): TestCaseImplementationDescriptionBoard.Html => ({
    value: value,
    type: \\"html\\",
    _visit: (visitor) => visitor.html(value),
  }),

  paramId: (
    value: MyApi.v2.v3.problem.ParameterId
  ): TestCaseImplementationDescriptionBoard.ParamId => ({
    value: value,
    type: \\"paramId\\",
    _visit: (visitor) => visitor.paramId(value),
  }),
} as const;
",
                        "name": "TestCaseImplementationDescriptionBoard.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export type TestCaseImplementationReference =
  | TestCaseImplementationReference.TemplateId
  | TestCaseImplementationReference.Implementation
  | TestCaseImplementationReference._Unknown;

export declare namespace TestCaseImplementationReference {
  interface TemplateId extends _Utils {
    type: \\"templateId\\";
    value: MyApi.v2.v3.problem.TestCaseTemplateId;
  }

  interface Implementation
    extends MyApi.v2.v3.problem.TestCaseImplementation,
      _Utils {
    type: \\"implementation\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <Result>(
      visitor: TestCaseImplementationReference._Visitor<Result>
    ) => Result;
  }

  interface _Visitor<Result> {
    templateId: (value: MyApi.v2.v3.problem.TestCaseTemplateId) => Result;
    implementation: (
      value: MyApi.v2.v3.problem.TestCaseImplementation
    ) => Result;
    _other: (value: { type: string }) => Result;
  }
}

export const TestCaseImplementationReference = {
  templateId: (
    value: MyApi.v2.v3.problem.TestCaseTemplateId
  ): TestCaseImplementationReference.TemplateId => ({
    value: value,
    type: \\"templateId\\",
    _visit: (visitor) => visitor.templateId(value),
  }),

  implementation: (
    value: MyApi.v2.v3.problem.TestCaseImplementation
  ): TestCaseImplementationReference.Implementation => ({
    ...value,
    type: \\"implementation\\",
    _visit: (visitor) => visitor.implementation(value),
  }),
} as const;
",
                        "name": "TestCaseImplementationReference.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface TestCaseMetadata {
  id: MyApi.v2.v3.problem.TestCaseId;
  name: string;
  hidden: boolean;
}
",
                        "name": "TestCaseMetadata.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface TestCaseTemplate {
  templateId: MyApi.v2.v3.problem.TestCaseTemplateId;
  name: string;
  implementation: MyApi.v2.v3.problem.TestCaseImplementation;
}
",
                        "name": "TestCaseTemplate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export type TestCaseTemplateId = string;
",
                        "name": "TestCaseTemplateId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface TestCaseV2 {
  metadata: MyApi.v2.v3.problem.TestCaseMetadata;
  implementation: MyApi.v2.v3.problem.TestCaseImplementationReference;
  arguments: Record<string, MyApi.commons.VariableValue>;
  expects?: MyApi.v2.v3.problem.TestCaseExpects;
}
",
                        "name": "TestCaseV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface TestCaseWithActualResultImplementation {
  getActualResult: MyApi.v2.v3.problem.NonVoidFunctionDefinition;
  assertCorrectnessCheck: MyApi.v2.v3.problem.AssertCorrectnessCheck;
}
",
                        "name": "TestCaseWithActualResultImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface VoidFunctionDefinition {
  parameters: MyApi.v2.v3.problem.Parameter[];
  code: MyApi.v2.v3.problem.FunctionImplementationForMultipleLanguages;
}
",
                        "name": "VoidFunctionDefinition.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

/**
 * The generated signature will include an additional param, actualResult
 */
export interface VoidFunctionDefinitionThatTakesActualResult {
  additionalParameters: MyApi.v2.v3.problem.Parameter[];
  code: MyApi.v2.v3.problem.FunctionImplementationForMultipleLanguages;
}
",
                        "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface VoidFunctionSignature {
  parameters: MyApi.v2.v3.problem.Parameter[];
}
",
                        "name": "VoidFunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";

export interface VoidFunctionSignatureThatTakesActualResult {
  parameters: MyApi.v2.v3.problem.Parameter[];
  actualResultType: MyApi.commons.VariableType;
}
",
                        "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "problem",
                "type": "directory",
              },
            ],
            "name": "v3",
            "type": "directory",
          },
        ],
        "name": "v2",
        "type": "directory",
      },
    ],
    "name": "api",
    "type": "directory",
  },
  Object {
    "contents": Array [
      Object {
        "contents": Array [
          Object {
            "contents": "import { parse } from \\"basic-auth\\";
import { Base64 } from \\"js-base64\\";

export interface BasicAuth {
  username: string;
  password: string;
}

export const BasicAuth = {
  toAuthorizationHeader: (basicAuth: BasicAuth): string => {
    const token = Base64.encode(\`\${basicAuth.username}:\${basicAuth.password}\`);
    return \`Basic \${token}\`;
  },
  fromAuthorizationHeader: (header: string): BasicAuth => {
    const parsed = parse(header);
    if (parsed == null) {
      throw new Error(\\"Invalid basic auth\\");
    }
    return {
      username: parsed.name,
      password: parsed.pass,
    };
  },
};
",
            "name": "BasicAuth.ts",
            "type": "file",
          },
          Object {
            "contents": "export type BearerToken = string;

const BEARER_AUTH_HEADER_PREFIX = /^Bearer /i;

export const BearerToken = {
  toAuthorizationHeader: (token: BearerToken): string => {
    return \`Bearer \${token}\`;
  },
  fromAuthorizationHeader: (header: string): BearerToken => {
    return header.replace(BEARER_AUTH_HEADER_PREFIX, \\"\\").trim() as BearerToken;
  },
};
",
            "name": "BearerToken.ts",
            "type": "file",
          },
          Object {
            "contents": "export { BasicAuth } from \\"./BasicAuth\\";
export { BearerToken } from \\"./BearerToken\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "auth",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export type APIResponse<Success, Failure> =
  | SuccessfulResponse<Success>
  | FailedResponse<Failure>;

export interface SuccessfulResponse<T> {
  ok: true;
  body: T;
}

export interface FailedResponse<T> {
  ok: false;
  error: T;
}
",
            "name": "APIResponse.ts",
            "type": "file",
          },
          Object {
            "contents": "import axios, { AxiosError } from \\"axios\\";
import { APIResponse } from \\"./APIResponse\\";

export interface Fetcher {
  fetch: FetchFunction;
}

export type FetchFunction = (
  args: Fetcher.Args
) => Promise<APIResponse<unknown, Fetcher.Error>>;

export declare namespace Fetcher {
  export interface Args {
    url: string;
    method: string;
    headers?: Record<string, string | undefined>;
    queryParameters?: URLSearchParams;
    body?: unknown;
    timeoutMs?: number;
  }

  export type Error =
    | FailedStatusCodeError
    | NonJsonError
    | TimeoutError
    | UnknownError;

  export interface FailedStatusCodeError {
    reason: \\"status-code\\";
    statusCode: number;
    body: unknown;
  }

  export interface NonJsonError {
    reason: \\"non-json\\";
    statusCode: number;
    rawBody: string;
  }

  export interface TimeoutError {
    reason: \\"timeout\\";
  }

  export interface UnknownError {
    reason: \\"unknown\\";
    errorMessage: string;
  }
}

export const fetcher: FetchFunction = async (args) => {
  const headers: Record<string, string> = {
    \\"Content-Type\\": \\"application/json\\",
  };

  if (args.headers != null) {
    for (const [key, value] of Object.entries(args.headers)) {
      if (value != null) {
        headers[key] = value;
      }
    }
  }

  try {
    const response = await axios({
      url: args.url,
      params: args.queryParameters,
      method: args.method,
      headers,
      data: args.body,
      validateStatus: () => true,
      transformResponse: (response) => response,
      timeout: args.timeoutMs ?? 60_000,
      transitional: {
        clarifyTimeoutError: true,
      },
    });

    let body: unknown;
    if (response.data != null) {
      try {
        body = JSON.parse(response.data) ?? undefined;
      } catch {
        return {
          ok: false,
          error: {
            reason: \\"non-json\\",
            statusCode: response.status,
            rawBody: response.data,
          },
        };
      }
    }

    if (response.status >= 200 && response.status < 300) {
      return {
        ok: true,
        body: {
          statusCode: response.status,
          body,
        },
      };
    } else {
      return {
        ok: false,
        error: {
          reason: \\"status-code\\",
          statusCode: response.status,
          body,
        },
      };
    }
  } catch (error) {
    if ((error as AxiosError).code === \\"ETIMEDOUT\\") {
      return {
        ok: false,
        error: {
          reason: \\"timeout\\",
        },
      };
    }

    return {
      ok: false,
      error: {
        reason: \\"unknown\\",
        errorMessage: (error as AxiosError).message,
      },
    };
  }
};
",
            "name": "Fetcher.ts",
            "type": "file",
          },
          Object {
            "contents": "export { type APIResponse } from \\"./APIResponse\\";
export { fetcher, type Fetcher, type FetchFunction } from \\"./Fetcher\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "fetcher",
        "type": "directory",
      },
      Object {
        "contents": "export * as schemas from \\"./schemas\\";
export * from \\"./auth\\";
export * from \\"./fetcher\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "import { SchemaUtils } from \\"./builders\\";

export type Schema<Raw = unknown, Parsed = unknown> = BaseSchema<Raw, Parsed> &
  SchemaUtils<Raw, Parsed>;

export type inferRaw<S extends Schema> = S extends Schema<infer Raw, any>
  ? Raw
  : never;
export type inferParsed<S extends Schema> = S extends Schema<any, infer Parsed>
  ? Parsed
  : never;

export interface BaseSchema<Raw, Parsed> {
  parse: (raw: Raw, opts?: SchemaOptions) => Parsed;
  json: (parsed: Parsed, opts?: SchemaOptions) => Raw;
}

export interface SchemaOptions {
  /**
   * @default false
   */
  skipUnknownKeysOnParse?: boolean;

  /**
   * @default false
   */
  includeUnknownKeysOnJson?: boolean;
}
",
            "name": "Schema.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function date(): Schema<string, Date> {
  const baseSchema: BaseSchema<string, Date> = {
    parse: (raw) => new Date(raw),
    json: (date) => date.toISOString(),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                    "name": "date.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { date } from \\"./date\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "date",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function enum_<U extends string, E extends Readonly<[U, ...U[]]>>(
  _values: E
): Schema<E[number], E[number]> {
  return createIdentitySchemaCreator<E[number]>()();
}
",
                    "name": "enum.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { enum_ } from \\"./enum\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "enum",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
import { identity } from \\"./identity\\";

export function createIdentitySchemaCreator<T>(): () => Schema<T, T> {
  return <T>() => identity<T>();
}
",
                    "name": "createIdentitySchemaCreator.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function identity<T>(): Schema<T, T> {
  const baseSchema: BaseSchema<T, T> = {
    parse: (raw) => raw,
    json: (parsed) => parsed,
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                    "name": "identity.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { createIdentitySchemaCreator } from \\"./createIdentitySchemaCreator\\";
export { identity } from \\"./identity\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "identity",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./date\\";
export * from \\"./enum\\";
export * from \\"./identity\\";
export * from \\"./lazy\\";
export * from \\"./list\\";
export * from \\"./literals\\";
export * from \\"./object\\";
export * from \\"./object-like\\";
export * from \\"./primitives\\";
export * from \\"./record\\";
export * from \\"./schema-utils\\";
export * from \\"./set\\";
export * from \\"./union\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { lazy } from \\"./lazy\\";
export { lazyObject } from \\"./lazyObject\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

type Getter<Raw, Parsed> = () => Schema<Raw, Parsed>;
type MemoizedGetter<Raw, Parsed> = Getter<Raw, Parsed> & {
  __zurg_memoized?: Schema<Raw, Parsed>;
};

export function lazy<Raw, Parsed>(
  getter: Getter<Raw, Parsed>
): Schema<Raw, Parsed> {
  const baseSchema = constructLazyBaseSchema(getter);
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function constructLazyBaseSchema<Raw, Parsed>(
  getter: Getter<Raw, Parsed>
): BaseSchema<Raw, Parsed> {
  const getSchema = () => {
    const castedGetter = getter as MemoizedGetter<Raw, Parsed>;
    if (castedGetter.__zurg_memoized == null) {
      castedGetter.__zurg_memoized = getter();
    }
    return castedGetter.__zurg_memoized;
  };

  return {
    parse: (raw) => getSchema().parse(raw),
    json: (parsed) => getSchema().json(parsed),
  };
}
",
                    "name": "lazy.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { getObjectUtils } from \\"../object\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { ObjectSchema } from \\"../object/types\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { constructLazyBaseSchema } from \\"./lazy\\";

export function lazyObject<Raw, Parsed>(
  getter: () => ObjectSchema<Raw, Parsed>
): ObjectSchema<Raw, Parsed> {
  const baseSchema = {
    ...OBJECT_LIKE_BRAND,
    ...constructLazyBaseSchema(getter),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}
",
                    "name": "lazyObject.ts",
                    "type": "file",
                  },
                ],
                "name": "lazy",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { list } from \\"./list\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function list<Raw, Parsed>(
  schema: Schema<Raw, Parsed>
): Schema<Raw[], Parsed[]> {
  const baseSchema: BaseSchema<Raw[], Parsed[]> = {
    parse: (raw, opts) => raw.map((item) => schema.parse(item, opts)),
    json: (parsed, opts) => parsed.map((item) => schema.json(item, opts)),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                    "name": "list.ts",
                    "type": "file",
                  },
                ],
                "name": "list",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { stringLiteral } from \\"./stringLiteral\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function stringLiteral<V extends string>(_value: V): Schema<V, V> {
  return createIdentitySchemaCreator<V>()();
}
",
                    "name": "stringLiteral.ts",
                    "type": "file",
                  },
                ],
                "name": "literals",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { getObjectUtils, object } from \\"./object\\";
export { isProperty, property, type Property } from \\"./property\\";
export {
  type BaseObjectSchema,
  type inferObjectSchemaFromPropertySchemas,
  type inferParsedObject,
  type inferParsedObjectFromPropertySchemas,
  type inferParsedPropertySchema,
  type inferRawKey,
  type inferRawObject,
  type inferRawObjectFromPropertySchemas,
  type inferRawPropertySchema,
  type ObjectSchema,
  type ObjectUtils,
  type PropertySchemas,
} from \\"./types\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { isProperty } from \\"./property\\";
import {
  BaseObjectSchema,
  inferObjectSchemaFromPropertySchemas,
  inferParsedObjectFromPropertySchemas,
  inferRawObjectFromPropertySchemas,
  ObjectUtils,
  PropertySchemas,
} from \\"./types\\";

interface ObjectPropertyWithRawKey {
  rawKey: string;
  parsedKey: string | number | symbol;
  valueSchema: Schema<any, any>;
}

export function object<
  ParsedKeys extends string,
  T extends PropertySchemas<ParsedKeys>
>(schemas: T): inferObjectSchemaFromPropertySchemas<T> {
  const baseSchema: BaseObjectSchema<
    inferRawObjectFromPropertySchemas<T>,
    inferParsedObjectFromPropertySchemas<T>
  > = {
    ...OBJECT_LIKE_BRAND,

    parse: (raw, { skipUnknownKeysOnParse = false } = {}) => {
      const rawKeyToProperty: Record<string, ObjectPropertyWithRawKey> = {};

      for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
        const rawKey = isProperty(schemaOrObjectProperty)
          ? schemaOrObjectProperty.rawKey
          : parsedKey;

        const property: ObjectPropertyWithRawKey = {
          rawKey,
          parsedKey,
          valueSchema: isProperty(schemaOrObjectProperty)
            ? schemaOrObjectProperty.valueSchema
            : schemaOrObjectProperty,
        };

        rawKeyToProperty[rawKey] = property;
      }

      const parsed: Record<string | number | symbol, any> = {};

      for (const [rawKey, rawPropertyValue] of Object.entries(raw)) {
        const property = rawKeyToProperty[rawKey];

        if (property != null) {
          const value = property.valueSchema.parse(rawPropertyValue);
          if (value != null) {
            parsed[property.parsedKey] = value;
          }
        } else if (!skipUnknownKeysOnParse && rawPropertyValue != null) {
          parsed[rawKey] = rawPropertyValue;
        }
      }

      return parsed as inferParsedObjectFromPropertySchemas<T>;
    },

    json: (parsed, { includeUnknownKeysOnJson = false } = {}) => {
      const raw: Record<string | number | symbol, any> = {};

      for (const [parsedKey, parsedPropertyValue] of entries(parsed)) {
        const schemaOrObjectProperty = schemas[parsedKey as keyof T];
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (schemaOrObjectProperty != null) {
          if (isProperty(schemaOrObjectProperty)) {
            const value =
              schemaOrObjectProperty.valueSchema.json(parsedPropertyValue);
            if (value != null) {
              raw[schemaOrObjectProperty.rawKey] = value;
            }
          } else {
            const value = schemaOrObjectProperty.json(parsedPropertyValue);
            if (value != null) {
              raw[parsedKey] = value;
            }
          }
        } else if (includeUnknownKeysOnJson && parsedPropertyValue != null) {
          raw[parsedKey] = parsedPropertyValue;
        }
      }

      return raw as inferRawObjectFromPropertySchemas<T>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}

export function getObjectUtils<Raw, Parsed>(
  schema: BaseObjectSchema<Raw, Parsed>
): ObjectUtils<Raw, Parsed> {
  return {
    extend: <U extends PropertySchemas<keyof U>>(extension: U) => {
      const baseSchema: BaseObjectSchema<
        Raw & inferRawObjectFromPropertySchemas<U>,
        Parsed & inferParsedObjectFromPropertySchemas<U>
      > = {
        ...OBJECT_LIKE_BRAND,
        parse: (raw, opts) => ({
          ...schema.parse(raw, opts),
          ...object(extension).parse(raw, opts),
        }),
        json: (parsed, opts) => ({
          ...schema.json(parsed, opts),
          ...object(extension).json(parsed, opts),
        }),
      };

      return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
      };
    },
  };
}
",
                    "name": "object.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";

export function property<RawKey extends string, RawValue, ParsedValue>(
  rawKey: RawKey,
  valueSchema: Schema<RawValue, ParsedValue>
): Property<RawKey, RawValue, ParsedValue> {
  return {
    rawKey,
    valueSchema,
    isProperty: true,
  };
}

export interface Property<RawKey extends string, RawValue, ParsedValue> {
  rawKey: RawKey;
  valueSchema: Schema<RawValue, ParsedValue>;
  isProperty: true;
}

export function isProperty<O extends Property<any, any, any>>(
  maybeProperty: unknown
): maybeProperty is O {
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return (maybeProperty as O).isProperty;
}
",
                    "name": "property.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { inferParsed, inferRaw, Schema } from \\"../../Schema\\";
import { addQuestionMarksToNullableProperties } from \\"../../utils/addQuestionMarksToNullableProperties\\";
import { BaseObjectLikeSchema, ObjectLikeSchema } from \\"../object-like\\";
import { Property } from \\"./property\\";

export type ObjectSchema<Raw, Parsed> = BaseObjectSchema<Raw, Parsed> &
  ObjectLikeSchema<Raw, Parsed> &
  ObjectUtils<Raw, Parsed>;

export type BaseObjectSchema<Raw, Parsed> = BaseObjectLikeSchema<Raw, Parsed>;

export interface ObjectUtils<Raw, Parsed> {
  extend: <U extends PropertySchemas<keyof U>>(
    schemas: U
  ) => ObjectSchema<
    Raw & inferRawObjectFromPropertySchemas<U>,
    Parsed & inferParsedObjectFromPropertySchemas<U>
  >;
}

export type inferRawObject<O extends ObjectSchema<any, any>> =
  O extends ObjectSchema<infer Raw, any> ? Raw : never;

export type inferParsedObject<O extends ObjectSchema<any, any>> =
  O extends ObjectSchema<any, infer Parsed> ? Parsed : never;

export type inferObjectSchemaFromPropertySchemas<
  T extends PropertySchemas<keyof T>
> = ObjectSchema<
  inferRawObjectFromPropertySchemas<T>,
  inferParsedObjectFromPropertySchemas<T>
>;

export type inferRawObjectFromPropertySchemas<
  T extends PropertySchemas<keyof T>
> = addQuestionMarksToNullableProperties<{
  [ParsedKey in keyof T as inferRawKey<
    ParsedKey,
    T[ParsedKey]
  >]: inferRawPropertySchema<T[ParsedKey]>;
}>;

export type inferParsedObjectFromPropertySchemas<
  T extends PropertySchemas<keyof T>
> = addQuestionMarksToNullableProperties<{
  [K in keyof T]: inferParsedPropertySchema<T[K]>;
}>;

export type PropertySchemas<ParsedKeys extends string | number | symbol> =
  Record<ParsedKeys, Property<any, any, any> | Schema<any, any>>;

export type inferRawPropertySchema<
  P extends Property<any, any, any> | Schema<any, any>
> = P extends Property<any, infer Raw, any>
  ? Raw
  : P extends Schema<any, any>
  ? inferRaw<P>
  : never;

export type inferParsedPropertySchema<
  P extends Property<any, any, any> | Schema<any, any>
> = P extends Property<any, any, infer Parsed>
  ? Parsed
  : P extends Schema<any, any>
  ? inferParsed<P>
  : never;

export type inferRawKey<
  ParsedKey extends string | number | symbol,
  P extends Property<any, any, any> | Schema<any, any>
> = P extends Property<infer Raw, any, any> ? Raw : ParsedKey;
",
                    "name": "types.ts",
                    "type": "file",
                  },
                ],
                "name": "object",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { BaseObjectLikeSchema, ObjectLikeUtils } from \\"./types\\";
import { withProperties } from \\"./withProperties\\";

export function getObjectLikeUtils<Raw, Parsed>(
  schema: BaseObjectLikeSchema<Raw, Parsed>
): ObjectLikeUtils<Raw, Parsed> {
  return {
    withProperties: (properties) => withProperties(schema, properties),
  };
}
",
                    "name": "getObjectLikeUtils.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { getObjectLikeUtils } from \\"./getObjectLikeUtils\\";
export {
  OBJECT_LIKE_BRAND,
  type BaseObjectLikeSchema,
  type ObjectLikeSchema,
  type ObjectLikeUtils,
} from \\"./types\\";
export { withProperties } from \\"./withProperties\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";

export type ObjectLikeSchema<Raw, Parsed> = Schema<Raw, Parsed> &
  BaseObjectLikeSchema<Raw, Parsed> &
  ObjectLikeUtils<Raw, Parsed>;

export type BaseObjectLikeSchema<Raw, Parsed> = BaseSchema<Raw, Parsed> & {
  _objectLike: void;
};

export interface ObjectLikeUtils<Raw, Parsed> {
  withProperties: <T extends Record<string, any>>(properties: {
    [K in keyof T]: T[K] | ((parsed: Parsed) => T[K]);
  }) => ObjectLikeSchema<Raw, Parsed & T>;
}

export const OBJECT_LIKE_BRAND = undefined as unknown as { _objectLike: void };
",
                    "name": "types.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { getSchemaUtils } from \\"../schema-utils\\";
import { getObjectLikeUtils } from \\"./getObjectLikeUtils\\";
import {
  BaseObjectLikeSchema,
  ObjectLikeSchema,
  OBJECT_LIKE_BRAND,
} from \\"./types\\";

export function withProperties<RawObjectShape, ParsedObjectShape, Properties>(
  objectLike: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape>,
  properties: {
    [K in keyof Properties]:
      | Properties[K]
      | ((parsed: ParsedObjectShape) => Properties[K]);
  }
): ObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> {
  const objectSchema: BaseObjectLikeSchema<
    RawObjectShape,
    ParsedObjectShape & Properties
  > = {
    ...OBJECT_LIKE_BRAND,
    parse: (raw, opts) => {
      const parsedObject = objectLike.parse(raw, opts);
      const additionalProperties = Object.entries(properties).reduce<
        Record<string, any>
      >((processed, [key, value]) => {
        return {
          ...processed,
          [key]: typeof value === \\"function\\" ? value(parsedObject) : value,
        };
      }, {});

      return {
        ...parsedObject,
        ...(additionalProperties as Properties),
      };
    },
    json: (parsed, opts) => {
      // strip out added properties
      const addedPropertyKeys = new Set(Object.keys(properties));
      const parsedWithoutAddedProperties = Object.entries(parsed).reduce<
        Record<string, any>
      >((filtered, [key, value]) => {
        if (!addedPropertyKeys.has(key)) {
          filtered[key] = value;
        }
        return filtered;
      }, {});

      return objectLike.json(
        parsedWithoutAddedProperties as ParsedObjectShape,
        opts
      );
    },
  };

  return {
    ...objectSchema,
    ...getSchemaUtils(objectSchema),
    ...getObjectLikeUtils(objectSchema),
  };
}
",
                    "name": "withProperties.ts",
                    "type": "file",
                  },
                ],
                "name": "object-like",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const any = createIdentitySchemaCreator<any>();
",
                    "name": "any.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const boolean = createIdentitySchemaCreator<boolean>();
",
                    "name": "boolean.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { any } from \\"./any\\";
export { boolean } from \\"./boolean\\";
export { number } from \\"./number\\";
export { string } from \\"./string\\";
export { unknown } from \\"./unknown\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const number = createIdentitySchemaCreator<number>();
",
                    "name": "number.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const string = createIdentitySchemaCreator<string>();
",
                    "name": "string.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const unknown = createIdentitySchemaCreator<unknown>();
",
                    "name": "unknown.ts",
                    "type": "file",
                  },
                ],
                "name": "primitives",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { record } from \\"./record\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function record<
  RawKey extends string | number,
  ParsedKey extends string | number,
  RawValue,
  ParsedValue
>(
  keySchema: Schema<RawKey, ParsedKey>,
  valueSchema: Schema<RawValue, ParsedValue>
): Schema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> {
  const baseSchema: BaseSchema<
    Record<RawKey, RawValue>,
    Record<ParsedKey, ParsedValue>
  > = {
    parse: (raw, opts) => {
      return entries(raw).reduce(
        (parsed, [key, value]) => {
          parsed[keySchema.parse(key, opts)] = valueSchema.parse(value, opts);
          return parsed;
        },
        // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
        {} as Record<ParsedKey, ParsedValue>
      );
    },
    json: (parsed, opts) => {
      return entries(parsed).reduce(
        (raw, [key, value]) => {
          raw[keySchema.json(key, opts)] = valueSchema.json(value, opts);
          return raw;
        },
        // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
        {} as Record<RawKey, RawValue>
      );
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                    "name": "record.ts",
                    "type": "file",
                  },
                ],
                "name": "record",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { OptionalSchema, OPTIONAL_BRAND } from \\"./types\\";

export interface SchemaUtils<Raw, Parsed> {
  optional: () => OptionalSchema<Raw, Parsed>;
  transform: <PostTransform>(
    transformer: BaseSchema<Parsed, PostTransform>
  ) => Schema<Raw, PostTransform>;
}

export function getSchemaUtils<Raw, Parsed>(
  schema: BaseSchema<Raw, Parsed>
): SchemaUtils<Raw, Parsed> {
  return {
    optional: () => optional(schema),
    transform: (transformer) => transform(schema, transformer),
  };
}

/**
 * schema utils are defined in one file to resolve issues with circular imports
 */

export function optional<Raw, Parsed>(
  schema: BaseSchema<Raw, Parsed>
): OptionalSchema<Raw, Parsed> {
  const baseSchema: BaseSchema<Raw | null | undefined, Parsed | undefined> = {
    parse: (raw, opts) => (raw != null ? schema.parse(raw, opts) : undefined),
    json: (parsed, opts) =>
      parsed != null ? schema.json(parsed, opts) : undefined,
  };

  return {
    ...OPTIONAL_BRAND,
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function transform<PreTransformRaw, PreTransformParsed, PostTransform>(
  schema: BaseSchema<PreTransformRaw, PreTransformParsed>,
  transformer: BaseSchema<PreTransformParsed, PostTransform>
): Schema<PreTransformRaw, PostTransform> {
  const baseSchema: BaseSchema<PreTransformRaw, PostTransform> = {
    parse: (raw, opts) => {
      const postTransformParsed = schema.parse(raw, opts);
      return transformer.parse(postTransformParsed, opts);
    },
    json: (parsed, opts) => {
      const preTransformParsed = transformer.json(parsed, opts);
      return schema.json(preTransformParsed, opts);
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                    "name": "getSchemaUtils.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export {
  getSchemaUtils,
  optional,
  transform,
  type SchemaUtils,
} from \\"./getSchemaUtils\\";
export { OPTIONAL_BRAND, type OptionalSchema } from \\"./types\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { Schema } from \\"../../Schema\\";

export const OPTIONAL_BRAND = undefined as unknown as { _isOptional: void };

export type OptionalSchema<Raw, Parsed> = Schema<
  Raw | null | undefined,
  Parsed | undefined
> & {
  _isOptional: void;
};
",
                    "name": "types.ts",
                    "type": "file",
                  },
                ],
                "name": "schema-utils",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export { set } from \\"./set\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function set<Raw, Parsed>(
  schema: Schema<Raw, Parsed>
): Schema<Raw[], Set<Parsed>> {
  const baseSchema: BaseSchema<Raw[], Set<Parsed>> = {
    parse: (raw, opts) => new Set(raw.map((item) => schema.parse(item, opts))),
    json: (parsed, opts) => [...parsed].map((item) => schema.json(item, opts)),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                    "name": "set.ts",
                    "type": "file",
                  },
                ],
                "name": "set",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export function discriminant<
  RawDiscriminant extends string,
  ParsedDiscriminant extends string
>(
  parsedDiscriminant: ParsedDiscriminant,
  rawDiscriminant: RawDiscriminant
): Discriminant<RawDiscriminant, ParsedDiscriminant> {
  return {
    parsedDiscriminant,
    rawDiscriminant,
  };
}

export interface Discriminant<
  RawDiscriminant extends string,
  ParsedDiscriminant extends string
> {
  parsedDiscriminant: ParsedDiscriminant;
  rawDiscriminant: RawDiscriminant;
}
",
                    "name": "discriminant.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export { discriminant, type Discriminant } from \\"./discriminant\\";
export {
  type inferParsedDiscriminant,
  type inferParsedUnion,
  type inferRawDiscriminant,
  type inferRawUnion,
  type UnionSubtypes,
} from \\"./types\\";
export { union } from \\"./union\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { inferParsedObject, inferRawObject, ObjectSchema } from \\"../object\\";
import { Discriminant } from \\"./discriminant\\";

export type UnionSubtypes<DiscriminantValues extends string | number | symbol> =
  {
    [K in DiscriminantValues]: ObjectSchema<any, any>;
  };

export type inferRawUnion<
  D extends string | Discriminant<any, any>,
  U extends UnionSubtypes<keyof U>
> = {
  [K in keyof U]: Record<inferRawDiscriminant<D>, K> & inferRawObject<U[K]>;
}[keyof U];

export type inferParsedUnion<
  D extends string | Discriminant<any, any>,
  U extends UnionSubtypes<keyof U>
> = {
  [K in keyof U]: Record<inferParsedDiscriminant<D>, K> &
    inferParsedObject<U[K]>;
}[keyof U];

export type inferRawDiscriminant<D extends string | Discriminant<any, any>> =
  D extends string ? D : D extends Discriminant<infer Raw, any> ? Raw : never;

export type inferParsedDiscriminant<D extends string | Discriminant<any, any>> =
  D extends string
    ? D
    : D extends Discriminant<any, infer Parsed>
    ? Parsed
    : never;
",
                    "name": "types.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import {
  BaseObjectLikeSchema,
  getObjectLikeUtils,
  ObjectLikeSchema,
  OBJECT_LIKE_BRAND,
} from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { Discriminant } from \\"./discriminant\\";
import {
  inferParsedDiscriminant,
  inferParsedUnion,
  inferRawDiscriminant,
  inferRawUnion,
  UnionSubtypes,
} from \\"./types\\";

export function union<
  D extends string | Discriminant<any, any>,
  U extends UnionSubtypes<any>
>(
  discriminant: D,
  union: U
): ObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> {
  const rawDiscriminant =
    typeof discriminant === \\"string\\"
      ? discriminant
      : (discriminant.rawDiscriminant as inferRawDiscriminant<D>);
  const parsedDiscriminant =
    typeof discriminant === \\"string\\"
      ? discriminant
      : (discriminant.parsedDiscriminant as inferParsedDiscriminant<D>);

  const baseSchema: BaseObjectLikeSchema<
    inferRawUnion<D, U>,
    inferParsedUnion<D, U>
  > = {
    ...OBJECT_LIKE_BRAND,

    parse: (raw, opts) => {
      const { [rawDiscriminant]: discriminantValue, ...additionalProperties } =
        raw;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [parsedDiscriminant]: discriminantValue,
        } as inferParsedUnion<D, U>;
      }

      return {
        ...additionalPropertySchemas.parse(additionalProperties, opts),
        [parsedDiscriminant]: discriminantValue,
      } as inferParsedUnion<D, U>;
    },

    json: (parsed, opts) => {
      const {
        [parsedDiscriminant]: discriminantValue,
        ...additionalProperties
      } = parsed;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [rawDiscriminant]: discriminantValue,
        } as unknown as inferRawUnion<D, U>;
      }

      return {
        ...additionalPropertySchemas.json(additionalProperties, opts),
        [rawDiscriminant]: discriminantValue,
      } as inferRawUnion<D, U>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
  };
}
",
                    "name": "union.ts",
                    "type": "file",
                  },
                ],
                "name": "union",
                "type": "directory",
              },
            ],
            "name": "builders",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./builders\\";
export {
  type inferParsed,
  type inferRaw,
  type Schema,
  type SchemaOptions,
} from \\"./Schema\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export type addQuestionMarksToNullableProperties<T> = {
  [K in OptionalKeys<T>]?: undefined extends T[K] ? T[K] : never;
} & Pick<T, RequiredKeys<T>>;

export type OptionalKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? K : never;
}[keyof T];

export type RequiredKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? never : K;
}[keyof T];
",
                "name": "addQuestionMarksToNullableProperties.ts",
                "type": "file",
              },
              Object {
                "contents": "export function entries<T>(object: T): [keyof T, T[keyof T]][] {
  return Object.entries(object) as [keyof T, T[keyof T]][];
}
",
                "name": "entries.ts",
                "type": "file",
              },
              Object {
                "contents": "export function keys<T>(object: T): (keyof T)[] {
  return Object.keys(object) as (keyof T)[];
}
",
                "name": "keys.ts",
                "type": "file",
              },
            ],
            "name": "utils",
            "type": "directory",
          },
        ],
        "name": "schemas",
        "type": "directory",
      },
    ],
    "name": "core",
    "type": "directory",
  },
  Object {
    "contents": "export * as MyApi from \\"./api\\";
",
    "name": "index.ts",
    "type": "file",
  },
  Object {
    "contents": "{
    \\"name\\": \\"@fern-api/my-api-client\\",
    \\"main\\": \\"./index.js\\",
    \\"types\\": \\"./index.d.ts\\",
    \\"files\\": [
        \\"/api\\",
        \\"/schemas\\",
        \\"/core\\",
        \\"!*.ts\\",
        \\"*.d.ts\\"
    ],
    \\"scripts\\": {
        \\"format\\": \\"prettier --write '**/*.ts'\\",
        \\"build\\": \\"esbuild $(find . -name '*.ts' -not -path './node_modules/*') --format=cjs --sourcemap --outdir=. && tsc\\"
    },
    \\"dependencies\\": {
        \\"@types/basic-auth\\": \\"^1.1.3\\",
        \\"@types/url-join\\": \\"4.0.1\\",
        \\"axios\\": \\"^0.27.2\\",
        \\"basic-auth\\": \\"^2.0.1\\",
        \\"js-base64\\": \\"^3.7.2\\",
        \\"url-join\\": \\"4.0.1\\"
    },
    \\"peerDependencies\\": {
        \\"axios\\": \\"*\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"esbuild\\": \\"0.14.47\\",
        \\"prettier\\": \\"2.7.1\\",
        \\"typescript\\": \\"4.6.4\\"
    },
    \\"packageManager\\": \\"yarn@3.2.3\\"
}
",
    "name": "package.json",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "export * as storeTracedTestCaseV2 from \\"./storeTracedTestCaseV2\\";
export * as storeTracedWorkspaceV2 from \\"./storeTracedWorkspaceV2\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  schemas.submission.TraceResponseV2.Raw[],
  MyApi.submission.TraceResponseV2[]
> = core.schemas.list(
  core.schemas.lazyObject(() => schemas.submission.TraceResponseV2)
);
",
                "name": "storeTracedTestCaseV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  schemas.submission.TraceResponseV2.Raw[],
  MyApi.submission.TraceResponseV2[]
> = core.schemas.list(
  core.schemas.lazyObject(() => schemas.submission.TraceResponseV2)
);
",
                "name": "storeTracedWorkspaceV2.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const StoreTracedTestCaseRequest: core.schemas.ObjectSchema<
  StoreTracedTestCaseRequest.Raw,
  MyApi.admin.StoreTracedTestCaseRequest
> = core.schemas.object({
  result: core.schemas.lazyObject(
    () => schemas.submission.TestCaseResultWithStdout
  ),
  traceResponses: core.schemas.list(
    core.schemas.lazyObject(() => schemas.submission.TraceResponse)
  ),
});

export declare namespace StoreTracedTestCaseRequest {
  interface Raw {
    result: schemas.submission.TestCaseResultWithStdout.Raw;
    traceResponses: schemas.submission.TraceResponse.Raw[];
  }
}
",
                "name": "StoreTracedTestCaseRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const StoreTracedWorkspaceRequest: core.schemas.ObjectSchema<
  StoreTracedWorkspaceRequest.Raw,
  MyApi.admin.StoreTracedWorkspaceRequest
> = core.schemas.object({
  workspaceRunDetails: core.schemas.lazyObject(
    () => schemas.submission.WorkspaceRunDetails
  ),
  traceResponses: core.schemas.list(
    core.schemas.lazyObject(() => schemas.submission.TraceResponse)
  ),
});

export declare namespace StoreTracedWorkspaceRequest {
  interface Raw {
    workspaceRunDetails: schemas.submission.WorkspaceRunDetails.Raw;
    traceResponses: schemas.submission.TraceResponse.Raw[];
  }
}
",
                "name": "StoreTracedWorkspaceRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./StoreTracedTestCaseRequest\\";
export * from \\"./StoreTracedWorkspaceRequest\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "admin",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const BinaryTreeNodeAndTreeValue: core.schemas.ObjectSchema<
  BinaryTreeNodeAndTreeValue.Raw,
  MyApi.commons.BinaryTreeNodeAndTreeValue
> = core.schemas.object({
  nodeId: core.schemas.lazy(() => schemas.commons.NodeId),
  fullTree: core.schemas.lazyObject(() => schemas.commons.BinaryTreeValue),
});

export declare namespace BinaryTreeNodeAndTreeValue {
  interface Raw {
    nodeId: schemas.commons.NodeId.Raw;
    fullTree: schemas.commons.BinaryTreeValue.Raw;
  }
}
",
                "name": "BinaryTreeNodeAndTreeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const BinaryTreeNodeValue: core.schemas.ObjectSchema<
  BinaryTreeNodeValue.Raw,
  MyApi.commons.BinaryTreeNodeValue
> = core.schemas.object({
  nodeId: core.schemas.lazy(() => schemas.commons.NodeId),
  val: core.schemas.number(),
  right: core.schemas.lazy(() => schemas.commons.NodeId).optional(),
  left: core.schemas.lazy(() => schemas.commons.NodeId).optional(),
});

export declare namespace BinaryTreeNodeValue {
  interface Raw {
    nodeId: schemas.commons.NodeId.Raw;
    val: number;
    right?: schemas.commons.NodeId.Raw | null;
    left?: schemas.commons.NodeId.Raw | null;
  }
}
",
                "name": "BinaryTreeNodeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const BinaryTreeValue: core.schemas.ObjectSchema<
  BinaryTreeValue.Raw,
  MyApi.commons.BinaryTreeValue
> = core.schemas.object({
  root: core.schemas.lazy(() => schemas.commons.NodeId).optional(),
  nodes: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.commons.BinaryTreeNodeValue)
  ),
});

export declare namespace BinaryTreeValue {
  interface Raw {
    root?: schemas.commons.NodeId.Raw | null;
    nodes: Record<
      schemas.commons.NodeId.Raw,
      schemas.commons.BinaryTreeNodeValue.Raw
    >;
  }
}
",
                "name": "BinaryTreeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const DebugKeyValuePairs: core.schemas.ObjectSchema<
  DebugKeyValuePairs.Raw,
  MyApi.commons.DebugKeyValuePairs
> = core.schemas.object({
  key: core.schemas.lazy(() => schemas.commons.DebugVariableValue),
  value: core.schemas.lazy(() => schemas.commons.DebugVariableValue),
});

export declare namespace DebugKeyValuePairs {
  interface Raw {
    key: schemas.commons.DebugVariableValue.Raw;
    value: schemas.commons.DebugVariableValue.Raw;
  }
}
",
                "name": "DebugKeyValuePairs.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const DebugMapValue: core.schemas.ObjectSchema<
  DebugMapValue.Raw,
  MyApi.commons.DebugMapValue
> = core.schemas.object({
  keyValuePairs: core.schemas.list(
    core.schemas.lazyObject(() => schemas.commons.DebugKeyValuePairs)
  ),
});

export declare namespace DebugMapValue {
  interface Raw {
    keyValuePairs: schemas.commons.DebugKeyValuePairs.Raw[];
  }
}
",
                "name": "DebugMapValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const DebugVariableValue: core.schemas.Schema<
  DebugVariableValue.Raw,
  MyApi.commons.DebugVariableValue
> = core.schemas
  .union(\\"type\\", {
    integerValue: core.schemas.object({
      value: core.schemas.number(),
    }),
    booleanValue: core.schemas.object({
      value: core.schemas.boolean(),
    }),
    doubleValue: core.schemas.object({
      value: core.schemas.number(),
    }),
    stringValue: core.schemas.object({
      value: core.schemas.string(),
    }),
    charValue: core.schemas.object({
      value: core.schemas.string(),
    }),
    mapValue: core.schemas.lazyObject(() => schemas.commons.DebugMapValue),
    listValue: core.schemas.object({
      value: core.schemas.list(
        core.schemas.lazy(() => schemas.commons.DebugVariableValue)
      ),
    }),
    binaryTreeNodeValue: core.schemas.lazyObject(
      () => schemas.commons.BinaryTreeNodeAndTreeValue
    ),
    singlyLinkedListNodeValue: core.schemas.lazyObject(
      () => schemas.commons.SinglyLinkedListNodeAndListValue
    ),
    doublyLinkedListNodeValue: core.schemas.lazyObject(
      () => schemas.commons.DoublyLinkedListNodeAndListValue
    ),
    undefinedValue: core.schemas.object({}),
    nullValue: core.schemas.object({}),
    genericValue: core.schemas.lazyObject(() => schemas.commons.GenericValue),
  })
  .transform<MyApi.commons.DebugVariableValue>({
    parse: (value) => {
      switch (value.type) {
        case \\"integerValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.integerValue(value.value),
          };
        }
        case \\"booleanValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.booleanValue(value.value),
          };
        }
        case \\"doubleValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.doubleValue(value.value),
          };
        }
        case \\"stringValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.stringValue(value.value),
          };
        }
        case \\"charValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.charValue(value.value),
          };
        }
        case \\"mapValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.mapValue(value),
          };
        }
        case \\"listValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.listValue(value.value),
          };
        }
        case \\"binaryTreeNodeValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.binaryTreeNodeValue(value),
          };
        }
        case \\"singlyLinkedListNodeValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.singlyLinkedListNodeValue(value),
          };
        }
        case \\"doublyLinkedListNodeValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.doublyLinkedListNodeValue(value),
          };
        }
        case \\"undefinedValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.undefinedValue(),
          };
        }
        case \\"nullValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.nullValue(),
          };
        }
        case \\"genericValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.genericValue(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace DebugVariableValue {
  type Raw =
    | DebugVariableValue.IntegerValue
    | DebugVariableValue.BooleanValue
    | DebugVariableValue.DoubleValue
    | DebugVariableValue.StringValue
    | DebugVariableValue.CharValue
    | DebugVariableValue.MapValue
    | DebugVariableValue.ListValue
    | DebugVariableValue.BinaryTreeNodeValue
    | DebugVariableValue.SinglyLinkedListNodeValue
    | DebugVariableValue.DoublyLinkedListNodeValue
    | DebugVariableValue.UndefinedValue
    | DebugVariableValue.NullValue
    | DebugVariableValue.GenericValue;

  interface IntegerValue {
    type: \\"integerValue\\";
    value: number;
  }

  interface BooleanValue {
    type: \\"booleanValue\\";
    value: boolean;
  }

  interface DoubleValue {
    type: \\"doubleValue\\";
    value: number;
  }

  interface StringValue {
    type: \\"stringValue\\";
    value: string;
  }

  interface CharValue {
    type: \\"charValue\\";
    value: string;
  }

  interface MapValue extends schemas.commons.DebugMapValue.Raw {
    type: \\"mapValue\\";
  }

  interface ListValue {
    type: \\"listValue\\";
    value: schemas.commons.DebugVariableValue.Raw[];
  }

  interface BinaryTreeNodeValue
    extends schemas.commons.BinaryTreeNodeAndTreeValue.Raw {
    type: \\"binaryTreeNodeValue\\";
  }

  interface SinglyLinkedListNodeValue
    extends schemas.commons.SinglyLinkedListNodeAndListValue.Raw {
    type: \\"singlyLinkedListNodeValue\\";
  }

  interface DoublyLinkedListNodeValue
    extends schemas.commons.DoublyLinkedListNodeAndListValue.Raw {
    type: \\"doublyLinkedListNodeValue\\";
  }

  interface UndefinedValue {
    type: \\"undefinedValue\\";
  }

  interface NullValue {
    type: \\"nullValue\\";
  }

  interface GenericValue extends schemas.commons.GenericValue.Raw {
    type: \\"genericValue\\";
  }
}
",
                "name": "DebugVariableValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const DoublyLinkedListNodeAndListValue: core.schemas.ObjectSchema<
  DoublyLinkedListNodeAndListValue.Raw,
  MyApi.commons.DoublyLinkedListNodeAndListValue
> = core.schemas.object({
  nodeId: core.schemas.lazy(() => schemas.commons.NodeId),
  fullList: core.schemas.lazyObject(
    () => schemas.commons.DoublyLinkedListValue
  ),
});

export declare namespace DoublyLinkedListNodeAndListValue {
  interface Raw {
    nodeId: schemas.commons.NodeId.Raw;
    fullList: schemas.commons.DoublyLinkedListValue.Raw;
  }
}
",
                "name": "DoublyLinkedListNodeAndListValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const DoublyLinkedListNodeValue: core.schemas.ObjectSchema<
  DoublyLinkedListNodeValue.Raw,
  MyApi.commons.DoublyLinkedListNodeValue
> = core.schemas.object({
  nodeId: core.schemas.lazy(() => schemas.commons.NodeId),
  val: core.schemas.number(),
  next: core.schemas.lazy(() => schemas.commons.NodeId).optional(),
  prev: core.schemas.lazy(() => schemas.commons.NodeId).optional(),
});

export declare namespace DoublyLinkedListNodeValue {
  interface Raw {
    nodeId: schemas.commons.NodeId.Raw;
    val: number;
    next?: schemas.commons.NodeId.Raw | null;
    prev?: schemas.commons.NodeId.Raw | null;
  }
}
",
                "name": "DoublyLinkedListNodeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const DoublyLinkedListValue: core.schemas.ObjectSchema<
  DoublyLinkedListValue.Raw,
  MyApi.commons.DoublyLinkedListValue
> = core.schemas.object({
  head: core.schemas.lazy(() => schemas.commons.NodeId).optional(),
  nodes: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.commons.DoublyLinkedListNodeValue)
  ),
});

export declare namespace DoublyLinkedListValue {
  interface Raw {
    head?: schemas.commons.NodeId.Raw | null;
    nodes: Record<
      schemas.commons.NodeId.Raw,
      schemas.commons.DoublyLinkedListNodeValue.Raw
    >;
  }
}
",
                "name": "DoublyLinkedListValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const FileInfo: core.schemas.ObjectSchema<
  FileInfo.Raw,
  MyApi.commons.FileInfo
> = core.schemas.object({
  filename: core.schemas.string(),
  contents: core.schemas.string(),
});

export declare namespace FileInfo {
  interface Raw {
    filename: string;
    contents: string;
  }
}
",
                "name": "FileInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const GenericValue: core.schemas.ObjectSchema<
  GenericValue.Raw,
  MyApi.commons.GenericValue
> = core.schemas.object({
  stringifiedType: core.schemas.string().optional(),
  stringifiedValue: core.schemas.string(),
});

export declare namespace GenericValue {
  interface Raw {
    stringifiedType?: string | null;
    stringifiedValue: string;
  }
}
",
                "name": "GenericValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const KeyValuePair: core.schemas.ObjectSchema<
  KeyValuePair.Raw,
  MyApi.commons.KeyValuePair
> = core.schemas.object({
  key: core.schemas.lazy(() => schemas.commons.VariableValue),
  value: core.schemas.lazy(() => schemas.commons.VariableValue),
});

export declare namespace KeyValuePair {
  interface Raw {
    key: schemas.commons.VariableValue.Raw;
    value: schemas.commons.VariableValue.Raw;
  }
}
",
                "name": "KeyValuePair.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Language: core.schemas.Schema<
  Language.Raw,
  MyApi.commons.Language
> = core.schemas.string().transform<MyApi.commons.Language>({
  parse: (value) => {
    switch (value) {
      case \\"JAVA\\": {
        return MyApi.commons.Language.Java();
      }
      case \\"JAVASCRIPT\\": {
        return MyApi.commons.Language.Javascript();
      }
      case \\"PYTHON\\": {
        return MyApi.commons.Language.Python();
      }
      default: {
        return {
          get: () => value,
          visit: (visitor) => visitor._other(value),
        };
      }
    }
  },
  json: (value) => value.get(),
});

export declare namespace Language {
  type Raw = string;
}
",
                "name": "Language.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const ListType: core.schemas.ObjectSchema<
  ListType.Raw,
  MyApi.commons.ListType
> = core.schemas.object({
  valueType: core.schemas.lazy(() => schemas.commons.VariableType),
  isFixedLength: core.schemas.boolean().optional(),
});

export declare namespace ListType {
  interface Raw {
    valueType: schemas.commons.VariableType.Raw;
    isFixedLength?: boolean | null;
  }
}
",
                "name": "ListType.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const MapType: core.schemas.ObjectSchema<
  MapType.Raw,
  MyApi.commons.MapType
> = core.schemas.object({
  keyType: core.schemas.lazy(() => schemas.commons.VariableType),
  valueType: core.schemas.lazy(() => schemas.commons.VariableType),
});

export declare namespace MapType {
  interface Raw {
    keyType: schemas.commons.VariableType.Raw;
    valueType: schemas.commons.VariableType.Raw;
  }
}
",
                "name": "MapType.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const MapValue: core.schemas.ObjectSchema<
  MapValue.Raw,
  MyApi.commons.MapValue
> = core.schemas.object({
  keyValuePairs: core.schemas.list(
    core.schemas.lazyObject(() => schemas.commons.KeyValuePair)
  ),
});

export declare namespace MapValue {
  interface Raw {
    keyValuePairs: schemas.commons.KeyValuePair.Raw[];
  }
}
",
                "name": "MapValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const NodeId: core.schemas.Schema<NodeId.Raw, MyApi.commons.NodeId> =
  core.schemas.string();

export declare namespace NodeId {
  type Raw = string;
}
",
                "name": "NodeId.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const ProblemId: core.schemas.Schema<
  ProblemId.Raw,
  MyApi.commons.ProblemId
> = core.schemas.string();

export declare namespace ProblemId {
  type Raw = string;
}
",
                "name": "ProblemId.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const SinglyLinkedListNodeAndListValue: core.schemas.ObjectSchema<
  SinglyLinkedListNodeAndListValue.Raw,
  MyApi.commons.SinglyLinkedListNodeAndListValue
> = core.schemas.object({
  nodeId: core.schemas.lazy(() => schemas.commons.NodeId),
  fullList: core.schemas.lazyObject(
    () => schemas.commons.SinglyLinkedListValue
  ),
});

export declare namespace SinglyLinkedListNodeAndListValue {
  interface Raw {
    nodeId: schemas.commons.NodeId.Raw;
    fullList: schemas.commons.SinglyLinkedListValue.Raw;
  }
}
",
                "name": "SinglyLinkedListNodeAndListValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const SinglyLinkedListNodeValue: core.schemas.ObjectSchema<
  SinglyLinkedListNodeValue.Raw,
  MyApi.commons.SinglyLinkedListNodeValue
> = core.schemas.object({
  nodeId: core.schemas.lazy(() => schemas.commons.NodeId),
  val: core.schemas.number(),
  next: core.schemas.lazy(() => schemas.commons.NodeId).optional(),
});

export declare namespace SinglyLinkedListNodeValue {
  interface Raw {
    nodeId: schemas.commons.NodeId.Raw;
    val: number;
    next?: schemas.commons.NodeId.Raw | null;
  }
}
",
                "name": "SinglyLinkedListNodeValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const SinglyLinkedListValue: core.schemas.ObjectSchema<
  SinglyLinkedListValue.Raw,
  MyApi.commons.SinglyLinkedListValue
> = core.schemas.object({
  head: core.schemas.lazy(() => schemas.commons.NodeId).optional(),
  nodes: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.commons.SinglyLinkedListNodeValue)
  ),
});

export declare namespace SinglyLinkedListValue {
  interface Raw {
    head?: schemas.commons.NodeId.Raw | null;
    nodes: Record<
      schemas.commons.NodeId.Raw,
      schemas.commons.SinglyLinkedListNodeValue.Raw
    >;
  }
}
",
                "name": "SinglyLinkedListValue.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TestCase: core.schemas.ObjectSchema<
  TestCase.Raw,
  MyApi.commons.TestCase
> = core.schemas.object({
  id: core.schemas.string(),
  params: core.schemas.list(
    core.schemas.lazy(() => schemas.commons.VariableValue)
  ),
});

export declare namespace TestCase {
  interface Raw {
    id: string;
    params: schemas.commons.VariableValue.Raw[];
  }
}
",
                "name": "TestCase.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TestCaseWithExpectedResult: core.schemas.ObjectSchema<
  TestCaseWithExpectedResult.Raw,
  MyApi.commons.TestCaseWithExpectedResult
> = core.schemas.object({
  testCase: core.schemas.lazyObject(() => schemas.commons.TestCase),
  expectedResult: core.schemas.lazy(() => schemas.commons.VariableValue),
});

export declare namespace TestCaseWithExpectedResult {
  interface Raw {
    testCase: schemas.commons.TestCase.Raw;
    expectedResult: schemas.commons.VariableValue.Raw;
  }
}
",
                "name": "TestCaseWithExpectedResult.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const UserId: core.schemas.Schema<UserId.Raw, MyApi.commons.UserId> =
  core.schemas.string();

export declare namespace UserId {
  type Raw = string;
}
",
                "name": "UserId.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const VariableType: core.schemas.Schema<
  VariableType.Raw,
  MyApi.commons.VariableType
> = core.schemas
  .union(\\"type\\", {
    integerType: core.schemas.object({}),
    doubleType: core.schemas.object({}),
    booleanType: core.schemas.object({}),
    stringType: core.schemas.object({}),
    charType: core.schemas.object({}),
    listType: core.schemas.lazyObject(() => schemas.commons.ListType),
    mapType: core.schemas.lazyObject(() => schemas.commons.MapType),
    binaryTreeType: core.schemas.object({}),
    singlyLinkedListType: core.schemas.object({}),
    doublyLinkedListType: core.schemas.object({}),
  })
  .transform<MyApi.commons.VariableType>({
    parse: (value) => {
      switch (value.type) {
        case \\"integerType\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.integerType(),
          };
        }
        case \\"doubleType\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.doubleType(),
          };
        }
        case \\"booleanType\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.booleanType(),
          };
        }
        case \\"stringType\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.stringType(),
          };
        }
        case \\"charType\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.charType(),
          };
        }
        case \\"listType\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.listType(value),
          };
        }
        case \\"mapType\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.mapType(value),
          };
        }
        case \\"binaryTreeType\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.binaryTreeType(),
          };
        }
        case \\"singlyLinkedListType\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.singlyLinkedListType(),
          };
        }
        case \\"doublyLinkedListType\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.doublyLinkedListType(),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace VariableType {
  type Raw =
    | VariableType.IntegerType
    | VariableType.DoubleType
    | VariableType.BooleanType
    | VariableType.StringType
    | VariableType.CharType
    | VariableType.ListType
    | VariableType.MapType
    | VariableType.BinaryTreeType
    | VariableType.SinglyLinkedListType
    | VariableType.DoublyLinkedListType;

  interface IntegerType {
    type: \\"integerType\\";
  }

  interface DoubleType {
    type: \\"doubleType\\";
  }

  interface BooleanType {
    type: \\"booleanType\\";
  }

  interface StringType {
    type: \\"stringType\\";
  }

  interface CharType {
    type: \\"charType\\";
  }

  interface ListType extends schemas.commons.ListType.Raw {
    type: \\"listType\\";
  }

  interface MapType extends schemas.commons.MapType.Raw {
    type: \\"mapType\\";
  }

  interface BinaryTreeType {
    type: \\"binaryTreeType\\";
  }

  interface SinglyLinkedListType {
    type: \\"singlyLinkedListType\\";
  }

  interface DoublyLinkedListType {
    type: \\"doublyLinkedListType\\";
  }
}
",
                "name": "VariableType.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const VariableValue: core.schemas.Schema<
  VariableValue.Raw,
  MyApi.commons.VariableValue
> = core.schemas
  .union(\\"type\\", {
    integerValue: core.schemas.object({
      value: core.schemas.number(),
    }),
    booleanValue: core.schemas.object({
      value: core.schemas.boolean(),
    }),
    doubleValue: core.schemas.object({
      value: core.schemas.number(),
    }),
    stringValue: core.schemas.object({
      value: core.schemas.string(),
    }),
    charValue: core.schemas.object({
      value: core.schemas.string(),
    }),
    mapValue: core.schemas.lazyObject(() => schemas.commons.MapValue),
    listValue: core.schemas.object({
      value: core.schemas.list(
        core.schemas.lazy(() => schemas.commons.VariableValue)
      ),
    }),
    binaryTreeValue: core.schemas.lazyObject(
      () => schemas.commons.BinaryTreeValue
    ),
    singlyLinkedListValue: core.schemas.lazyObject(
      () => schemas.commons.SinglyLinkedListValue
    ),
    doublyLinkedListValue: core.schemas.lazyObject(
      () => schemas.commons.DoublyLinkedListValue
    ),
    nullValue: core.schemas.object({}),
  })
  .transform<MyApi.commons.VariableValue>({
    parse: (value) => {
      switch (value.type) {
        case \\"integerValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.integerValue(value.value),
          };
        }
        case \\"booleanValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.booleanValue(value.value),
          };
        }
        case \\"doubleValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.doubleValue(value.value),
          };
        }
        case \\"stringValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.stringValue(value.value),
          };
        }
        case \\"charValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.charValue(value.value),
          };
        }
        case \\"mapValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.mapValue(value),
          };
        }
        case \\"listValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.listValue(value.value),
          };
        }
        case \\"binaryTreeValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.binaryTreeValue(value),
          };
        }
        case \\"singlyLinkedListValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.singlyLinkedListValue(value),
          };
        }
        case \\"doublyLinkedListValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.doublyLinkedListValue(value),
          };
        }
        case \\"nullValue\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.nullValue(),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace VariableValue {
  type Raw =
    | VariableValue.IntegerValue
    | VariableValue.BooleanValue
    | VariableValue.DoubleValue
    | VariableValue.StringValue
    | VariableValue.CharValue
    | VariableValue.MapValue
    | VariableValue.ListValue
    | VariableValue.BinaryTreeValue
    | VariableValue.SinglyLinkedListValue
    | VariableValue.DoublyLinkedListValue
    | VariableValue.NullValue;

  interface IntegerValue {
    type: \\"integerValue\\";
    value: number;
  }

  interface BooleanValue {
    type: \\"booleanValue\\";
    value: boolean;
  }

  interface DoubleValue {
    type: \\"doubleValue\\";
    value: number;
  }

  interface StringValue {
    type: \\"stringValue\\";
    value: string;
  }

  interface CharValue {
    type: \\"charValue\\";
    value: string;
  }

  interface MapValue extends schemas.commons.MapValue.Raw {
    type: \\"mapValue\\";
  }

  interface ListValue {
    type: \\"listValue\\";
    value: schemas.commons.VariableValue.Raw[];
  }

  interface BinaryTreeValue extends schemas.commons.BinaryTreeValue.Raw {
    type: \\"binaryTreeValue\\";
  }

  interface SinglyLinkedListValue
    extends schemas.commons.SinglyLinkedListValue.Raw {
    type: \\"singlyLinkedListValue\\";
  }

  interface DoublyLinkedListValue
    extends schemas.commons.DoublyLinkedListValue.Raw {
    type: \\"doublyLinkedListValue\\";
  }

  interface NullValue {
    type: \\"nullValue\\";
  }
}
",
                "name": "VariableValue.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./UserId\\";
export * from \\"./ProblemId\\";
export * from \\"./NodeId\\";
export * from \\"./VariableType\\";
export * from \\"./ListType\\";
export * from \\"./MapType\\";
export * from \\"./VariableValue\\";
export * from \\"./DebugVariableValue\\";
export * from \\"./GenericValue\\";
export * from \\"./MapValue\\";
export * from \\"./KeyValuePair\\";
export * from \\"./BinaryTreeValue\\";
export * from \\"./BinaryTreeNodeValue\\";
export * from \\"./BinaryTreeNodeAndTreeValue\\";
export * from \\"./SinglyLinkedListValue\\";
export * from \\"./SinglyLinkedListNodeValue\\";
export * from \\"./SinglyLinkedListNodeAndListValue\\";
export * from \\"./DoublyLinkedListValue\\";
export * from \\"./DoublyLinkedListNodeValue\\";
export * from \\"./DoublyLinkedListNodeAndListValue\\";
export * from \\"./DebugMapValue\\";
export * from \\"./DebugKeyValuePairs\\";
export * from \\"./TestCase\\";
export * from \\"./TestCaseWithExpectedResult\\";
export * from \\"./FileInfo\\";
export * from \\"./Language\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "commons",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  schemas.commons.ProblemId.Raw[],
  MyApi.commons.ProblemId[]
> = core.schemas.list(core.schemas.lazy(() => schemas.commons.ProblemId));
",
                "name": "getHomepageProblems.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as getHomepageProblems from \\"./getHomepageProblems\\";
export * as setHomepageProblems from \\"./setHomepageProblems\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  schemas.commons.ProblemId.Raw[],
  MyApi.commons.ProblemId[]
> = core.schemas.list(core.schemas.lazy(() => schemas.commons.ProblemId));
",
                "name": "setHomepageProblems.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "homepage",
        "type": "directory",
      },
      Object {
        "contents": "export * as admin from \\"./admin\\";
export * from \\"./admin/types\\";
export * as commons from \\"./commons\\";
export * from \\"./commons/types\\";
export * as langServer from \\"./lang-server\\";
export * from \\"./lang-server/types\\";
export * as migration from \\"./migration\\";
export * from \\"./migration/types\\";
export * as playlist from \\"./playlist\\";
export * from \\"./playlist/types\\";
export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as submission from \\"./submission\\";
export * from \\"./submission/types\\";
export * as v2 from \\"./v2\\";
export * from \\"./playlist/errors\\";
export * as homepage from \\"./homepage\\";
export * as sysprop from \\"./sysprop\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const LangServerRequest: core.schemas.ObjectSchema<
  LangServerRequest.Raw,
  MyApi.langServer.LangServerRequest
> = core.schemas.object({
  request: core.schemas.unknown(),
});

export declare namespace LangServerRequest {
  interface Raw {
    request?: unknown;
  }
}
",
                "name": "LangServerRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const LangServerResponse: core.schemas.ObjectSchema<
  LangServerResponse.Raw,
  MyApi.langServer.LangServerResponse
> = core.schemas.object({
  response: core.schemas.unknown(),
});

export declare namespace LangServerResponse {
  interface Raw {
    response?: unknown;
  }
}
",
                "name": "LangServerResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./LangServerRequest\\";
export * from \\"./LangServerResponse\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "lang-server",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  schemas.migration.Migration.Raw[],
  MyApi.migration.Migration[]
> = core.schemas.list(
  core.schemas.lazyObject(() => schemas.migration.Migration)
);
",
                "name": "getAttemptedMigrations.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as getAttemptedMigrations from \\"./getAttemptedMigrations\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const Migration: core.schemas.ObjectSchema<
  Migration.Raw,
  MyApi.migration.Migration
> = core.schemas.object({
  name: core.schemas.string(),
  status: core.schemas.lazy(() => schemas.migration.MigrationStatus),
});

export declare namespace Migration {
  interface Raw {
    name: string;
    status: schemas.migration.MigrationStatus.Raw;
  }
}
",
                "name": "Migration.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const MigrationStatus: core.schemas.Schema<
  MigrationStatus.Raw,
  MyApi.migration.MigrationStatus
> = core.schemas.string().transform<MyApi.migration.MigrationStatus>({
  parse: (value) => {
    switch (value) {
      case \\"RUNNING\\": {
        return MyApi.migration.MigrationStatus.Running();
      }
      case \\"FAILED\\": {
        return MyApi.migration.MigrationStatus.Failed();
      }
      case \\"FINISHED\\": {
        return MyApi.migration.MigrationStatus.Finished();
      }
      default: {
        return {
          get: () => value,
          visit: (visitor) => visitor._other(value),
        };
      }
    }
  },
  json: (value) => value.get(),
});

export declare namespace MigrationStatus {
  type Raw = string;
}
",
                "name": "MigrationStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./MigrationStatus\\";
export * from \\"./Migration\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "migration",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const Error: core.schemas.Schema<
  Error.Raw,
  MyApi.playlist.getPlaylist.Error
> = core.schemas
  .union(\\"errorName\\", {
    PlaylistIdNotFoundError: core.schemas.object({
      content: schemas.playlist.PlaylistIdNotFoundError,
    }),
    UnauthorizedError: core.schemas.object({}),
  })
  .transform<MyApi.playlist.getPlaylist.Error>({
    parse: (value) => {
      switch (value.errorName) {
        case \\"PlaylistIdNotFoundError\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.playlistIdNotFoundError(value.content),
          };
        }
        case \\"UnauthorizedError\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.unauthorizedError(),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace Error {
  type Raw = Error.PlaylistIdNotFoundError | Error.UnauthorizedError;

  interface PlaylistIdNotFoundError {
    errorName: \\"PlaylistIdNotFoundError\\";
    content: schemas.playlist.PlaylistIdNotFoundError.Raw;
  }

  interface UnauthorizedError {
    errorName: \\"UnauthorizedError\\";
  }
}
",
                "name": "getPlaylist.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  schemas.playlist.Playlist.Raw[],
  MyApi.playlist.Playlist[]
> = core.schemas.list(core.schemas.lazyObject(() => schemas.playlist.Playlist));
",
                "name": "getPlaylists.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as getPlaylists from \\"./getPlaylists\\";
export * as getPlaylist from \\"./getPlaylist\\";
export * as updatePlaylist from \\"./updatePlaylist\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": "import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  schemas.playlist.UpdatePlaylistRequest.Raw | null | undefined,
  MyApi.playlist.UpdatePlaylistRequest | undefined
> = core.schemas
  .lazyObject(() => schemas.playlist.UpdatePlaylistRequest)
  .optional();
export const Response: core.schemas.Schema<
  schemas.playlist.Playlist.Raw | null | undefined,
  MyApi.playlist.Playlist | undefined
> = core.schemas.lazyObject(() => schemas.playlist.Playlist).optional();
export const Error: core.schemas.Schema<
  Error.Raw,
  MyApi.playlist.updatePlaylist.Error
> = core.schemas
  .union(\\"errorName\\", {
    PlaylistIdNotFoundError: core.schemas.object({
      content: schemas.playlist.PlaylistIdNotFoundError,
    }),
  })
  .transform<MyApi.playlist.updatePlaylist.Error>({
    parse: (value) => {
      switch (value.errorName) {
        case \\"PlaylistIdNotFoundError\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.playlistIdNotFoundError(value.content),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace Error {
  type Raw = Error.PlaylistIdNotFoundError;

  interface PlaylistIdNotFoundError {
    errorName: \\"PlaylistIdNotFoundError\\";
    content: schemas.playlist.PlaylistIdNotFoundError.Raw;
  }
}
",
                "name": "updatePlaylist.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const PlaylistIdNotFoundError: core.schemas.Schema<
  PlaylistIdNotFoundError.Raw,
  MyApi.playlist.PlaylistIdNotFoundError
> = core.schemas
  .union(\\"type\\", {
    playlistId: core.schemas.object({
      value: core.schemas.lazy(() => schemas.playlist.PlaylistId),
    }),
  })
  .transform<MyApi.playlist.PlaylistIdNotFoundError>({
    parse: (value) => {
      switch (value.type) {
        case \\"playlistId\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.playlistId(value.value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace PlaylistIdNotFoundError {
  type Raw = PlaylistIdNotFoundError.PlaylistId;

  interface PlaylistId {
    type: \\"playlistId\\";
    value: schemas.playlist.PlaylistId.Raw;
  }
}
",
                "name": "PlaylistIdNotFoundError.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./PlaylistIdNotFoundError\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "errors",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./errors\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const Playlist: core.schemas.ObjectSchema<
  Playlist.Raw,
  MyApi.playlist.Playlist
> = core.schemas.object({
  playlistId: core.schemas.property(
    \\"playlist_id\\",
    core.schemas.lazy(() => schemas.playlist.PlaylistId)
  ),
  name: core.schemas.string(),
  problems: core.schemas.list(
    core.schemas.lazy(() => schemas.commons.ProblemId)
  ),
  ownerId: core.schemas.property(
    \\"owner-id\\",
    core.schemas.lazy(() => schemas.commons.UserId)
  ),
});

export declare namespace Playlist {
  interface Raw {
    playlist_id: schemas.playlist.PlaylistId.Raw;
    name: string;
    problems: schemas.commons.ProblemId.Raw[];
    \\"owner-id\\": schemas.commons.UserId.Raw;
  }
}
",
                "name": "Playlist.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const PlaylistCreateRequest: core.schemas.ObjectSchema<
  PlaylistCreateRequest.Raw,
  MyApi.playlist.PlaylistCreateRequest
> = core.schemas.object({
  name: core.schemas.string(),
  problems: core.schemas.list(
    core.schemas.lazy(() => schemas.commons.ProblemId)
  ),
});

export declare namespace PlaylistCreateRequest {
  interface Raw {
    name: string;
    problems: schemas.commons.ProblemId.Raw[];
  }
}
",
                "name": "PlaylistCreateRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const PlaylistId: core.schemas.Schema<
  PlaylistId.Raw,
  MyApi.playlist.PlaylistId
> = core.schemas.string();

export declare namespace PlaylistId {
  type Raw = string;
}
",
                "name": "PlaylistId.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const UpdatePlaylistRequest: core.schemas.ObjectSchema<
  UpdatePlaylistRequest.Raw,
  MyApi.playlist.UpdatePlaylistRequest
> = core.schemas.object({
  name: core.schemas.string(),
  problems: core.schemas.list(
    core.schemas.lazy(() => schemas.commons.ProblemId)
  ),
});

export declare namespace UpdatePlaylistRequest {
  interface Raw {
    name: string;
    problems: schemas.commons.ProblemId.Raw[];
  }
}
",
                "name": "UpdatePlaylistRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./PlaylistId\\";
export * from \\"./Playlist\\";
export * from \\"./PlaylistCreateRequest\\";
export * from \\"./UpdatePlaylistRequest\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "playlist",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * from \\"./types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const CreateProblemError: core.schemas.Schema<
  CreateProblemError.Raw,
  MyApi.problem.CreateProblemError
> = core.schemas
  .union(core.schemas.discriminant(\\"errorType\\", \\"_type\\"), {
    generic: core.schemas.lazyObject(
      () => schemas.problem.GenericCreateProblemError
    ),
  })
  .transform<MyApi.problem.CreateProblemError>({
    parse: (value) => {
      switch (value.errorType) {
        case \\"generic\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.generic(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace CreateProblemError {
  type Raw = CreateProblemError.Generic;

  interface Generic extends schemas.problem.GenericCreateProblemError.Raw {
    _type: \\"generic\\";
  }
}
",
                "name": "CreateProblemError.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const CreateProblemRequest: core.schemas.ObjectSchema<
  CreateProblemRequest.Raw,
  MyApi.problem.CreateProblemRequest
> = core.schemas.object({
  problemName: core.schemas.string(),
  problemDescription: core.schemas.lazyObject(
    () => schemas.problem.ProblemDescription
  ),
  files: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.problem.ProblemFiles)
  ),
  inputParams: core.schemas.list(
    core.schemas.lazyObject(() => schemas.problem.VariableTypeAndName)
  ),
  outputType: core.schemas.lazy(() => schemas.commons.VariableType),
  testcases: core.schemas.list(
    core.schemas.lazyObject(() => schemas.commons.TestCaseWithExpectedResult)
  ),
  methodName: core.schemas.string(),
});

export declare namespace CreateProblemRequest {
  interface Raw {
    problemName: string;
    problemDescription: schemas.problem.ProblemDescription.Raw;
    files: Record<
      schemas.commons.Language.Raw,
      schemas.problem.ProblemFiles.Raw
    >;
    inputParams: schemas.problem.VariableTypeAndName.Raw[];
    outputType: schemas.commons.VariableType.Raw;
    testcases: schemas.commons.TestCaseWithExpectedResult.Raw[];
    methodName: string;
  }
}
",
                "name": "CreateProblemRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const CreateProblemResponse: core.schemas.Schema<
  CreateProblemResponse.Raw,
  MyApi.problem.CreateProblemResponse
> = core.schemas
  .union(\\"type\\", {
    success: core.schemas.object({
      value: core.schemas.lazy(() => schemas.commons.ProblemId),
    }),
    error: core.schemas.object({
      value: core.schemas.lazy(() => schemas.problem.CreateProblemError),
    }),
  })
  .transform<MyApi.problem.CreateProblemResponse>({
    parse: (value) => {
      switch (value.type) {
        case \\"success\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.success(value.value),
          };
        }
        case \\"error\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.error(value.value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace CreateProblemResponse {
  type Raw = CreateProblemResponse.Success | CreateProblemResponse.Error;

  interface Success {
    type: \\"success\\";
    value: schemas.commons.ProblemId.Raw;
  }

  interface Error {
    type: \\"error\\";
    value: schemas.problem.CreateProblemError.Raw;
  }
}
",
                "name": "CreateProblemResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const GenericCreateProblemError: core.schemas.ObjectSchema<
  GenericCreateProblemError.Raw,
  MyApi.problem.GenericCreateProblemError
> = core.schemas.object({
  message: core.schemas.string(),
  type: core.schemas.string(),
  stacktrace: core.schemas.string(),
});

export declare namespace GenericCreateProblemError {
  interface Raw {
    message: string;
    type: string;
    stacktrace: string;
  }
}
",
                "name": "GenericCreateProblemError.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const GetDefaultStarterFilesRequest: core.schemas.ObjectSchema<
  GetDefaultStarterFilesRequest.Raw,
  MyApi.problem.GetDefaultStarterFilesRequest
> = core.schemas.object({
  inputParams: core.schemas.list(
    core.schemas.lazyObject(() => schemas.problem.VariableTypeAndName)
  ),
  outputType: core.schemas.lazy(() => schemas.commons.VariableType),
  methodName: core.schemas.string(),
});

export declare namespace GetDefaultStarterFilesRequest {
  interface Raw {
    inputParams: schemas.problem.VariableTypeAndName.Raw[];
    outputType: schemas.commons.VariableType.Raw;
    methodName: string;
  }
}
",
                "name": "GetDefaultStarterFilesRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const GetDefaultStarterFilesResponse: core.schemas.ObjectSchema<
  GetDefaultStarterFilesResponse.Raw,
  MyApi.problem.GetDefaultStarterFilesResponse
> = core.schemas.object({
  files: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.problem.ProblemFiles)
  ),
});

export declare namespace GetDefaultStarterFilesResponse {
  interface Raw {
    files: Record<
      schemas.commons.Language.Raw,
      schemas.problem.ProblemFiles.Raw
    >;
  }
}
",
                "name": "GetDefaultStarterFilesResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const ProblemDescription: core.schemas.ObjectSchema<
  ProblemDescription.Raw,
  MyApi.problem.ProblemDescription
> = core.schemas.object({
  boards: core.schemas.list(
    core.schemas.lazy(() => schemas.problem.ProblemDescriptionBoard)
  ),
});

export declare namespace ProblemDescription {
  interface Raw {
    boards: schemas.problem.ProblemDescriptionBoard.Raw[];
  }
}
",
                "name": "ProblemDescription.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const ProblemDescriptionBoard: core.schemas.Schema<
  ProblemDescriptionBoard.Raw,
  MyApi.problem.ProblemDescriptionBoard
> = core.schemas
  .union(\\"type\\", {
    html: core.schemas.object({
      value: core.schemas.string(),
    }),
    variable: core.schemas.object({
      value: core.schemas.lazy(() => schemas.commons.VariableValue),
    }),
    testCaseId: core.schemas.object({
      value: core.schemas.string(),
    }),
  })
  .transform<MyApi.problem.ProblemDescriptionBoard>({
    parse: (value) => {
      switch (value.type) {
        case \\"html\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.html(value.value),
          };
        }
        case \\"variable\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.variable(value.value),
          };
        }
        case \\"testCaseId\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.testCaseId(value.value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace ProblemDescriptionBoard {
  type Raw =
    | ProblemDescriptionBoard.Html
    | ProblemDescriptionBoard.Variable
    | ProblemDescriptionBoard.TestCaseId;

  interface Html {
    type: \\"html\\";
    value: string;
  }

  interface Variable {
    type: \\"variable\\";
    value: schemas.commons.VariableValue.Raw;
  }

  interface TestCaseId {
    type: \\"testCaseId\\";
    value: string;
  }
}
",
                "name": "ProblemDescriptionBoard.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const ProblemFiles: core.schemas.ObjectSchema<
  ProblemFiles.Raw,
  MyApi.problem.ProblemFiles
> = core.schemas.object({
  solutionFile: core.schemas.lazyObject(() => schemas.commons.FileInfo),
  readOnlyFiles: core.schemas.list(
    core.schemas.lazyObject(() => schemas.commons.FileInfo)
  ),
});

export declare namespace ProblemFiles {
  interface Raw {
    solutionFile: schemas.commons.FileInfo.Raw;
    readOnlyFiles: schemas.commons.FileInfo.Raw[];
  }
}
",
                "name": "ProblemFiles.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const ProblemInfo: core.schemas.ObjectSchema<
  ProblemInfo.Raw,
  MyApi.problem.ProblemInfo
> = core.schemas.object({
  problemId: core.schemas.lazy(() => schemas.commons.ProblemId),
  problemDescription: core.schemas.lazyObject(
    () => schemas.problem.ProblemDescription
  ),
  problemName: core.schemas.string(),
  problemVersion: core.schemas.number(),
  files: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.problem.ProblemFiles)
  ),
  inputParams: core.schemas.list(
    core.schemas.lazyObject(() => schemas.problem.VariableTypeAndName)
  ),
  outputType: core.schemas.lazy(() => schemas.commons.VariableType),
  testcases: core.schemas.list(
    core.schemas.lazyObject(() => schemas.commons.TestCaseWithExpectedResult)
  ),
  methodName: core.schemas.string(),
  supportsCustomTestCases: core.schemas.boolean(),
});

export declare namespace ProblemInfo {
  interface Raw {
    problemId: schemas.commons.ProblemId.Raw;
    problemDescription: schemas.problem.ProblemDescription.Raw;
    problemName: string;
    problemVersion: number;
    files: Record<
      schemas.commons.Language.Raw,
      schemas.problem.ProblemFiles.Raw
    >;
    inputParams: schemas.problem.VariableTypeAndName.Raw[];
    outputType: schemas.commons.VariableType.Raw;
    testcases: schemas.commons.TestCaseWithExpectedResult.Raw[];
    methodName: string;
    supportsCustomTestCases: boolean;
  }
}
",
                "name": "ProblemInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const UpdateProblemResponse: core.schemas.ObjectSchema<
  UpdateProblemResponse.Raw,
  MyApi.problem.UpdateProblemResponse
> = core.schemas.object({
  problemVersion: core.schemas.number(),
});

export declare namespace UpdateProblemResponse {
  interface Raw {
    problemVersion: number;
  }
}
",
                "name": "UpdateProblemResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const VariableTypeAndName: core.schemas.ObjectSchema<
  VariableTypeAndName.Raw,
  MyApi.problem.VariableTypeAndName
> = core.schemas.object({
  variableType: core.schemas.lazy(() => schemas.commons.VariableType),
  name: core.schemas.string(),
});

export declare namespace VariableTypeAndName {
  interface Raw {
    variableType: schemas.commons.VariableType.Raw;
    name: string;
  }
}
",
                "name": "VariableTypeAndName.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./ProblemInfo\\";
export * from \\"./ProblemDescription\\";
export * from \\"./ProblemDescriptionBoard\\";
export * from \\"./ProblemFiles\\";
export * from \\"./VariableTypeAndName\\";
export * from \\"./CreateProblemRequest\\";
export * from \\"./CreateProblemResponse\\";
export * from \\"./UpdateProblemResponse\\";
export * from \\"./CreateProblemError\\";
export * from \\"./GenericCreateProblemError\\";
export * from \\"./GetDefaultStarterFilesRequest\\";
export * from \\"./GetDefaultStarterFilesResponse\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "problem",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  schemas.submission.ExecutionSessionResponse.Raw | null | undefined,
  MyApi.submission.ExecutionSessionResponse | undefined
> = core.schemas
  .lazyObject(() => schemas.submission.ExecutionSessionResponse)
  .optional();
",
                "name": "getExecutionSession.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as getExecutionSession from \\"./getExecutionSession\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const ActualResult: core.schemas.Schema<
  ActualResult.Raw,
  MyApi.submission.ActualResult
> = core.schemas
  .union(\\"type\\", {
    value: core.schemas.object({
      value: core.schemas.lazy(() => schemas.commons.VariableValue),
    }),
    exception: core.schemas.lazyObject(() => schemas.submission.ExceptionInfo),
    exceptionV2: core.schemas.object({
      value: core.schemas.lazy(() => schemas.submission.ExceptionV2),
    }),
  })
  .transform<MyApi.submission.ActualResult>({
    parse: (value) => {
      switch (value.type) {
        case \\"value\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.value(value.value),
          };
        }
        case \\"exception\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.exception(value),
          };
        }
        case \\"exceptionV2\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.exceptionV2(value.value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace ActualResult {
  type Raw =
    | ActualResult.Value
    | ActualResult.Exception
    | ActualResult.ExceptionV2;

  interface Value {
    type: \\"value\\";
    value: schemas.commons.VariableValue.Raw;
  }

  interface Exception extends schemas.submission.ExceptionInfo.Raw {
    type: \\"exception\\";
  }

  interface ExceptionV2 {
    type: \\"exceptionV2\\";
    value: schemas.submission.ExceptionV2.Raw;
  }
}
",
                "name": "ActualResult.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const BuildingExecutorResponse: core.schemas.ObjectSchema<
  BuildingExecutorResponse.Raw,
  MyApi.submission.BuildingExecutorResponse
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
  status: core.schemas.lazy(() => schemas.submission.ExecutionSessionStatus),
});

export declare namespace BuildingExecutorResponse {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
    status: schemas.submission.ExecutionSessionStatus.Raw;
  }
}
",
                "name": "BuildingExecutorResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const CodeExecutionUpdate: core.schemas.Schema<
  CodeExecutionUpdate.Raw,
  MyApi.submission.CodeExecutionUpdate
> = core.schemas
  .union(\\"type\\", {
    buildingExecutor: core.schemas.lazyObject(
      () => schemas.submission.BuildingExecutorResponse
    ),
    running: core.schemas.lazyObject(() => schemas.submission.RunningResponse),
    errored: core.schemas.lazyObject(() => schemas.submission.ErroredResponse),
    stopped: core.schemas.lazyObject(() => schemas.submission.StoppedResponse),
    graded: core.schemas.lazyObject(() => schemas.submission.GradedResponse),
    gradedV2: core.schemas.lazyObject(
      () => schemas.submission.GradedResponseV2
    ),
    workspaceRan: core.schemas.lazyObject(
      () => schemas.submission.WorkspaceRanResponse
    ),
    recording: core.schemas.lazyObject(
      () => schemas.submission.RecordingResponseNotification
    ),
    recorded: core.schemas.lazyObject(
      () => schemas.submission.RecordedResponseNotification
    ),
    invalidRequest: core.schemas.lazyObject(
      () => schemas.submission.InvalidRequestResponse
    ),
    finished: core.schemas.lazyObject(
      () => schemas.submission.FinishedResponse
    ),
  })
  .transform<MyApi.submission.CodeExecutionUpdate>({
    parse: (value) => {
      switch (value.type) {
        case \\"buildingExecutor\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.buildingExecutor(value),
          };
        }
        case \\"running\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.running(value),
          };
        }
        case \\"errored\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.errored(value),
          };
        }
        case \\"stopped\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.stopped(value),
          };
        }
        case \\"graded\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.graded(value),
          };
        }
        case \\"gradedV2\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.gradedV2(value),
          };
        }
        case \\"workspaceRan\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.workspaceRan(value),
          };
        }
        case \\"recording\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.recording(value),
          };
        }
        case \\"recorded\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.recorded(value),
          };
        }
        case \\"invalidRequest\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.invalidRequest(value),
          };
        }
        case \\"finished\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.finished(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace CodeExecutionUpdate {
  type Raw =
    | CodeExecutionUpdate.BuildingExecutor
    | CodeExecutionUpdate.Running
    | CodeExecutionUpdate.Errored
    | CodeExecutionUpdate.Stopped
    | CodeExecutionUpdate.Graded
    | CodeExecutionUpdate.GradedV2
    | CodeExecutionUpdate.WorkspaceRan
    | CodeExecutionUpdate.Recording
    | CodeExecutionUpdate.Recorded
    | CodeExecutionUpdate.InvalidRequest
    | CodeExecutionUpdate.Finished;

  interface BuildingExecutor
    extends schemas.submission.BuildingExecutorResponse.Raw {
    type: \\"buildingExecutor\\";
  }

  interface Running extends schemas.submission.RunningResponse.Raw {
    type: \\"running\\";
  }

  interface Errored extends schemas.submission.ErroredResponse.Raw {
    type: \\"errored\\";
  }

  interface Stopped extends schemas.submission.StoppedResponse.Raw {
    type: \\"stopped\\";
  }

  interface Graded extends schemas.submission.GradedResponse.Raw {
    type: \\"graded\\";
  }

  interface GradedV2 extends schemas.submission.GradedResponseV2.Raw {
    type: \\"gradedV2\\";
  }

  interface WorkspaceRan extends schemas.submission.WorkspaceRanResponse.Raw {
    type: \\"workspaceRan\\";
  }

  interface Recording
    extends schemas.submission.RecordingResponseNotification.Raw {
    type: \\"recording\\";
  }

  interface Recorded
    extends schemas.submission.RecordedResponseNotification.Raw {
    type: \\"recorded\\";
  }

  interface InvalidRequest
    extends schemas.submission.InvalidRequestResponse.Raw {
    type: \\"invalidRequest\\";
  }

  interface Finished extends schemas.submission.FinishedResponse.Raw {
    type: \\"finished\\";
  }
}
",
                "name": "CodeExecutionUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const CompileError: core.schemas.ObjectSchema<
  CompileError.Raw,
  MyApi.submission.CompileError
> = core.schemas.object({
  message: core.schemas.string(),
});

export declare namespace CompileError {
  interface Raw {
    message: string;
  }
}
",
                "name": "CompileError.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const CustomTestCasesUnsupported: core.schemas.ObjectSchema<
  CustomTestCasesUnsupported.Raw,
  MyApi.submission.CustomTestCasesUnsupported
> = core.schemas.object({
  problemId: core.schemas.lazy(() => schemas.commons.ProblemId),
  submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
});

export declare namespace CustomTestCasesUnsupported {
  interface Raw {
    problemId: schemas.commons.ProblemId.Raw;
    submissionId: schemas.submission.SubmissionId.Raw;
  }
}
",
                "name": "CustomTestCasesUnsupported.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const ErrorInfo: core.schemas.Schema<
  ErrorInfo.Raw,
  MyApi.submission.ErrorInfo
> = core.schemas
  .union(\\"type\\", {
    compileError: core.schemas.lazyObject(
      () => schemas.submission.CompileError
    ),
    runtimeError: core.schemas.lazyObject(
      () => schemas.submission.RuntimeError
    ),
    internalError: core.schemas.lazyObject(
      () => schemas.submission.InternalError
    ),
  })
  .transform<MyApi.submission.ErrorInfo>({
    parse: (value) => {
      switch (value.type) {
        case \\"compileError\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.compileError(value),
          };
        }
        case \\"runtimeError\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.runtimeError(value),
          };
        }
        case \\"internalError\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.internalError(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace ErrorInfo {
  type Raw =
    | ErrorInfo.CompileError
    | ErrorInfo.RuntimeError
    | ErrorInfo.InternalError;

  interface CompileError extends schemas.submission.CompileError.Raw {
    type: \\"compileError\\";
  }

  interface RuntimeError extends schemas.submission.RuntimeError.Raw {
    type: \\"runtimeError\\";
  }

  interface InternalError extends schemas.submission.InternalError.Raw {
    type: \\"internalError\\";
  }
}
",
                "name": "ErrorInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const ErroredResponse: core.schemas.ObjectSchema<
  ErroredResponse.Raw,
  MyApi.submission.ErroredResponse
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
  errorInfo: core.schemas.lazy(() => schemas.submission.ErrorInfo),
});

export declare namespace ErroredResponse {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
    errorInfo: schemas.submission.ErrorInfo.Raw;
  }
}
",
                "name": "ErroredResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const ExceptionInfo: core.schemas.ObjectSchema<
  ExceptionInfo.Raw,
  MyApi.submission.ExceptionInfo
> = core.schemas.object({
  exceptionType: core.schemas.string(),
  exceptionMessage: core.schemas.string(),
  exceptionStacktrace: core.schemas.string(),
});

export declare namespace ExceptionInfo {
  interface Raw {
    exceptionType: string;
    exceptionMessage: string;
    exceptionStacktrace: string;
  }
}
",
                "name": "ExceptionInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const ExceptionV2: core.schemas.Schema<
  ExceptionV2.Raw,
  MyApi.submission.ExceptionV2
> = core.schemas
  .union(\\"type\\", {
    generic: core.schemas.lazyObject(() => schemas.submission.ExceptionInfo),
    timeout: core.schemas.object({}),
  })
  .transform<MyApi.submission.ExceptionV2>({
    parse: (value) => {
      switch (value.type) {
        case \\"generic\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.generic(value),
          };
        }
        case \\"timeout\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.timeout(),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace ExceptionV2 {
  type Raw = ExceptionV2.Generic | ExceptionV2.Timeout;

  interface Generic extends schemas.submission.ExceptionInfo.Raw {
    type: \\"generic\\";
  }

  interface Timeout {
    type: \\"timeout\\";
  }
}
",
                "name": "ExceptionV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const ExecutionSessionResponse: core.schemas.ObjectSchema<
  ExecutionSessionResponse.Raw,
  MyApi.submission.ExecutionSessionResponse
> = core.schemas.object({
  sessionId: core.schemas.string(),
  executionSessionUrl: core.schemas.string().optional(),
  language: core.schemas.lazy(() => schemas.commons.Language),
  status: core.schemas.lazy(() => schemas.submission.ExecutionSessionStatus),
});

export declare namespace ExecutionSessionResponse {
  interface Raw {
    sessionId: string;
    executionSessionUrl?: string | null;
    language: schemas.commons.Language.Raw;
    status: schemas.submission.ExecutionSessionStatus.Raw;
  }
}
",
                "name": "ExecutionSessionResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const ExecutionSessionState: core.schemas.ObjectSchema<
  ExecutionSessionState.Raw,
  MyApi.submission.ExecutionSessionState
> = core.schemas.object({
  lastTimeContacted: core.schemas.string().optional(),
  sessionId: core.schemas.string(),
  isWarmInstance: core.schemas.boolean(),
  awsTaskId: core.schemas.string().optional(),
  language: core.schemas.lazy(() => schemas.commons.Language),
  status: core.schemas.lazy(() => schemas.submission.ExecutionSessionStatus),
});

export declare namespace ExecutionSessionState {
  interface Raw {
    lastTimeContacted?: string | null;
    sessionId: string;
    isWarmInstance: boolean;
    awsTaskId?: string | null;
    language: schemas.commons.Language.Raw;
    status: schemas.submission.ExecutionSessionStatus.Raw;
  }
}
",
                "name": "ExecutionSessionState.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const ExecutionSessionStatus: core.schemas.Schema<
  ExecutionSessionStatus.Raw,
  MyApi.submission.ExecutionSessionStatus
> = core.schemas.string().transform<MyApi.submission.ExecutionSessionStatus>({
  parse: (value) => {
    switch (value) {
      case \\"CREATING_CONTAINER\\": {
        return MyApi.submission.ExecutionSessionStatus.CreatingContainer();
      }
      case \\"PROVISIONING_CONTAINER\\": {
        return MyApi.submission.ExecutionSessionStatus.ProvisioningContainer();
      }
      case \\"PENDING_CONTAINER\\": {
        return MyApi.submission.ExecutionSessionStatus.PendingContainer();
      }
      case \\"RUNNING_CONTAINER\\": {
        return MyApi.submission.ExecutionSessionStatus.RunningContainer();
      }
      case \\"LIVE_CONTAINER\\": {
        return MyApi.submission.ExecutionSessionStatus.LiveContainer();
      }
      case \\"FAILED_TO_LAUNCH\\": {
        return MyApi.submission.ExecutionSessionStatus.FailedToLaunch();
      }
      default: {
        return {
          get: () => value,
          visit: (visitor) => visitor._other(value),
        };
      }
    }
  },
  json: (value) => value.get(),
});

export declare namespace ExecutionSessionStatus {
  type Raw = string;
}
",
                "name": "ExecutionSessionStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const ExistingSubmissionExecuting: core.schemas.ObjectSchema<
  ExistingSubmissionExecuting.Raw,
  MyApi.submission.ExistingSubmissionExecuting
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
});

export declare namespace ExistingSubmissionExecuting {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
  }
}
",
                "name": "ExistingSubmissionExecuting.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const ExpressionLocation: core.schemas.ObjectSchema<
  ExpressionLocation.Raw,
  MyApi.submission.ExpressionLocation
> = core.schemas.object({
  start: core.schemas.number(),
  offset: core.schemas.number(),
});

export declare namespace ExpressionLocation {
  interface Raw {
    start: number;
    offset: number;
  }
}
",
                "name": "ExpressionLocation.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const FinishedResponse: core.schemas.ObjectSchema<
  FinishedResponse.Raw,
  MyApi.submission.FinishedResponse
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
});

export declare namespace FinishedResponse {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
  }
}
",
                "name": "FinishedResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const GetExecutionSessionStateResponse: core.schemas.ObjectSchema<
  GetExecutionSessionStateResponse.Raw,
  MyApi.submission.GetExecutionSessionStateResponse
> = core.schemas.object({
  states: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.submission.ExecutionSessionState)
  ),
  numWarmingInstances: core.schemas.number().optional(),
  warmingSessionIds: core.schemas.list(core.schemas.string()),
});

export declare namespace GetExecutionSessionStateResponse {
  interface Raw {
    states: Record<string, schemas.submission.ExecutionSessionState.Raw>;
    numWarmingInstances?: number | null;
    warmingSessionIds: string[];
  }
}
",
                "name": "GetExecutionSessionStateResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const GetSubmissionStateResponse: core.schemas.ObjectSchema<
  GetSubmissionStateResponse.Raw,
  MyApi.submission.GetSubmissionStateResponse
> = core.schemas.object({
  timeSubmitted: core.schemas.date().optional(),
  submission: core.schemas.string(),
  language: core.schemas.lazy(() => schemas.commons.Language),
  submissionTypeState: core.schemas.lazy(
    () => schemas.submission.SubmissionTypeState
  ),
});

export declare namespace GetSubmissionStateResponse {
  interface Raw {
    timeSubmitted?: string | null;
    submission: string;
    language: schemas.commons.Language.Raw;
    submissionTypeState: schemas.submission.SubmissionTypeState.Raw;
  }
}
",
                "name": "GetSubmissionStateResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const GetTraceResponsesPageRequest: core.schemas.ObjectSchema<
  GetTraceResponsesPageRequest.Raw,
  MyApi.submission.GetTraceResponsesPageRequest
> = core.schemas.object({
  offset: core.schemas.number().optional(),
});

export declare namespace GetTraceResponsesPageRequest {
  interface Raw {
    offset?: number | null;
  }
}
",
                "name": "GetTraceResponsesPageRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const GradedResponse: core.schemas.ObjectSchema<
  GradedResponse.Raw,
  MyApi.submission.GradedResponse
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
  testCases: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.submission.TestCaseResultWithStdout)
  ),
});

export declare namespace GradedResponse {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
    testCases: Record<string, schemas.submission.TestCaseResultWithStdout.Raw>;
  }
}
",
                "name": "GradedResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const GradedResponseV2: core.schemas.ObjectSchema<
  GradedResponseV2.Raw,
  MyApi.submission.GradedResponseV2
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
  testCases: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazy(() => schemas.submission.TestCaseGrade)
  ),
});

export declare namespace GradedResponseV2 {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
    testCases: Record<
      schemas.v2.problem.TestCaseId.Raw,
      schemas.submission.TestCaseGrade.Raw
    >;
  }
}
",
                "name": "GradedResponseV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const GradedTestCaseUpdate: core.schemas.ObjectSchema<
  GradedTestCaseUpdate.Raw,
  MyApi.submission.GradedTestCaseUpdate
> = core.schemas.object({
  testCaseId: core.schemas.lazy(() => schemas.v2.problem.TestCaseId),
  grade: core.schemas.lazy(() => schemas.submission.TestCaseGrade),
});

export declare namespace GradedTestCaseUpdate {
  interface Raw {
    testCaseId: schemas.v2.problem.TestCaseId.Raw;
    grade: schemas.submission.TestCaseGrade.Raw;
  }
}
",
                "name": "GradedTestCaseUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const InitializeProblemRequest: core.schemas.ObjectSchema<
  InitializeProblemRequest.Raw,
  MyApi.submission.InitializeProblemRequest
> = core.schemas.object({
  problemId: core.schemas.lazy(() => schemas.commons.ProblemId),
  problemVersion: core.schemas.number().optional(),
});

export declare namespace InitializeProblemRequest {
  interface Raw {
    problemId: schemas.commons.ProblemId.Raw;
    problemVersion?: number | null;
  }
}
",
                "name": "InitializeProblemRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const InternalError: core.schemas.ObjectSchema<
  InternalError.Raw,
  MyApi.submission.InternalError
> = core.schemas.object({
  exceptionInfo: core.schemas.lazyObject(
    () => schemas.submission.ExceptionInfo
  ),
});

export declare namespace InternalError {
  interface Raw {
    exceptionInfo: schemas.submission.ExceptionInfo.Raw;
  }
}
",
                "name": "InternalError.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const InvalidRequestCause: core.schemas.Schema<
  InvalidRequestCause.Raw,
  MyApi.submission.InvalidRequestCause
> = core.schemas
  .union(\\"type\\", {
    submissionIdNotFound: core.schemas.lazyObject(
      () => schemas.submission.SubmissionIdNotFound
    ),
    customTestCasesUnsupported: core.schemas.lazyObject(
      () => schemas.submission.CustomTestCasesUnsupported
    ),
    unexpectedLanguage: core.schemas.lazyObject(
      () => schemas.submission.UnexpectedLanguageError
    ),
  })
  .transform<MyApi.submission.InvalidRequestCause>({
    parse: (value) => {
      switch (value.type) {
        case \\"submissionIdNotFound\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.submissionIdNotFound(value),
          };
        }
        case \\"customTestCasesUnsupported\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.customTestCasesUnsupported(value),
          };
        }
        case \\"unexpectedLanguage\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.unexpectedLanguage(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace InvalidRequestCause {
  type Raw =
    | InvalidRequestCause.SubmissionIdNotFound
    | InvalidRequestCause.CustomTestCasesUnsupported
    | InvalidRequestCause.UnexpectedLanguage;

  interface SubmissionIdNotFound
    extends schemas.submission.SubmissionIdNotFound.Raw {
    type: \\"submissionIdNotFound\\";
  }

  interface CustomTestCasesUnsupported
    extends schemas.submission.CustomTestCasesUnsupported.Raw {
    type: \\"customTestCasesUnsupported\\";
  }

  interface UnexpectedLanguage
    extends schemas.submission.UnexpectedLanguageError.Raw {
    type: \\"unexpectedLanguage\\";
  }
}
",
                "name": "InvalidRequestCause.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const InvalidRequestResponse: core.schemas.ObjectSchema<
  InvalidRequestResponse.Raw,
  MyApi.submission.InvalidRequestResponse
> = core.schemas.object({
  request: core.schemas.lazy(() => schemas.submission.SubmissionRequest),
  cause: core.schemas.lazy(() => schemas.submission.InvalidRequestCause),
});

export declare namespace InvalidRequestResponse {
  interface Raw {
    request: schemas.submission.SubmissionRequest.Raw;
    cause: schemas.submission.InvalidRequestCause.Raw;
  }
}
",
                "name": "InvalidRequestResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const LightweightStackframeInformation: core.schemas.ObjectSchema<
  LightweightStackframeInformation.Raw,
  MyApi.submission.LightweightStackframeInformation
> = core.schemas.object({
  numStackFrames: core.schemas.number(),
  topStackFrameMethodName: core.schemas.string(),
});

export declare namespace LightweightStackframeInformation {
  interface Raw {
    numStackFrames: number;
    topStackFrameMethodName: string;
  }
}
",
                "name": "LightweightStackframeInformation.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const RecordedResponseNotification: core.schemas.ObjectSchema<
  RecordedResponseNotification.Raw,
  MyApi.submission.RecordedResponseNotification
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
  traceResponsesSize: core.schemas.number(),
  testCaseId: core.schemas.string().optional(),
});

export declare namespace RecordedResponseNotification {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
    traceResponsesSize: number;
    testCaseId?: string | null;
  }
}
",
                "name": "RecordedResponseNotification.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const RecordedTestCaseUpdate: core.schemas.ObjectSchema<
  RecordedTestCaseUpdate.Raw,
  MyApi.submission.RecordedTestCaseUpdate
> = core.schemas.object({
  testCaseId: core.schemas.lazy(() => schemas.v2.problem.TestCaseId),
  traceResponsesSize: core.schemas.number(),
});

export declare namespace RecordedTestCaseUpdate {
  interface Raw {
    testCaseId: schemas.v2.problem.TestCaseId.Raw;
    traceResponsesSize: number;
  }
}
",
                "name": "RecordedTestCaseUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const RecordingResponseNotification: core.schemas.ObjectSchema<
  RecordingResponseNotification.Raw,
  MyApi.submission.RecordingResponseNotification
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
  testCaseId: core.schemas.string().optional(),
  lineNumber: core.schemas.number(),
  lightweightStackInfo: core.schemas.lazyObject(
    () => schemas.submission.LightweightStackframeInformation
  ),
  tracedFile: core.schemas
    .lazyObject(() => schemas.submission.TracedFile)
    .optional(),
});

export declare namespace RecordingResponseNotification {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
    testCaseId?: string | null;
    lineNumber: number;
    lightweightStackInfo: schemas.submission.LightweightStackframeInformation.Raw;
    tracedFile?: schemas.submission.TracedFile.Raw | null;
  }
}
",
                "name": "RecordingResponseNotification.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const RunningResponse: core.schemas.ObjectSchema<
  RunningResponse.Raw,
  MyApi.submission.RunningResponse
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
  state: core.schemas.lazy(() => schemas.submission.RunningSubmissionState),
});

export declare namespace RunningResponse {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
    state: schemas.submission.RunningSubmissionState.Raw;
  }
}
",
                "name": "RunningResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const RunningSubmissionState: core.schemas.Schema<
  RunningSubmissionState.Raw,
  MyApi.submission.RunningSubmissionState
> = core.schemas.string().transform<MyApi.submission.RunningSubmissionState>({
  parse: (value) => {
    switch (value) {
      case \\"QUEUEING_SUBMISSION\\": {
        return MyApi.submission.RunningSubmissionState.QueueingSubmission();
      }
      case \\"KILLING_HISTORICAL_SUBMISSIONS\\": {
        return MyApi.submission.RunningSubmissionState.KillingHistoricalSubmissions();
      }
      case \\"WRITING_SUBMISSION_TO_FILE\\": {
        return MyApi.submission.RunningSubmissionState.WritingSubmissionToFile();
      }
      case \\"COMPILING_SUBMISSION\\": {
        return MyApi.submission.RunningSubmissionState.CompilingSubmission();
      }
      case \\"RUNNING_SUBMISSION\\": {
        return MyApi.submission.RunningSubmissionState.RunningSubmission();
      }
      default: {
        return {
          get: () => value,
          visit: (visitor) => visitor._other(value),
        };
      }
    }
  },
  json: (value) => value.get(),
});

export declare namespace RunningSubmissionState {
  type Raw = string;
}
",
                "name": "RunningSubmissionState.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const RuntimeError: core.schemas.ObjectSchema<
  RuntimeError.Raw,
  MyApi.submission.RuntimeError
> = core.schemas.object({
  message: core.schemas.string(),
});

export declare namespace RuntimeError {
  interface Raw {
    message: string;
  }
}
",
                "name": "RuntimeError.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const Scope: core.schemas.ObjectSchema<
  Scope.Raw,
  MyApi.submission.Scope
> = core.schemas.object({
  variables: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazy(() => schemas.commons.DebugVariableValue)
  ),
});

export declare namespace Scope {
  interface Raw {
    variables: Record<string, schemas.commons.DebugVariableValue.Raw>;
  }
}
",
                "name": "Scope.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const ShareId: core.schemas.Schema<
  ShareId.Raw,
  MyApi.submission.ShareId
> = core.schemas.string();

export declare namespace ShareId {
  type Raw = string;
}
",
                "name": "ShareId.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const StackFrame: core.schemas.ObjectSchema<
  StackFrame.Raw,
  MyApi.submission.StackFrame
> = core.schemas.object({
  methodName: core.schemas.string(),
  lineNumber: core.schemas.number(),
  scopes: core.schemas.list(
    core.schemas.lazyObject(() => schemas.submission.Scope)
  ),
});

export declare namespace StackFrame {
  interface Raw {
    methodName: string;
    lineNumber: number;
    scopes: schemas.submission.Scope.Raw[];
  }
}
",
                "name": "StackFrame.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const StackInformation: core.schemas.ObjectSchema<
  StackInformation.Raw,
  MyApi.submission.StackInformation
> = core.schemas.object({
  numStackFrames: core.schemas.number(),
  topStackFrame: core.schemas
    .lazyObject(() => schemas.submission.StackFrame)
    .optional(),
});

export declare namespace StackInformation {
  interface Raw {
    numStackFrames: number;
    topStackFrame?: schemas.submission.StackFrame.Raw | null;
  }
}
",
                "name": "StackInformation.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const StderrResponse: core.schemas.ObjectSchema<
  StderrResponse.Raw,
  MyApi.submission.StderrResponse
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
  stderr: core.schemas.string(),
});

export declare namespace StderrResponse {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
    stderr: string;
  }
}
",
                "name": "StderrResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const StdoutResponse: core.schemas.ObjectSchema<
  StdoutResponse.Raw,
  MyApi.submission.StdoutResponse
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
  stdout: core.schemas.string(),
});

export declare namespace StdoutResponse {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
    stdout: string;
  }
}
",
                "name": "StdoutResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const StopRequest: core.schemas.ObjectSchema<
  StopRequest.Raw,
  MyApi.submission.StopRequest
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
});

export declare namespace StopRequest {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
  }
}
",
                "name": "StopRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const StoppedResponse: core.schemas.ObjectSchema<
  StoppedResponse.Raw,
  MyApi.submission.StoppedResponse
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
});

export declare namespace StoppedResponse {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
  }
}
",
                "name": "StoppedResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const SubmissionFileInfo: core.schemas.ObjectSchema<
  SubmissionFileInfo.Raw,
  MyApi.submission.SubmissionFileInfo
> = core.schemas.object({
  directory: core.schemas.string(),
  filename: core.schemas.string(),
  contents: core.schemas.string(),
});

export declare namespace SubmissionFileInfo {
  interface Raw {
    directory: string;
    filename: string;
    contents: string;
  }
}
",
                "name": "SubmissionFileInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const SubmissionId: core.schemas.Schema<
  SubmissionId.Raw,
  MyApi.submission.SubmissionId
> = core.schemas.string();

export declare namespace SubmissionId {
  type Raw = string;
}
",
                "name": "SubmissionId.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const SubmissionIdNotFound: core.schemas.ObjectSchema<
  SubmissionIdNotFound.Raw,
  MyApi.submission.SubmissionIdNotFound
> = core.schemas.object({
  missingSubmissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
});

export declare namespace SubmissionIdNotFound {
  interface Raw {
    missingSubmissionId: schemas.submission.SubmissionId.Raw;
  }
}
",
                "name": "SubmissionIdNotFound.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const SubmissionRequest: core.schemas.Schema<
  SubmissionRequest.Raw,
  MyApi.submission.SubmissionRequest
> = core.schemas
  .union(\\"type\\", {
    initializeProblemRequest: core.schemas.lazyObject(
      () => schemas.submission.InitializeProblemRequest
    ),
    initializeWorkspaceRequest: core.schemas.object({}),
    submitV2: core.schemas.lazyObject(() => schemas.submission.SubmitRequestV2),
    workspaceSubmit: core.schemas.lazyObject(
      () => schemas.submission.WorkspaceSubmitRequest
    ),
    stop: core.schemas.lazyObject(() => schemas.submission.StopRequest),
  })
  .transform<MyApi.submission.SubmissionRequest>({
    parse: (value) => {
      switch (value.type) {
        case \\"initializeProblemRequest\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.initializeProblemRequest(value),
          };
        }
        case \\"initializeWorkspaceRequest\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.initializeWorkspaceRequest(),
          };
        }
        case \\"submitV2\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.submitV2(value),
          };
        }
        case \\"workspaceSubmit\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.workspaceSubmit(value),
          };
        }
        case \\"stop\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.stop(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace SubmissionRequest {
  type Raw =
    | SubmissionRequest.InitializeProblemRequest
    | SubmissionRequest.InitializeWorkspaceRequest
    | SubmissionRequest.SubmitV2
    | SubmissionRequest.WorkspaceSubmit
    | SubmissionRequest.Stop;

  interface InitializeProblemRequest
    extends schemas.submission.InitializeProblemRequest.Raw {
    type: \\"initializeProblemRequest\\";
  }

  interface InitializeWorkspaceRequest {
    type: \\"initializeWorkspaceRequest\\";
  }

  interface SubmitV2 extends schemas.submission.SubmitRequestV2.Raw {
    type: \\"submitV2\\";
  }

  interface WorkspaceSubmit
    extends schemas.submission.WorkspaceSubmitRequest.Raw {
    type: \\"workspaceSubmit\\";
  }

  interface Stop extends schemas.submission.StopRequest.Raw {
    type: \\"stop\\";
  }
}
",
                "name": "SubmissionRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const SubmissionResponse: core.schemas.Schema<
  SubmissionResponse.Raw,
  MyApi.submission.SubmissionResponse
> = core.schemas
  .union(\\"type\\", {
    serverInitialized: core.schemas.object({}),
    problemInitialized: core.schemas.object({
      value: core.schemas.lazy(() => schemas.commons.ProblemId),
    }),
    workspaceInitialized: core.schemas.object({}),
    serverErrored: core.schemas.lazyObject(
      () => schemas.submission.ExceptionInfo
    ),
    codeExecutionUpdate: core.schemas.object({
      value: core.schemas.lazy(() => schemas.submission.CodeExecutionUpdate),
    }),
    terminated: core.schemas.lazyObject(
      () => schemas.submission.TerminatedResponse
    ),
  })
  .transform<MyApi.submission.SubmissionResponse>({
    parse: (value) => {
      switch (value.type) {
        case \\"serverInitialized\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.serverInitialized(),
          };
        }
        case \\"problemInitialized\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.problemInitialized(value.value),
          };
        }
        case \\"workspaceInitialized\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.workspaceInitialized(),
          };
        }
        case \\"serverErrored\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.serverErrored(value),
          };
        }
        case \\"codeExecutionUpdate\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.codeExecutionUpdate(value.value),
          };
        }
        case \\"terminated\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.terminated(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace SubmissionResponse {
  type Raw =
    | SubmissionResponse.ServerInitialized
    | SubmissionResponse.ProblemInitialized
    | SubmissionResponse.WorkspaceInitialized
    | SubmissionResponse.ServerErrored
    | SubmissionResponse.CodeExecutionUpdate
    | SubmissionResponse.Terminated;

  interface ServerInitialized {
    type: \\"serverInitialized\\";
  }

  interface ProblemInitialized {
    type: \\"problemInitialized\\";
    value: schemas.commons.ProblemId.Raw;
  }

  interface WorkspaceInitialized {
    type: \\"workspaceInitialized\\";
  }

  interface ServerErrored extends schemas.submission.ExceptionInfo.Raw {
    type: \\"serverErrored\\";
  }

  interface CodeExecutionUpdate {
    type: \\"codeExecutionUpdate\\";
    value: schemas.submission.CodeExecutionUpdate.Raw;
  }

  interface Terminated extends schemas.submission.TerminatedResponse.Raw {
    type: \\"terminated\\";
  }
}
",
                "name": "SubmissionResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const SubmissionStatusForTestCase: core.schemas.Schema<
  SubmissionStatusForTestCase.Raw,
  MyApi.submission.SubmissionStatusForTestCase
> = core.schemas
  .union(\\"type\\", {
    graded: core.schemas.lazyObject(
      () => schemas.submission.TestCaseResultWithStdout
    ),
    gradedV2: core.schemas.object({
      value: core.schemas.lazy(() => schemas.submission.TestCaseGrade),
    }),
    traced: core.schemas.lazyObject(() => schemas.submission.TracedTestCase),
  })
  .transform<MyApi.submission.SubmissionStatusForTestCase>({
    parse: (value) => {
      switch (value.type) {
        case \\"graded\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.graded(value),
          };
        }
        case \\"gradedV2\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.gradedV2(value.value),
          };
        }
        case \\"traced\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.traced(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace SubmissionStatusForTestCase {
  type Raw =
    | SubmissionStatusForTestCase.Graded
    | SubmissionStatusForTestCase.GradedV2
    | SubmissionStatusForTestCase.Traced;

  interface Graded extends schemas.submission.TestCaseResultWithStdout.Raw {
    type: \\"graded\\";
  }

  interface GradedV2 {
    type: \\"gradedV2\\";
    value: schemas.submission.TestCaseGrade.Raw;
  }

  interface Traced extends schemas.submission.TracedTestCase.Raw {
    type: \\"traced\\";
  }
}
",
                "name": "SubmissionStatusForTestCase.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const SubmissionStatusV2: core.schemas.Schema<
  SubmissionStatusV2.Raw,
  MyApi.submission.SubmissionStatusV2
> = core.schemas
  .union(\\"type\\", {
    test: core.schemas.lazyObject(
      () => schemas.submission.TestSubmissionStatusV2
    ),
    workspace: core.schemas.lazyObject(
      () => schemas.submission.WorkspaceSubmissionStatusV2
    ),
  })
  .transform<MyApi.submission.SubmissionStatusV2>({
    parse: (value) => {
      switch (value.type) {
        case \\"test\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.test(value),
          };
        }
        case \\"workspace\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.workspace(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace SubmissionStatusV2 {
  type Raw = SubmissionStatusV2.Test | SubmissionStatusV2.Workspace;

  interface Test extends schemas.submission.TestSubmissionStatusV2.Raw {
    type: \\"test\\";
  }

  interface Workspace
    extends schemas.submission.WorkspaceSubmissionStatusV2.Raw {
    type: \\"workspace\\";
  }
}
",
                "name": "SubmissionStatusV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const SubmissionTypeEnum: core.schemas.Schema<
  SubmissionTypeEnum.Raw,
  MyApi.submission.SubmissionTypeEnum
> = core.schemas.string().transform<MyApi.submission.SubmissionTypeEnum>({
  parse: (value) => {
    switch (value) {
      case \\"TEST\\": {
        return MyApi.submission.SubmissionTypeEnum.Test();
      }
      default: {
        return {
          get: () => value,
          visit: (visitor) => visitor._other(value),
        };
      }
    }
  },
  json: (value) => value.get(),
});

export declare namespace SubmissionTypeEnum {
  type Raw = string;
}
",
                "name": "SubmissionTypeEnum.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const SubmissionTypeState: core.schemas.Schema<
  SubmissionTypeState.Raw,
  MyApi.submission.SubmissionTypeState
> = core.schemas
  .union(\\"type\\", {
    test: core.schemas.lazyObject(() => schemas.submission.TestSubmissionState),
    workspace: core.schemas.lazyObject(
      () => schemas.submission.WorkspaceSubmissionState
    ),
  })
  .transform<MyApi.submission.SubmissionTypeState>({
    parse: (value) => {
      switch (value.type) {
        case \\"test\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.test(value),
          };
        }
        case \\"workspace\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.workspace(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace SubmissionTypeState {
  type Raw = SubmissionTypeState.Test | SubmissionTypeState.Workspace;

  interface Test extends schemas.submission.TestSubmissionState.Raw {
    type: \\"test\\";
  }

  interface Workspace extends schemas.submission.WorkspaceSubmissionState.Raw {
    type: \\"workspace\\";
  }
}
",
                "name": "SubmissionTypeState.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const SubmitRequestV2: core.schemas.ObjectSchema<
  SubmitRequestV2.Raw,
  MyApi.submission.SubmitRequestV2
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
  language: core.schemas.lazy(() => schemas.commons.Language),
  submissionFiles: core.schemas.list(
    core.schemas.lazyObject(() => schemas.submission.SubmissionFileInfo)
  ),
  problemId: core.schemas.lazy(() => schemas.commons.ProblemId),
  problemVersion: core.schemas.number().optional(),
  userId: core.schemas.string().optional(),
});

export declare namespace SubmitRequestV2 {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
    language: schemas.commons.Language.Raw;
    submissionFiles: schemas.submission.SubmissionFileInfo.Raw[];
    problemId: schemas.commons.ProblemId.Raw;
    problemVersion?: number | null;
    userId?: string | null;
  }
}
",
                "name": "SubmitRequestV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const TerminatedResponse: core.schemas.ObjectSchema<
  TerminatedResponse.Raw,
  MyApi.submission.TerminatedResponse
> = core.schemas.object({});

export declare namespace TerminatedResponse {
  interface Raw {}
}
",
                "name": "TerminatedResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TestCaseGrade: core.schemas.Schema<
  TestCaseGrade.Raw,
  MyApi.submission.TestCaseGrade
> = core.schemas
  .union(\\"type\\", {
    hidden: core.schemas.lazyObject(
      () => schemas.submission.TestCaseHiddenGrade
    ),
    nonHidden: core.schemas.lazyObject(
      () => schemas.submission.TestCaseNonHiddenGrade
    ),
  })
  .transform<MyApi.submission.TestCaseGrade>({
    parse: (value) => {
      switch (value.type) {
        case \\"hidden\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.hidden(value),
          };
        }
        case \\"nonHidden\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.nonHidden(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestCaseGrade {
  type Raw = TestCaseGrade.Hidden | TestCaseGrade.NonHidden;

  interface Hidden extends schemas.submission.TestCaseHiddenGrade.Raw {
    type: \\"hidden\\";
  }

  interface NonHidden extends schemas.submission.TestCaseNonHiddenGrade.Raw {
    type: \\"nonHidden\\";
  }
}
",
                "name": "TestCaseGrade.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const TestCaseHiddenGrade: core.schemas.ObjectSchema<
  TestCaseHiddenGrade.Raw,
  MyApi.submission.TestCaseHiddenGrade
> = core.schemas.object({
  passed: core.schemas.boolean(),
});

export declare namespace TestCaseHiddenGrade {
  interface Raw {
    passed: boolean;
  }
}
",
                "name": "TestCaseHiddenGrade.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TestCaseNonHiddenGrade: core.schemas.ObjectSchema<
  TestCaseNonHiddenGrade.Raw,
  MyApi.submission.TestCaseNonHiddenGrade
> = core.schemas.object({
  passed: core.schemas.boolean(),
  actualResult: core.schemas
    .lazy(() => schemas.commons.VariableValue)
    .optional(),
  exception: core.schemas.lazy(() => schemas.submission.ExceptionV2).optional(),
  stdout: core.schemas.string(),
});

export declare namespace TestCaseNonHiddenGrade {
  interface Raw {
    passed: boolean;
    actualResult?: schemas.commons.VariableValue.Raw | null;
    exception?: schemas.submission.ExceptionV2.Raw | null;
    stdout: string;
  }
}
",
                "name": "TestCaseNonHiddenGrade.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TestCaseResult: core.schemas.ObjectSchema<
  TestCaseResult.Raw,
  MyApi.submission.TestCaseResult
> = core.schemas.object({
  expectedResult: core.schemas.lazy(() => schemas.commons.VariableValue),
  actualResult: core.schemas.lazy(() => schemas.submission.ActualResult),
  passed: core.schemas.boolean(),
});

export declare namespace TestCaseResult {
  interface Raw {
    expectedResult: schemas.commons.VariableValue.Raw;
    actualResult: schemas.submission.ActualResult.Raw;
    passed: boolean;
  }
}
",
                "name": "TestCaseResult.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TestCaseResultWithStdout: core.schemas.ObjectSchema<
  TestCaseResultWithStdout.Raw,
  MyApi.submission.TestCaseResultWithStdout
> = core.schemas.object({
  result: core.schemas.lazyObject(() => schemas.submission.TestCaseResult),
  stdout: core.schemas.string(),
});

export declare namespace TestCaseResultWithStdout {
  interface Raw {
    result: schemas.submission.TestCaseResult.Raw;
    stdout: string;
  }
}
",
                "name": "TestCaseResultWithStdout.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TestSubmissionState: core.schemas.ObjectSchema<
  TestSubmissionState.Raw,
  MyApi.submission.TestSubmissionState
> = core.schemas.object({
  problemId: core.schemas.lazy(() => schemas.commons.ProblemId),
  defaultTestCases: core.schemas.list(
    core.schemas.lazyObject(() => schemas.commons.TestCase)
  ),
  customTestCases: core.schemas.list(
    core.schemas.lazyObject(() => schemas.commons.TestCase)
  ),
  status: core.schemas.lazy(() => schemas.submission.TestSubmissionStatus),
});

export declare namespace TestSubmissionState {
  interface Raw {
    problemId: schemas.commons.ProblemId.Raw;
    defaultTestCases: schemas.commons.TestCase.Raw[];
    customTestCases: schemas.commons.TestCase.Raw[];
    status: schemas.submission.TestSubmissionStatus.Raw;
  }
}
",
                "name": "TestSubmissionState.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TestSubmissionStatus: core.schemas.Schema<
  TestSubmissionStatus.Raw,
  MyApi.submission.TestSubmissionStatus
> = core.schemas
  .union(\\"type\\", {
    stopped: core.schemas.object({}),
    errored: core.schemas.object({
      value: core.schemas.lazy(() => schemas.submission.ErrorInfo),
    }),
    running: core.schemas.object({
      value: core.schemas.lazy(() => schemas.submission.RunningSubmissionState),
    }),
    testCaseIdToState: core.schemas.object({
      value: core.schemas.record(
        core.schemas.string(),
        core.schemas.lazy(() => schemas.submission.SubmissionStatusForTestCase)
      ),
    }),
  })
  .transform<MyApi.submission.TestSubmissionStatus>({
    parse: (value) => {
      switch (value.type) {
        case \\"stopped\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.stopped(),
          };
        }
        case \\"errored\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.errored(value.value),
          };
        }
        case \\"running\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.running(value.value),
          };
        }
        case \\"testCaseIdToState\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.testCaseIdToState(value.value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestSubmissionStatus {
  type Raw =
    | TestSubmissionStatus.Stopped
    | TestSubmissionStatus.Errored
    | TestSubmissionStatus.Running
    | TestSubmissionStatus.TestCaseIdToState;

  interface Stopped {
    type: \\"stopped\\";
  }

  interface Errored {
    type: \\"errored\\";
    value: schemas.submission.ErrorInfo.Raw;
  }

  interface Running {
    type: \\"running\\";
    value: schemas.submission.RunningSubmissionState.Raw;
  }

  interface TestCaseIdToState {
    type: \\"testCaseIdToState\\";
    value: Record<string, schemas.submission.SubmissionStatusForTestCase.Raw>;
  }
}
",
                "name": "TestSubmissionStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TestSubmissionStatusV2: core.schemas.ObjectSchema<
  TestSubmissionStatusV2.Raw,
  MyApi.submission.TestSubmissionStatusV2
> = core.schemas.object({
  updates: core.schemas.list(
    core.schemas.lazyObject(() => schemas.submission.TestSubmissionUpdate)
  ),
  problemId: core.schemas.lazy(() => schemas.commons.ProblemId),
  problemVersion: core.schemas.number(),
  problemInfo: core.schemas.lazyObject(() => schemas.v2.problem.ProblemInfoV2),
});

export declare namespace TestSubmissionStatusV2 {
  interface Raw {
    updates: schemas.submission.TestSubmissionUpdate.Raw[];
    problemId: schemas.commons.ProblemId.Raw;
    problemVersion: number;
    problemInfo: schemas.v2.problem.ProblemInfoV2.Raw;
  }
}
",
                "name": "TestSubmissionStatusV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TestSubmissionUpdate: core.schemas.ObjectSchema<
  TestSubmissionUpdate.Raw,
  MyApi.submission.TestSubmissionUpdate
> = core.schemas.object({
  updateTime: core.schemas.date(),
  updateInfo: core.schemas.lazy(
    () => schemas.submission.TestSubmissionUpdateInfo
  ),
});

export declare namespace TestSubmissionUpdate {
  interface Raw {
    updateTime: string;
    updateInfo: schemas.submission.TestSubmissionUpdateInfo.Raw;
  }
}
",
                "name": "TestSubmissionUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TestSubmissionUpdateInfo: core.schemas.Schema<
  TestSubmissionUpdateInfo.Raw,
  MyApi.submission.TestSubmissionUpdateInfo
> = core.schemas
  .union(\\"type\\", {
    running: core.schemas.object({
      value: core.schemas.lazy(() => schemas.submission.RunningSubmissionState),
    }),
    stopped: core.schemas.object({}),
    errored: core.schemas.object({
      value: core.schemas.lazy(() => schemas.submission.ErrorInfo),
    }),
    gradedTestCase: core.schemas.lazyObject(
      () => schemas.submission.GradedTestCaseUpdate
    ),
    recordedTestCase: core.schemas.lazyObject(
      () => schemas.submission.RecordedTestCaseUpdate
    ),
    finished: core.schemas.object({}),
  })
  .transform<MyApi.submission.TestSubmissionUpdateInfo>({
    parse: (value) => {
      switch (value.type) {
        case \\"running\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.running(value.value),
          };
        }
        case \\"stopped\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.stopped(),
          };
        }
        case \\"errored\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.errored(value.value),
          };
        }
        case \\"gradedTestCase\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.gradedTestCase(value),
          };
        }
        case \\"recordedTestCase\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.recordedTestCase(value),
          };
        }
        case \\"finished\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.finished(),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestSubmissionUpdateInfo {
  type Raw =
    | TestSubmissionUpdateInfo.Running
    | TestSubmissionUpdateInfo.Stopped
    | TestSubmissionUpdateInfo.Errored
    | TestSubmissionUpdateInfo.GradedTestCase
    | TestSubmissionUpdateInfo.RecordedTestCase
    | TestSubmissionUpdateInfo.Finished;

  interface Running {
    type: \\"running\\";
    value: schemas.submission.RunningSubmissionState.Raw;
  }

  interface Stopped {
    type: \\"stopped\\";
  }

  interface Errored {
    type: \\"errored\\";
    value: schemas.submission.ErrorInfo.Raw;
  }

  interface GradedTestCase extends schemas.submission.GradedTestCaseUpdate.Raw {
    type: \\"gradedTestCase\\";
  }

  interface RecordedTestCase
    extends schemas.submission.RecordedTestCaseUpdate.Raw {
    type: \\"recordedTestCase\\";
  }

  interface Finished {
    type: \\"finished\\";
  }
}
",
                "name": "TestSubmissionUpdateInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TraceResponse: core.schemas.ObjectSchema<
  TraceResponse.Raw,
  MyApi.submission.TraceResponse
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
  lineNumber: core.schemas.number(),
  returnValue: core.schemas
    .lazy(() => schemas.commons.DebugVariableValue)
    .optional(),
  expressionLocation: core.schemas
    .lazyObject(() => schemas.submission.ExpressionLocation)
    .optional(),
  stack: core.schemas.lazyObject(() => schemas.submission.StackInformation),
  stdout: core.schemas.string().optional(),
});

export declare namespace TraceResponse {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
    lineNumber: number;
    returnValue?: schemas.commons.DebugVariableValue.Raw | null;
    expressionLocation?: schemas.submission.ExpressionLocation.Raw | null;
    stack: schemas.submission.StackInformation.Raw;
    stdout?: string | null;
  }
}
",
                "name": "TraceResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TraceResponseV2: core.schemas.ObjectSchema<
  TraceResponseV2.Raw,
  MyApi.submission.TraceResponseV2
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
  lineNumber: core.schemas.number(),
  file: core.schemas.lazyObject(() => schemas.submission.TracedFile),
  returnValue: core.schemas
    .lazy(() => schemas.commons.DebugVariableValue)
    .optional(),
  expressionLocation: core.schemas
    .lazyObject(() => schemas.submission.ExpressionLocation)
    .optional(),
  stack: core.schemas.lazyObject(() => schemas.submission.StackInformation),
  stdout: core.schemas.string().optional(),
});

export declare namespace TraceResponseV2 {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
    lineNumber: number;
    file: schemas.submission.TracedFile.Raw;
    returnValue?: schemas.commons.DebugVariableValue.Raw | null;
    expressionLocation?: schemas.submission.ExpressionLocation.Raw | null;
    stack: schemas.submission.StackInformation.Raw;
    stdout?: string | null;
  }
}
",
                "name": "TraceResponseV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TraceResponsesPage: core.schemas.ObjectSchema<
  TraceResponsesPage.Raw,
  MyApi.submission.TraceResponsesPage
> = core.schemas.object({
  offset: core.schemas.number().optional(),
  traceResponses: core.schemas.list(
    core.schemas.lazyObject(() => schemas.submission.TraceResponse)
  ),
});

export declare namespace TraceResponsesPage {
  interface Raw {
    offset?: number | null;
    traceResponses: schemas.submission.TraceResponse.Raw[];
  }
}
",
                "name": "TraceResponsesPage.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TraceResponsesPageV2: core.schemas.ObjectSchema<
  TraceResponsesPageV2.Raw,
  MyApi.submission.TraceResponsesPageV2
> = core.schemas.object({
  offset: core.schemas.number().optional(),
  traceResponses: core.schemas.list(
    core.schemas.lazyObject(() => schemas.submission.TraceResponseV2)
  ),
});

export declare namespace TraceResponsesPageV2 {
  interface Raw {
    offset?: number | null;
    traceResponses: schemas.submission.TraceResponseV2.Raw[];
  }
}
",
                "name": "TraceResponsesPageV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const TracedFile: core.schemas.ObjectSchema<
  TracedFile.Raw,
  MyApi.submission.TracedFile
> = core.schemas.object({
  filename: core.schemas.string(),
  directory: core.schemas.string(),
});

export declare namespace TracedFile {
  interface Raw {
    filename: string;
    directory: string;
  }
}
",
                "name": "TracedFile.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const TracedTestCase: core.schemas.ObjectSchema<
  TracedTestCase.Raw,
  MyApi.submission.TracedTestCase
> = core.schemas.object({
  result: core.schemas.lazyObject(
    () => schemas.submission.TestCaseResultWithStdout
  ),
  traceResponsesSize: core.schemas.number(),
});

export declare namespace TracedTestCase {
  interface Raw {
    result: schemas.submission.TestCaseResultWithStdout.Raw;
    traceResponsesSize: number;
  }
}
",
                "name": "TracedTestCase.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const UnexpectedLanguageError: core.schemas.ObjectSchema<
  UnexpectedLanguageError.Raw,
  MyApi.submission.UnexpectedLanguageError
> = core.schemas.object({
  expectedLanguage: core.schemas.lazy(() => schemas.commons.Language),
  actualLanguage: core.schemas.lazy(() => schemas.commons.Language),
});

export declare namespace UnexpectedLanguageError {
  interface Raw {
    expectedLanguage: schemas.commons.Language.Raw;
    actualLanguage: schemas.commons.Language.Raw;
  }
}
",
                "name": "UnexpectedLanguageError.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const WorkspaceFiles: core.schemas.ObjectSchema<
  WorkspaceFiles.Raw,
  MyApi.submission.WorkspaceFiles
> = core.schemas.object({
  mainFile: core.schemas.lazyObject(() => schemas.commons.FileInfo),
  readOnlyFiles: core.schemas.list(
    core.schemas.lazyObject(() => schemas.commons.FileInfo)
  ),
});

export declare namespace WorkspaceFiles {
  interface Raw {
    mainFile: schemas.commons.FileInfo.Raw;
    readOnlyFiles: schemas.commons.FileInfo.Raw[];
  }
}
",
                "name": "WorkspaceFiles.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const WorkspaceRanResponse: core.schemas.ObjectSchema<
  WorkspaceRanResponse.Raw,
  MyApi.submission.WorkspaceRanResponse
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
  runDetails: core.schemas.lazyObject(
    () => schemas.submission.WorkspaceRunDetails
  ),
});

export declare namespace WorkspaceRanResponse {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
    runDetails: schemas.submission.WorkspaceRunDetails.Raw;
  }
}
",
                "name": "WorkspaceRanResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const WorkspaceRunDetails: core.schemas.ObjectSchema<
  WorkspaceRunDetails.Raw,
  MyApi.submission.WorkspaceRunDetails
> = core.schemas.object({
  exceptionV2: core.schemas
    .lazy(() => schemas.submission.ExceptionV2)
    .optional(),
  exception: core.schemas
    .lazyObject(() => schemas.submission.ExceptionInfo)
    .optional(),
  stdout: core.schemas.string(),
});

export declare namespace WorkspaceRunDetails {
  interface Raw {
    exceptionV2?: schemas.submission.ExceptionV2.Raw | null;
    exception?: schemas.submission.ExceptionInfo.Raw | null;
    stdout: string;
  }
}
",
                "name": "WorkspaceRunDetails.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const WorkspaceStarterFilesResponse: core.schemas.ObjectSchema<
  WorkspaceStarterFilesResponse.Raw,
  MyApi.submission.WorkspaceStarterFilesResponse
> = core.schemas.object({
  files: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.submission.WorkspaceFiles)
  ),
});

export declare namespace WorkspaceStarterFilesResponse {
  interface Raw {
    files: Record<
      schemas.commons.Language.Raw,
      schemas.submission.WorkspaceFiles.Raw
    >;
  }
}
",
                "name": "WorkspaceStarterFilesResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const WorkspaceStarterFilesResponseV2: core.schemas.ObjectSchema<
  WorkspaceStarterFilesResponseV2.Raw,
  MyApi.submission.WorkspaceStarterFilesResponseV2
> = core.schemas.object({
  filesByLanguage: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.v2.problem.Files)
  ),
});

export declare namespace WorkspaceStarterFilesResponseV2 {
  interface Raw {
    filesByLanguage: Record<
      schemas.commons.Language.Raw,
      schemas.v2.problem.Files.Raw
    >;
  }
}
",
                "name": "WorkspaceStarterFilesResponseV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const WorkspaceSubmissionState: core.schemas.ObjectSchema<
  WorkspaceSubmissionState.Raw,
  MyApi.submission.WorkspaceSubmissionState
> = core.schemas.object({
  status: core.schemas.lazy(() => schemas.submission.WorkspaceSubmissionStatus),
});

export declare namespace WorkspaceSubmissionState {
  interface Raw {
    status: schemas.submission.WorkspaceSubmissionStatus.Raw;
  }
}
",
                "name": "WorkspaceSubmissionState.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const WorkspaceSubmissionStatus: core.schemas.Schema<
  WorkspaceSubmissionStatus.Raw,
  MyApi.submission.WorkspaceSubmissionStatus
> = core.schemas
  .union(\\"type\\", {
    stopped: core.schemas.object({}),
    errored: core.schemas.object({
      value: core.schemas.lazy(() => schemas.submission.ErrorInfo),
    }),
    running: core.schemas.object({
      value: core.schemas.lazy(() => schemas.submission.RunningSubmissionState),
    }),
    ran: core.schemas.lazyObject(() => schemas.submission.WorkspaceRunDetails),
    traced: core.schemas.lazyObject(
      () => schemas.submission.WorkspaceRunDetails
    ),
  })
  .transform<MyApi.submission.WorkspaceSubmissionStatus>({
    parse: (value) => {
      switch (value.type) {
        case \\"stopped\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.stopped(),
          };
        }
        case \\"errored\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.errored(value.value),
          };
        }
        case \\"running\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.running(value.value),
          };
        }
        case \\"ran\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.ran(value),
          };
        }
        case \\"traced\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.traced(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace WorkspaceSubmissionStatus {
  type Raw =
    | WorkspaceSubmissionStatus.Stopped
    | WorkspaceSubmissionStatus.Errored
    | WorkspaceSubmissionStatus.Running
    | WorkspaceSubmissionStatus.Ran
    | WorkspaceSubmissionStatus.Traced;

  interface Stopped {
    type: \\"stopped\\";
  }

  interface Errored {
    type: \\"errored\\";
    value: schemas.submission.ErrorInfo.Raw;
  }

  interface Running {
    type: \\"running\\";
    value: schemas.submission.RunningSubmissionState.Raw;
  }

  interface Ran extends schemas.submission.WorkspaceRunDetails.Raw {
    type: \\"ran\\";
  }

  interface Traced extends schemas.submission.WorkspaceRunDetails.Raw {
    type: \\"traced\\";
  }
}
",
                "name": "WorkspaceSubmissionStatus.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const WorkspaceSubmissionStatusV2: core.schemas.ObjectSchema<
  WorkspaceSubmissionStatusV2.Raw,
  MyApi.submission.WorkspaceSubmissionStatusV2
> = core.schemas.object({
  updates: core.schemas.list(
    core.schemas.lazyObject(() => schemas.submission.WorkspaceSubmissionUpdate)
  ),
});

export declare namespace WorkspaceSubmissionStatusV2 {
  interface Raw {
    updates: schemas.submission.WorkspaceSubmissionUpdate.Raw[];
  }
}
",
                "name": "WorkspaceSubmissionStatusV2.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const WorkspaceSubmissionUpdate: core.schemas.ObjectSchema<
  WorkspaceSubmissionUpdate.Raw,
  MyApi.submission.WorkspaceSubmissionUpdate
> = core.schemas.object({
  updateTime: core.schemas.date(),
  updateInfo: core.schemas.lazy(
    () => schemas.submission.WorkspaceSubmissionUpdateInfo
  ),
});

export declare namespace WorkspaceSubmissionUpdate {
  interface Raw {
    updateTime: string;
    updateInfo: schemas.submission.WorkspaceSubmissionUpdateInfo.Raw;
  }
}
",
                "name": "WorkspaceSubmissionUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const WorkspaceSubmissionUpdateInfo: core.schemas.Schema<
  WorkspaceSubmissionUpdateInfo.Raw,
  MyApi.submission.WorkspaceSubmissionUpdateInfo
> = core.schemas
  .union(\\"type\\", {
    running: core.schemas.object({
      value: core.schemas.lazy(() => schemas.submission.RunningSubmissionState),
    }),
    ran: core.schemas.lazyObject(() => schemas.submission.WorkspaceRunDetails),
    stopped: core.schemas.object({}),
    traced: core.schemas.object({}),
    tracedV2: core.schemas.lazyObject(
      () => schemas.submission.WorkspaceTracedUpdate
    ),
    errored: core.schemas.object({
      value: core.schemas.lazy(() => schemas.submission.ErrorInfo),
    }),
    finished: core.schemas.object({}),
  })
  .transform<MyApi.submission.WorkspaceSubmissionUpdateInfo>({
    parse: (value) => {
      switch (value.type) {
        case \\"running\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.running(value.value),
          };
        }
        case \\"ran\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.ran(value),
          };
        }
        case \\"stopped\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.stopped(),
          };
        }
        case \\"traced\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.traced(),
          };
        }
        case \\"tracedV2\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.tracedV2(value),
          };
        }
        case \\"errored\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.errored(value.value),
          };
        }
        case \\"finished\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.finished(),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace WorkspaceSubmissionUpdateInfo {
  type Raw =
    | WorkspaceSubmissionUpdateInfo.Running
    | WorkspaceSubmissionUpdateInfo.Ran
    | WorkspaceSubmissionUpdateInfo.Stopped
    | WorkspaceSubmissionUpdateInfo.Traced
    | WorkspaceSubmissionUpdateInfo.TracedV2
    | WorkspaceSubmissionUpdateInfo.Errored
    | WorkspaceSubmissionUpdateInfo.Finished;

  interface Running {
    type: \\"running\\";
    value: schemas.submission.RunningSubmissionState.Raw;
  }

  interface Ran extends schemas.submission.WorkspaceRunDetails.Raw {
    type: \\"ran\\";
  }

  interface Stopped {
    type: \\"stopped\\";
  }

  interface Traced {
    type: \\"traced\\";
  }

  interface TracedV2 extends schemas.submission.WorkspaceTracedUpdate.Raw {
    type: \\"tracedV2\\";
  }

  interface Errored {
    type: \\"errored\\";
    value: schemas.submission.ErrorInfo.Raw;
  }

  interface Finished {
    type: \\"finished\\";
  }
}
",
                "name": "WorkspaceSubmissionUpdateInfo.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as schemas from \\"../..\\";

export const WorkspaceSubmitRequest: core.schemas.ObjectSchema<
  WorkspaceSubmitRequest.Raw,
  MyApi.submission.WorkspaceSubmitRequest
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => schemas.submission.SubmissionId),
  language: core.schemas.lazy(() => schemas.commons.Language),
  submissionFiles: core.schemas.list(
    core.schemas.lazyObject(() => schemas.submission.SubmissionFileInfo)
  ),
  userId: core.schemas.string().optional(),
});

export declare namespace WorkspaceSubmitRequest {
  interface Raw {
    submissionId: schemas.submission.SubmissionId.Raw;
    language: schemas.commons.Language.Raw;
    submissionFiles: schemas.submission.SubmissionFileInfo.Raw[];
    userId?: string | null;
  }
}
",
                "name": "WorkspaceSubmitRequest.ts",
                "type": "file",
              },
              Object {
                "contents": "import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const WorkspaceTracedUpdate: core.schemas.ObjectSchema<
  WorkspaceTracedUpdate.Raw,
  MyApi.submission.WorkspaceTracedUpdate
> = core.schemas.object({
  traceResponsesSize: core.schemas.number(),
});

export declare namespace WorkspaceTracedUpdate {
  interface Raw {
    traceResponsesSize: number;
  }
}
",
                "name": "WorkspaceTracedUpdate.ts",
                "type": "file",
              },
              Object {
                "contents": "export * from \\"./SubmissionId\\";
export * from \\"./ShareId\\";
export * from \\"./SubmissionRequest\\";
export * from \\"./InitializeProblemRequest\\";
export * from \\"./SubmitRequestV2\\";
export * from \\"./WorkspaceSubmitRequest\\";
export * from \\"./SubmissionFileInfo\\";
export * from \\"./SubmissionTypeEnum\\";
export * from \\"./StopRequest\\";
export * from \\"./SubmissionResponse\\";
export * from \\"./CodeExecutionUpdate\\";
export * from \\"./BuildingExecutorResponse\\";
export * from \\"./RunningResponse\\";
export * from \\"./RunningSubmissionState\\";
export * from \\"./ErroredResponse\\";
export * from \\"./ErrorInfo\\";
export * from \\"./CompileError\\";
export * from \\"./RuntimeError\\";
export * from \\"./InternalError\\";
export * from \\"./StoppedResponse\\";
export * from \\"./WorkspaceRanResponse\\";
export * from \\"./WorkspaceRunDetails\\";
export * from \\"./GradedResponse\\";
export * from \\"./GradedResponseV2\\";
export * from \\"./TestCaseGrade\\";
export * from \\"./TestCaseHiddenGrade\\";
export * from \\"./TestCaseNonHiddenGrade\\";
export * from \\"./RecordedResponseNotification\\";
export * from \\"./RecordingResponseNotification\\";
export * from \\"./LightweightStackframeInformation\\";
export * from \\"./TestCaseResultWithStdout\\";
export * from \\"./TestCaseResult\\";
export * from \\"./ActualResult\\";
export * from \\"./ExceptionV2\\";
export * from \\"./ExceptionInfo\\";
export * from \\"./InvalidRequestResponse\\";
export * from \\"./InvalidRequestCause\\";
export * from \\"./ExistingSubmissionExecuting\\";
export * from \\"./SubmissionIdNotFound\\";
export * from \\"./CustomTestCasesUnsupported\\";
export * from \\"./UnexpectedLanguageError\\";
export * from \\"./TerminatedResponse\\";
export * from \\"./FinishedResponse\\";
export * from \\"./StdoutResponse\\";
export * from \\"./StderrResponse\\";
export * from \\"./TraceResponse\\";
export * from \\"./TraceResponseV2\\";
export * from \\"./TracedFile\\";
export * from \\"./ExpressionLocation\\";
export * from \\"./StackInformation\\";
export * from \\"./StackFrame\\";
export * from \\"./Scope\\";
export * from \\"./ExecutionSessionResponse\\";
export * from \\"./ExecutionSessionStatus\\";
export * from \\"./SubmissionStatusV2\\";
export * from \\"./TestSubmissionStatusV2\\";
export * from \\"./WorkspaceSubmissionStatusV2\\";
export * from \\"./TestSubmissionUpdate\\";
export * from \\"./TestSubmissionUpdateInfo\\";
export * from \\"./WorkspaceSubmissionUpdate\\";
export * from \\"./WorkspaceSubmissionUpdateInfo\\";
export * from \\"./GradedTestCaseUpdate\\";
export * from \\"./RecordedTestCaseUpdate\\";
export * from \\"./WorkspaceTracedUpdate\\";
export * from \\"./SubmissionTypeState\\";
export * from \\"./WorkspaceSubmissionState\\";
export * from \\"./WorkspaceSubmissionStatus\\";
export * from \\"./TestSubmissionState\\";
export * from \\"./TestSubmissionStatus\\";
export * from \\"./SubmissionStatusForTestCase\\";
export * from \\"./TracedTestCase\\";
export * from \\"./TraceResponsesPage\\";
export * from \\"./TraceResponsesPageV2\\";
export * from \\"./GetTraceResponsesPageRequest\\";
export * from \\"./WorkspaceStarterFilesResponse\\";
export * from \\"./WorkspaceStarterFilesResponseV2\\";
export * from \\"./WorkspaceFiles\\";
export * from \\"./ExecutionSessionState\\";
export * from \\"./GetExecutionSessionStateResponse\\";
export * from \\"./GetSubmissionStateResponse\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "types",
            "type": "directory",
          },
        ],
        "name": "submission",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "import * as schemas from \\"../..\\";
import { MyApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  Record<schemas.commons.Language.Raw, number>,
  Record<MyApi.commons.Language.RawValue, number>
> = core.schemas.record(core.schemas.string(), core.schemas.number());
",
                "name": "getNumWarmInstances.ts",
                "type": "file",
              },
              Object {
                "contents": "export * as getNumWarmInstances from \\"./getNumWarmInstances\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "client",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./client\\";
",
            "name": "index.ts",
            "type": "file",
          },
        ],
        "name": "sysprop",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as v3 from \\"./v3\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "import * as schemas from \\"../../..\\";
import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const Response: core.schemas.Schema<
  schemas.v2.problem.LightweightProblemInfoV2.Raw[],
  MyApi.v2.problem.LightweightProblemInfoV2[]
> = core.schemas.list(
  core.schemas.lazyObject(() => schemas.v2.problem.LightweightProblemInfoV2)
);
",
                    "name": "getLightweightProblems.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import * as schemas from \\"../../..\\";
import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const Response: core.schemas.Schema<
  schemas.v2.problem.ProblemInfoV2.Raw[],
  MyApi.v2.problem.ProblemInfoV2[]
> = core.schemas.list(
  core.schemas.lazyObject(() => schemas.v2.problem.ProblemInfoV2)
);
",
                    "name": "getProblems.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const AssertCorrectnessCheck: core.schemas.Schema<
  AssertCorrectnessCheck.Raw,
  MyApi.v2.problem.AssertCorrectnessCheck
> = core.schemas
  .union(\\"type\\", {
    deepEquality: core.schemas.lazyObject(
      () => schemas.v2.problem.DeepEqualityCorrectnessCheck
    ),
    custom: core.schemas.lazyObject(
      () => schemas.v2.problem.VoidFunctionDefinitionThatTakesActualResult
    ),
  })
  .transform<MyApi.v2.problem.AssertCorrectnessCheck>({
    parse: (value) => {
      switch (value.type) {
        case \\"deepEquality\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.deepEquality(value),
          };
        }
        case \\"custom\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.custom(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace AssertCorrectnessCheck {
  type Raw =
    | AssertCorrectnessCheck.DeepEquality
    | AssertCorrectnessCheck.Custom;

  interface DeepEquality
    extends schemas.v2.problem.DeepEqualityCorrectnessCheck.Raw {
    type: \\"deepEquality\\";
  }

  interface Custom
    extends schemas.v2.problem.VoidFunctionDefinitionThatTakesActualResult.Raw {
    type: \\"custom\\";
  }
}
",
                    "name": "AssertCorrectnessCheck.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const BasicCustomFiles: core.schemas.ObjectSchema<
  BasicCustomFiles.Raw,
  MyApi.v2.problem.BasicCustomFiles
> = core.schemas.object({
  methodName: core.schemas.string(),
  signature: core.schemas.lazyObject(
    () => schemas.v2.problem.NonVoidFunctionSignature
  ),
  additionalFiles: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.v2.problem.Files)
  ),
  basicTestCaseTemplate: core.schemas.lazyObject(
    () => schemas.v2.problem.BasicTestCaseTemplate
  ),
});

export declare namespace BasicCustomFiles {
  interface Raw {
    methodName: string;
    signature: schemas.v2.problem.NonVoidFunctionSignature.Raw;
    additionalFiles: Record<
      schemas.commons.Language.Raw,
      schemas.v2.problem.Files.Raw
    >;
    basicTestCaseTemplate: schemas.v2.problem.BasicTestCaseTemplate.Raw;
  }
}
",
                    "name": "BasicCustomFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const BasicTestCaseTemplate: core.schemas.ObjectSchema<
  BasicTestCaseTemplate.Raw,
  MyApi.v2.problem.BasicTestCaseTemplate
> = core.schemas.object({
  templateId: core.schemas.lazy(() => schemas.v2.problem.TestCaseTemplateId),
  name: core.schemas.string(),
  description: core.schemas.lazyObject(
    () => schemas.v2.problem.TestCaseImplementationDescription
  ),
  expectedValueParameterId: core.schemas.lazy(
    () => schemas.v2.problem.ParameterId
  ),
});

export declare namespace BasicTestCaseTemplate {
  interface Raw {
    templateId: schemas.v2.problem.TestCaseTemplateId.Raw;
    name: string;
    description: schemas.v2.problem.TestCaseImplementationDescription.Raw;
    expectedValueParameterId: schemas.v2.problem.ParameterId.Raw;
  }
}
",
                    "name": "BasicTestCaseTemplate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const CreateProblemRequestV2: core.schemas.ObjectSchema<
  CreateProblemRequestV2.Raw,
  MyApi.v2.problem.CreateProblemRequestV2
> = core.schemas.object({
  problemName: core.schemas.string(),
  problemDescription: core.schemas.lazyObject(
    () => schemas.problem.ProblemDescription
  ),
  customFiles: core.schemas.lazy(() => schemas.v2.problem.CustomFiles),
  customTestCaseTemplates: core.schemas.list(
    core.schemas.lazyObject(() => schemas.v2.problem.TestCaseTemplate)
  ),
  testcases: core.schemas.list(
    core.schemas.lazyObject(() => schemas.v2.problem.TestCaseV2)
  ),
  supportedLanguages: core.schemas.list(
    core.schemas.lazy(() => schemas.commons.Language)
  ),
  isPublic: core.schemas.boolean(),
});

export declare namespace CreateProblemRequestV2 {
  interface Raw {
    problemName: string;
    problemDescription: schemas.problem.ProblemDescription.Raw;
    customFiles: schemas.v2.problem.CustomFiles.Raw;
    customTestCaseTemplates: schemas.v2.problem.TestCaseTemplate.Raw[];
    testcases: schemas.v2.problem.TestCaseV2.Raw[];
    supportedLanguages: schemas.commons.Language.Raw[];
    isPublic: boolean;
  }
}
",
                    "name": "CreateProblemRequestV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const CustomFiles: core.schemas.Schema<
  CustomFiles.Raw,
  MyApi.v2.problem.CustomFiles
> = core.schemas
  .union(\\"type\\", {
    basic: core.schemas.lazyObject(() => schemas.v2.problem.BasicCustomFiles),
    custom: core.schemas.object({
      value: core.schemas.record(
        core.schemas.string(),
        core.schemas.lazyObject(() => schemas.v2.problem.Files)
      ),
    }),
  })
  .transform<MyApi.v2.problem.CustomFiles>({
    parse: (value) => {
      switch (value.type) {
        case \\"basic\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.basic(value),
          };
        }
        case \\"custom\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.custom(value.value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace CustomFiles {
  type Raw = CustomFiles.Basic | CustomFiles.Custom;

  interface Basic extends schemas.v2.problem.BasicCustomFiles.Raw {
    type: \\"basic\\";
  }

  interface Custom {
    type: \\"custom\\";
    value: Record<schemas.commons.Language.Raw, schemas.v2.problem.Files.Raw>;
  }
}
",
                    "name": "CustomFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const DeepEqualityCorrectnessCheck: core.schemas.ObjectSchema<
  DeepEqualityCorrectnessCheck.Raw,
  MyApi.v2.problem.DeepEqualityCorrectnessCheck
> = core.schemas.object({
  expectedValueParameterId: core.schemas.lazy(
    () => schemas.v2.problem.ParameterId
  ),
});

export declare namespace DeepEqualityCorrectnessCheck {
  interface Raw {
    expectedValueParameterId: schemas.v2.problem.ParameterId.Raw;
  }
}
",
                    "name": "DeepEqualityCorrectnessCheck.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const DefaultProvidedFile: core.schemas.ObjectSchema<
  DefaultProvidedFile.Raw,
  MyApi.v2.problem.DefaultProvidedFile
> = core.schemas.object({
  file: core.schemas.lazyObject(() => schemas.v2.problem.FileInfoV2),
  relatedTypes: core.schemas.list(
    core.schemas.lazy(() => schemas.commons.VariableType)
  ),
});

export declare namespace DefaultProvidedFile {
  interface Raw {
    file: schemas.v2.problem.FileInfoV2.Raw;
    relatedTypes: schemas.commons.VariableType.Raw[];
  }
}
",
                    "name": "DefaultProvidedFile.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const FileInfoV2: core.schemas.ObjectSchema<
  FileInfoV2.Raw,
  MyApi.v2.problem.FileInfoV2
> = core.schemas.object({
  filename: core.schemas.string(),
  directory: core.schemas.string(),
  contents: core.schemas.string(),
  editable: core.schemas.boolean(),
});

export declare namespace FileInfoV2 {
  interface Raw {
    filename: string;
    directory: string;
    contents: string;
    editable: boolean;
  }
}
",
                    "name": "FileInfoV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const Files: core.schemas.ObjectSchema<
  Files.Raw,
  MyApi.v2.problem.Files
> = core.schemas.object({
  files: core.schemas.list(
    core.schemas.lazyObject(() => schemas.v2.problem.FileInfoV2)
  ),
});

export declare namespace Files {
  interface Raw {
    files: schemas.v2.problem.FileInfoV2.Raw[];
  }
}
",
                    "name": "Files.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const FunctionImplementation: core.schemas.ObjectSchema<
  FunctionImplementation.Raw,
  MyApi.v2.problem.FunctionImplementation
> = core.schemas.object({
  impl: core.schemas.string(),
  imports: core.schemas.string().optional(),
});

export declare namespace FunctionImplementation {
  interface Raw {
    impl: string;
    imports?: string | null;
  }
}
",
                    "name": "FunctionImplementation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const FunctionImplementationForMultipleLanguages: core.schemas.ObjectSchema<
  FunctionImplementationForMultipleLanguages.Raw,
  MyApi.v2.problem.FunctionImplementationForMultipleLanguages
> = core.schemas.object({
  codeByLanguage: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.v2.problem.FunctionImplementation)
  ),
});

export declare namespace FunctionImplementationForMultipleLanguages {
  interface Raw {
    codeByLanguage: Record<
      schemas.commons.Language.Raw,
      schemas.v2.problem.FunctionImplementation.Raw
    >;
  }
}
",
                    "name": "FunctionImplementationForMultipleLanguages.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const FunctionSignature: core.schemas.Schema<
  FunctionSignature.Raw,
  MyApi.v2.problem.FunctionSignature
> = core.schemas
  .union(\\"type\\", {
    void: core.schemas.lazyObject(
      () => schemas.v2.problem.VoidFunctionSignature
    ),
    nonVoid: core.schemas.lazyObject(
      () => schemas.v2.problem.NonVoidFunctionSignature
    ),
    voidThatTakesActualResult: core.schemas.lazyObject(
      () => schemas.v2.problem.VoidFunctionSignatureThatTakesActualResult
    ),
  })
  .transform<MyApi.v2.problem.FunctionSignature>({
    parse: (value) => {
      switch (value.type) {
        case \\"void\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.void(value),
          };
        }
        case \\"nonVoid\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.nonVoid(value),
          };
        }
        case \\"voidThatTakesActualResult\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.voidThatTakesActualResult(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace FunctionSignature {
  type Raw =
    | FunctionSignature.Void
    | FunctionSignature.NonVoid
    | FunctionSignature.VoidThatTakesActualResult;

  interface Void extends schemas.v2.problem.VoidFunctionSignature.Raw {
    type: \\"void\\";
  }

  interface NonVoid extends schemas.v2.problem.NonVoidFunctionSignature.Raw {
    type: \\"nonVoid\\";
  }

  interface VoidThatTakesActualResult
    extends schemas.v2.problem.VoidFunctionSignatureThatTakesActualResult.Raw {
    type: \\"voidThatTakesActualResult\\";
  }
}
",
                    "name": "FunctionSignature.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const GeneratedFiles: core.schemas.ObjectSchema<
  GeneratedFiles.Raw,
  MyApi.v2.problem.GeneratedFiles
> = core.schemas.object({
  generatedTestCaseFiles: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.v2.problem.Files)
  ),
  generatedTemplateFiles: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.v2.problem.Files)
  ),
  other: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.v2.problem.Files)
  ),
});

export declare namespace GeneratedFiles {
  interface Raw {
    generatedTestCaseFiles: Record<
      schemas.commons.Language.Raw,
      schemas.v2.problem.Files.Raw
    >;
    generatedTemplateFiles: Record<
      schemas.commons.Language.Raw,
      schemas.v2.problem.Files.Raw
    >;
    other: Record<schemas.commons.Language.Raw, schemas.v2.problem.Files.Raw>;
  }
}
",
                    "name": "GeneratedFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const GetBasicSolutionFileRequest: core.schemas.ObjectSchema<
  GetBasicSolutionFileRequest.Raw,
  MyApi.v2.problem.GetBasicSolutionFileRequest
> = core.schemas.object({
  methodName: core.schemas.string(),
  signature: core.schemas.lazyObject(
    () => schemas.v2.problem.NonVoidFunctionSignature
  ),
});

export declare namespace GetBasicSolutionFileRequest {
  interface Raw {
    methodName: string;
    signature: schemas.v2.problem.NonVoidFunctionSignature.Raw;
  }
}
",
                    "name": "GetBasicSolutionFileRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const GetBasicSolutionFileResponse: core.schemas.ObjectSchema<
  GetBasicSolutionFileResponse.Raw,
  MyApi.v2.problem.GetBasicSolutionFileResponse
> = core.schemas.object({
  solutionFileByLanguage: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.v2.problem.FileInfoV2)
  ),
});

export declare namespace GetBasicSolutionFileResponse {
  interface Raw {
    solutionFileByLanguage: Record<
      schemas.commons.Language.Raw,
      schemas.v2.problem.FileInfoV2.Raw
    >;
  }
}
",
                    "name": "GetBasicSolutionFileResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const GetFunctionSignatureRequest: core.schemas.ObjectSchema<
  GetFunctionSignatureRequest.Raw,
  MyApi.v2.problem.GetFunctionSignatureRequest
> = core.schemas.object({
  functionSignature: core.schemas.lazy(
    () => schemas.v2.problem.FunctionSignature
  ),
});

export declare namespace GetFunctionSignatureRequest {
  interface Raw {
    functionSignature: schemas.v2.problem.FunctionSignature.Raw;
  }
}
",
                    "name": "GetFunctionSignatureRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const GetFunctionSignatureResponse: core.schemas.ObjectSchema<
  GetFunctionSignatureResponse.Raw,
  MyApi.v2.problem.GetFunctionSignatureResponse
> = core.schemas.object({
  functionByLanguage: core.schemas.record(
    core.schemas.string(),
    core.schemas.string()
  ),
});

export declare namespace GetFunctionSignatureResponse {
  interface Raw {
    functionByLanguage: Record<schemas.commons.Language.Raw, string>;
  }
}
",
                    "name": "GetFunctionSignatureResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const GetGeneratedTestCaseFileRequest: core.schemas.ObjectSchema<
  GetGeneratedTestCaseFileRequest.Raw,
  MyApi.v2.problem.GetGeneratedTestCaseFileRequest
> = core.schemas.object({
  template: core.schemas
    .lazyObject(() => schemas.v2.problem.TestCaseTemplate)
    .optional(),
  testCase: core.schemas.lazyObject(() => schemas.v2.problem.TestCaseV2),
});

export declare namespace GetGeneratedTestCaseFileRequest {
  interface Raw {
    template?: schemas.v2.problem.TestCaseTemplate.Raw | null;
    testCase: schemas.v2.problem.TestCaseV2.Raw;
  }
}
",
                    "name": "GetGeneratedTestCaseFileRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const GetGeneratedTestCaseTemplateFileRequest: core.schemas.ObjectSchema<
  GetGeneratedTestCaseTemplateFileRequest.Raw,
  MyApi.v2.problem.GetGeneratedTestCaseTemplateFileRequest
> = core.schemas.object({
  template: core.schemas.lazyObject(() => schemas.v2.problem.TestCaseTemplate),
});

export declare namespace GetGeneratedTestCaseTemplateFileRequest {
  interface Raw {
    template: schemas.v2.problem.TestCaseTemplate.Raw;
  }
}
",
                    "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const LightweightProblemInfoV2: core.schemas.ObjectSchema<
  LightweightProblemInfoV2.Raw,
  MyApi.v2.problem.LightweightProblemInfoV2
> = core.schemas.object({
  problemId: core.schemas.lazy(() => schemas.commons.ProblemId),
  problemName: core.schemas.string(),
  problemVersion: core.schemas.number(),
  variableTypes: core.schemas.list(
    core.schemas.lazy(() => schemas.commons.VariableType)
  ),
});

export declare namespace LightweightProblemInfoV2 {
  interface Raw {
    problemId: schemas.commons.ProblemId.Raw;
    problemName: string;
    problemVersion: number;
    variableTypes: schemas.commons.VariableType.Raw[];
  }
}
",
                    "name": "LightweightProblemInfoV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const NonVoidFunctionDefinition: core.schemas.ObjectSchema<
  NonVoidFunctionDefinition.Raw,
  MyApi.v2.problem.NonVoidFunctionDefinition
> = core.schemas.object({
  signature: core.schemas.lazyObject(
    () => schemas.v2.problem.NonVoidFunctionSignature
  ),
  code: core.schemas.lazyObject(
    () => schemas.v2.problem.FunctionImplementationForMultipleLanguages
  ),
});

export declare namespace NonVoidFunctionDefinition {
  interface Raw {
    signature: schemas.v2.problem.NonVoidFunctionSignature.Raw;
    code: schemas.v2.problem.FunctionImplementationForMultipleLanguages.Raw;
  }
}
",
                    "name": "NonVoidFunctionDefinition.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const NonVoidFunctionSignature: core.schemas.ObjectSchema<
  NonVoidFunctionSignature.Raw,
  MyApi.v2.problem.NonVoidFunctionSignature
> = core.schemas.object({
  parameters: core.schemas.list(
    core.schemas.lazyObject(() => schemas.v2.problem.Parameter)
  ),
  returnType: core.schemas.lazy(() => schemas.commons.VariableType),
});

export declare namespace NonVoidFunctionSignature {
  interface Raw {
    parameters: schemas.v2.problem.Parameter.Raw[];
    returnType: schemas.commons.VariableType.Raw;
  }
}
",
                    "name": "NonVoidFunctionSignature.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const Parameter: core.schemas.ObjectSchema<
  Parameter.Raw,
  MyApi.v2.problem.Parameter
> = core.schemas.object({
  parameterId: core.schemas.lazy(() => schemas.v2.problem.ParameterId),
  name: core.schemas.string(),
  variableType: core.schemas.lazy(() => schemas.commons.VariableType),
});

export declare namespace Parameter {
  interface Raw {
    parameterId: schemas.v2.problem.ParameterId.Raw;
    name: string;
    variableType: schemas.commons.VariableType.Raw;
  }
}
",
                    "name": "Parameter.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const ParameterId: core.schemas.Schema<
  ParameterId.Raw,
  MyApi.v2.problem.ParameterId
> = core.schemas.string();

export declare namespace ParameterId {
  type Raw = string;
}
",
                    "name": "ParameterId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const ProblemInfoV2: core.schemas.ObjectSchema<
  ProblemInfoV2.Raw,
  MyApi.v2.problem.ProblemInfoV2
> = core.schemas.object({
  problemId: core.schemas.lazy(() => schemas.commons.ProblemId),
  problemDescription: core.schemas.lazyObject(
    () => schemas.problem.ProblemDescription
  ),
  problemName: core.schemas.string(),
  problemVersion: core.schemas.number(),
  supportedLanguages: core.schemas.list(
    core.schemas.lazy(() => schemas.commons.Language)
  ),
  customFiles: core.schemas.lazy(() => schemas.v2.problem.CustomFiles),
  generatedFiles: core.schemas.lazyObject(
    () => schemas.v2.problem.GeneratedFiles
  ),
  customTestCaseTemplates: core.schemas.list(
    core.schemas.lazyObject(() => schemas.v2.problem.TestCaseTemplate)
  ),
  testcases: core.schemas.list(
    core.schemas.lazyObject(() => schemas.v2.problem.TestCaseV2)
  ),
  isPublic: core.schemas.boolean(),
});

export declare namespace ProblemInfoV2 {
  interface Raw {
    problemId: schemas.commons.ProblemId.Raw;
    problemDescription: schemas.problem.ProblemDescription.Raw;
    problemName: string;
    problemVersion: number;
    supportedLanguages: schemas.commons.Language.Raw[];
    customFiles: schemas.v2.problem.CustomFiles.Raw;
    generatedFiles: schemas.v2.problem.GeneratedFiles.Raw;
    customTestCaseTemplates: schemas.v2.problem.TestCaseTemplate.Raw[];
    testcases: schemas.v2.problem.TestCaseV2.Raw[];
    isPublic: boolean;
  }
}
",
                    "name": "ProblemInfoV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const TestCaseExpects: core.schemas.ObjectSchema<
  TestCaseExpects.Raw,
  MyApi.v2.problem.TestCaseExpects
> = core.schemas.object({
  expectedStdout: core.schemas.string().optional(),
});

export declare namespace TestCaseExpects {
  interface Raw {
    expectedStdout?: string | null;
  }
}
",
                    "name": "TestCaseExpects.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const TestCaseFunction: core.schemas.Schema<
  TestCaseFunction.Raw,
  MyApi.v2.problem.TestCaseFunction
> = core.schemas
  .union(\\"type\\", {
    withActualResult: core.schemas.lazyObject(
      () => schemas.v2.problem.TestCaseWithActualResultImplementation
    ),
    custom: core.schemas.lazyObject(
      () => schemas.v2.problem.VoidFunctionDefinition
    ),
  })
  .transform<MyApi.v2.problem.TestCaseFunction>({
    parse: (value) => {
      switch (value.type) {
        case \\"withActualResult\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.withActualResult(value),
          };
        }
        case \\"custom\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.custom(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestCaseFunction {
  type Raw = TestCaseFunction.WithActualResult | TestCaseFunction.Custom;

  interface WithActualResult
    extends schemas.v2.problem.TestCaseWithActualResultImplementation.Raw {
    type: \\"withActualResult\\";
  }

  interface Custom extends schemas.v2.problem.VoidFunctionDefinition.Raw {
    type: \\"custom\\";
  }
}
",
                    "name": "TestCaseFunction.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const TestCaseId: core.schemas.Schema<
  TestCaseId.Raw,
  MyApi.v2.problem.TestCaseId
> = core.schemas.string();

export declare namespace TestCaseId {
  type Raw = string;
}
",
                    "name": "TestCaseId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const TestCaseImplementation: core.schemas.ObjectSchema<
  TestCaseImplementation.Raw,
  MyApi.v2.problem.TestCaseImplementation
> = core.schemas.object({
  description: core.schemas.lazyObject(
    () => schemas.v2.problem.TestCaseImplementationDescription
  ),
  function: core.schemas.lazy(() => schemas.v2.problem.TestCaseFunction),
});

export declare namespace TestCaseImplementation {
  interface Raw {
    description: schemas.v2.problem.TestCaseImplementationDescription.Raw;
    function: schemas.v2.problem.TestCaseFunction.Raw;
  }
}
",
                    "name": "TestCaseImplementation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const TestCaseImplementationDescription: core.schemas.ObjectSchema<
  TestCaseImplementationDescription.Raw,
  MyApi.v2.problem.TestCaseImplementationDescription
> = core.schemas.object({
  boards: core.schemas.list(
    core.schemas.lazy(
      () => schemas.v2.problem.TestCaseImplementationDescriptionBoard
    )
  ),
});

export declare namespace TestCaseImplementationDescription {
  interface Raw {
    boards: schemas.v2.problem.TestCaseImplementationDescriptionBoard.Raw[];
  }
}
",
                    "name": "TestCaseImplementationDescription.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const TestCaseImplementationDescriptionBoard: core.schemas.Schema<
  TestCaseImplementationDescriptionBoard.Raw,
  MyApi.v2.problem.TestCaseImplementationDescriptionBoard
> = core.schemas
  .union(\\"type\\", {
    html: core.schemas.object({
      value: core.schemas.string(),
    }),
    paramId: core.schemas.object({
      value: core.schemas.lazy(() => schemas.v2.problem.ParameterId),
    }),
  })
  .transform<MyApi.v2.problem.TestCaseImplementationDescriptionBoard>({
    parse: (value) => {
      switch (value.type) {
        case \\"html\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.html(value.value),
          };
        }
        case \\"paramId\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.paramId(value.value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestCaseImplementationDescriptionBoard {
  type Raw =
    | TestCaseImplementationDescriptionBoard.Html
    | TestCaseImplementationDescriptionBoard.ParamId;

  interface Html {
    type: \\"html\\";
    value: string;
  }

  interface ParamId {
    type: \\"paramId\\";
    value: schemas.v2.problem.ParameterId.Raw;
  }
}
",
                    "name": "TestCaseImplementationDescriptionBoard.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const TestCaseImplementationReference: core.schemas.Schema<
  TestCaseImplementationReference.Raw,
  MyApi.v2.problem.TestCaseImplementationReference
> = core.schemas
  .union(\\"type\\", {
    templateId: core.schemas.object({
      value: core.schemas.lazy(() => schemas.v2.problem.TestCaseTemplateId),
    }),
    implementation: core.schemas.lazyObject(
      () => schemas.v2.problem.TestCaseImplementation
    ),
  })
  .transform<MyApi.v2.problem.TestCaseImplementationReference>({
    parse: (value) => {
      switch (value.type) {
        case \\"templateId\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.templateId(value.value),
          };
        }
        case \\"implementation\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.implementation(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestCaseImplementationReference {
  type Raw =
    | TestCaseImplementationReference.TemplateId
    | TestCaseImplementationReference.Implementation;

  interface TemplateId {
    type: \\"templateId\\";
    value: schemas.v2.problem.TestCaseTemplateId.Raw;
  }

  interface Implementation
    extends schemas.v2.problem.TestCaseImplementation.Raw {
    type: \\"implementation\\";
  }
}
",
                    "name": "TestCaseImplementationReference.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const TestCaseMetadata: core.schemas.ObjectSchema<
  TestCaseMetadata.Raw,
  MyApi.v2.problem.TestCaseMetadata
> = core.schemas.object({
  id: core.schemas.lazy(() => schemas.v2.problem.TestCaseId),
  name: core.schemas.string(),
  hidden: core.schemas.boolean(),
});

export declare namespace TestCaseMetadata {
  interface Raw {
    id: schemas.v2.problem.TestCaseId.Raw;
    name: string;
    hidden: boolean;
  }
}
",
                    "name": "TestCaseMetadata.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const TestCaseTemplate: core.schemas.ObjectSchema<
  TestCaseTemplate.Raw,
  MyApi.v2.problem.TestCaseTemplate
> = core.schemas.object({
  templateId: core.schemas.lazy(() => schemas.v2.problem.TestCaseTemplateId),
  name: core.schemas.string(),
  implementation: core.schemas.lazyObject(
    () => schemas.v2.problem.TestCaseImplementation
  ),
});

export declare namespace TestCaseTemplate {
  interface Raw {
    templateId: schemas.v2.problem.TestCaseTemplateId.Raw;
    name: string;
    implementation: schemas.v2.problem.TestCaseImplementation.Raw;
  }
}
",
                    "name": "TestCaseTemplate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";

export const TestCaseTemplateId: core.schemas.Schema<
  TestCaseTemplateId.Raw,
  MyApi.v2.problem.TestCaseTemplateId
> = core.schemas.string();

export declare namespace TestCaseTemplateId {
  type Raw = string;
}
",
                    "name": "TestCaseTemplateId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const TestCaseV2: core.schemas.ObjectSchema<
  TestCaseV2.Raw,
  MyApi.v2.problem.TestCaseV2
> = core.schemas.object({
  metadata: core.schemas.lazyObject(() => schemas.v2.problem.TestCaseMetadata),
  implementation: core.schemas.lazy(
    () => schemas.v2.problem.TestCaseImplementationReference
  ),
  arguments: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazy(() => schemas.commons.VariableValue)
  ),
  expects: core.schemas
    .lazyObject(() => schemas.v2.problem.TestCaseExpects)
    .optional(),
});

export declare namespace TestCaseV2 {
  interface Raw {
    metadata: schemas.v2.problem.TestCaseMetadata.Raw;
    implementation: schemas.v2.problem.TestCaseImplementationReference.Raw;
    arguments: Record<
      schemas.v2.problem.ParameterId.Raw,
      schemas.commons.VariableValue.Raw
    >;
    expects?: schemas.v2.problem.TestCaseExpects.Raw | null;
  }
}
",
                    "name": "TestCaseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const TestCaseWithActualResultImplementation: core.schemas.ObjectSchema<
  TestCaseWithActualResultImplementation.Raw,
  MyApi.v2.problem.TestCaseWithActualResultImplementation
> = core.schemas.object({
  getActualResult: core.schemas.lazyObject(
    () => schemas.v2.problem.NonVoidFunctionDefinition
  ),
  assertCorrectnessCheck: core.schemas.lazy(
    () => schemas.v2.problem.AssertCorrectnessCheck
  ),
});

export declare namespace TestCaseWithActualResultImplementation {
  interface Raw {
    getActualResult: schemas.v2.problem.NonVoidFunctionDefinition.Raw;
    assertCorrectnessCheck: schemas.v2.problem.AssertCorrectnessCheck.Raw;
  }
}
",
                    "name": "TestCaseWithActualResultImplementation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const VoidFunctionDefinition: core.schemas.ObjectSchema<
  VoidFunctionDefinition.Raw,
  MyApi.v2.problem.VoidFunctionDefinition
> = core.schemas.object({
  parameters: core.schemas.list(
    core.schemas.lazyObject(() => schemas.v2.problem.Parameter)
  ),
  code: core.schemas.lazyObject(
    () => schemas.v2.problem.FunctionImplementationForMultipleLanguages
  ),
});

export declare namespace VoidFunctionDefinition {
  interface Raw {
    parameters: schemas.v2.problem.Parameter.Raw[];
    code: schemas.v2.problem.FunctionImplementationForMultipleLanguages.Raw;
  }
}
",
                    "name": "VoidFunctionDefinition.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const VoidFunctionDefinitionThatTakesActualResult: core.schemas.ObjectSchema<
  VoidFunctionDefinitionThatTakesActualResult.Raw,
  MyApi.v2.problem.VoidFunctionDefinitionThatTakesActualResult
> = core.schemas.object({
  additionalParameters: core.schemas.list(
    core.schemas.lazyObject(() => schemas.v2.problem.Parameter)
  ),
  code: core.schemas.lazyObject(
    () => schemas.v2.problem.FunctionImplementationForMultipleLanguages
  ),
});

export declare namespace VoidFunctionDefinitionThatTakesActualResult {
  interface Raw {
    additionalParameters: schemas.v2.problem.Parameter.Raw[];
    code: schemas.v2.problem.FunctionImplementationForMultipleLanguages.Raw;
  }
}
",
                    "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const VoidFunctionSignature: core.schemas.ObjectSchema<
  VoidFunctionSignature.Raw,
  MyApi.v2.problem.VoidFunctionSignature
> = core.schemas.object({
  parameters: core.schemas.list(
    core.schemas.lazyObject(() => schemas.v2.problem.Parameter)
  ),
});

export declare namespace VoidFunctionSignature {
  interface Raw {
    parameters: schemas.v2.problem.Parameter.Raw[];
  }
}
",
                    "name": "VoidFunctionSignature.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "import { MyApi } from \\"../../../..\\";
import * as core from \\"../../../../core\\";
import * as schemas from \\"../../..\\";

export const VoidFunctionSignatureThatTakesActualResult: core.schemas.ObjectSchema<
  VoidFunctionSignatureThatTakesActualResult.Raw,
  MyApi.v2.problem.VoidFunctionSignatureThatTakesActualResult
> = core.schemas.object({
  parameters: core.schemas.list(
    core.schemas.lazyObject(() => schemas.v2.problem.Parameter)
  ),
  actualResultType: core.schemas.lazy(() => schemas.commons.VariableType),
});

export declare namespace VoidFunctionSignatureThatTakesActualResult {
  interface Raw {
    parameters: schemas.v2.problem.Parameter.Raw[];
    actualResultType: schemas.commons.VariableType.Raw;
  }
}
",
                    "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "problem",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import * as schemas from \\"../../../..\\";
import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const Response: core.schemas.Schema<
  schemas.v2.v3.problem.LightweightProblemInfoV2.Raw[],
  MyApi.v2.v3.problem.LightweightProblemInfoV2[]
> = core.schemas.list(
  core.schemas.lazyObject(() => schemas.v2.v3.problem.LightweightProblemInfoV2)
);
",
                        "name": "getLightweightProblems.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import * as schemas from \\"../../../..\\";
import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const Response: core.schemas.Schema<
  schemas.v2.v3.problem.ProblemInfoV2.Raw[],
  MyApi.v2.v3.problem.ProblemInfoV2[]
> = core.schemas.list(
  core.schemas.lazyObject(() => schemas.v2.v3.problem.ProblemInfoV2)
);
",
                        "name": "getProblems.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "client",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const AssertCorrectnessCheck: core.schemas.Schema<
  AssertCorrectnessCheck.Raw,
  MyApi.v2.v3.problem.AssertCorrectnessCheck
> = core.schemas
  .union(\\"type\\", {
    deepEquality: core.schemas.lazyObject(
      () => schemas.v2.v3.problem.DeepEqualityCorrectnessCheck
    ),
    custom: core.schemas.lazyObject(
      () => schemas.v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult
    ),
  })
  .transform<MyApi.v2.v3.problem.AssertCorrectnessCheck>({
    parse: (value) => {
      switch (value.type) {
        case \\"deepEquality\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.deepEquality(value),
          };
        }
        case \\"custom\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.custom(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace AssertCorrectnessCheck {
  type Raw =
    | AssertCorrectnessCheck.DeepEquality
    | AssertCorrectnessCheck.Custom;

  interface DeepEquality
    extends schemas.v2.v3.problem.DeepEqualityCorrectnessCheck.Raw {
    type: \\"deepEquality\\";
  }

  interface Custom
    extends schemas.v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult
      .Raw {
    type: \\"custom\\";
  }
}
",
                        "name": "AssertCorrectnessCheck.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const BasicCustomFiles: core.schemas.ObjectSchema<
  BasicCustomFiles.Raw,
  MyApi.v2.v3.problem.BasicCustomFiles
> = core.schemas.object({
  methodName: core.schemas.string(),
  signature: core.schemas.lazyObject(
    () => schemas.v2.v3.problem.NonVoidFunctionSignature
  ),
  additionalFiles: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.v2.v3.problem.Files)
  ),
  basicTestCaseTemplate: core.schemas.lazyObject(
    () => schemas.v2.v3.problem.BasicTestCaseTemplate
  ),
});

export declare namespace BasicCustomFiles {
  interface Raw {
    methodName: string;
    signature: schemas.v2.v3.problem.NonVoidFunctionSignature.Raw;
    additionalFiles: Record<
      schemas.commons.Language.Raw,
      schemas.v2.v3.problem.Files.Raw
    >;
    basicTestCaseTemplate: schemas.v2.v3.problem.BasicTestCaseTemplate.Raw;
  }
}
",
                        "name": "BasicCustomFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const BasicTestCaseTemplate: core.schemas.ObjectSchema<
  BasicTestCaseTemplate.Raw,
  MyApi.v2.v3.problem.BasicTestCaseTemplate
> = core.schemas.object({
  templateId: core.schemas.lazy(() => schemas.v2.v3.problem.TestCaseTemplateId),
  name: core.schemas.string(),
  description: core.schemas.lazyObject(
    () => schemas.v2.v3.problem.TestCaseImplementationDescription
  ),
  expectedValueParameterId: core.schemas.lazy(
    () => schemas.v2.v3.problem.ParameterId
  ),
});

export declare namespace BasicTestCaseTemplate {
  interface Raw {
    templateId: schemas.v2.v3.problem.TestCaseTemplateId.Raw;
    name: string;
    description: schemas.v2.v3.problem.TestCaseImplementationDescription.Raw;
    expectedValueParameterId: schemas.v2.v3.problem.ParameterId.Raw;
  }
}
",
                        "name": "BasicTestCaseTemplate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const CreateProblemRequestV2: core.schemas.ObjectSchema<
  CreateProblemRequestV2.Raw,
  MyApi.v2.v3.problem.CreateProblemRequestV2
> = core.schemas.object({
  problemName: core.schemas.string(),
  problemDescription: core.schemas.lazyObject(
    () => schemas.problem.ProblemDescription
  ),
  customFiles: core.schemas.lazy(() => schemas.v2.v3.problem.CustomFiles),
  customTestCaseTemplates: core.schemas.list(
    core.schemas.lazyObject(() => schemas.v2.v3.problem.TestCaseTemplate)
  ),
  testcases: core.schemas.list(
    core.schemas.lazyObject(() => schemas.v2.v3.problem.TestCaseV2)
  ),
  supportedLanguages: core.schemas.list(
    core.schemas.lazy(() => schemas.commons.Language)
  ),
  isPublic: core.schemas.boolean(),
});

export declare namespace CreateProblemRequestV2 {
  interface Raw {
    problemName: string;
    problemDescription: schemas.problem.ProblemDescription.Raw;
    customFiles: schemas.v2.v3.problem.CustomFiles.Raw;
    customTestCaseTemplates: schemas.v2.v3.problem.TestCaseTemplate.Raw[];
    testcases: schemas.v2.v3.problem.TestCaseV2.Raw[];
    supportedLanguages: schemas.commons.Language.Raw[];
    isPublic: boolean;
  }
}
",
                        "name": "CreateProblemRequestV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const CustomFiles: core.schemas.Schema<
  CustomFiles.Raw,
  MyApi.v2.v3.problem.CustomFiles
> = core.schemas
  .union(\\"type\\", {
    basic: core.schemas.lazyObject(
      () => schemas.v2.v3.problem.BasicCustomFiles
    ),
    custom: core.schemas.object({
      value: core.schemas.record(
        core.schemas.string(),
        core.schemas.lazyObject(() => schemas.v2.v3.problem.Files)
      ),
    }),
  })
  .transform<MyApi.v2.v3.problem.CustomFiles>({
    parse: (value) => {
      switch (value.type) {
        case \\"basic\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.basic(value),
          };
        }
        case \\"custom\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.custom(value.value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace CustomFiles {
  type Raw = CustomFiles.Basic | CustomFiles.Custom;

  interface Basic extends schemas.v2.v3.problem.BasicCustomFiles.Raw {
    type: \\"basic\\";
  }

  interface Custom {
    type: \\"custom\\";
    value: Record<
      schemas.commons.Language.Raw,
      schemas.v2.v3.problem.Files.Raw
    >;
  }
}
",
                        "name": "CustomFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const DeepEqualityCorrectnessCheck: core.schemas.ObjectSchema<
  DeepEqualityCorrectnessCheck.Raw,
  MyApi.v2.v3.problem.DeepEqualityCorrectnessCheck
> = core.schemas.object({
  expectedValueParameterId: core.schemas.lazy(
    () => schemas.v2.v3.problem.ParameterId
  ),
});

export declare namespace DeepEqualityCorrectnessCheck {
  interface Raw {
    expectedValueParameterId: schemas.v2.v3.problem.ParameterId.Raw;
  }
}
",
                        "name": "DeepEqualityCorrectnessCheck.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const DefaultProvidedFile: core.schemas.ObjectSchema<
  DefaultProvidedFile.Raw,
  MyApi.v2.v3.problem.DefaultProvidedFile
> = core.schemas.object({
  file: core.schemas.lazyObject(() => schemas.v2.v3.problem.FileInfoV2),
  relatedTypes: core.schemas.list(
    core.schemas.lazy(() => schemas.commons.VariableType)
  ),
});

export declare namespace DefaultProvidedFile {
  interface Raw {
    file: schemas.v2.v3.problem.FileInfoV2.Raw;
    relatedTypes: schemas.commons.VariableType.Raw[];
  }
}
",
                        "name": "DefaultProvidedFile.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const FileInfoV2: core.schemas.ObjectSchema<
  FileInfoV2.Raw,
  MyApi.v2.v3.problem.FileInfoV2
> = core.schemas.object({
  filename: core.schemas.string(),
  directory: core.schemas.string(),
  contents: core.schemas.string(),
  editable: core.schemas.boolean(),
});

export declare namespace FileInfoV2 {
  interface Raw {
    filename: string;
    directory: string;
    contents: string;
    editable: boolean;
  }
}
",
                        "name": "FileInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const Files: core.schemas.ObjectSchema<
  Files.Raw,
  MyApi.v2.v3.problem.Files
> = core.schemas.object({
  files: core.schemas.list(
    core.schemas.lazyObject(() => schemas.v2.v3.problem.FileInfoV2)
  ),
});

export declare namespace Files {
  interface Raw {
    files: schemas.v2.v3.problem.FileInfoV2.Raw[];
  }
}
",
                        "name": "Files.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const FunctionImplementation: core.schemas.ObjectSchema<
  FunctionImplementation.Raw,
  MyApi.v2.v3.problem.FunctionImplementation
> = core.schemas.object({
  impl: core.schemas.string(),
  imports: core.schemas.string().optional(),
});

export declare namespace FunctionImplementation {
  interface Raw {
    impl: string;
    imports?: string | null;
  }
}
",
                        "name": "FunctionImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const FunctionImplementationForMultipleLanguages: core.schemas.ObjectSchema<
  FunctionImplementationForMultipleLanguages.Raw,
  MyApi.v2.v3.problem.FunctionImplementationForMultipleLanguages
> = core.schemas.object({
  codeByLanguage: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.v2.v3.problem.FunctionImplementation)
  ),
});

export declare namespace FunctionImplementationForMultipleLanguages {
  interface Raw {
    codeByLanguage: Record<
      schemas.commons.Language.Raw,
      schemas.v2.v3.problem.FunctionImplementation.Raw
    >;
  }
}
",
                        "name": "FunctionImplementationForMultipleLanguages.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const FunctionSignature: core.schemas.Schema<
  FunctionSignature.Raw,
  MyApi.v2.v3.problem.FunctionSignature
> = core.schemas
  .union(\\"type\\", {
    void: core.schemas.lazyObject(
      () => schemas.v2.v3.problem.VoidFunctionSignature
    ),
    nonVoid: core.schemas.lazyObject(
      () => schemas.v2.v3.problem.NonVoidFunctionSignature
    ),
    voidThatTakesActualResult: core.schemas.lazyObject(
      () => schemas.v2.v3.problem.VoidFunctionSignatureThatTakesActualResult
    ),
  })
  .transform<MyApi.v2.v3.problem.FunctionSignature>({
    parse: (value) => {
      switch (value.type) {
        case \\"void\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.void(value),
          };
        }
        case \\"nonVoid\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.nonVoid(value),
          };
        }
        case \\"voidThatTakesActualResult\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.voidThatTakesActualResult(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace FunctionSignature {
  type Raw =
    | FunctionSignature.Void
    | FunctionSignature.NonVoid
    | FunctionSignature.VoidThatTakesActualResult;

  interface Void extends schemas.v2.v3.problem.VoidFunctionSignature.Raw {
    type: \\"void\\";
  }

  interface NonVoid extends schemas.v2.v3.problem.NonVoidFunctionSignature.Raw {
    type: \\"nonVoid\\";
  }

  interface VoidThatTakesActualResult
    extends schemas.v2.v3.problem.VoidFunctionSignatureThatTakesActualResult
      .Raw {
    type: \\"voidThatTakesActualResult\\";
  }
}
",
                        "name": "FunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const GeneratedFiles: core.schemas.ObjectSchema<
  GeneratedFiles.Raw,
  MyApi.v2.v3.problem.GeneratedFiles
> = core.schemas.object({
  generatedTestCaseFiles: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.v2.v3.problem.Files)
  ),
  generatedTemplateFiles: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.v2.v3.problem.Files)
  ),
  other: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.v2.v3.problem.Files)
  ),
});

export declare namespace GeneratedFiles {
  interface Raw {
    generatedTestCaseFiles: Record<
      schemas.commons.Language.Raw,
      schemas.v2.v3.problem.Files.Raw
    >;
    generatedTemplateFiles: Record<
      schemas.commons.Language.Raw,
      schemas.v2.v3.problem.Files.Raw
    >;
    other: Record<
      schemas.commons.Language.Raw,
      schemas.v2.v3.problem.Files.Raw
    >;
  }
}
",
                        "name": "GeneratedFiles.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const GetBasicSolutionFileRequest: core.schemas.ObjectSchema<
  GetBasicSolutionFileRequest.Raw,
  MyApi.v2.v3.problem.GetBasicSolutionFileRequest
> = core.schemas.object({
  methodName: core.schemas.string(),
  signature: core.schemas.lazyObject(
    () => schemas.v2.v3.problem.NonVoidFunctionSignature
  ),
});

export declare namespace GetBasicSolutionFileRequest {
  interface Raw {
    methodName: string;
    signature: schemas.v2.v3.problem.NonVoidFunctionSignature.Raw;
  }
}
",
                        "name": "GetBasicSolutionFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const GetBasicSolutionFileResponse: core.schemas.ObjectSchema<
  GetBasicSolutionFileResponse.Raw,
  MyApi.v2.v3.problem.GetBasicSolutionFileResponse
> = core.schemas.object({
  solutionFileByLanguage: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => schemas.v2.v3.problem.FileInfoV2)
  ),
});

export declare namespace GetBasicSolutionFileResponse {
  interface Raw {
    solutionFileByLanguage: Record<
      schemas.commons.Language.Raw,
      schemas.v2.v3.problem.FileInfoV2.Raw
    >;
  }
}
",
                        "name": "GetBasicSolutionFileResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const GetFunctionSignatureRequest: core.schemas.ObjectSchema<
  GetFunctionSignatureRequest.Raw,
  MyApi.v2.v3.problem.GetFunctionSignatureRequest
> = core.schemas.object({
  functionSignature: core.schemas.lazy(
    () => schemas.v2.v3.problem.FunctionSignature
  ),
});

export declare namespace GetFunctionSignatureRequest {
  interface Raw {
    functionSignature: schemas.v2.v3.problem.FunctionSignature.Raw;
  }
}
",
                        "name": "GetFunctionSignatureRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const GetFunctionSignatureResponse: core.schemas.ObjectSchema<
  GetFunctionSignatureResponse.Raw,
  MyApi.v2.v3.problem.GetFunctionSignatureResponse
> = core.schemas.object({
  functionByLanguage: core.schemas.record(
    core.schemas.string(),
    core.schemas.string()
  ),
});

export declare namespace GetFunctionSignatureResponse {
  interface Raw {
    functionByLanguage: Record<schemas.commons.Language.Raw, string>;
  }
}
",
                        "name": "GetFunctionSignatureResponse.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const GetGeneratedTestCaseFileRequest: core.schemas.ObjectSchema<
  GetGeneratedTestCaseFileRequest.Raw,
  MyApi.v2.v3.problem.GetGeneratedTestCaseFileRequest
> = core.schemas.object({
  template: core.schemas
    .lazyObject(() => schemas.v2.v3.problem.TestCaseTemplate)
    .optional(),
  testCase: core.schemas.lazyObject(() => schemas.v2.v3.problem.TestCaseV2),
});

export declare namespace GetGeneratedTestCaseFileRequest {
  interface Raw {
    template?: schemas.v2.v3.problem.TestCaseTemplate.Raw | null;
    testCase: schemas.v2.v3.problem.TestCaseV2.Raw;
  }
}
",
                        "name": "GetGeneratedTestCaseFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const GetGeneratedTestCaseTemplateFileRequest: core.schemas.ObjectSchema<
  GetGeneratedTestCaseTemplateFileRequest.Raw,
  MyApi.v2.v3.problem.GetGeneratedTestCaseTemplateFileRequest
> = core.schemas.object({
  template: core.schemas.lazyObject(
    () => schemas.v2.v3.problem.TestCaseTemplate
  ),
});

export declare namespace GetGeneratedTestCaseTemplateFileRequest {
  interface Raw {
    template: schemas.v2.v3.problem.TestCaseTemplate.Raw;
  }
}
",
                        "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const LightweightProblemInfoV2: core.schemas.ObjectSchema<
  LightweightProblemInfoV2.Raw,
  MyApi.v2.v3.problem.LightweightProblemInfoV2
> = core.schemas.object({
  problemId: core.schemas.lazy(() => schemas.commons.ProblemId),
  problemName: core.schemas.string(),
  problemVersion: core.schemas.number(),
  variableTypes: core.schemas.list(
    core.schemas.lazy(() => schemas.commons.VariableType)
  ),
});

export declare namespace LightweightProblemInfoV2 {
  interface Raw {
    problemId: schemas.commons.ProblemId.Raw;
    problemName: string;
    problemVersion: number;
    variableTypes: schemas.commons.VariableType.Raw[];
  }
}
",
                        "name": "LightweightProblemInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const NonVoidFunctionDefinition: core.schemas.ObjectSchema<
  NonVoidFunctionDefinition.Raw,
  MyApi.v2.v3.problem.NonVoidFunctionDefinition
> = core.schemas.object({
  signature: core.schemas.lazyObject(
    () => schemas.v2.v3.problem.NonVoidFunctionSignature
  ),
  code: core.schemas.lazyObject(
    () => schemas.v2.v3.problem.FunctionImplementationForMultipleLanguages
  ),
});

export declare namespace NonVoidFunctionDefinition {
  interface Raw {
    signature: schemas.v2.v3.problem.NonVoidFunctionSignature.Raw;
    code: schemas.v2.v3.problem.FunctionImplementationForMultipleLanguages.Raw;
  }
}
",
                        "name": "NonVoidFunctionDefinition.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const NonVoidFunctionSignature: core.schemas.ObjectSchema<
  NonVoidFunctionSignature.Raw,
  MyApi.v2.v3.problem.NonVoidFunctionSignature
> = core.schemas.object({
  parameters: core.schemas.list(
    core.schemas.lazyObject(() => schemas.v2.v3.problem.Parameter)
  ),
  returnType: core.schemas.lazy(() => schemas.commons.VariableType),
});

export declare namespace NonVoidFunctionSignature {
  interface Raw {
    parameters: schemas.v2.v3.problem.Parameter.Raw[];
    returnType: schemas.commons.VariableType.Raw;
  }
}
",
                        "name": "NonVoidFunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const Parameter: core.schemas.ObjectSchema<
  Parameter.Raw,
  MyApi.v2.v3.problem.Parameter
> = core.schemas.object({
  parameterId: core.schemas.lazy(() => schemas.v2.v3.problem.ParameterId),
  name: core.schemas.string(),
  variableType: core.schemas.lazy(() => schemas.commons.VariableType),
});

export declare namespace Parameter {
  interface Raw {
    parameterId: schemas.v2.v3.problem.ParameterId.Raw;
    name: string;
    variableType: schemas.commons.VariableType.Raw;
  }
}
",
                        "name": "Parameter.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const ParameterId: core.schemas.Schema<
  ParameterId.Raw,
  MyApi.v2.v3.problem.ParameterId
> = core.schemas.string();

export declare namespace ParameterId {
  type Raw = string;
}
",
                        "name": "ParameterId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const ProblemInfoV2: core.schemas.ObjectSchema<
  ProblemInfoV2.Raw,
  MyApi.v2.v3.problem.ProblemInfoV2
> = core.schemas.object({
  problemId: core.schemas.lazy(() => schemas.commons.ProblemId),
  problemDescription: core.schemas.lazyObject(
    () => schemas.problem.ProblemDescription
  ),
  problemName: core.schemas.string(),
  problemVersion: core.schemas.number(),
  supportedLanguages: core.schemas.list(
    core.schemas.lazy(() => schemas.commons.Language)
  ),
  customFiles: core.schemas.lazy(() => schemas.v2.v3.problem.CustomFiles),
  generatedFiles: core.schemas.lazyObject(
    () => schemas.v2.v3.problem.GeneratedFiles
  ),
  customTestCaseTemplates: core.schemas.list(
    core.schemas.lazyObject(() => schemas.v2.v3.problem.TestCaseTemplate)
  ),
  testcases: core.schemas.list(
    core.schemas.lazyObject(() => schemas.v2.v3.problem.TestCaseV2)
  ),
  isPublic: core.schemas.boolean(),
});

export declare namespace ProblemInfoV2 {
  interface Raw {
    problemId: schemas.commons.ProblemId.Raw;
    problemDescription: schemas.problem.ProblemDescription.Raw;
    problemName: string;
    problemVersion: number;
    supportedLanguages: schemas.commons.Language.Raw[];
    customFiles: schemas.v2.v3.problem.CustomFiles.Raw;
    generatedFiles: schemas.v2.v3.problem.GeneratedFiles.Raw;
    customTestCaseTemplates: schemas.v2.v3.problem.TestCaseTemplate.Raw[];
    testcases: schemas.v2.v3.problem.TestCaseV2.Raw[];
    isPublic: boolean;
  }
}
",
                        "name": "ProblemInfoV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const TestCaseExpects: core.schemas.ObjectSchema<
  TestCaseExpects.Raw,
  MyApi.v2.v3.problem.TestCaseExpects
> = core.schemas.object({
  expectedStdout: core.schemas.string().optional(),
});

export declare namespace TestCaseExpects {
  interface Raw {
    expectedStdout?: string | null;
  }
}
",
                        "name": "TestCaseExpects.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const TestCaseFunction: core.schemas.Schema<
  TestCaseFunction.Raw,
  MyApi.v2.v3.problem.TestCaseFunction
> = core.schemas
  .union(\\"type\\", {
    withActualResult: core.schemas.lazyObject(
      () => schemas.v2.v3.problem.TestCaseWithActualResultImplementation
    ),
    custom: core.schemas.lazyObject(
      () => schemas.v2.v3.problem.VoidFunctionDefinition
    ),
  })
  .transform<MyApi.v2.v3.problem.TestCaseFunction>({
    parse: (value) => {
      switch (value.type) {
        case \\"withActualResult\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.withActualResult(value),
          };
        }
        case \\"custom\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.custom(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestCaseFunction {
  type Raw = TestCaseFunction.WithActualResult | TestCaseFunction.Custom;

  interface WithActualResult
    extends schemas.v2.v3.problem.TestCaseWithActualResultImplementation.Raw {
    type: \\"withActualResult\\";
  }

  interface Custom extends schemas.v2.v3.problem.VoidFunctionDefinition.Raw {
    type: \\"custom\\";
  }
}
",
                        "name": "TestCaseFunction.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const TestCaseId: core.schemas.Schema<
  TestCaseId.Raw,
  MyApi.v2.v3.problem.TestCaseId
> = core.schemas.string();

export declare namespace TestCaseId {
  type Raw = string;
}
",
                        "name": "TestCaseId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const TestCaseImplementation: core.schemas.ObjectSchema<
  TestCaseImplementation.Raw,
  MyApi.v2.v3.problem.TestCaseImplementation
> = core.schemas.object({
  description: core.schemas.lazyObject(
    () => schemas.v2.v3.problem.TestCaseImplementationDescription
  ),
  function: core.schemas.lazy(() => schemas.v2.v3.problem.TestCaseFunction),
});

export declare namespace TestCaseImplementation {
  interface Raw {
    description: schemas.v2.v3.problem.TestCaseImplementationDescription.Raw;
    function: schemas.v2.v3.problem.TestCaseFunction.Raw;
  }
}
",
                        "name": "TestCaseImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const TestCaseImplementationDescription: core.schemas.ObjectSchema<
  TestCaseImplementationDescription.Raw,
  MyApi.v2.v3.problem.TestCaseImplementationDescription
> = core.schemas.object({
  boards: core.schemas.list(
    core.schemas.lazy(
      () => schemas.v2.v3.problem.TestCaseImplementationDescriptionBoard
    )
  ),
});

export declare namespace TestCaseImplementationDescription {
  interface Raw {
    boards: schemas.v2.v3.problem.TestCaseImplementationDescriptionBoard.Raw[];
  }
}
",
                        "name": "TestCaseImplementationDescription.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const TestCaseImplementationDescriptionBoard: core.schemas.Schema<
  TestCaseImplementationDescriptionBoard.Raw,
  MyApi.v2.v3.problem.TestCaseImplementationDescriptionBoard
> = core.schemas
  .union(\\"type\\", {
    html: core.schemas.object({
      value: core.schemas.string(),
    }),
    paramId: core.schemas.object({
      value: core.schemas.lazy(() => schemas.v2.v3.problem.ParameterId),
    }),
  })
  .transform<MyApi.v2.v3.problem.TestCaseImplementationDescriptionBoard>({
    parse: (value) => {
      switch (value.type) {
        case \\"html\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.html(value.value),
          };
        }
        case \\"paramId\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.paramId(value.value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestCaseImplementationDescriptionBoard {
  type Raw =
    | TestCaseImplementationDescriptionBoard.Html
    | TestCaseImplementationDescriptionBoard.ParamId;

  interface Html {
    type: \\"html\\";
    value: string;
  }

  interface ParamId {
    type: \\"paramId\\";
    value: schemas.v2.v3.problem.ParameterId.Raw;
  }
}
",
                        "name": "TestCaseImplementationDescriptionBoard.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const TestCaseImplementationReference: core.schemas.Schema<
  TestCaseImplementationReference.Raw,
  MyApi.v2.v3.problem.TestCaseImplementationReference
> = core.schemas
  .union(\\"type\\", {
    templateId: core.schemas.object({
      value: core.schemas.lazy(() => schemas.v2.v3.problem.TestCaseTemplateId),
    }),
    implementation: core.schemas.lazyObject(
      () => schemas.v2.v3.problem.TestCaseImplementation
    ),
  })
  .transform<MyApi.v2.v3.problem.TestCaseImplementationReference>({
    parse: (value) => {
      switch (value.type) {
        case \\"templateId\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.templateId(value.value),
          };
        }
        case \\"implementation\\": {
          return {
            ...value,
            _visit: (visitor) => visitor.implementation(value),
          };
        }
        default: {
          return {
            ...(value as any),
            _visit: (visitor) => visitor._other(value),
          };
        }
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestCaseImplementationReference {
  type Raw =
    | TestCaseImplementationReference.TemplateId
    | TestCaseImplementationReference.Implementation;

  interface TemplateId {
    type: \\"templateId\\";
    value: schemas.v2.v3.problem.TestCaseTemplateId.Raw;
  }

  interface Implementation
    extends schemas.v2.v3.problem.TestCaseImplementation.Raw {
    type: \\"implementation\\";
  }
}
",
                        "name": "TestCaseImplementationReference.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const TestCaseMetadata: core.schemas.ObjectSchema<
  TestCaseMetadata.Raw,
  MyApi.v2.v3.problem.TestCaseMetadata
> = core.schemas.object({
  id: core.schemas.lazy(() => schemas.v2.v3.problem.TestCaseId),
  name: core.schemas.string(),
  hidden: core.schemas.boolean(),
});

export declare namespace TestCaseMetadata {
  interface Raw {
    id: schemas.v2.v3.problem.TestCaseId.Raw;
    name: string;
    hidden: boolean;
  }
}
",
                        "name": "TestCaseMetadata.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const TestCaseTemplate: core.schemas.ObjectSchema<
  TestCaseTemplate.Raw,
  MyApi.v2.v3.problem.TestCaseTemplate
> = core.schemas.object({
  templateId: core.schemas.lazy(() => schemas.v2.v3.problem.TestCaseTemplateId),
  name: core.schemas.string(),
  implementation: core.schemas.lazyObject(
    () => schemas.v2.v3.problem.TestCaseImplementation
  ),
});

export declare namespace TestCaseTemplate {
  interface Raw {
    templateId: schemas.v2.v3.problem.TestCaseTemplateId.Raw;
    name: string;
    implementation: schemas.v2.v3.problem.TestCaseImplementation.Raw;
  }
}
",
                        "name": "TestCaseTemplate.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const TestCaseTemplateId: core.schemas.Schema<
  TestCaseTemplateId.Raw,
  MyApi.v2.v3.problem.TestCaseTemplateId
> = core.schemas.string();

export declare namespace TestCaseTemplateId {
  type Raw = string;
}
",
                        "name": "TestCaseTemplateId.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const TestCaseV2: core.schemas.ObjectSchema<
  TestCaseV2.Raw,
  MyApi.v2.v3.problem.TestCaseV2
> = core.schemas.object({
  metadata: core.schemas.lazyObject(
    () => schemas.v2.v3.problem.TestCaseMetadata
  ),
  implementation: core.schemas.lazy(
    () => schemas.v2.v3.problem.TestCaseImplementationReference
  ),
  arguments: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazy(() => schemas.commons.VariableValue)
  ),
  expects: core.schemas
    .lazyObject(() => schemas.v2.v3.problem.TestCaseExpects)
    .optional(),
});

export declare namespace TestCaseV2 {
  interface Raw {
    metadata: schemas.v2.v3.problem.TestCaseMetadata.Raw;
    implementation: schemas.v2.v3.problem.TestCaseImplementationReference.Raw;
    arguments: Record<
      schemas.v2.v3.problem.ParameterId.Raw,
      schemas.commons.VariableValue.Raw
    >;
    expects?: schemas.v2.v3.problem.TestCaseExpects.Raw | null;
  }
}
",
                        "name": "TestCaseV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const TestCaseWithActualResultImplementation: core.schemas.ObjectSchema<
  TestCaseWithActualResultImplementation.Raw,
  MyApi.v2.v3.problem.TestCaseWithActualResultImplementation
> = core.schemas.object({
  getActualResult: core.schemas.lazyObject(
    () => schemas.v2.v3.problem.NonVoidFunctionDefinition
  ),
  assertCorrectnessCheck: core.schemas.lazy(
    () => schemas.v2.v3.problem.AssertCorrectnessCheck
  ),
});

export declare namespace TestCaseWithActualResultImplementation {
  interface Raw {
    getActualResult: schemas.v2.v3.problem.NonVoidFunctionDefinition.Raw;
    assertCorrectnessCheck: schemas.v2.v3.problem.AssertCorrectnessCheck.Raw;
  }
}
",
                        "name": "TestCaseWithActualResultImplementation.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const VoidFunctionDefinition: core.schemas.ObjectSchema<
  VoidFunctionDefinition.Raw,
  MyApi.v2.v3.problem.VoidFunctionDefinition
> = core.schemas.object({
  parameters: core.schemas.list(
    core.schemas.lazyObject(() => schemas.v2.v3.problem.Parameter)
  ),
  code: core.schemas.lazyObject(
    () => schemas.v2.v3.problem.FunctionImplementationForMultipleLanguages
  ),
});

export declare namespace VoidFunctionDefinition {
  interface Raw {
    parameters: schemas.v2.v3.problem.Parameter.Raw[];
    code: schemas.v2.v3.problem.FunctionImplementationForMultipleLanguages.Raw;
  }
}
",
                        "name": "VoidFunctionDefinition.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const VoidFunctionDefinitionThatTakesActualResult: core.schemas.ObjectSchema<
  VoidFunctionDefinitionThatTakesActualResult.Raw,
  MyApi.v2.v3.problem.VoidFunctionDefinitionThatTakesActualResult
> = core.schemas.object({
  additionalParameters: core.schemas.list(
    core.schemas.lazyObject(() => schemas.v2.v3.problem.Parameter)
  ),
  code: core.schemas.lazyObject(
    () => schemas.v2.v3.problem.FunctionImplementationForMultipleLanguages
  ),
});

export declare namespace VoidFunctionDefinitionThatTakesActualResult {
  interface Raw {
    additionalParameters: schemas.v2.v3.problem.Parameter.Raw[];
    code: schemas.v2.v3.problem.FunctionImplementationForMultipleLanguages.Raw;
  }
}
",
                        "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const VoidFunctionSignature: core.schemas.ObjectSchema<
  VoidFunctionSignature.Raw,
  MyApi.v2.v3.problem.VoidFunctionSignature
> = core.schemas.object({
  parameters: core.schemas.list(
    core.schemas.lazyObject(() => schemas.v2.v3.problem.Parameter)
  ),
});

export declare namespace VoidFunctionSignature {
  interface Raw {
    parameters: schemas.v2.v3.problem.Parameter.Raw[];
  }
}
",
                        "name": "VoidFunctionSignature.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { MyApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as schemas from \\"../../../..\\";

export const VoidFunctionSignatureThatTakesActualResult: core.schemas.ObjectSchema<
  VoidFunctionSignatureThatTakesActualResult.Raw,
  MyApi.v2.v3.problem.VoidFunctionSignatureThatTakesActualResult
> = core.schemas.object({
  parameters: core.schemas.list(
    core.schemas.lazyObject(() => schemas.v2.v3.problem.Parameter)
  ),
  actualResultType: core.schemas.lazy(() => schemas.commons.VariableType),
});

export declare namespace VoidFunctionSignatureThatTakesActualResult {
  interface Raw {
    parameters: schemas.v2.v3.problem.Parameter.Raw[];
    actualResultType: schemas.commons.VariableType.Raw;
  }
}
",
                        "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "types",
                    "type": "directory",
                  },
                ],
                "name": "problem",
                "type": "directory",
              },
            ],
            "name": "v3",
            "type": "directory",
          },
        ],
        "name": "v2",
        "type": "directory",
      },
    ],
    "name": "schemas",
    "type": "directory",
  },
  Object {
    "contents": "{
    \\"compilerOptions\\": {
        \\"strict\\": true,
        \\"target\\": \\"esnext\\",
        \\"moduleResolution\\": \\"node\\",
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"sourceMap\\": true,
        \\"emitDeclarationOnly\\": true,
        \\"esModuleInterop\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true
    }
}",
    "name": "tsconfig.json",
    "type": "file",
  },
]
`;
