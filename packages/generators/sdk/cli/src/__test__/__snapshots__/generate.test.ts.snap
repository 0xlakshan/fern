// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`runGenerator fiddle 1`] = `
Array [
  Object {
    "contents": "node_modules
.DS_Store
*.d.ts
*.js
*.js.map
*.cjs
*.mjs

# yarn berry
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions

# these are needed to override '*.js' above
!.yarn/patches/**
!.yarn/plugins/**
!.yarn/releases/**
!.yarn/sdks/**
!.yarn/versions/**",
    "name": ".gitignore",
    "type": "file",
  },
  Object {
    "contents": ".yarn
node_modules
.npmignore
.pnp.cjs
*.js
*.d.ts",
    "name": ".prettierignore",
    "type": "file",
  },
  Object {
    "contents": "nodeLinker: pnp

yarnPath: .yarn/releases/yarn-3.2.4.cjs
",
    "name": ".yarnrc.yml",
    "type": "file",
  },
  Object {
    "contents": "{
    \\"name\\": \\"@fern-fern/fiddle-sdk\\",
    \\"version\\": \\"\\",
    \\"files\\": [
        \\"index.mjs\\",
        \\"index.cjs\\",
        \\"browser.js\\",
        \\"browser.js.map\\",
        \\"*.d.ts\\"
    ],
    \\"exports\\": {
        \\".\\": {
            \\"import\\": \\"./index.mjs\\",
            \\"module\\": \\"./index.mjs\\",
            \\"require\\": \\"./index.cjs\\",
            \\"browser\\": \\"./browser.js\\",
            \\"default\\": \\"./index.cjs\\"
        }
    },
    \\"types\\": \\"./index.d.ts\\",
    \\"scripts\\": {
        \\"format\\": \\"prettier --write --print-width 120 src/**/*.ts\\",
        \\"build:esm\\": \\"esbuild src/index.ts --bundle --platform=node --format=esm --outfile=index.mjs\\",
        \\"build:cjs\\": \\"esbuild src/index.ts --bundle --platform=node --format=cjs --outfile=index.cjs\\",
        \\"build:browser\\": \\"esbuild src/index.ts --bundle --platform=browser --sourcemap --outfile=browser.js\\",
        \\"build\\": \\"yarn build:esm && yarn build:cjs && yarn build:browser && tsc && tsc-alias\\"
    },
    \\"dependencies\\": {
        \\"@types/url-join\\": \\"4.0.1\\",
        \\"axios\\": \\"^0.27.2\\",
        \\"url-join\\": \\"4.0.1\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"esbuild\\": \\"0.16.13\\",
        \\"prettier\\": \\"2.7.1\\",
        \\"tsc-alias\\": \\"^1.7.1\\",
        \\"typescript\\": \\"4.6.4\\"
    },
    \\"packageManager\\": \\"yarn@3.2.4\\"
}
",
    "name": "package.json",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Client as HealthClient } from \\"./resources/health/client/Client\\";
import { Client as RemoteGenClient } from \\"./resources/remoteGen/client/Client\\";

export declare namespace FernFiddleClient {
  interface Options {
    environment: string;
  }
}

export class FernFiddleClient {
  constructor(private readonly options: FernFiddleClient.Options) {}

  #health: HealthClient | undefined;

  public get health(): HealthClient {
    return (this.#health ??= new HealthClient(this.options));
  }

  #remoteGen: RemoteGenClient | undefined;

  public get remoteGen(): RemoteGenClient {
    return (this.#remoteGen ??= new RemoteGenClient(this.options));
  }
}
",
        "name": "Client.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "export type APIResponse<Success, Failure> = SuccessfulResponse<Success> | FailedResponse<Failure>;

export interface SuccessfulResponse<T> {
  ok: true;
  body: T;
}

export interface FailedResponse<T> {
  ok: false;
  error: T;
}
",
                "name": "APIResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import axios, { AxiosError } from \\"axios\\";
import { APIResponse } from \\"./APIResponse\\";

export interface Fetcher {
  fetch: FetchFunction;
}

export type FetchFunction = (args: Fetcher.Args) => Promise<APIResponse<unknown, Fetcher.Error>>;

export declare namespace Fetcher {
  export interface Args {
    url: string;
    method: string;
    headers?: Record<string, string | undefined>;
    queryParameters?: URLSearchParams;
    body?: unknown;
    timeoutMs?: number;
  }

  export type Error = FailedStatusCodeError | NonJsonError | TimeoutError | UnknownError;

  export interface FailedStatusCodeError {
    reason: \\"status-code\\";
    statusCode: number;
    body: unknown;
  }

  export interface NonJsonError {
    reason: \\"non-json\\";
    statusCode: number;
    rawBody: string;
  }

  export interface TimeoutError {
    reason: \\"timeout\\";
  }

  export interface UnknownError {
    reason: \\"unknown\\";
    errorMessage: string;
  }
}

export const fetcher: FetchFunction = async (args) => {
  const headers: Record<string, string> = {
    \\"Content-Type\\": \\"application/json\\",
  };

  if (args.headers != null) {
    for (const [key, value] of Object.entries(args.headers)) {
      if (value != null) {
        headers[key] = value;
      }
    }
  }

  try {
    const response = await axios({
      url: args.url,
      params: args.queryParameters,
      method: args.method,
      headers,
      data: args.body,
      validateStatus: () => true,
      transformResponse: (response) => response,
      timeout: args.timeoutMs ?? 60_000,
      transitional: {
        clarifyTimeoutError: true,
      },
      withCredentials: true,
    });

    let body: unknown;
    if (response.data != null && response.data.length > 0) {
      try {
        body = JSON.parse(response.data) ?? undefined;
      } catch {
        return {
          ok: false,
          error: {
            reason: \\"non-json\\",
            statusCode: response.status,
            rawBody: response.data,
          },
        };
      }
    }

    if (response.status >= 200 && response.status < 300) {
      return {
        ok: true,
        body,
      };
    } else {
      return {
        ok: false,
        error: {
          reason: \\"status-code\\",
          statusCode: response.status,
          body,
        },
      };
    }
  } catch (error) {
    if ((error as AxiosError).code === \\"ETIMEDOUT\\") {
      return {
        ok: false,
        error: {
          reason: \\"timeout\\",
        },
      };
    }

    return {
      ok: false,
      error: {
        reason: \\"unknown\\",
        errorMessage: (error as AxiosError).message,
      },
    };
  }
};
",
                "name": "Fetcher.ts",
                "type": "file",
              },
              Object {
                "contents": "export type Supplier<T> = T | Promise<T> | (() => T | Promise<T>);

export const Supplier = {
  get: async <T>(supplier: Supplier<T>): Promise<T> => {
    if (typeof supplier === \\"function\\") {
      return (supplier as () => T)();
    } else {
      return supplier;
    }
  },
};
",
                "name": "Supplier.ts",
                "type": "file",
              },
              Object {
                "contents": "export { type APIResponse } from \\"./APIResponse\\";
export { fetcher, type Fetcher, type FetchFunction } from \\"./Fetcher\\";
export { Supplier } from \\"./Supplier\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "fetcher",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./utils\\";
export * as schemas from \\"./schemas\\";
export * from \\"./fetcher\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { SchemaUtils } from \\"./builders\\";

export type Schema<Raw = unknown, Parsed = unknown> = BaseSchema<Raw, Parsed> & SchemaUtils<Raw, Parsed>;

export type inferRaw<S extends Schema> = S extends Schema<infer Raw, any> ? Raw : never;
export type inferParsed<S extends Schema> = S extends Schema<any, infer Parsed> ? Parsed : never;

export interface BaseSchema<Raw, Parsed> {
  parse: (raw: Raw, opts?: SchemaOptions) => Parsed | Promise<Parsed>;
  json: (parsed: Parsed, opts?: SchemaOptions) => Raw | Promise<Raw>;
}

export interface SchemaOptions {
  /**
   * @default false
   */
  skipUnknownKeysOnParse?: boolean;

  /**
   * @default false
   */
  includeUnknownKeysOnJson?: boolean;
}
",
                "name": "Schema.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function date(): Schema<string, Date> {
  const baseSchema: BaseSchema<string, Date> = {
    parse: (raw) => new Date(raw),
    json: (date) => date.toISOString(),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "date.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { date } from \\"./date\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "date",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function enum_<U extends string, E extends Readonly<[U, ...U[]]>>(_values: E): Schema<E[number], E[number]> {
  return createIdentitySchemaCreator<E[number]>()();
}
",
                        "name": "enum.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { enum_ } from \\"./enum\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "enum",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { identity } from \\"./identity\\";

export function createIdentitySchemaCreator<T>(): () => Schema<T, T> {
  return <T>() => identity<T>();
}
",
                        "name": "createIdentitySchemaCreator.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function identity<T>(): Schema<T, T> {
  const baseSchema: BaseSchema<T, T> = {
    parse: (raw) => raw,
    json: (parsed) => parsed,
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "identity.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { createIdentitySchemaCreator } from \\"./createIdentitySchemaCreator\\";
export { identity } from \\"./identity\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "identity",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./date\\";
export * from \\"./enum\\";
export * from \\"./identity\\";
export * from \\"./lazy\\";
export * from \\"./list\\";
export * from \\"./literals\\";
export * from \\"./object\\";
export * from \\"./object-like\\";
export * from \\"./primitives\\";
export * from \\"./record\\";
export * from \\"./schema-utils\\";
export * from \\"./set\\";
export * from \\"./union\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { lazy, type SchemaGetter } from \\"./lazy\\";
export { lazyObject } from \\"./lazyObject\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export type SchemaGetter<SchemaType extends Schema<any, any>> = () => SchemaType | Promise<SchemaType>;

export function lazy<Raw, Parsed>(getter: SchemaGetter<Schema<Raw, Parsed>>): Schema<Raw, Parsed> {
  const baseSchema = constructLazyBaseSchema(getter);
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function constructLazyBaseSchema<Raw, Parsed>(
  getter: SchemaGetter<Schema<Raw, Parsed>>
): BaseSchema<Raw, Parsed> {
  return {
    parse: async (raw) => (await getMemoizedSchema(getter)).parse(raw),
    json: async (parsed) => (await getMemoizedSchema(getter)).json(parsed),
  };
}

type MemoizedGetter<SchemaType extends Schema<any, any>> = SchemaGetter<SchemaType> & { __zurg_memoized?: SchemaType };

export async function getMemoizedSchema<SchemaType extends Schema<any, any>>(
  getter: SchemaGetter<SchemaType>
): Promise<SchemaType> {
  const castedGetter = getter as MemoizedGetter<SchemaType>;
  if (castedGetter.__zurg_memoized == null) {
    castedGetter.__zurg_memoized = await getter();
  }
  return castedGetter.__zurg_memoized;
}
",
                        "name": "lazy.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { getObjectUtils } from \\"../object\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { BaseObjectSchema, ObjectSchema } from \\"../object/types\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { constructLazyBaseSchema, getMemoizedSchema, SchemaGetter } from \\"./lazy\\";

export function lazyObject<Raw, Parsed>(getter: SchemaGetter<ObjectSchema<Raw, Parsed>>): ObjectSchema<Raw, Parsed> {
  const baseSchema: BaseObjectSchema<Raw, Parsed> = {
    ...OBJECT_LIKE_BRAND,
    ...constructLazyBaseSchema(getter),
    _getRawProperties: async () => (await getMemoizedSchema(getter))._getRawProperties(),
    _getParsedProperties: async () => (await getMemoizedSchema(getter))._getParsedProperties(),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}
",
                        "name": "lazyObject.ts",
                        "type": "file",
                      },
                    ],
                    "name": "lazy",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { list } from \\"./list\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function list<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Parsed[]> {
  const baseSchema: BaseSchema<Raw[], Parsed[]> = {
    parse: (raw, opts) => Promise.all(raw.map((item) => schema.parse(item, opts))),
    json: (parsed, opts) => Promise.all(parsed.map((item) => schema.json(item, opts))),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "list.ts",
                        "type": "file",
                      },
                    ],
                    "name": "list",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { stringLiteral } from \\"./stringLiteral\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function stringLiteral<V extends string>(_value: V): Schema<V, V> {
  return createIdentitySchemaCreator<V>()();
}
",
                        "name": "stringLiteral.ts",
                        "type": "file",
                      },
                    ],
                    "name": "literals",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { getObjectUtils, object } from \\"./object\\";
export { isProperty, property, type Property } from \\"./property\\";
export {
  type BaseObjectSchema,
  type inferObjectSchemaFromPropertySchemas,
  type inferParsedObject,
  type inferParsedObjectFromPropertySchemas,
  type inferParsedPropertySchema,
  type inferRawKey,
  type inferRawObject,
  type inferRawObjectFromPropertySchemas,
  type inferRawPropertySchema,
  type ObjectSchema,
  type ObjectUtils,
  type PropertySchemas,
} from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { filterObject } from \\"../../utils/filterObject\\";
import { keys } from \\"../../utils/keys\\";
import { partition } from \\"../../utils/partition\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { isProperty } from \\"./property\\";
import {
  BaseObjectSchema,
  inferObjectSchemaFromPropertySchemas,
  inferParsedObjectFromPropertySchemas,
  inferRawObjectFromPropertySchemas,
  ObjectSchema,
  ObjectUtils,
  PropertySchemas,
} from \\"./types\\";

interface ObjectPropertyWithRawKey {
  rawKey: string;
  parsedKey: string | number | symbol;
  valueSchema: Schema<any, any>;
}

export function object<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(
  schemas: T
): inferObjectSchemaFromPropertySchemas<T> {
  const baseSchema: BaseObjectSchema<inferRawObjectFromPropertySchemas<T>, inferParsedObjectFromPropertySchemas<T>> = {
    ...OBJECT_LIKE_BRAND,
    _getRawProperties: () =>
      Promise.resolve(
        Object.entries(schemas).map(([parsedKey, propertySchema]) =>
          isProperty(propertySchema) ? propertySchema.rawKey : parsedKey
        ) as unknown as (keyof inferRawObjectFromPropertySchemas<T>)[]
      ),
    _getParsedProperties: () =>
      Promise.resolve(keys(schemas) as unknown as (keyof inferParsedObjectFromPropertySchemas<T>)[]),

    parse: async (raw, { skipUnknownKeysOnParse = false } = {}) => {
      const rawKeyToProperty: Record<string, ObjectPropertyWithRawKey> = {};

      for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
        const rawKey = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;

        const property: ObjectPropertyWithRawKey = {
          rawKey,
          parsedKey,
          valueSchema: isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.valueSchema : schemaOrObjectProperty,
        };

        rawKeyToProperty[rawKey] = property;
      }

      const parsed: Record<string | number | symbol, any> = {};

      for (const [rawKey, rawPropertyValue] of Object.entries(raw)) {
        const property = rawKeyToProperty[rawKey];

        if (property != null) {
          const value = await property.valueSchema.parse(rawPropertyValue);
          parsed[property.parsedKey] = value;
        } else if (!skipUnknownKeysOnParse && rawPropertyValue != null) {
          parsed[rawKey] = rawPropertyValue;
        }
      }

      return parsed as inferParsedObjectFromPropertySchemas<T>;
    },

    json: async (parsed, { includeUnknownKeysOnJson = false } = {}) => {
      const raw: Record<string | number | symbol, any> = {};

      for (const [parsedKey, parsedPropertyValue] of entries(parsed)) {
        const schemaOrObjectProperty = schemas[parsedKey as keyof T];
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (schemaOrObjectProperty != null) {
          if (isProperty(schemaOrObjectProperty)) {
            const value = await schemaOrObjectProperty.valueSchema.json(parsedPropertyValue);
            raw[schemaOrObjectProperty.rawKey] = value;
          } else {
            const value = await schemaOrObjectProperty.json(parsedPropertyValue);
            raw[parsedKey] = value;
          }
        } else if (includeUnknownKeysOnJson && parsedPropertyValue != null) {
          raw[parsedKey] = parsedPropertyValue;
        }
      }

      return raw as inferRawObjectFromPropertySchemas<T>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}

export function getObjectUtils<Raw, Parsed>(schema: BaseObjectSchema<Raw, Parsed>): ObjectUtils<Raw, Parsed> {
  return {
    extend: <RawExtension, ParsedExtension>(extension: ObjectSchema<RawExtension, ParsedExtension>) => {
      const baseSchema: BaseObjectSchema<Raw & RawExtension, Parsed & ParsedExtension> = {
        ...OBJECT_LIKE_BRAND,
        _getParsedProperties: async () => [
          ...(await schema._getParsedProperties()),
          ...(await extension._getParsedProperties()),
        ],
        _getRawProperties: async () => [
          ...(await schema._getRawProperties()),
          ...(await extension._getRawProperties()),
        ],
        parse: async (raw, opts) => {
          const rawExtensionPropertiesSet = new Set(await extension._getRawProperties());
          const [extensionProperties, otherProperties] = partition(keys(raw), (key) =>
            rawExtensionPropertiesSet.has(key as keyof RawExtension)
          );
          return {
            ...(await schema.parse(filterObject(raw, otherProperties), opts)),
            ...(await extension.parse(filterObject(raw, extensionProperties), opts)),
          };
        },
        json: async (parsed, opts) => {
          const parsedExtensionPropertiesSet = new Set(await extension._getParsedProperties());
          const [extensionProperties, otherProperties] = partition(keys(parsed), (key) =>
            parsedExtensionPropertiesSet.has(key as keyof ParsedExtension)
          );
          return {
            ...(await schema.json(filterObject(parsed, otherProperties), opts)),
            ...(await extension.json(filterObject(parsed, extensionProperties), opts)),
          };
        },
      };

      return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
      };
    },
  };
}
",
                        "name": "object.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export function property<RawKey extends string, RawValue, ParsedValue>(
  rawKey: RawKey,
  valueSchema: Schema<RawValue, ParsedValue>
): Property<RawKey, RawValue, ParsedValue> {
  return {
    rawKey,
    valueSchema,
    isProperty: true,
  };
}

export interface Property<RawKey extends string, RawValue, ParsedValue> {
  rawKey: RawKey;
  valueSchema: Schema<RawValue, ParsedValue>;
  isProperty: true;
}

export function isProperty<O extends Property<any, any, any>>(maybeProperty: unknown): maybeProperty is O {
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return (maybeProperty as O).isProperty;
}
",
                        "name": "property.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsed, inferRaw, Schema } from \\"../../Schema\\";
import { addQuestionMarksToNullableProperties } from \\"../../utils/addQuestionMarksToNullableProperties\\";
import { BaseObjectLikeSchema, ObjectLikeSchema } from \\"../object-like\\";
import { Property } from \\"./property\\";

export type ObjectSchema<Raw, Parsed> = BaseObjectSchema<Raw, Parsed> &
  ObjectLikeSchema<Raw, Parsed> &
  ObjectUtils<Raw, Parsed>;

export interface BaseObjectSchema<Raw, Parsed> extends BaseObjectLikeSchema<Raw, Parsed> {
  _getRawProperties: () => Promise<(keyof Raw)[]>;
  _getParsedProperties: () => Promise<(keyof Parsed)[]>;
}

export interface ObjectUtils<Raw, Parsed> {
  extend: <RawExtension, ParsedExtension>(
    schemas: ObjectSchema<RawExtension, ParsedExtension>
  ) => ObjectSchema<Raw & RawExtension, Parsed & ParsedExtension>;
}

export type inferRawObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<infer Raw, any> ? Raw : never;

export type inferParsedObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<any, infer Parsed>
  ? Parsed
  : never;

export type inferObjectSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> = ObjectSchema<
  inferRawObjectFromPropertySchemas<T>,
  inferParsedObjectFromPropertySchemas<T>
>;

export type inferRawObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
  addQuestionMarksToNullableProperties<{
    [ParsedKey in keyof T as inferRawKey<ParsedKey, T[ParsedKey]>]: inferRawPropertySchema<T[ParsedKey]>;
  }>;

export type inferParsedObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
  addQuestionMarksToNullableProperties<{
    [K in keyof T]: inferParsedPropertySchema<T[K]>;
  }>;

export type PropertySchemas<ParsedKeys extends string | number | symbol> = Record<
  ParsedKeys,
  Property<any, any, any> | Schema<any, any>
>;

export type inferRawPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
  any,
  infer Raw,
  any
>
  ? Raw
  : P extends Schema<any, any>
  ? inferRaw<P>
  : never;

export type inferParsedPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
  any,
  any,
  infer Parsed
>
  ? Parsed
  : P extends Schema<any, any>
  ? inferParsed<P>
  : never;

export type inferRawKey<
  ParsedKey extends string | number | symbol,
  P extends Property<any, any, any> | Schema<any, any>
> = P extends Property<infer Raw, any, any> ? Raw : ParsedKey;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { getSchemaUtils } from \\"../schema-utils\\";
import { BaseObjectLikeSchema, ObjectLikeSchema, ObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"./types\\";

export function getObjectLikeUtils<Raw, Parsed>(
  schema: BaseObjectLikeSchema<Raw, Parsed>
): ObjectLikeUtils<Raw, Parsed> {
  return {
    withProperties: (properties) => withProperties(schema, properties),
  };
}

/**
 * object-like utils are defined in one file to resolve issues with circular imports
 */

export function withProperties<RawObjectShape, ParsedObjectShape, Properties>(
  objectLike: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape>,
  properties: { [K in keyof Properties]: Properties[K] | ((parsed: ParsedObjectShape) => Properties[K]) }
): ObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> {
  const objectSchema: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> = {
    ...OBJECT_LIKE_BRAND,
    parse: async (raw, opts) => {
      const parsedObject = await objectLike.parse(raw, opts);
      const additionalProperties = Object.entries(properties).reduce<Record<string, any>>((processed, [key, value]) => {
        return {
          ...processed,
          [key]: typeof value === \\"function\\" ? value(parsedObject) : value,
        };
      }, {});

      return {
        ...parsedObject,
        ...(additionalProperties as Properties),
      };
    },
    json: (parsed, opts) => {
      // strip out added properties
      const addedPropertyKeys = new Set(Object.keys(properties));
      const parsedWithoutAddedProperties = Object.entries(parsed).reduce<Record<string, any>>(
        (filtered, [key, value]) => {
          if (!addedPropertyKeys.has(key)) {
            filtered[key] = value;
          }
          return filtered;
        },
        {}
      );

      return objectLike.json(parsedWithoutAddedProperties as ParsedObjectShape, opts);
    },
  };

  return {
    ...objectSchema,
    ...getSchemaUtils(objectSchema),
    ...getObjectLikeUtils(objectSchema),
  };
}
",
                        "name": "getObjectLikeUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getObjectLikeUtils, withProperties } from \\"./getObjectLikeUtils\\";
export { OBJECT_LIKE_BRAND, type BaseObjectLikeSchema, type ObjectLikeSchema, type ObjectLikeUtils } from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";

export type ObjectLikeSchema<Raw, Parsed> = Schema<Raw, Parsed> &
  BaseObjectLikeSchema<Raw, Parsed> &
  ObjectLikeUtils<Raw, Parsed>;

export type BaseObjectLikeSchema<Raw, Parsed> = BaseSchema<Raw, Parsed> & {
  _objectLike: void;
};

export interface ObjectLikeUtils<Raw, Parsed> {
  withProperties: <T extends Record<string, any>>(properties: {
    [K in keyof T]: T[K] | ((parsed: Parsed) => T[K]);
  }) => ObjectLikeSchema<Raw, Parsed & T>;
}

export const OBJECT_LIKE_BRAND = undefined as unknown as { _objectLike: void };
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object-like",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const any = createIdentitySchemaCreator<any>();
",
                        "name": "any.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const boolean = createIdentitySchemaCreator<boolean>();
",
                        "name": "boolean.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { any } from \\"./any\\";
export { boolean } from \\"./boolean\\";
export { number } from \\"./number\\";
export { string } from \\"./string\\";
export { unknown } from \\"./unknown\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const number = createIdentitySchemaCreator<number>();
",
                        "name": "number.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const string = createIdentitySchemaCreator<string>();
",
                        "name": "string.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const unknown = createIdentitySchemaCreator<unknown>();
",
                        "name": "unknown.ts",
                        "type": "file",
                      },
                    ],
                    "name": "primitives",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { record } from \\"./record\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function record<RawKey extends string | number, ParsedKey extends string | number, RawValue, ParsedValue>(
  keySchema: Schema<RawKey, ParsedKey>,
  valueSchema: Schema<RawValue, ParsedValue>
): Schema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> {
  const baseSchema: BaseSchema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> = {
    parse: (raw, opts) => {
      return entries(raw).reduce(async (parsedPromise, [key, value]) => {
        const parsed: Record<ParsedKey, ParsedValue> = await parsedPromise;
        const parsedKey = await keySchema.parse(key, opts);
        parsed[parsedKey] = await valueSchema.parse(value, opts);
        return parsedPromise;
      }, Promise.resolve({} as Record<ParsedKey, ParsedValue>));
    },
    json: (parsed, opts) => {
      return entries(parsed).reduce(async (rawPromise, [key, value]) => {
        const raw: Record<RawKey, RawValue> = await rawPromise;
        const rawKey = await keySchema.json(key, opts);
        raw[rawKey] = await valueSchema.json(value, opts);
        return rawPromise;
      }, Promise.resolve({} as Record<RawKey, RawValue>));
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "record.ts",
                        "type": "file",
                      },
                    ],
                    "name": "record",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { OptionalSchema, OPTIONAL_BRAND } from \\"./types\\";

export interface SchemaUtils<Raw, Parsed> {
  optional: () => OptionalSchema<Raw, Parsed>;
  transform: <PostTransform>(transformer: BaseSchema<Parsed, PostTransform>) => Schema<Raw, PostTransform>;
}

export function getSchemaUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): SchemaUtils<Raw, Parsed> {
  return {
    optional: () => optional(schema),
    transform: (transformer) => transform(schema, transformer),
  };
}

/**
 * schema utils are defined in one file to resolve issues with circular imports
 */

export function optional<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): OptionalSchema<Raw, Parsed> {
  const baseSchema: BaseSchema<Raw | null | undefined, Parsed | undefined> = {
    parse: (raw, opts) => (raw != null ? schema.parse(raw, opts) : undefined),
    json: (parsed, opts) => (parsed != null ? schema.json(parsed, opts) : undefined),
  };

  return {
    ...OPTIONAL_BRAND,
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function transform<PreTransformRaw, PreTransformParsed, PostTransform>(
  schema: BaseSchema<PreTransformRaw, PreTransformParsed>,
  transformer: BaseSchema<PreTransformParsed, PostTransform>
): Schema<PreTransformRaw, PostTransform> {
  const baseSchema: BaseSchema<PreTransformRaw, PostTransform> = {
    parse: async (raw, opts) => {
      const postTransformParsed = await schema.parse(raw, opts);
      return transformer.parse(postTransformParsed, opts);
    },
    json: async (parsed, opts) => {
      const preTransformParsed = await transformer.json(parsed, opts);
      return schema.json(preTransformParsed, opts);
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "getSchemaUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getSchemaUtils, optional, transform, type SchemaUtils } from \\"./getSchemaUtils\\";
export { OPTIONAL_BRAND, type OptionalSchema } from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export const OPTIONAL_BRAND = undefined as unknown as { _isOptional: void };

export type OptionalSchema<Raw, Parsed> = Schema<Raw | null | undefined, Parsed | undefined> & {
  _isOptional: void;
};
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "schema-utils",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { set } from \\"./set\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function set<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Set<Parsed>> {
  const baseSchema: BaseSchema<Raw[], Set<Parsed>> = {
    parse: async (raw, opts) => new Set(await Promise.all(raw.map((item) => schema.parse(item, opts)))),
    json: (parsed, opts) => Promise.all([...parsed].map((item) => schema.json(item, opts))),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "set.ts",
                        "type": "file",
                      },
                    ],
                    "name": "set",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export function discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string>(
  parsedDiscriminant: ParsedDiscriminant,
  rawDiscriminant: RawDiscriminant
): Discriminant<RawDiscriminant, ParsedDiscriminant> {
  return {
    parsedDiscriminant,
    rawDiscriminant,
  };
}

export interface Discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string> {
  parsedDiscriminant: ParsedDiscriminant;
  rawDiscriminant: RawDiscriminant;
}
",
                        "name": "discriminant.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { discriminant, type Discriminant } from \\"./discriminant\\";
export {
  type inferParsedDiscriminant,
  type inferParsedUnion,
  type inferRawDiscriminant,
  type inferRawUnion,
  type UnionSubtypes,
} from \\"./types\\";
export { union } from \\"./union\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsedObject, inferRawObject, ObjectSchema } from \\"../object\\";
import { Discriminant } from \\"./discriminant\\";

export type UnionSubtypes<DiscriminantValues extends string | number | symbol> = {
  [K in DiscriminantValues]: ObjectSchema<any, any>;
};

export type inferRawUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
  [K in keyof U]: Record<inferRawDiscriminant<D>, K> & inferRawObject<U[K]>;
}[keyof U];

export type inferParsedUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
  [K in keyof U]: Record<inferParsedDiscriminant<D>, K> & inferParsedObject<U[K]>;
}[keyof U];

export type inferRawDiscriminant<D extends string | Discriminant<any, any>> = D extends string
  ? D
  : D extends Discriminant<infer Raw, any>
  ? Raw
  : never;

export type inferParsedDiscriminant<D extends string | Discriminant<any, any>> = D extends string
  ? D
  : D extends Discriminant<any, infer Parsed>
  ? Parsed
  : never;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseObjectLikeSchema, getObjectLikeUtils, ObjectLikeSchema, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { Discriminant } from \\"./discriminant\\";
import { inferParsedDiscriminant, inferParsedUnion, inferRawDiscriminant, inferRawUnion, UnionSubtypes } from \\"./types\\";

export function union<D extends string | Discriminant<any, any>, U extends UnionSubtypes<any>>(
  discriminant: D,
  union: U
): ObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> {
  const rawDiscriminant =
    typeof discriminant === \\"string\\" ? discriminant : (discriminant.rawDiscriminant as inferRawDiscriminant<D>);
  const parsedDiscriminant =
    typeof discriminant === \\"string\\" ? discriminant : (discriminant.parsedDiscriminant as inferParsedDiscriminant<D>);

  const baseSchema: BaseObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> = {
    ...OBJECT_LIKE_BRAND,

    parse: async (raw, opts) => {
      const { [rawDiscriminant]: discriminantValue, ...additionalProperties } = raw;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [parsedDiscriminant]: discriminantValue,
        } as inferParsedUnion<D, U>;
      }

      return {
        ...(await additionalPropertySchemas.parse(additionalProperties, opts)),
        [parsedDiscriminant]: discriminantValue,
      } as inferParsedUnion<D, U>;
    },

    json: async (parsed, opts) => {
      const { [parsedDiscriminant]: discriminantValue, ...additionalProperties } = parsed;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [rawDiscriminant]: discriminantValue,
        } as unknown as inferRawUnion<D, U>;
      }

      return {
        ...(await additionalPropertySchemas.json(additionalProperties, opts)),
        [rawDiscriminant]: discriminantValue,
      } as inferRawUnion<D, U>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
  };
}
",
                        "name": "union.ts",
                        "type": "file",
                      },
                    ],
                    "name": "union",
                    "type": "directory",
                  },
                ],
                "name": "builders",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./builders\\";
export { type inferParsed, type inferRaw, type Schema, type SchemaOptions } from \\"./Schema\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export type addQuestionMarksToNullableProperties<T> = {
  [K in OptionalKeys<T>]?: undefined extends T[K] ? T[K] : never;
} & Pick<T, RequiredKeys<T>>;

export type OptionalKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? K : never;
}[keyof T];

export type RequiredKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? never : K;
}[keyof T];
",
                    "name": "addQuestionMarksToNullableProperties.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function entries<T>(object: T): [keyof T, T[keyof T]][] {
  return Object.entries(object) as [keyof T, T[keyof T]][];
}
",
                    "name": "entries.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function filterObject<T, K extends keyof T>(obj: T, keysToInclude: K[]): Pick<T, K> {
  const keysToIncludeSet = new Set(keysToInclude);
  return Object.entries(obj).reduce((acc, [key, value]) => {
    if (keysToIncludeSet.has(key as K)) {
      acc[key as K] = value;
    }
    return acc;
    // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
  }, {} as Pick<T, K>);
}
",
                    "name": "filterObject.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function keys<T>(object: T): (keyof T)[] {
  return Object.keys(object) as (keyof T)[];
}
",
                    "name": "keys.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function partition<T>(items: readonly T[], predicate: (item: T) => boolean): [T[], T[]] {
  const trueItems: T[] = [],
    falseItems: T[] = [];
  for (const item of items) {
    if (predicate(item)) {
      trueItems.push(item);
    } else {
      falseItems.push(item);
    }
  }
  return [trueItems, falseItems];
}
",
                    "name": "partition.ts",
                    "type": "file",
                  },
                ],
                "name": "utils",
                "type": "directory",
              },
            ],
            "name": "schemas",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export function addNonEnumerableProperty<T, K extends string, V>(object: T, key: K, value: V): T & Record<K, V> {
  const copy = { ...object };
  Object.defineProperty(copy, key, {
    enumerable: false,
    writable: true,
  });
  (copy as any)[key] = value;
  return copy as T & Record<K, V>;
}
",
                "name": "addNonEnumerableProperty.ts",
                "type": "file",
              },
              Object {
                "contents": "export { addNonEnumerableProperty } from \\"./addNonEnumerableProperty\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "utils",
            "type": "directory",
          },
        ],
        "name": "core",
        "type": "directory",
      },
      Object {
        "contents": "export * as FernFiddle from \\"./resources\\";
export { FernFiddleClient } from \\"./Client\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import urlJoin from \\"url-join\\";
import * as core from \\"../../../core\\";

export declare namespace Client {
  interface Options {
    environment: string;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async status(): Promise<FernFiddle.health.status.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment, \\"/api/health/\\"),
      method: \\"GET\\",
    });
    if (_response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: FernFiddle.health.status.Error._unknown(_response.error),
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as status from \\"./status\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, FernFiddle.health.status.Error>;
export type Error = FernFiddle.health.status.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    error: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernFiddle.health.status.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): FernFiddle.health.status.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<FernFiddle.health.status.Error._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.health.status.Error._Unknown, visitor: FernFiddle.health.status.Error._Visitor<_Result>) {
      return FernFiddle.health.status.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: FernFiddle.health.status.Error,
    visitor: FernFiddle.health.status.Error._Visitor<_Result>
  ): _Result => {
    switch (value.error) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "status.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "health",
            "type": "directory",
          },
          Object {
            "contents": "export * as remoteGen from \\"./remoteGen\\";
export * from \\"./remoteGen/types\\";
export * from \\"./remoteGen/errors\\";
export * as health from \\"./health\\";
export * from \\"./remoteGen/client/requests\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";
import * as core from \\"../../../core\\";

export declare namespace Client {
  interface Options {
    environment: string;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async createJob(request: FernFiddle.CreateJobRequest): Promise<FernFiddle.remoteGen.createJob.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment, \\"/api/remote-gen/create-job\\"),
      method: \\"POST\\",
      body: await serializers.remoteGen.createJob.Request.json({
        apiName: request.apiName,
        organizationName: request.organizationName,
        version: request.version,
        generators: request.generators,
      }),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.remoteGen.createJob.Response.parse(
          _response.body as serializers.remoteGen.createJob.Response.Raw
        ),
      };
    }

    if (_response.error.reason === \\"status-code\\") {
      switch ((_response.error.body as serializers.remoteGen.createJob.Error.Raw)?.error) {
        case \\"IllegalApiNameError\\":
        case \\"GeneratorsDoNotExistError\\":
        case \\"CannotPublishToNpmScope\\":
        case \\"CannotPublishToMavenGroup\\":
        case \\"InsufficientPermissions\\":
          return {
            ok: false,
            error: await serializers.remoteGen.createJob.Error.parse(
              _response.error.body as serializers.remoteGen.createJob.Error.Raw
            ),
          };
      }
    }

    return {
      ok: false,
      error: FernFiddle.remoteGen.createJob.Error._unknown(_response.error),
    };
  }

  public async createJobV2(request: FernFiddle.CreateJobRequestV2): Promise<FernFiddle.remoteGen.createJobV2.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment, \\"/api/remote-gen/create-job-v2\\"),
      method: \\"POST\\",
      body: await serializers.remoteGen.createJobV2.Request.json({
        apiName: request.apiName,
        organizationName: request.organizationName,
        version: request.version,
        generators: request.generators,
        uploadToS3: request.uploadToS3,
      }),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.remoteGen.createJobV2.Response.parse(
          _response.body as serializers.remoteGen.createJobV2.Response.Raw
        ),
      };
    }

    if (_response.error.reason === \\"status-code\\") {
      switch ((_response.error.body as serializers.remoteGen.createJobV2.Error.Raw)?.error) {
        case \\"IllegalApiNameError\\":
        case \\"GeneratorsDoNotExistError\\":
        case \\"CannotPublishToNpmScope\\":
        case \\"CannotPublishToMavenGroup\\":
        case \\"InsufficientPermissions\\":
          return {
            ok: false,
            error: await serializers.remoteGen.createJobV2.Error.parse(
              _response.error.body as serializers.remoteGen.createJobV2.Error.Raw
            ),
          };
      }
    }

    return {
      ok: false,
      error: FernFiddle.remoteGen.createJobV2.Error._unknown(_response.error),
    };
  }

  public async getJobStatus(jobId: FernFiddle.RemoteGenJobId): Promise<FernFiddle.remoteGen.getJobStatus.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment, \`/api/remote-gen/jobs/\${jobId}/status\`),
      method: \\"POST\\",
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.remoteGen.getJobStatus.Response.parse(
          _response.body as serializers.remoteGen.getJobStatus.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: FernFiddle.remoteGen.getJobStatus.Error._unknown(_response.error),
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<FernFiddle.CreateJobResponse, FernFiddle.remoteGen.createJob.Error>;
export type Error =
  | FernFiddle.remoteGen.createJob.Error.IllegalApiNameError
  | FernFiddle.remoteGen.createJob.Error.GeneratorsDoNotExistError
  | FernFiddle.remoteGen.createJob.Error.CannotPublishToNpmScope
  | FernFiddle.remoteGen.createJob.Error.CannotPublishToMavenGroup
  | FernFiddle.remoteGen.createJob.Error.InsufficientPermissions
  | FernFiddle.remoteGen.createJob.Error._Unknown;

export declare namespace Error {
  interface IllegalApiNameError extends _Utils {
    error: \\"IllegalApiNameError\\";
  }

  interface GeneratorsDoNotExistError extends _Utils {
    error: \\"GeneratorsDoNotExistError\\";
    content: FernFiddle.GeneratorsDoNotExistError;
  }

  interface CannotPublishToNpmScope extends _Utils {
    error: \\"CannotPublishToNpmScope\\";
    content: FernFiddle.CannotPublishToNpmScope;
  }

  interface CannotPublishToMavenGroup extends _Utils {
    error: \\"CannotPublishToMavenGroup\\";
    content: FernFiddle.CannotPublishToMavenGroup;
  }

  interface InsufficientPermissions extends _Utils {
    error: \\"InsufficientPermissions\\";
    content: FernFiddle.InsufficientPermissions;
  }

  interface _Unknown extends _Utils {
    error: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernFiddle.remoteGen.createJob.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    illegalApiNameError: () => _Result;
    generatorsDoNotExistError: (value: FernFiddle.GeneratorsDoNotExistError) => _Result;
    cannotPublishToNpmScope: (value: FernFiddle.CannotPublishToNpmScope) => _Result;
    cannotPublishToMavenGroup: (value: FernFiddle.CannotPublishToMavenGroup) => _Result;
    insufficientPermissions: (value: FernFiddle.InsufficientPermissions) => _Result;
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  illegalApiNameError: (): FernFiddle.remoteGen.createJob.Error.IllegalApiNameError => {
    const valueWithoutVisit: Omit<FernFiddle.remoteGen.createJob.Error.IllegalApiNameError, \\"_visit\\"> = {
      error: \\"IllegalApiNameError\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.remoteGen.createJob.Error.IllegalApiNameError, visitor: FernFiddle.remoteGen.createJob.Error._Visitor<_Result>) {
      return FernFiddle.remoteGen.createJob.Error._visit(this, visitor);
    });
  },

  generatorsDoNotExistError: (
    value: FernFiddle.GeneratorsDoNotExistError
  ): FernFiddle.remoteGen.createJob.Error.GeneratorsDoNotExistError => {
    const valueWithoutVisit: Omit<FernFiddle.remoteGen.createJob.Error.GeneratorsDoNotExistError, \\"_visit\\"> = {
      content: value,
      error: \\"GeneratorsDoNotExistError\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.remoteGen.createJob.Error.GeneratorsDoNotExistError, visitor: FernFiddle.remoteGen.createJob.Error._Visitor<_Result>) {
      return FernFiddle.remoteGen.createJob.Error._visit(this, visitor);
    });
  },

  cannotPublishToNpmScope: (
    value: FernFiddle.CannotPublishToNpmScope
  ): FernFiddle.remoteGen.createJob.Error.CannotPublishToNpmScope => {
    const valueWithoutVisit: Omit<FernFiddle.remoteGen.createJob.Error.CannotPublishToNpmScope, \\"_visit\\"> = {
      content: value,
      error: \\"CannotPublishToNpmScope\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.remoteGen.createJob.Error.CannotPublishToNpmScope, visitor: FernFiddle.remoteGen.createJob.Error._Visitor<_Result>) {
      return FernFiddle.remoteGen.createJob.Error._visit(this, visitor);
    });
  },

  cannotPublishToMavenGroup: (
    value: FernFiddle.CannotPublishToMavenGroup
  ): FernFiddle.remoteGen.createJob.Error.CannotPublishToMavenGroup => {
    const valueWithoutVisit: Omit<FernFiddle.remoteGen.createJob.Error.CannotPublishToMavenGroup, \\"_visit\\"> = {
      content: value,
      error: \\"CannotPublishToMavenGroup\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.remoteGen.createJob.Error.CannotPublishToMavenGroup, visitor: FernFiddle.remoteGen.createJob.Error._Visitor<_Result>) {
      return FernFiddle.remoteGen.createJob.Error._visit(this, visitor);
    });
  },

  insufficientPermissions: (
    value: FernFiddle.InsufficientPermissions
  ): FernFiddle.remoteGen.createJob.Error.InsufficientPermissions => {
    const valueWithoutVisit: Omit<FernFiddle.remoteGen.createJob.Error.InsufficientPermissions, \\"_visit\\"> = {
      content: value,
      error: \\"InsufficientPermissions\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.remoteGen.createJob.Error.InsufficientPermissions, visitor: FernFiddle.remoteGen.createJob.Error._Visitor<_Result>) {
      return FernFiddle.remoteGen.createJob.Error._visit(this, visitor);
    });
  },

  _unknown: (fetcherError: core.Fetcher.Error): FernFiddle.remoteGen.createJob.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<FernFiddle.remoteGen.createJob.Error._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.remoteGen.createJob.Error._Unknown, visitor: FernFiddle.remoteGen.createJob.Error._Visitor<_Result>) {
      return FernFiddle.remoteGen.createJob.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: FernFiddle.remoteGen.createJob.Error,
    visitor: FernFiddle.remoteGen.createJob.Error._Visitor<_Result>
  ): _Result => {
    switch (value.error) {
      case \\"IllegalApiNameError\\":
        return visitor.illegalApiNameError();
      case \\"GeneratorsDoNotExistError\\":
        return visitor.generatorsDoNotExistError(value.content);
      case \\"CannotPublishToNpmScope\\":
        return visitor.cannotPublishToNpmScope(value.content);
      case \\"CannotPublishToMavenGroup\\":
        return visitor.cannotPublishToMavenGroup(value.content);
      case \\"InsufficientPermissions\\":
        return visitor.insufficientPermissions(value.content);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "createJob.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<FernFiddle.CreateJobResponse, FernFiddle.remoteGen.createJobV2.Error>;
export type Error =
  | FernFiddle.remoteGen.createJobV2.Error.IllegalApiNameError
  | FernFiddle.remoteGen.createJobV2.Error.GeneratorsDoNotExistError
  | FernFiddle.remoteGen.createJobV2.Error.CannotPublishToNpmScope
  | FernFiddle.remoteGen.createJobV2.Error.CannotPublishToMavenGroup
  | FernFiddle.remoteGen.createJobV2.Error.InsufficientPermissions
  | FernFiddle.remoteGen.createJobV2.Error._Unknown;

export declare namespace Error {
  interface IllegalApiNameError extends _Utils {
    error: \\"IllegalApiNameError\\";
  }

  interface GeneratorsDoNotExistError extends _Utils {
    error: \\"GeneratorsDoNotExistError\\";
    content: FernFiddle.GeneratorsDoNotExistError;
  }

  interface CannotPublishToNpmScope extends _Utils {
    error: \\"CannotPublishToNpmScope\\";
    content: FernFiddle.CannotPublishToNpmScope;
  }

  interface CannotPublishToMavenGroup extends _Utils {
    error: \\"CannotPublishToMavenGroup\\";
    content: FernFiddle.CannotPublishToMavenGroup;
  }

  interface InsufficientPermissions extends _Utils {
    error: \\"InsufficientPermissions\\";
    content: FernFiddle.InsufficientPermissions;
  }

  interface _Unknown extends _Utils {
    error: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernFiddle.remoteGen.createJobV2.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    illegalApiNameError: () => _Result;
    generatorsDoNotExistError: (value: FernFiddle.GeneratorsDoNotExistError) => _Result;
    cannotPublishToNpmScope: (value: FernFiddle.CannotPublishToNpmScope) => _Result;
    cannotPublishToMavenGroup: (value: FernFiddle.CannotPublishToMavenGroup) => _Result;
    insufficientPermissions: (value: FernFiddle.InsufficientPermissions) => _Result;
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  illegalApiNameError: (): FernFiddle.remoteGen.createJobV2.Error.IllegalApiNameError => {
    const valueWithoutVisit: Omit<FernFiddle.remoteGen.createJobV2.Error.IllegalApiNameError, \\"_visit\\"> = {
      error: \\"IllegalApiNameError\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.remoteGen.createJobV2.Error.IllegalApiNameError, visitor: FernFiddle.remoteGen.createJobV2.Error._Visitor<_Result>) {
      return FernFiddle.remoteGen.createJobV2.Error._visit(this, visitor);
    });
  },

  generatorsDoNotExistError: (
    value: FernFiddle.GeneratorsDoNotExistError
  ): FernFiddle.remoteGen.createJobV2.Error.GeneratorsDoNotExistError => {
    const valueWithoutVisit: Omit<FernFiddle.remoteGen.createJobV2.Error.GeneratorsDoNotExistError, \\"_visit\\"> = {
      content: value,
      error: \\"GeneratorsDoNotExistError\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.remoteGen.createJobV2.Error.GeneratorsDoNotExistError, visitor: FernFiddle.remoteGen.createJobV2.Error._Visitor<_Result>) {
      return FernFiddle.remoteGen.createJobV2.Error._visit(this, visitor);
    });
  },

  cannotPublishToNpmScope: (
    value: FernFiddle.CannotPublishToNpmScope
  ): FernFiddle.remoteGen.createJobV2.Error.CannotPublishToNpmScope => {
    const valueWithoutVisit: Omit<FernFiddle.remoteGen.createJobV2.Error.CannotPublishToNpmScope, \\"_visit\\"> = {
      content: value,
      error: \\"CannotPublishToNpmScope\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.remoteGen.createJobV2.Error.CannotPublishToNpmScope, visitor: FernFiddle.remoteGen.createJobV2.Error._Visitor<_Result>) {
      return FernFiddle.remoteGen.createJobV2.Error._visit(this, visitor);
    });
  },

  cannotPublishToMavenGroup: (
    value: FernFiddle.CannotPublishToMavenGroup
  ): FernFiddle.remoteGen.createJobV2.Error.CannotPublishToMavenGroup => {
    const valueWithoutVisit: Omit<FernFiddle.remoteGen.createJobV2.Error.CannotPublishToMavenGroup, \\"_visit\\"> = {
      content: value,
      error: \\"CannotPublishToMavenGroup\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.remoteGen.createJobV2.Error.CannotPublishToMavenGroup, visitor: FernFiddle.remoteGen.createJobV2.Error._Visitor<_Result>) {
      return FernFiddle.remoteGen.createJobV2.Error._visit(this, visitor);
    });
  },

  insufficientPermissions: (
    value: FernFiddle.InsufficientPermissions
  ): FernFiddle.remoteGen.createJobV2.Error.InsufficientPermissions => {
    const valueWithoutVisit: Omit<FernFiddle.remoteGen.createJobV2.Error.InsufficientPermissions, \\"_visit\\"> = {
      content: value,
      error: \\"InsufficientPermissions\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.remoteGen.createJobV2.Error.InsufficientPermissions, visitor: FernFiddle.remoteGen.createJobV2.Error._Visitor<_Result>) {
      return FernFiddle.remoteGen.createJobV2.Error._visit(this, visitor);
    });
  },

  _unknown: (fetcherError: core.Fetcher.Error): FernFiddle.remoteGen.createJobV2.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      FernFiddle.remoteGen.createJobV2.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.remoteGen.createJobV2.Error._Unknown, visitor: FernFiddle.remoteGen.createJobV2.Error._Visitor<_Result>) {
      return FernFiddle.remoteGen.createJobV2.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: FernFiddle.remoteGen.createJobV2.Error,
    visitor: FernFiddle.remoteGen.createJobV2.Error._Visitor<_Result>
  ): _Result => {
    switch (value.error) {
      case \\"IllegalApiNameError\\":
        return visitor.illegalApiNameError();
      case \\"GeneratorsDoNotExistError\\":
        return visitor.generatorsDoNotExistError(value.content);
      case \\"CannotPublishToNpmScope\\":
        return visitor.cannotPublishToNpmScope(value.content);
      case \\"CannotPublishToMavenGroup\\":
        return visitor.cannotPublishToMavenGroup(value.content);
      case \\"InsufficientPermissions\\":
        return visitor.insufficientPermissions(value.content);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "createJobV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  Record<FernFiddle.RemoteGenTaskId, FernFiddle.Task>,
  FernFiddle.remoteGen.getJobStatus.Error
>;
export type Error = FernFiddle.remoteGen.getJobStatus.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    error: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernFiddle.remoteGen.getJobStatus.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): FernFiddle.remoteGen.getJobStatus.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      FernFiddle.remoteGen.getJobStatus.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.remoteGen.getJobStatus.Error._Unknown, visitor: FernFiddle.remoteGen.getJobStatus.Error._Visitor<_Result>) {
      return FernFiddle.remoteGen.getJobStatus.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: FernFiddle.remoteGen.getJobStatus.Error,
    visitor: FernFiddle.remoteGen.getJobStatus.Error._Visitor<_Result>
  ): _Result => {
    switch (value.error) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "getJobStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as createJob from \\"./createJob\\";
export * from \\"./requests\\";
export * as createJobV2 from \\"./createJobV2\\";
export * as getJobStatus from \\"./getJobStatus\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";

export interface CreateJobRequest {
  apiName: string;
  organizationName: string;
  version?: string;
  generators: FernFiddle.GeneratorConfig[];
}
",
                        "name": "CreateJobRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";

export interface CreateJobRequestV2 {
  apiName: string;
  organizationName: string;
  version?: string;
  generators: FernFiddle.GeneratorConfigV2[];
  uploadToS3?: boolean;
}
",
                        "name": "CreateJobRequestV2.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { CreateJobRequest } from \\"./CreateJobRequest\\";
export { CreateJobRequestV2 } from \\"./CreateJobRequestV2\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "requests",
                    "type": "directory",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";

export type CannotPublishToMavenGroup = FernFiddle.CannotPublishToMavenGroupDetails;
",
                    "name": "CannotPublishToMavenGroup.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";

export type CannotPublishToNpmScope = FernFiddle.CannotPublishToNpmScopeDetails;
",
                    "name": "CannotPublishToNpmScope.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";

export type GeneratorsDoNotExistError = FernFiddle.GeneratorsDoNotExistErrorBodyType;
",
                    "name": "GeneratorsDoNotExistError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";

export type InsufficientPermissions = FernFiddle.InsufficientPermissionsDetails;
",
                    "name": "InsufficientPermissions.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./GeneratorsDoNotExistError\\";
export * from \\"./CannotPublishToNpmScope\\";
export * from \\"./CannotPublishToMavenGroup\\";
export * from \\"./InsufficientPermissions\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "errors",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./errors\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface CannotPublishToMavenGroupDetails {
  generatorId: string;
  invalidGroup: string;
  validGroup: string;
}
",
                    "name": "CannotPublishToMavenGroupDetails.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface CannotPublishToNpmScopeDetails {
  generatorId: string;
  invalidScope: string;
  validScope: string;
}
",
                    "name": "CannotPublishToNpmScopeDetails.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";

export interface CreateJobResponse {
  jobId: FernFiddle.RemoteGenJobId;
  /** The order of this list corresponds to the order of the generators supplied in the request. */
  taskIds: FernFiddle.RemoteGenTaskId[];
}
",
                    "name": "CreateJobResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface FailedTaskStatus {
  message: string;
  /** Pre-signed URL that points to a zipfile containing generated code. */
  s3PreSignedReadUrl?: string;
}
",
                    "name": "FailedTaskStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface FinishedTaskStatus {
  /** This field is deprecated. */
  hasFilesToDownload: boolean;
  /** Deprecated (use v2). Pre-signed URL that points to a zipfile containing generated code. */
  s3PreSignedReadUrl: string;
  /** Pre-signed URL that points to a zipfile containing generated code. */
  s3PreSignedReadUrlV2?: string;
}
",
                    "name": "FinishedTaskStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";

export interface GeneratorConfig {
  id: string;
  version: string;
  customConfig?: unknown;
  willDownloadFiles: boolean;
  /** Npm and Maven outputs default to fern registries. */
  outputs: FernFiddle.GeneratorOutputs;
}
",
                    "name": "GeneratorConfig.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";

export interface GeneratorConfigV2 {
  id: string;
  version: string;
  customConfig?: unknown;
  outputMode: FernFiddle.OutputMode;
}
",
                    "name": "GeneratorConfigV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface GeneratorIdAndVersion {
  id: string;
  version: string;
}
",
                    "name": "GeneratorIdAndVersion.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";

export interface GeneratorOutputs {
  npm?: FernFiddle.NpmOutput;
  maven?: FernFiddle.MavenOutput;
}
",
                    "name": "GeneratorOutputs.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";

export interface GeneratorsDoNotExistErrorBodyType {
  nonExistentGenerators: FernFiddle.GeneratorIdAndVersion[];
}
",
                    "name": "GeneratorsDoNotExistErrorBodyType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";

export interface GithubOutputMode {
  owner: string;
  repo: string;
  publishInfo?: FernFiddle.GithubPublishInfo;
}
",
                    "name": "GithubOutputMode.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export type GithubPublishInfo =
  | FernFiddle.GithubPublishInfo.Npm
  | FernFiddle.GithubPublishInfo.Maven
  | FernFiddle.GithubPublishInfo.Postman
  | FernFiddle.GithubPublishInfo._Unknown;

export declare namespace GithubPublishInfo {
  interface Npm extends FernFiddle.NpmOutputWithOptionalToken, _Utils {
    type: \\"npm\\";
  }

  interface Maven extends FernFiddle.MavenOutputWithOptionalCreds, _Utils {
    type: \\"maven\\";
  }

  interface Postman extends FernFiddle.PostmanOutput, _Utils {
    type: \\"postman\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernFiddle.GithubPublishInfo._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    npm: (value: FernFiddle.NpmOutputWithOptionalToken) => _Result;
    maven: (value: FernFiddle.MavenOutputWithOptionalCreds) => _Result;
    postman: (value: FernFiddle.PostmanOutput) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const GithubPublishInfo = {
  npm: (value: FernFiddle.NpmOutputWithOptionalToken): FernFiddle.GithubPublishInfo.Npm => {
    const valueWithoutVisit: Omit<FernFiddle.GithubPublishInfo.Npm, \\"_visit\\"> = {
      ...value,
      type: \\"npm\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.GithubPublishInfo.Npm, visitor: FernFiddle.GithubPublishInfo._Visitor<_Result>) {
      return FernFiddle.GithubPublishInfo._visit(this, visitor);
    });
  },

  maven: (value: FernFiddle.MavenOutputWithOptionalCreds): FernFiddle.GithubPublishInfo.Maven => {
    const valueWithoutVisit: Omit<FernFiddle.GithubPublishInfo.Maven, \\"_visit\\"> = {
      ...value,
      type: \\"maven\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.GithubPublishInfo.Maven, visitor: FernFiddle.GithubPublishInfo._Visitor<_Result>) {
      return FernFiddle.GithubPublishInfo._visit(this, visitor);
    });
  },

  postman: (value: FernFiddle.PostmanOutput): FernFiddle.GithubPublishInfo.Postman => {
    const valueWithoutVisit: Omit<FernFiddle.GithubPublishInfo.Postman, \\"_visit\\"> = {
      ...value,
      type: \\"postman\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.GithubPublishInfo.Postman, visitor: FernFiddle.GithubPublishInfo._Visitor<_Result>) {
      return FernFiddle.GithubPublishInfo._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): FernFiddle.GithubPublishInfo._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<FernFiddle.GithubPublishInfo._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.GithubPublishInfo._Unknown, visitor: FernFiddle.GithubPublishInfo._Visitor<_Result>) {
      return FernFiddle.GithubPublishInfo._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: FernFiddle.GithubPublishInfo,
    visitor: FernFiddle.GithubPublishInfo._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"npm\\":
        return visitor.npm(value);
      case \\"maven\\":
        return visitor.maven(value);
      case \\"postman\\":
        return visitor.postman(value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "GithubPublishInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface InsufficientPermissionsDetails {
  dummy?: string;
}
",
                    "name": "InsufficientPermissionsDetails.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type LogLevel = \\"DEBUG\\" | \\"INFO\\" | \\"WARN\\" | \\"ERROR\\";

export const LogLevel = {
  Debug: \\"DEBUG\\",
  Info: \\"INFO\\",
  Warn: \\"WARN\\",
  Error: \\"ERROR\\",
} as const;
",
                    "name": "LogLevel.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface MavenCoordinate {
  group: string;
  artifact: string;
  version: string;
}
",
                    "name": "MavenCoordinate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface MavenOutput {
  registryUrl: string;
  username: string;
  password: string;
  coordinate: string;
}
",
                    "name": "MavenOutput.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";

export interface MavenOutputWithOptionalCreds {
  registryUrl: string;
  coordinate: string;
  credentials?: FernFiddle.UsernamePassword;
}
",
                    "name": "MavenOutputWithOptionalCreds.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface NpmCoordinate {
  name: string;
  version: string;
}
",
                    "name": "NpmCoordinate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface NpmOutput {
  registryUrl: string;
  packageName: string;
  token: string;
}
",
                    "name": "NpmOutput.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface NpmOutputWithOptionalToken {
  registryUrl: string;
  packageName: string;
  token?: string;
}
",
                    "name": "NpmOutputWithOptionalToken.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export type OutputMode =
  | FernFiddle.OutputMode.Publish
  | FernFiddle.OutputMode.PublishV2
  | FernFiddle.OutputMode.DownloadFiles
  | FernFiddle.OutputMode.Github
  | FernFiddle.OutputMode._Unknown;

export declare namespace OutputMode {
  interface Publish extends FernFiddle.PublishOutputMode, _Utils {
    type: \\"publish\\";
  }

  interface PublishV2 extends _Utils {
    type: \\"publishV2\\";
    publishV2: FernFiddle.PublishOutputModeV2;
  }

  interface DownloadFiles extends _Utils {
    type: \\"downloadFiles\\";
  }

  interface Github extends FernFiddle.GithubOutputMode, _Utils {
    type: \\"github\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernFiddle.OutputMode._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    publish: (value: FernFiddle.PublishOutputMode) => _Result;
    publishV2: (value: FernFiddle.PublishOutputModeV2) => _Result;
    downloadFiles: () => _Result;
    github: (value: FernFiddle.GithubOutputMode) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const OutputMode = {
  publish: (value: FernFiddle.PublishOutputMode): FernFiddle.OutputMode.Publish => {
    const valueWithoutVisit: Omit<FernFiddle.OutputMode.Publish, \\"_visit\\"> = {
      ...value,
      type: \\"publish\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.OutputMode.Publish, visitor: FernFiddle.OutputMode._Visitor<_Result>) {
      return FernFiddle.OutputMode._visit(this, visitor);
    });
  },

  publishV2: (value: FernFiddle.PublishOutputModeV2): FernFiddle.OutputMode.PublishV2 => {
    const valueWithoutVisit: Omit<FernFiddle.OutputMode.PublishV2, \\"_visit\\"> = {
      publishV2: value,
      type: \\"publishV2\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.OutputMode.PublishV2, visitor: FernFiddle.OutputMode._Visitor<_Result>) {
      return FernFiddle.OutputMode._visit(this, visitor);
    });
  },

  downloadFiles: (): FernFiddle.OutputMode.DownloadFiles => {
    const valueWithoutVisit: Omit<FernFiddle.OutputMode.DownloadFiles, \\"_visit\\"> = {
      type: \\"downloadFiles\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.OutputMode.DownloadFiles, visitor: FernFiddle.OutputMode._Visitor<_Result>) {
      return FernFiddle.OutputMode._visit(this, visitor);
    });
  },

  github: (value: FernFiddle.GithubOutputMode): FernFiddle.OutputMode.Github => {
    const valueWithoutVisit: Omit<FernFiddle.OutputMode.Github, \\"_visit\\"> = {
      ...value,
      type: \\"github\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.OutputMode.Github, visitor: FernFiddle.OutputMode._Visitor<_Result>) {
      return FernFiddle.OutputMode._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): FernFiddle.OutputMode._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<FernFiddle.OutputMode._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.OutputMode._Unknown, visitor: FernFiddle.OutputMode._Visitor<_Result>) {
      return FernFiddle.OutputMode._visit(this, visitor);
    });
  },

  _visit: <_Result>(value: FernFiddle.OutputMode, visitor: FernFiddle.OutputMode._Visitor<_Result>): _Result => {
    switch (value.type) {
      case \\"publish\\":
        return visitor.publish(value);
      case \\"publishV2\\":
        return visitor.publishV2(value.publishV2);
      case \\"downloadFiles\\":
        return visitor.downloadFiles();
      case \\"github\\":
        return visitor.github(value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "OutputMode.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";

export interface Package {
  coordinate: FernFiddle.PackageCoordinate;
  status: FernFiddle.PackagePublishStatus;
}
",
                    "name": "Package.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export type PackageCoordinate =
  | FernFiddle.PackageCoordinate.Npm
  | FernFiddle.PackageCoordinate.Maven
  | FernFiddle.PackageCoordinate.Pypi
  | FernFiddle.PackageCoordinate._Unknown;

export declare namespace PackageCoordinate {
  interface Npm extends FernFiddle.NpmCoordinate, _Utils {
    type: \\"npm\\";
  }

  interface Maven extends FernFiddle.MavenCoordinate, _Utils {
    type: \\"maven\\";
  }

  interface Pypi extends FernFiddle.PypiCoordinate, _Utils {
    type: \\"pypi\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernFiddle.PackageCoordinate._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    npm: (value: FernFiddle.NpmCoordinate) => _Result;
    maven: (value: FernFiddle.MavenCoordinate) => _Result;
    pypi: (value: FernFiddle.PypiCoordinate) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const PackageCoordinate = {
  npm: (value: FernFiddle.NpmCoordinate): FernFiddle.PackageCoordinate.Npm => {
    const valueWithoutVisit: Omit<FernFiddle.PackageCoordinate.Npm, \\"_visit\\"> = {
      ...value,
      type: \\"npm\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.PackageCoordinate.Npm, visitor: FernFiddle.PackageCoordinate._Visitor<_Result>) {
      return FernFiddle.PackageCoordinate._visit(this, visitor);
    });
  },

  maven: (value: FernFiddle.MavenCoordinate): FernFiddle.PackageCoordinate.Maven => {
    const valueWithoutVisit: Omit<FernFiddle.PackageCoordinate.Maven, \\"_visit\\"> = {
      ...value,
      type: \\"maven\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.PackageCoordinate.Maven, visitor: FernFiddle.PackageCoordinate._Visitor<_Result>) {
      return FernFiddle.PackageCoordinate._visit(this, visitor);
    });
  },

  pypi: (value: FernFiddle.PypiCoordinate): FernFiddle.PackageCoordinate.Pypi => {
    const valueWithoutVisit: Omit<FernFiddle.PackageCoordinate.Pypi, \\"_visit\\"> = {
      ...value,
      type: \\"pypi\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.PackageCoordinate.Pypi, visitor: FernFiddle.PackageCoordinate._Visitor<_Result>) {
      return FernFiddle.PackageCoordinate._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): FernFiddle.PackageCoordinate._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<FernFiddle.PackageCoordinate._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.PackageCoordinate._Unknown, visitor: FernFiddle.PackageCoordinate._Visitor<_Result>) {
      return FernFiddle.PackageCoordinate._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: FernFiddle.PackageCoordinate,
    visitor: FernFiddle.PackageCoordinate._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"npm\\":
        return visitor.npm(value);
      case \\"maven\\":
        return visitor.maven(value);
      case \\"pypi\\":
        return visitor.pypi(value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "PackageCoordinate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type PackagePublishStatus = \\"NOT_STARTED_PUBLISHING\\" | \\"PUBLISHING\\" | \\"PUBLISHED\\" | \\"FAILED_TO_PUBLISH\\";

export const PackagePublishStatus = {
  NotStartedPublishing: \\"NOT_STARTED_PUBLISHING\\",
  Publishing: \\"PUBLISHING\\",
  Published: \\"PUBLISHED\\",
  FailedToPublish: \\"FAILED_TO_PUBLISH\\",
} as const;
",
                    "name": "PackagePublishStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface PostmanOutput {
  apiKey: string;
  workspaceId: string;
}
",
                    "name": "PostmanOutput.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";

export interface PublishOutputMode {
  registryOverrides: FernFiddle.RegistryOverrides;
}
",
                    "name": "PublishOutputMode.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export type PublishOutputModeV2 =
  | FernFiddle.PublishOutputModeV2.NpmOverride
  | FernFiddle.PublishOutputModeV2.MavenOverride
  | FernFiddle.PublishOutputModeV2.Postman
  | FernFiddle.PublishOutputModeV2._Unknown;

export declare namespace PublishOutputModeV2 {
  interface NpmOverride extends _Utils {
    type: \\"npmOverride\\";
    npmOverride?: FernFiddle.NpmOutput;
  }

  interface MavenOverride extends _Utils {
    type: \\"mavenOverride\\";
    mavenOverride?: FernFiddle.MavenOutput;
  }

  interface Postman extends FernFiddle.PostmanOutput, _Utils {
    type: \\"postman\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernFiddle.PublishOutputModeV2._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    npmOverride: (value: FernFiddle.NpmOutput | undefined) => _Result;
    mavenOverride: (value: FernFiddle.MavenOutput | undefined) => _Result;
    postman: (value: FernFiddle.PostmanOutput) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const PublishOutputModeV2 = {
  npmOverride: (value?: FernFiddle.NpmOutput): FernFiddle.PublishOutputModeV2.NpmOverride => {
    const valueWithoutVisit: Omit<FernFiddle.PublishOutputModeV2.NpmOverride, \\"_visit\\"> = {
      npmOverride: value,
      type: \\"npmOverride\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.PublishOutputModeV2.NpmOverride, visitor: FernFiddle.PublishOutputModeV2._Visitor<_Result>) {
      return FernFiddle.PublishOutputModeV2._visit(this, visitor);
    });
  },

  mavenOverride: (value?: FernFiddle.MavenOutput): FernFiddle.PublishOutputModeV2.MavenOverride => {
    const valueWithoutVisit: Omit<FernFiddle.PublishOutputModeV2.MavenOverride, \\"_visit\\"> = {
      mavenOverride: value,
      type: \\"mavenOverride\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.PublishOutputModeV2.MavenOverride, visitor: FernFiddle.PublishOutputModeV2._Visitor<_Result>) {
      return FernFiddle.PublishOutputModeV2._visit(this, visitor);
    });
  },

  postman: (value: FernFiddle.PostmanOutput): FernFiddle.PublishOutputModeV2.Postman => {
    const valueWithoutVisit: Omit<FernFiddle.PublishOutputModeV2.Postman, \\"_visit\\"> = {
      ...value,
      type: \\"postman\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.PublishOutputModeV2.Postman, visitor: FernFiddle.PublishOutputModeV2._Visitor<_Result>) {
      return FernFiddle.PublishOutputModeV2._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): FernFiddle.PublishOutputModeV2._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<FernFiddle.PublishOutputModeV2._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.PublishOutputModeV2._Unknown, visitor: FernFiddle.PublishOutputModeV2._Visitor<_Result>) {
      return FernFiddle.PublishOutputModeV2._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: FernFiddle.PublishOutputModeV2,
    visitor: FernFiddle.PublishOutputModeV2._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"npmOverride\\":
        return visitor.npmOverride(value.npmOverride);
      case \\"mavenOverride\\":
        return visitor.mavenOverride(value.mavenOverride);
      case \\"postman\\":
        return visitor.postman(value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "PublishOutputModeV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface PypiCoordinate {
  name: string;
  version: string;
}
",
                    "name": "PypiCoordinate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";

export interface RegistryOverrides {
  npm?: FernFiddle.NpmOutput;
  maven?: FernFiddle.MavenOutput;
}
",
                    "name": "RegistryOverrides.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";

export type RemoteGenJobId = string & {
  RemoteGenJobId: void;
};

export function RemoteGenJobId(value: string): FernFiddle.RemoteGenJobId {
  return value as unknown as FernFiddle.RemoteGenJobId;
}
",
                    "name": "RemoteGenJobId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";

/**
 * A remote gen job can be made up of several tasks.
 * A task corresponds to an instance of a generator (in .fernrc.yml).
 *
 */
export type RemoteGenTaskId = string & {
  RemoteGenTaskId: void;
};

export function RemoteGenTaskId(value: string): FernFiddle.RemoteGenTaskId {
  return value as unknown as FernFiddle.RemoteGenTaskId;
}
",
                    "name": "RemoteGenTaskId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";

export interface Task {
  status: FernFiddle.TaskStatus;
  packages: FernFiddle.Package[];
  logs: FernFiddle.TaskLog[];
}
",
                    "name": "Task.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";

export interface TaskLog {
  level: FernFiddle.LogLevel;
  message: string;
}
",
                    "name": "TaskLog.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export type TaskStatus =
  | FernFiddle.TaskStatus.NotStarted
  | FernFiddle.TaskStatus.Running
  | FernFiddle.TaskStatus.Failed
  | FernFiddle.TaskStatus.Finished
  | FernFiddle.TaskStatus._Unknown;

export declare namespace TaskStatus {
  interface NotStarted extends _Utils {
    type: \\"notStarted\\";
  }

  interface Running extends _Utils {
    type: \\"running\\";
  }

  interface Failed extends FernFiddle.FailedTaskStatus, _Utils {
    type: \\"failed\\";
  }

  interface Finished extends FernFiddle.FinishedTaskStatus, _Utils {
    type: \\"finished\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernFiddle.TaskStatus._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    notStarted: () => _Result;
    running: () => _Result;
    failed: (value: FernFiddle.FailedTaskStatus) => _Result;
    finished: (value: FernFiddle.FinishedTaskStatus) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const TaskStatus = {
  notStarted: (): FernFiddle.TaskStatus.NotStarted => {
    const valueWithoutVisit: Omit<FernFiddle.TaskStatus.NotStarted, \\"_visit\\"> = {
      type: \\"notStarted\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.TaskStatus.NotStarted, visitor: FernFiddle.TaskStatus._Visitor<_Result>) {
      return FernFiddle.TaskStatus._visit(this, visitor);
    });
  },

  running: (): FernFiddle.TaskStatus.Running => {
    const valueWithoutVisit: Omit<FernFiddle.TaskStatus.Running, \\"_visit\\"> = {
      type: \\"running\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.TaskStatus.Running, visitor: FernFiddle.TaskStatus._Visitor<_Result>) {
      return FernFiddle.TaskStatus._visit(this, visitor);
    });
  },

  failed: (value: FernFiddle.FailedTaskStatus): FernFiddle.TaskStatus.Failed => {
    const valueWithoutVisit: Omit<FernFiddle.TaskStatus.Failed, \\"_visit\\"> = {
      ...value,
      type: \\"failed\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.TaskStatus.Failed, visitor: FernFiddle.TaskStatus._Visitor<_Result>) {
      return FernFiddle.TaskStatus._visit(this, visitor);
    });
  },

  finished: (value: FernFiddle.FinishedTaskStatus): FernFiddle.TaskStatus.Finished => {
    const valueWithoutVisit: Omit<FernFiddle.TaskStatus.Finished, \\"_visit\\"> = {
      ...value,
      type: \\"finished\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.TaskStatus.Finished, visitor: FernFiddle.TaskStatus._Visitor<_Result>) {
      return FernFiddle.TaskStatus._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): FernFiddle.TaskStatus._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<FernFiddle.TaskStatus._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernFiddle.TaskStatus._Unknown, visitor: FernFiddle.TaskStatus._Visitor<_Result>) {
      return FernFiddle.TaskStatus._visit(this, visitor);
    });
  },

  _visit: <_Result>(value: FernFiddle.TaskStatus, visitor: FernFiddle.TaskStatus._Visitor<_Result>): _Result => {
    switch (value.type) {
      case \\"notStarted\\":
        return visitor.notStarted();
      case \\"running\\":
        return visitor.running();
      case \\"failed\\":
        return visitor.failed(value);
      case \\"finished\\":
        return visitor.finished(value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "TaskStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface UsernamePassword {
  username: string;
  password: string;
}
",
                    "name": "UsernamePassword.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./RemoteGenJobId\\";
export * from \\"./RemoteGenTaskId\\";
export * from \\"./GeneratorIdAndVersion\\";
export * from \\"./GeneratorConfig\\";
export * from \\"./GeneratorConfigV2\\";
export * from \\"./OutputMode\\";
export * from \\"./PublishOutputMode\\";
export * from \\"./PublishOutputModeV2\\";
export * from \\"./RegistryOverrides\\";
export * from \\"./GeneratorOutputs\\";
export * from \\"./NpmOutput\\";
export * from \\"./MavenOutput\\";
export * from \\"./PostmanOutput\\";
export * from \\"./GithubOutputMode\\";
export * from \\"./GithubPublishInfo\\";
export * from \\"./NpmOutputWithOptionalToken\\";
export * from \\"./MavenOutputWithOptionalCreds\\";
export * from \\"./UsernamePassword\\";
export * from \\"./Task\\";
export * from \\"./TaskStatus\\";
export * from \\"./FailedTaskStatus\\";
export * from \\"./FinishedTaskStatus\\";
export * from \\"./TaskLog\\";
export * from \\"./LogLevel\\";
export * from \\"./Package\\";
export * from \\"./PackagePublishStatus\\";
export * from \\"./PackageCoordinate\\";
export * from \\"./NpmCoordinate\\";
export * from \\"./MavenCoordinate\\";
export * from \\"./PypiCoordinate\\";
export * from \\"./CreateJobResponse\\";
export * from \\"./GeneratorsDoNotExistErrorBodyType\\";
export * from \\"./CannotPublishToNpmScopeDetails\\";
export * from \\"./CannotPublishToMavenGroupDetails\\";
export * from \\"./InsufficientPermissionsDetails\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "remoteGen",
            "type": "directory",
          },
        ],
        "name": "resources",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * as remoteGen from \\"./remoteGen\\";
export * from \\"./remoteGen/types\\";
export * from \\"./remoteGen/errors\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<serializers.remoteGen.createJob.Request.Raw, FernFiddle.CreateJobRequest> =
  core.schemas.object({
    apiName: core.schemas.string(),
    organizationName: core.schemas.string(),
    version: core.schemas.string().optional(),
    generators: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).GeneratorConfig)),
  });

export declare namespace Request {
  interface Raw {
    apiName: string;
    organizationName: string;
    version?: string | null;
    generators: serializers.GeneratorConfig.Raw[];
  }
}

export const Response: core.schemas.Schema<serializers.remoteGen.createJob.Response.Raw, FernFiddle.CreateJobResponse> =
  core.schemas.lazyObject(async () => (await import(\\"../..\\")).CreateJobResponse);

export declare namespace Response {
  type Raw = serializers.CreateJobResponse.Raw;
}

export const Error: core.schemas.Schema<
  serializers.remoteGen.createJob.Error.Raw,
  FernFiddle.remoteGen.createJob.Error
> = core.schemas
  .union(\\"error\\", {
    IllegalApiNameError: core.schemas.object({}),
    GeneratorsDoNotExistError: core.schemas.object({
      content: core.schemas.lazy(async () => (await import(\\"../..\\")).GeneratorsDoNotExistError),
    }),
    CannotPublishToNpmScope: core.schemas.object({
      content: core.schemas.lazy(async () => (await import(\\"../..\\")).CannotPublishToNpmScope),
    }),
    CannotPublishToMavenGroup: core.schemas.object({
      content: core.schemas.lazy(async () => (await import(\\"../..\\")).CannotPublishToMavenGroup),
    }),
    InsufficientPermissions: core.schemas.object({
      content: core.schemas.lazy(async () => (await import(\\"../..\\")).InsufficientPermissions),
    }),
  })
  .transform<FernFiddle.remoteGen.createJob.Error>({
    parse: (value) => {
      switch (value.error) {
        case \\"IllegalApiNameError\\":
          return FernFiddle.remoteGen.createJob.Error.illegalApiNameError();
        case \\"GeneratorsDoNotExistError\\":
          return FernFiddle.remoteGen.createJob.Error.generatorsDoNotExistError(value.content);
        case \\"CannotPublishToNpmScope\\":
          return FernFiddle.remoteGen.createJob.Error.cannotPublishToNpmScope(value.content);
        case \\"CannotPublishToMavenGroup\\":
          return FernFiddle.remoteGen.createJob.Error.cannotPublishToMavenGroup(value.content);
        case \\"InsufficientPermissions\\":
          return FernFiddle.remoteGen.createJob.Error.insufficientPermissions(value.content);
      }
    },
    json: (value) => value as any,
  });

export declare namespace Error {
  type Raw =
    | Error.IllegalApiNameError
    | Error.GeneratorsDoNotExistError
    | Error.CannotPublishToNpmScope
    | Error.CannotPublishToMavenGroup
    | Error.InsufficientPermissions;

  interface IllegalApiNameError {
    error: \\"IllegalApiNameError\\";
  }

  interface GeneratorsDoNotExistError {
    error: \\"GeneratorsDoNotExistError\\";
    content: serializers.GeneratorsDoNotExistError.Raw;
  }

  interface CannotPublishToNpmScope {
    error: \\"CannotPublishToNpmScope\\";
    content: serializers.CannotPublishToNpmScope.Raw;
  }

  interface CannotPublishToMavenGroup {
    error: \\"CannotPublishToMavenGroup\\";
    content: serializers.CannotPublishToMavenGroup.Raw;
  }

  interface InsufficientPermissions {
    error: \\"InsufficientPermissions\\";
    content: serializers.InsufficientPermissions.Raw;
  }
}
",
                    "name": "createJob.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.remoteGen.createJobV2.Request.Raw,
  FernFiddle.CreateJobRequestV2
> = core.schemas.object({
  apiName: core.schemas.string(),
  organizationName: core.schemas.string(),
  version: core.schemas.string().optional(),
  generators: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).GeneratorConfigV2)),
  uploadToS3: core.schemas.boolean().optional(),
});

export declare namespace Request {
  interface Raw {
    apiName: string;
    organizationName: string;
    version?: string | null;
    generators: serializers.GeneratorConfigV2.Raw[];
    uploadToS3?: boolean | null;
  }
}

export const Response: core.schemas.Schema<
  serializers.remoteGen.createJobV2.Response.Raw,
  FernFiddle.CreateJobResponse
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).CreateJobResponse);

export declare namespace Response {
  type Raw = serializers.CreateJobResponse.Raw;
}

export const Error: core.schemas.Schema<
  serializers.remoteGen.createJobV2.Error.Raw,
  FernFiddle.remoteGen.createJobV2.Error
> = core.schemas
  .union(\\"error\\", {
    IllegalApiNameError: core.schemas.object({}),
    GeneratorsDoNotExistError: core.schemas.object({
      content: core.schemas.lazy(async () => (await import(\\"../..\\")).GeneratorsDoNotExistError),
    }),
    CannotPublishToNpmScope: core.schemas.object({
      content: core.schemas.lazy(async () => (await import(\\"../..\\")).CannotPublishToNpmScope),
    }),
    CannotPublishToMavenGroup: core.schemas.object({
      content: core.schemas.lazy(async () => (await import(\\"../..\\")).CannotPublishToMavenGroup),
    }),
    InsufficientPermissions: core.schemas.object({
      content: core.schemas.lazy(async () => (await import(\\"../..\\")).InsufficientPermissions),
    }),
  })
  .transform<FernFiddle.remoteGen.createJobV2.Error>({
    parse: (value) => {
      switch (value.error) {
        case \\"IllegalApiNameError\\":
          return FernFiddle.remoteGen.createJobV2.Error.illegalApiNameError();
        case \\"GeneratorsDoNotExistError\\":
          return FernFiddle.remoteGen.createJobV2.Error.generatorsDoNotExistError(value.content);
        case \\"CannotPublishToNpmScope\\":
          return FernFiddle.remoteGen.createJobV2.Error.cannotPublishToNpmScope(value.content);
        case \\"CannotPublishToMavenGroup\\":
          return FernFiddle.remoteGen.createJobV2.Error.cannotPublishToMavenGroup(value.content);
        case \\"InsufficientPermissions\\":
          return FernFiddle.remoteGen.createJobV2.Error.insufficientPermissions(value.content);
      }
    },
    json: (value) => value as any,
  });

export declare namespace Error {
  type Raw =
    | Error.IllegalApiNameError
    | Error.GeneratorsDoNotExistError
    | Error.CannotPublishToNpmScope
    | Error.CannotPublishToMavenGroup
    | Error.InsufficientPermissions;

  interface IllegalApiNameError {
    error: \\"IllegalApiNameError\\";
  }

  interface GeneratorsDoNotExistError {
    error: \\"GeneratorsDoNotExistError\\";
    content: serializers.GeneratorsDoNotExistError.Raw;
  }

  interface CannotPublishToNpmScope {
    error: \\"CannotPublishToNpmScope\\";
    content: serializers.CannotPublishToNpmScope.Raw;
  }

  interface CannotPublishToMavenGroup {
    error: \\"CannotPublishToMavenGroup\\";
    content: serializers.CannotPublishToMavenGroup.Raw;
  }

  interface InsufficientPermissions {
    error: \\"InsufficientPermissions\\";
    content: serializers.InsufficientPermissions.Raw;
  }
}
",
                    "name": "createJobV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  serializers.remoteGen.getJobStatus.Response.Raw,
  Record<FernFiddle.RemoteGenTaskId, FernFiddle.Task>
> = core.schemas.record(
  core.schemas.lazy(async () => (await import(\\"../..\\")).RemoteGenTaskId),
  core.schemas.lazyObject(async () => (await import(\\"../..\\")).Task)
);

export declare namespace Response {
  type Raw = Record<serializers.RemoteGenTaskId.Raw, serializers.Task.Raw>;
}
",
                    "name": "getJobStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as createJob from \\"./createJob\\";
export * as createJobV2 from \\"./createJobV2\\";
export * as getJobStatus from \\"./getJobStatus\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const CannotPublishToMavenGroup: core.schemas.Schema<
  serializers.CannotPublishToMavenGroup.Raw,
  FernFiddle.CannotPublishToMavenGroup
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).CannotPublishToMavenGroupDetails);

export declare namespace CannotPublishToMavenGroup {
  type Raw = serializers.CannotPublishToMavenGroupDetails.Raw;
}
",
                    "name": "CannotPublishToMavenGroup.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const CannotPublishToNpmScope: core.schemas.Schema<
  serializers.CannotPublishToNpmScope.Raw,
  FernFiddle.CannotPublishToNpmScope
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).CannotPublishToNpmScopeDetails);

export declare namespace CannotPublishToNpmScope {
  type Raw = serializers.CannotPublishToNpmScopeDetails.Raw;
}
",
                    "name": "CannotPublishToNpmScope.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const GeneratorsDoNotExistError: core.schemas.Schema<
  serializers.GeneratorsDoNotExistError.Raw,
  FernFiddle.GeneratorsDoNotExistError
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).GeneratorsDoNotExistErrorBodyType);

export declare namespace GeneratorsDoNotExistError {
  type Raw = serializers.GeneratorsDoNotExistErrorBodyType.Raw;
}
",
                    "name": "GeneratorsDoNotExistError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const InsufficientPermissions: core.schemas.Schema<
  serializers.InsufficientPermissions.Raw,
  FernFiddle.InsufficientPermissions
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).InsufficientPermissionsDetails);

export declare namespace InsufficientPermissions {
  type Raw = serializers.InsufficientPermissionsDetails.Raw;
}
",
                    "name": "InsufficientPermissions.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./GeneratorsDoNotExistError\\";
export * from \\"./CannotPublishToNpmScope\\";
export * from \\"./CannotPublishToMavenGroup\\";
export * from \\"./InsufficientPermissions\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "errors",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./errors\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const CannotPublishToMavenGroupDetails: core.schemas.ObjectSchema<
  serializers.CannotPublishToMavenGroupDetails.Raw,
  FernFiddle.CannotPublishToMavenGroupDetails
> = core.schemas.object({
  generatorId: core.schemas.string(),
  invalidGroup: core.schemas.string(),
  validGroup: core.schemas.string(),
});

export declare namespace CannotPublishToMavenGroupDetails {
  interface Raw {
    generatorId: string;
    invalidGroup: string;
    validGroup: string;
  }
}
",
                    "name": "CannotPublishToMavenGroupDetails.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const CannotPublishToNpmScopeDetails: core.schemas.ObjectSchema<
  serializers.CannotPublishToNpmScopeDetails.Raw,
  FernFiddle.CannotPublishToNpmScopeDetails
> = core.schemas.object({
  generatorId: core.schemas.string(),
  invalidScope: core.schemas.string(),
  validScope: core.schemas.string(),
});

export declare namespace CannotPublishToNpmScopeDetails {
  interface Raw {
    generatorId: string;
    invalidScope: string;
    validScope: string;
  }
}
",
                    "name": "CannotPublishToNpmScopeDetails.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const CreateJobResponse: core.schemas.ObjectSchema<
  serializers.CreateJobResponse.Raw,
  FernFiddle.CreateJobResponse
> = core.schemas.object({
  jobId: core.schemas.lazy(async () => (await import(\\"../..\\")).RemoteGenJobId),
  taskIds: core.schemas.list(core.schemas.lazy(async () => (await import(\\"../..\\")).RemoteGenTaskId)),
});

export declare namespace CreateJobResponse {
  interface Raw {
    jobId: serializers.RemoteGenJobId.Raw;
    taskIds: serializers.RemoteGenTaskId.Raw[];
  }
}
",
                    "name": "CreateJobResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const FailedTaskStatus: core.schemas.ObjectSchema<
  serializers.FailedTaskStatus.Raw,
  FernFiddle.FailedTaskStatus
> = core.schemas.object({
  message: core.schemas.string(),
  s3PreSignedReadUrl: core.schemas.string().optional(),
});

export declare namespace FailedTaskStatus {
  interface Raw {
    message: string;
    s3PreSignedReadUrl?: string | null;
  }
}
",
                    "name": "FailedTaskStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const FinishedTaskStatus: core.schemas.ObjectSchema<
  serializers.FinishedTaskStatus.Raw,
  FernFiddle.FinishedTaskStatus
> = core.schemas.object({
  hasFilesToDownload: core.schemas.boolean(),
  s3PreSignedReadUrl: core.schemas.string(),
  s3PreSignedReadUrlV2: core.schemas.string().optional(),
});

export declare namespace FinishedTaskStatus {
  interface Raw {
    hasFilesToDownload: boolean;
    s3PreSignedReadUrl: string;
    s3PreSignedReadUrlV2?: string | null;
  }
}
",
                    "name": "FinishedTaskStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const GeneratorConfig: core.schemas.ObjectSchema<serializers.GeneratorConfig.Raw, FernFiddle.GeneratorConfig> =
  core.schemas.object({
    id: core.schemas.string(),
    version: core.schemas.string(),
    customConfig: core.schemas.unknown(),
    willDownloadFiles: core.schemas.boolean(),
    outputs: core.schemas.lazyObject(async () => (await import(\\"../..\\")).GeneratorOutputs),
  });

export declare namespace GeneratorConfig {
  interface Raw {
    id: string;
    version: string;
    customConfig?: unknown;
    willDownloadFiles: boolean;
    outputs: serializers.GeneratorOutputs.Raw;
  }
}
",
                    "name": "GeneratorConfig.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const GeneratorConfigV2: core.schemas.ObjectSchema<
  serializers.GeneratorConfigV2.Raw,
  FernFiddle.GeneratorConfigV2
> = core.schemas.object({
  id: core.schemas.string(),
  version: core.schemas.string(),
  customConfig: core.schemas.unknown(),
  outputMode: core.schemas.lazy(async () => (await import(\\"../..\\")).OutputMode),
});

export declare namespace GeneratorConfigV2 {
  interface Raw {
    id: string;
    version: string;
    customConfig?: unknown;
    outputMode: serializers.OutputMode.Raw;
  }
}
",
                    "name": "GeneratorConfigV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const GeneratorIdAndVersion: core.schemas.ObjectSchema<
  serializers.GeneratorIdAndVersion.Raw,
  FernFiddle.GeneratorIdAndVersion
> = core.schemas.object({
  id: core.schemas.string(),
  version: core.schemas.string(),
});

export declare namespace GeneratorIdAndVersion {
  interface Raw {
    id: string;
    version: string;
  }
}
",
                    "name": "GeneratorIdAndVersion.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const GeneratorOutputs: core.schemas.ObjectSchema<
  serializers.GeneratorOutputs.Raw,
  FernFiddle.GeneratorOutputs
> = core.schemas.object({
  npm: core.schemas.lazyObject(async () => (await import(\\"../..\\")).NpmOutput).optional(),
  maven: core.schemas.lazyObject(async () => (await import(\\"../..\\")).MavenOutput).optional(),
});

export declare namespace GeneratorOutputs {
  interface Raw {
    npm?: serializers.NpmOutput.Raw | null;
    maven?: serializers.MavenOutput.Raw | null;
  }
}
",
                    "name": "GeneratorOutputs.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const GeneratorsDoNotExistErrorBodyType: core.schemas.ObjectSchema<
  serializers.GeneratorsDoNotExistErrorBodyType.Raw,
  FernFiddle.GeneratorsDoNotExistErrorBodyType
> = core.schemas.object({
  nonExistentGenerators: core.schemas.list(
    core.schemas.lazyObject(async () => (await import(\\"../..\\")).GeneratorIdAndVersion)
  ),
});

export declare namespace GeneratorsDoNotExistErrorBodyType {
  interface Raw {
    nonExistentGenerators: serializers.GeneratorIdAndVersion.Raw[];
  }
}
",
                    "name": "GeneratorsDoNotExistErrorBodyType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const GithubOutputMode: core.schemas.ObjectSchema<
  serializers.GithubOutputMode.Raw,
  FernFiddle.GithubOutputMode
> = core.schemas.object({
  owner: core.schemas.string(),
  repo: core.schemas.string(),
  publishInfo: core.schemas.lazy(async () => (await import(\\"../..\\")).GithubPublishInfo).optional(),
});

export declare namespace GithubOutputMode {
  interface Raw {
    owner: string;
    repo: string;
    publishInfo?: serializers.GithubPublishInfo.Raw | null;
  }
}
",
                    "name": "GithubOutputMode.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const GithubPublishInfo: core.schemas.Schema<serializers.GithubPublishInfo.Raw, FernFiddle.GithubPublishInfo> =
  core.schemas
    .union(\\"type\\", {
      npm: core.schemas.lazyObject(async () => (await import(\\"../..\\")).NpmOutputWithOptionalToken),
      maven: core.schemas.lazyObject(async () => (await import(\\"../..\\")).MavenOutputWithOptionalCreds),
      postman: core.schemas.lazyObject(async () => (await import(\\"../..\\")).PostmanOutput),
    })
    .transform<FernFiddle.GithubPublishInfo>({
      parse: (value) => {
        switch (value.type) {
          case \\"npm\\":
            return FernFiddle.GithubPublishInfo.npm(value);
          case \\"maven\\":
            return FernFiddle.GithubPublishInfo.maven(value);
          case \\"postman\\":
            return FernFiddle.GithubPublishInfo.postman(value);
          default:
            return FernFiddle.GithubPublishInfo._unknown(value);
        }
      },
      json: (value) => value as any,
    });

export declare namespace GithubPublishInfo {
  type Raw = GithubPublishInfo.Npm | GithubPublishInfo.Maven | GithubPublishInfo.Postman;

  interface Npm extends serializers.NpmOutputWithOptionalToken.Raw {
    type: \\"npm\\";
  }

  interface Maven extends serializers.MavenOutputWithOptionalCreds.Raw {
    type: \\"maven\\";
  }

  interface Postman extends serializers.PostmanOutput.Raw {
    type: \\"postman\\";
  }
}
",
                    "name": "GithubPublishInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const InsufficientPermissionsDetails: core.schemas.ObjectSchema<
  serializers.InsufficientPermissionsDetails.Raw,
  FernFiddle.InsufficientPermissionsDetails
> = core.schemas.object({
  dummy: core.schemas.string().optional(),
});

export declare namespace InsufficientPermissionsDetails {
  interface Raw {
    dummy?: string | null;
  }
}
",
                    "name": "InsufficientPermissionsDetails.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const LogLevel: core.schemas.Schema<serializers.LogLevel.Raw, FernFiddle.LogLevel> = core.schemas.enum_([
  \\"DEBUG\\",
  \\"INFO\\",
  \\"WARN\\",
  \\"ERROR\\",
]);

export declare namespace LogLevel {
  type Raw = \\"DEBUG\\" | \\"INFO\\" | \\"WARN\\" | \\"ERROR\\";
}
",
                    "name": "LogLevel.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const MavenCoordinate: core.schemas.ObjectSchema<serializers.MavenCoordinate.Raw, FernFiddle.MavenCoordinate> =
  core.schemas.object({
    group: core.schemas.string(),
    artifact: core.schemas.string(),
    version: core.schemas.string(),
  });

export declare namespace MavenCoordinate {
  interface Raw {
    group: string;
    artifact: string;
    version: string;
  }
}
",
                    "name": "MavenCoordinate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const MavenOutput: core.schemas.ObjectSchema<serializers.MavenOutput.Raw, FernFiddle.MavenOutput> =
  core.schemas.object({
    registryUrl: core.schemas.string(),
    username: core.schemas.string(),
    password: core.schemas.string(),
    coordinate: core.schemas.string(),
  });

export declare namespace MavenOutput {
  interface Raw {
    registryUrl: string;
    username: string;
    password: string;
    coordinate: string;
  }
}
",
                    "name": "MavenOutput.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const MavenOutputWithOptionalCreds: core.schemas.ObjectSchema<
  serializers.MavenOutputWithOptionalCreds.Raw,
  FernFiddle.MavenOutputWithOptionalCreds
> = core.schemas.object({
  registryUrl: core.schemas.string(),
  coordinate: core.schemas.string(),
  credentials: core.schemas.lazyObject(async () => (await import(\\"../..\\")).UsernamePassword).optional(),
});

export declare namespace MavenOutputWithOptionalCreds {
  interface Raw {
    registryUrl: string;
    coordinate: string;
    credentials?: serializers.UsernamePassword.Raw | null;
  }
}
",
                    "name": "MavenOutputWithOptionalCreds.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const NpmCoordinate: core.schemas.ObjectSchema<serializers.NpmCoordinate.Raw, FernFiddle.NpmCoordinate> =
  core.schemas.object({
    name: core.schemas.string(),
    version: core.schemas.string(),
  });

export declare namespace NpmCoordinate {
  interface Raw {
    name: string;
    version: string;
  }
}
",
                    "name": "NpmCoordinate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const NpmOutput: core.schemas.ObjectSchema<serializers.NpmOutput.Raw, FernFiddle.NpmOutput> =
  core.schemas.object({
    registryUrl: core.schemas.string(),
    packageName: core.schemas.string(),
    token: core.schemas.string(),
  });

export declare namespace NpmOutput {
  interface Raw {
    registryUrl: string;
    packageName: string;
    token: string;
  }
}
",
                    "name": "NpmOutput.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const NpmOutputWithOptionalToken: core.schemas.ObjectSchema<
  serializers.NpmOutputWithOptionalToken.Raw,
  FernFiddle.NpmOutputWithOptionalToken
> = core.schemas.object({
  registryUrl: core.schemas.string(),
  packageName: core.schemas.string(),
  token: core.schemas.string().optional(),
});

export declare namespace NpmOutputWithOptionalToken {
  interface Raw {
    registryUrl: string;
    packageName: string;
    token?: string | null;
  }
}
",
                    "name": "NpmOutputWithOptionalToken.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const OutputMode: core.schemas.Schema<serializers.OutputMode.Raw, FernFiddle.OutputMode> = core.schemas
  .union(\\"type\\", {
    publish: core.schemas.lazyObject(async () => (await import(\\"../..\\")).PublishOutputMode),
    publishV2: core.schemas.object({
      publishV2: core.schemas.lazy(async () => (await import(\\"../..\\")).PublishOutputModeV2),
    }),
    downloadFiles: core.schemas.object({}),
    github: core.schemas.lazyObject(async () => (await import(\\"../..\\")).GithubOutputMode),
  })
  .transform<FernFiddle.OutputMode>({
    parse: (value) => {
      switch (value.type) {
        case \\"publish\\":
          return FernFiddle.OutputMode.publish(value);
        case \\"publishV2\\":
          return FernFiddle.OutputMode.publishV2(value.publishV2);
        case \\"downloadFiles\\":
          return FernFiddle.OutputMode.downloadFiles();
        case \\"github\\":
          return FernFiddle.OutputMode.github(value);
        default:
          return FernFiddle.OutputMode._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace OutputMode {
  type Raw = OutputMode.Publish | OutputMode.PublishV2 | OutputMode.DownloadFiles | OutputMode.Github;

  interface Publish extends serializers.PublishOutputMode.Raw {
    type: \\"publish\\";
  }

  interface PublishV2 {
    type: \\"publishV2\\";
    publishV2: serializers.PublishOutputModeV2.Raw;
  }

  interface DownloadFiles {
    type: \\"downloadFiles\\";
  }

  interface Github extends serializers.GithubOutputMode.Raw {
    type: \\"github\\";
  }
}
",
                    "name": "OutputMode.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const Package: core.schemas.ObjectSchema<serializers.Package.Raw, FernFiddle.Package> = core.schemas.object({
  coordinate: core.schemas.lazy(async () => (await import(\\"../..\\")).PackageCoordinate),
  status: core.schemas.lazy(async () => (await import(\\"../..\\")).PackagePublishStatus),
});

export declare namespace Package {
  interface Raw {
    coordinate: serializers.PackageCoordinate.Raw;
    status: serializers.PackagePublishStatus.Raw;
  }
}
",
                    "name": "Package.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const PackageCoordinate: core.schemas.Schema<serializers.PackageCoordinate.Raw, FernFiddle.PackageCoordinate> =
  core.schemas
    .union(core.schemas.discriminant(\\"type\\", \\"_type\\"), {
      npm: core.schemas.lazyObject(async () => (await import(\\"../..\\")).NpmCoordinate),
      maven: core.schemas.lazyObject(async () => (await import(\\"../..\\")).MavenCoordinate),
      pypi: core.schemas.lazyObject(async () => (await import(\\"../..\\")).PypiCoordinate),
    })
    .transform<FernFiddle.PackageCoordinate>({
      parse: (value) => {
        switch (value.type) {
          case \\"npm\\":
            return FernFiddle.PackageCoordinate.npm(value);
          case \\"maven\\":
            return FernFiddle.PackageCoordinate.maven(value);
          case \\"pypi\\":
            return FernFiddle.PackageCoordinate.pypi(value);
          default:
            return FernFiddle.PackageCoordinate._unknown(value);
        }
      },
      json: (value) => value as any,
    });

export declare namespace PackageCoordinate {
  type Raw = PackageCoordinate.Npm | PackageCoordinate.Maven | PackageCoordinate.Pypi;

  interface Npm extends serializers.NpmCoordinate.Raw {
    _type: \\"npm\\";
  }

  interface Maven extends serializers.MavenCoordinate.Raw {
    _type: \\"maven\\";
  }

  interface Pypi extends serializers.PypiCoordinate.Raw {
    _type: \\"pypi\\";
  }
}
",
                    "name": "PackageCoordinate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const PackagePublishStatus: core.schemas.Schema<
  serializers.PackagePublishStatus.Raw,
  FernFiddle.PackagePublishStatus
> = core.schemas.enum_([\\"NOT_STARTED_PUBLISHING\\", \\"PUBLISHING\\", \\"PUBLISHED\\", \\"FAILED_TO_PUBLISH\\"]);

export declare namespace PackagePublishStatus {
  type Raw = \\"NOT_STARTED_PUBLISHING\\" | \\"PUBLISHING\\" | \\"PUBLISHED\\" | \\"FAILED_TO_PUBLISH\\";
}
",
                    "name": "PackagePublishStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const PostmanOutput: core.schemas.ObjectSchema<serializers.PostmanOutput.Raw, FernFiddle.PostmanOutput> =
  core.schemas.object({
    apiKey: core.schemas.string(),
    workspaceId: core.schemas.string(),
  });

export declare namespace PostmanOutput {
  interface Raw {
    apiKey: string;
    workspaceId: string;
  }
}
",
                    "name": "PostmanOutput.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const PublishOutputMode: core.schemas.ObjectSchema<
  serializers.PublishOutputMode.Raw,
  FernFiddle.PublishOutputMode
> = core.schemas.object({
  registryOverrides: core.schemas.lazyObject(async () => (await import(\\"../..\\")).RegistryOverrides),
});

export declare namespace PublishOutputMode {
  interface Raw {
    registryOverrides: serializers.RegistryOverrides.Raw;
  }
}
",
                    "name": "PublishOutputMode.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const PublishOutputModeV2: core.schemas.Schema<
  serializers.PublishOutputModeV2.Raw,
  FernFiddle.PublishOutputModeV2
> = core.schemas
  .union(\\"type\\", {
    npmOverride: core.schemas.object({
      npmOverride: core.schemas.lazyObject(async () => (await import(\\"../..\\")).NpmOutput).optional(),
    }),
    mavenOverride: core.schemas.object({
      mavenOverride: core.schemas.lazyObject(async () => (await import(\\"../..\\")).MavenOutput).optional(),
    }),
    postman: core.schemas.lazyObject(async () => (await import(\\"../..\\")).PostmanOutput),
  })
  .transform<FernFiddle.PublishOutputModeV2>({
    parse: (value) => {
      switch (value.type) {
        case \\"npmOverride\\":
          return FernFiddle.PublishOutputModeV2.npmOverride(value.npmOverride);
        case \\"mavenOverride\\":
          return FernFiddle.PublishOutputModeV2.mavenOverride(value.mavenOverride);
        case \\"postman\\":
          return FernFiddle.PublishOutputModeV2.postman(value);
        default:
          return FernFiddle.PublishOutputModeV2._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace PublishOutputModeV2 {
  type Raw = PublishOutputModeV2.NpmOverride | PublishOutputModeV2.MavenOverride | PublishOutputModeV2.Postman;

  interface NpmOverride {
    type: \\"npmOverride\\";
    npmOverride?: serializers.NpmOutput.Raw | null;
  }

  interface MavenOverride {
    type: \\"mavenOverride\\";
    mavenOverride?: serializers.MavenOutput.Raw | null;
  }

  interface Postman extends serializers.PostmanOutput.Raw {
    type: \\"postman\\";
  }
}
",
                    "name": "PublishOutputModeV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const PypiCoordinate: core.schemas.ObjectSchema<serializers.PypiCoordinate.Raw, FernFiddle.PypiCoordinate> =
  core.schemas.object({
    name: core.schemas.string(),
    version: core.schemas.string(),
  });

export declare namespace PypiCoordinate {
  interface Raw {
    name: string;
    version: string;
  }
}
",
                    "name": "PypiCoordinate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const RegistryOverrides: core.schemas.ObjectSchema<
  serializers.RegistryOverrides.Raw,
  FernFiddle.RegistryOverrides
> = core.schemas.object({
  npm: core.schemas.lazyObject(async () => (await import(\\"../..\\")).NpmOutput).optional(),
  maven: core.schemas.lazyObject(async () => (await import(\\"../..\\")).MavenOutput).optional(),
});

export declare namespace RegistryOverrides {
  interface Raw {
    npm?: serializers.NpmOutput.Raw | null;
    maven?: serializers.MavenOutput.Raw | null;
  }
}
",
                    "name": "RegistryOverrides.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const RemoteGenJobId: core.schemas.Schema<serializers.RemoteGenJobId.Raw, FernFiddle.RemoteGenJobId> =
  core.schemas.string().transform({
    parse: FernFiddle.RemoteGenJobId,
    json: (value) => value,
  });

export declare namespace RemoteGenJobId {
  type Raw = string;
}
",
                    "name": "RemoteGenJobId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const RemoteGenTaskId: core.schemas.Schema<serializers.RemoteGenTaskId.Raw, FernFiddle.RemoteGenTaskId> =
  core.schemas.string().transform({
    parse: FernFiddle.RemoteGenTaskId,
    json: (value) => value,
  });

export declare namespace RemoteGenTaskId {
  type Raw = string;
}
",
                    "name": "RemoteGenTaskId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const Task: core.schemas.ObjectSchema<serializers.Task.Raw, FernFiddle.Task> = core.schemas.object({
  status: core.schemas.lazy(async () => (await import(\\"../..\\")).TaskStatus),
  packages: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).Package)),
  logs: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).TaskLog)),
});

export declare namespace Task {
  interface Raw {
    status: serializers.TaskStatus.Raw;
    packages: serializers.Package.Raw[];
    logs: serializers.TaskLog.Raw[];
  }
}
",
                    "name": "Task.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const TaskLog: core.schemas.ObjectSchema<serializers.TaskLog.Raw, FernFiddle.TaskLog> = core.schemas.object({
  level: core.schemas.lazy(async () => (await import(\\"../..\\")).LogLevel),
  message: core.schemas.string(),
});

export declare namespace TaskLog {
  interface Raw {
    level: serializers.LogLevel.Raw;
    message: string;
  }
}
",
                    "name": "TaskLog.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const TaskStatus: core.schemas.Schema<serializers.TaskStatus.Raw, FernFiddle.TaskStatus> = core.schemas
  .union(core.schemas.discriminant(\\"type\\", \\"_type\\"), {
    notStarted: core.schemas.object({}),
    running: core.schemas.object({}),
    failed: core.schemas.lazyObject(async () => (await import(\\"../..\\")).FailedTaskStatus),
    finished: core.schemas.lazyObject(async () => (await import(\\"../..\\")).FinishedTaskStatus),
  })
  .transform<FernFiddle.TaskStatus>({
    parse: (value) => {
      switch (value.type) {
        case \\"notStarted\\":
          return FernFiddle.TaskStatus.notStarted();
        case \\"running\\":
          return FernFiddle.TaskStatus.running();
        case \\"failed\\":
          return FernFiddle.TaskStatus.failed(value);
        case \\"finished\\":
          return FernFiddle.TaskStatus.finished(value);
        default:
          return FernFiddle.TaskStatus._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace TaskStatus {
  type Raw = TaskStatus.NotStarted | TaskStatus.Running | TaskStatus.Failed | TaskStatus.Finished;

  interface NotStarted {
    _type: \\"notStarted\\";
  }

  interface Running {
    _type: \\"running\\";
  }

  interface Failed extends serializers.FailedTaskStatus.Raw {
    _type: \\"failed\\";
  }

  interface Finished extends serializers.FinishedTaskStatus.Raw {
    _type: \\"finished\\";
  }
}
",
                    "name": "TaskStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernFiddle } from \\"@fern-fern/fiddle-sdk\\";
import * as core from \\"../../../core\\";

export const UsernamePassword: core.schemas.ObjectSchema<
  serializers.UsernamePassword.Raw,
  FernFiddle.UsernamePassword
> = core.schemas.object({
  username: core.schemas.string(),
  password: core.schemas.string(),
});

export declare namespace UsernamePassword {
  interface Raw {
    username: string;
    password: string;
  }
}
",
                    "name": "UsernamePassword.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./RemoteGenJobId\\";
export * from \\"./RemoteGenTaskId\\";
export * from \\"./GeneratorIdAndVersion\\";
export * from \\"./GeneratorConfig\\";
export * from \\"./GeneratorConfigV2\\";
export * from \\"./OutputMode\\";
export * from \\"./PublishOutputMode\\";
export * from \\"./PublishOutputModeV2\\";
export * from \\"./RegistryOverrides\\";
export * from \\"./GeneratorOutputs\\";
export * from \\"./NpmOutput\\";
export * from \\"./MavenOutput\\";
export * from \\"./PostmanOutput\\";
export * from \\"./GithubOutputMode\\";
export * from \\"./GithubPublishInfo\\";
export * from \\"./NpmOutputWithOptionalToken\\";
export * from \\"./MavenOutputWithOptionalCreds\\";
export * from \\"./UsernamePassword\\";
export * from \\"./Task\\";
export * from \\"./TaskStatus\\";
export * from \\"./FailedTaskStatus\\";
export * from \\"./FinishedTaskStatus\\";
export * from \\"./TaskLog\\";
export * from \\"./LogLevel\\";
export * from \\"./Package\\";
export * from \\"./PackagePublishStatus\\";
export * from \\"./PackageCoordinate\\";
export * from \\"./NpmCoordinate\\";
export * from \\"./MavenCoordinate\\";
export * from \\"./PypiCoordinate\\";
export * from \\"./CreateJobResponse\\";
export * from \\"./GeneratorsDoNotExistErrorBodyType\\";
export * from \\"./CannotPublishToNpmScopeDetails\\";
export * from \\"./CannotPublishToMavenGroupDetails\\";
export * from \\"./InsufficientPermissionsDetails\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "remoteGen",
            "type": "directory",
          },
        ],
        "name": "serialization",
        "type": "directory",
      },
    ],
    "name": "src",
    "type": "directory",
  },
  Object {
    "contents": "{
    \\"compilerOptions\\": {
        \\"strict\\": true,
        \\"target\\": \\"esnext\\",
        \\"module\\": \\"esnext\\",
        \\"moduleResolution\\": \\"node\\",
        \\"esModuleInterop\\": true,
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"emitDeclarationOnly\\": true,
        \\"sourceMap\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true,
        \\"outDir\\": \\".\\",
        \\"rootDir\\": \\"src\\",
        \\"baseUrl\\": \\"src\\",
        \\"paths\\": {
            \\"@fern-fern/fiddle-sdk\\": [
                \\".\\"
            ]
        }
    },
    \\"include\\": [
        \\"src\\"
    ],
    \\"exclude\\": []
}",
    "name": "tsconfig.json",
    "type": "file",
  },
]
`;

exports[`runGenerator nursery 1`] = `
Array [
  Object {
    "contents": Array [
      Object {
        "contents": Array [
          Object {
            "contents": "name: ci

on: [push]

jobs:
  compile:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Set up node
        uses: actions/setup-node@v3

      - name: Compile
        run: yarn && yarn build
  
  publish:
    needs: [ compile ]
    if: github.event_name == 'push' && contains(github.ref, 'refs/tags/')
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Set up node
        uses: actions/setup-node@v3

      - name: Install dependencies
        run: yarn install

      - name: Build
        run: yarn build

      - name: Publish to npm
        run: |
          npm config set //registry.npmjs.org/:_authToken \${NPM_TOKEN}
          npm publish --ignore-scripts --access restricted
        env:
          NPM_TOKEN: \${{ secrets.NPM_TOKEN }}",
            "name": "ci.yml",
            "type": "file",
          },
        ],
        "name": "workflows",
        "type": "directory",
      },
    ],
    "name": ".github",
    "type": "directory",
  },
  Object {
    "contents": "node_modules
.DS_Store
*.d.ts
*.js
*.js.map
*.cjs
*.mjs

# yarn berry
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions

# these are needed to override '*.js' above
!.yarn/patches/**
!.yarn/plugins/**
!.yarn/releases/**
!.yarn/sdks/**
!.yarn/versions/**",
    "name": ".gitignore",
    "type": "file",
  },
  Object {
    "contents": ".yarn
node_modules
.npmignore
.pnp.cjs
*.js
*.d.ts",
    "name": ".prettierignore",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "{
  \\"recommendations\\": [
    \\"arcanis.vscode-zipfs\\",
    \\"esbenp.prettier-vscode\\"
  ]
}
",
        "name": "extensions.json",
        "type": "file",
      },
      Object {
        "contents": "{
  \\"search.exclude\\": {
    \\"**/.yarn\\": true,
    \\"**/.pnp.*\\": true
  },
  \\"prettier.prettierPath\\": \\".yarn/sdks/prettier/index.js\\",
  \\"typescript.tsdk\\": \\".yarn/sdks/typescript/lib\\",
  \\"typescript.enablePromptUseWorkspaceTsdk\\": true
}
",
        "name": "settings.json",
        "type": "file",
      },
    ],
    "name": ".vscode",
    "type": "directory",
  },
  Object {
    "contents": "nodeLinker: pnp

yarnPath: .yarn/releases/yarn-3.2.4.cjs
",
    "name": ".yarnrc.yml",
    "type": "file",
  },
  Object {
    "contents": "{
    \\"name\\": \\"@fern/api\\",
    \\"version\\": \\"0.0.1\\",
    \\"private\\": true,
    \\"repository\\": \\"https://github.com/fern/api}\\",
    \\"files\\": [
        \\"index.mjs\\",
        \\"index.cjs\\",
        \\"browser.js\\",
        \\"browser.js.map\\",
        \\"*.d.ts\\"
    ],
    \\"exports\\": {
        \\".\\": {
            \\"import\\": \\"./index.mjs\\",
            \\"module\\": \\"./index.mjs\\",
            \\"require\\": \\"./index.cjs\\",
            \\"browser\\": \\"./browser.js\\",
            \\"default\\": \\"./index.cjs\\"
        }
    },
    \\"types\\": \\"./index.d.ts\\",
    \\"scripts\\": {
        \\"format\\": \\"prettier --write --print-width 120 src/**/*.ts\\",
        \\"build:esm\\": \\"esbuild src/index.ts --bundle --platform=node --format=esm --outfile=index.mjs\\",
        \\"build:cjs\\": \\"esbuild src/index.ts --bundle --platform=node --format=cjs --outfile=index.cjs\\",
        \\"build:browser\\": \\"esbuild src/index.ts --bundle --platform=browser --sourcemap --outfile=browser.js\\",
        \\"build\\": \\"yarn build:esm && yarn build:cjs && yarn build:browser && tsc && tsc-alias\\"
    },
    \\"dependencies\\": {
        \\"@types/url-join\\": \\"4.0.1\\",
        \\"axios\\": \\"^0.27.2\\",
        \\"url-join\\": \\"4.0.1\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"esbuild\\": \\"0.16.13\\",
        \\"prettier\\": \\"2.7.1\\",
        \\"tsc-alias\\": \\"^1.7.1\\",
        \\"typescript\\": \\"4.6.4\\"
    },
    \\"packageManager\\": \\"yarn@3.2.4\\"
}
",
    "name": "package.json",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { Client as OwnerClient } from \\"./resources/owner/client/Client\\";
import { Client as TokenClient } from \\"./resources/token/client/Client\\";

export declare namespace FernApiClient {
  interface Options {
    environment: string;
    apiVersion: string;
  }
}

export class FernApiClient {
  constructor(private readonly options: FernApiClient.Options) {}

  #owner: OwnerClient | undefined;

  public get owner(): OwnerClient {
    return (this.#owner ??= new OwnerClient(this.options));
  }

  #token: TokenClient | undefined;

  public get token(): TokenClient {
    return (this.#token ??= new TokenClient(this.options));
  }
}
",
        "name": "Client.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "export type APIResponse<Success, Failure> = SuccessfulResponse<Success> | FailedResponse<Failure>;

export interface SuccessfulResponse<T> {
  ok: true;
  body: T;
}

export interface FailedResponse<T> {
  ok: false;
  error: T;
}
",
                "name": "APIResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import axios, { AxiosError } from \\"axios\\";
import { APIResponse } from \\"./APIResponse\\";

export interface Fetcher {
  fetch: FetchFunction;
}

export type FetchFunction = (args: Fetcher.Args) => Promise<APIResponse<unknown, Fetcher.Error>>;

export declare namespace Fetcher {
  export interface Args {
    url: string;
    method: string;
    headers?: Record<string, string | undefined>;
    queryParameters?: URLSearchParams;
    body?: unknown;
    timeoutMs?: number;
  }

  export type Error = FailedStatusCodeError | NonJsonError | TimeoutError | UnknownError;

  export interface FailedStatusCodeError {
    reason: \\"status-code\\";
    statusCode: number;
    body: unknown;
  }

  export interface NonJsonError {
    reason: \\"non-json\\";
    statusCode: number;
    rawBody: string;
  }

  export interface TimeoutError {
    reason: \\"timeout\\";
  }

  export interface UnknownError {
    reason: \\"unknown\\";
    errorMessage: string;
  }
}

export const fetcher: FetchFunction = async (args) => {
  const headers: Record<string, string> = {
    \\"Content-Type\\": \\"application/json\\",
  };

  if (args.headers != null) {
    for (const [key, value] of Object.entries(args.headers)) {
      if (value != null) {
        headers[key] = value;
      }
    }
  }

  try {
    const response = await axios({
      url: args.url,
      params: args.queryParameters,
      method: args.method,
      headers,
      data: args.body,
      validateStatus: () => true,
      transformResponse: (response) => response,
      timeout: args.timeoutMs ?? 60_000,
      transitional: {
        clarifyTimeoutError: true,
      },
      withCredentials: true,
    });

    let body: unknown;
    if (response.data != null && response.data.length > 0) {
      try {
        body = JSON.parse(response.data) ?? undefined;
      } catch {
        return {
          ok: false,
          error: {
            reason: \\"non-json\\",
            statusCode: response.status,
            rawBody: response.data,
          },
        };
      }
    }

    if (response.status >= 200 && response.status < 300) {
      return {
        ok: true,
        body,
      };
    } else {
      return {
        ok: false,
        error: {
          reason: \\"status-code\\",
          statusCode: response.status,
          body,
        },
      };
    }
  } catch (error) {
    if ((error as AxiosError).code === \\"ETIMEDOUT\\") {
      return {
        ok: false,
        error: {
          reason: \\"timeout\\",
        },
      };
    }

    return {
      ok: false,
      error: {
        reason: \\"unknown\\",
        errorMessage: (error as AxiosError).message,
      },
    };
  }
};
",
                "name": "Fetcher.ts",
                "type": "file",
              },
              Object {
                "contents": "export type Supplier<T> = T | Promise<T> | (() => T | Promise<T>);

export const Supplier = {
  get: async <T>(supplier: Supplier<T>): Promise<T> => {
    if (typeof supplier === \\"function\\") {
      return (supplier as () => T)();
    } else {
      return supplier;
    }
  },
};
",
                "name": "Supplier.ts",
                "type": "file",
              },
              Object {
                "contents": "export { type APIResponse } from \\"./APIResponse\\";
export { fetcher, type Fetcher, type FetchFunction } from \\"./Fetcher\\";
export { Supplier } from \\"./Supplier\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "fetcher",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./utils\\";
export * as schemas from \\"./schemas\\";
export * from \\"./fetcher\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { SchemaUtils } from \\"./builders\\";

export type Schema<Raw = unknown, Parsed = unknown> = BaseSchema<Raw, Parsed> & SchemaUtils<Raw, Parsed>;

export type inferRaw<S extends Schema> = S extends Schema<infer Raw, any> ? Raw : never;
export type inferParsed<S extends Schema> = S extends Schema<any, infer Parsed> ? Parsed : never;

export interface BaseSchema<Raw, Parsed> {
  parse: (raw: Raw, opts?: SchemaOptions) => Parsed | Promise<Parsed>;
  json: (parsed: Parsed, opts?: SchemaOptions) => Raw | Promise<Raw>;
}

export interface SchemaOptions {
  /**
   * @default false
   */
  skipUnknownKeysOnParse?: boolean;

  /**
   * @default false
   */
  includeUnknownKeysOnJson?: boolean;
}
",
                "name": "Schema.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function date(): Schema<string, Date> {
  const baseSchema: BaseSchema<string, Date> = {
    parse: (raw) => new Date(raw),
    json: (date) => date.toISOString(),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "date.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { date } from \\"./date\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "date",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function enum_<U extends string, E extends Readonly<[U, ...U[]]>>(_values: E): Schema<E[number], E[number]> {
  return createIdentitySchemaCreator<E[number]>()();
}
",
                        "name": "enum.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { enum_ } from \\"./enum\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "enum",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { identity } from \\"./identity\\";

export function createIdentitySchemaCreator<T>(): () => Schema<T, T> {
  return <T>() => identity<T>();
}
",
                        "name": "createIdentitySchemaCreator.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function identity<T>(): Schema<T, T> {
  const baseSchema: BaseSchema<T, T> = {
    parse: (raw) => raw,
    json: (parsed) => parsed,
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "identity.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { createIdentitySchemaCreator } from \\"./createIdentitySchemaCreator\\";
export { identity } from \\"./identity\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "identity",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./date\\";
export * from \\"./enum\\";
export * from \\"./identity\\";
export * from \\"./lazy\\";
export * from \\"./list\\";
export * from \\"./literals\\";
export * from \\"./object\\";
export * from \\"./object-like\\";
export * from \\"./primitives\\";
export * from \\"./record\\";
export * from \\"./schema-utils\\";
export * from \\"./set\\";
export * from \\"./union\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { lazy, type SchemaGetter } from \\"./lazy\\";
export { lazyObject } from \\"./lazyObject\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export type SchemaGetter<SchemaType extends Schema<any, any>> = () => SchemaType | Promise<SchemaType>;

export function lazy<Raw, Parsed>(getter: SchemaGetter<Schema<Raw, Parsed>>): Schema<Raw, Parsed> {
  const baseSchema = constructLazyBaseSchema(getter);
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function constructLazyBaseSchema<Raw, Parsed>(
  getter: SchemaGetter<Schema<Raw, Parsed>>
): BaseSchema<Raw, Parsed> {
  return {
    parse: async (raw) => (await getMemoizedSchema(getter)).parse(raw),
    json: async (parsed) => (await getMemoizedSchema(getter)).json(parsed),
  };
}

type MemoizedGetter<SchemaType extends Schema<any, any>> = SchemaGetter<SchemaType> & { __zurg_memoized?: SchemaType };

export async function getMemoizedSchema<SchemaType extends Schema<any, any>>(
  getter: SchemaGetter<SchemaType>
): Promise<SchemaType> {
  const castedGetter = getter as MemoizedGetter<SchemaType>;
  if (castedGetter.__zurg_memoized == null) {
    castedGetter.__zurg_memoized = await getter();
  }
  return castedGetter.__zurg_memoized;
}
",
                        "name": "lazy.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { getObjectUtils } from \\"../object\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { BaseObjectSchema, ObjectSchema } from \\"../object/types\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { constructLazyBaseSchema, getMemoizedSchema, SchemaGetter } from \\"./lazy\\";

export function lazyObject<Raw, Parsed>(getter: SchemaGetter<ObjectSchema<Raw, Parsed>>): ObjectSchema<Raw, Parsed> {
  const baseSchema: BaseObjectSchema<Raw, Parsed> = {
    ...OBJECT_LIKE_BRAND,
    ...constructLazyBaseSchema(getter),
    _getRawProperties: async () => (await getMemoizedSchema(getter))._getRawProperties(),
    _getParsedProperties: async () => (await getMemoizedSchema(getter))._getParsedProperties(),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}
",
                        "name": "lazyObject.ts",
                        "type": "file",
                      },
                    ],
                    "name": "lazy",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { list } from \\"./list\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function list<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Parsed[]> {
  const baseSchema: BaseSchema<Raw[], Parsed[]> = {
    parse: (raw, opts) => Promise.all(raw.map((item) => schema.parse(item, opts))),
    json: (parsed, opts) => Promise.all(parsed.map((item) => schema.json(item, opts))),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "list.ts",
                        "type": "file",
                      },
                    ],
                    "name": "list",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { stringLiteral } from \\"./stringLiteral\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function stringLiteral<V extends string>(_value: V): Schema<V, V> {
  return createIdentitySchemaCreator<V>()();
}
",
                        "name": "stringLiteral.ts",
                        "type": "file",
                      },
                    ],
                    "name": "literals",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { getObjectUtils, object } from \\"./object\\";
export { isProperty, property, type Property } from \\"./property\\";
export {
  type BaseObjectSchema,
  type inferObjectSchemaFromPropertySchemas,
  type inferParsedObject,
  type inferParsedObjectFromPropertySchemas,
  type inferParsedPropertySchema,
  type inferRawKey,
  type inferRawObject,
  type inferRawObjectFromPropertySchemas,
  type inferRawPropertySchema,
  type ObjectSchema,
  type ObjectUtils,
  type PropertySchemas,
} from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { filterObject } from \\"../../utils/filterObject\\";
import { keys } from \\"../../utils/keys\\";
import { partition } from \\"../../utils/partition\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { isProperty } from \\"./property\\";
import {
  BaseObjectSchema,
  inferObjectSchemaFromPropertySchemas,
  inferParsedObjectFromPropertySchemas,
  inferRawObjectFromPropertySchemas,
  ObjectSchema,
  ObjectUtils,
  PropertySchemas,
} from \\"./types\\";

interface ObjectPropertyWithRawKey {
  rawKey: string;
  parsedKey: string | number | symbol;
  valueSchema: Schema<any, any>;
}

export function object<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(
  schemas: T
): inferObjectSchemaFromPropertySchemas<T> {
  const baseSchema: BaseObjectSchema<inferRawObjectFromPropertySchemas<T>, inferParsedObjectFromPropertySchemas<T>> = {
    ...OBJECT_LIKE_BRAND,
    _getRawProperties: () =>
      Promise.resolve(
        Object.entries(schemas).map(([parsedKey, propertySchema]) =>
          isProperty(propertySchema) ? propertySchema.rawKey : parsedKey
        ) as unknown as (keyof inferRawObjectFromPropertySchemas<T>)[]
      ),
    _getParsedProperties: () =>
      Promise.resolve(keys(schemas) as unknown as (keyof inferParsedObjectFromPropertySchemas<T>)[]),

    parse: async (raw, { skipUnknownKeysOnParse = false } = {}) => {
      const rawKeyToProperty: Record<string, ObjectPropertyWithRawKey> = {};

      for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
        const rawKey = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;

        const property: ObjectPropertyWithRawKey = {
          rawKey,
          parsedKey,
          valueSchema: isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.valueSchema : schemaOrObjectProperty,
        };

        rawKeyToProperty[rawKey] = property;
      }

      const parsed: Record<string | number | symbol, any> = {};

      for (const [rawKey, rawPropertyValue] of Object.entries(raw)) {
        const property = rawKeyToProperty[rawKey];

        if (property != null) {
          const value = await property.valueSchema.parse(rawPropertyValue);
          parsed[property.parsedKey] = value;
        } else if (!skipUnknownKeysOnParse && rawPropertyValue != null) {
          parsed[rawKey] = rawPropertyValue;
        }
      }

      return parsed as inferParsedObjectFromPropertySchemas<T>;
    },

    json: async (parsed, { includeUnknownKeysOnJson = false } = {}) => {
      const raw: Record<string | number | symbol, any> = {};

      for (const [parsedKey, parsedPropertyValue] of entries(parsed)) {
        const schemaOrObjectProperty = schemas[parsedKey as keyof T];
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (schemaOrObjectProperty != null) {
          if (isProperty(schemaOrObjectProperty)) {
            const value = await schemaOrObjectProperty.valueSchema.json(parsedPropertyValue);
            raw[schemaOrObjectProperty.rawKey] = value;
          } else {
            const value = await schemaOrObjectProperty.json(parsedPropertyValue);
            raw[parsedKey] = value;
          }
        } else if (includeUnknownKeysOnJson && parsedPropertyValue != null) {
          raw[parsedKey] = parsedPropertyValue;
        }
      }

      return raw as inferRawObjectFromPropertySchemas<T>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}

export function getObjectUtils<Raw, Parsed>(schema: BaseObjectSchema<Raw, Parsed>): ObjectUtils<Raw, Parsed> {
  return {
    extend: <RawExtension, ParsedExtension>(extension: ObjectSchema<RawExtension, ParsedExtension>) => {
      const baseSchema: BaseObjectSchema<Raw & RawExtension, Parsed & ParsedExtension> = {
        ...OBJECT_LIKE_BRAND,
        _getParsedProperties: async () => [
          ...(await schema._getParsedProperties()),
          ...(await extension._getParsedProperties()),
        ],
        _getRawProperties: async () => [
          ...(await schema._getRawProperties()),
          ...(await extension._getRawProperties()),
        ],
        parse: async (raw, opts) => {
          const rawExtensionPropertiesSet = new Set(await extension._getRawProperties());
          const [extensionProperties, otherProperties] = partition(keys(raw), (key) =>
            rawExtensionPropertiesSet.has(key as keyof RawExtension)
          );
          return {
            ...(await schema.parse(filterObject(raw, otherProperties), opts)),
            ...(await extension.parse(filterObject(raw, extensionProperties), opts)),
          };
        },
        json: async (parsed, opts) => {
          const parsedExtensionPropertiesSet = new Set(await extension._getParsedProperties());
          const [extensionProperties, otherProperties] = partition(keys(parsed), (key) =>
            parsedExtensionPropertiesSet.has(key as keyof ParsedExtension)
          );
          return {
            ...(await schema.json(filterObject(parsed, otherProperties), opts)),
            ...(await extension.json(filterObject(parsed, extensionProperties), opts)),
          };
        },
      };

      return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
      };
    },
  };
}
",
                        "name": "object.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export function property<RawKey extends string, RawValue, ParsedValue>(
  rawKey: RawKey,
  valueSchema: Schema<RawValue, ParsedValue>
): Property<RawKey, RawValue, ParsedValue> {
  return {
    rawKey,
    valueSchema,
    isProperty: true,
  };
}

export interface Property<RawKey extends string, RawValue, ParsedValue> {
  rawKey: RawKey;
  valueSchema: Schema<RawValue, ParsedValue>;
  isProperty: true;
}

export function isProperty<O extends Property<any, any, any>>(maybeProperty: unknown): maybeProperty is O {
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return (maybeProperty as O).isProperty;
}
",
                        "name": "property.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsed, inferRaw, Schema } from \\"../../Schema\\";
import { addQuestionMarksToNullableProperties } from \\"../../utils/addQuestionMarksToNullableProperties\\";
import { BaseObjectLikeSchema, ObjectLikeSchema } from \\"../object-like\\";
import { Property } from \\"./property\\";

export type ObjectSchema<Raw, Parsed> = BaseObjectSchema<Raw, Parsed> &
  ObjectLikeSchema<Raw, Parsed> &
  ObjectUtils<Raw, Parsed>;

export interface BaseObjectSchema<Raw, Parsed> extends BaseObjectLikeSchema<Raw, Parsed> {
  _getRawProperties: () => Promise<(keyof Raw)[]>;
  _getParsedProperties: () => Promise<(keyof Parsed)[]>;
}

export interface ObjectUtils<Raw, Parsed> {
  extend: <RawExtension, ParsedExtension>(
    schemas: ObjectSchema<RawExtension, ParsedExtension>
  ) => ObjectSchema<Raw & RawExtension, Parsed & ParsedExtension>;
}

export type inferRawObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<infer Raw, any> ? Raw : never;

export type inferParsedObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<any, infer Parsed>
  ? Parsed
  : never;

export type inferObjectSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> = ObjectSchema<
  inferRawObjectFromPropertySchemas<T>,
  inferParsedObjectFromPropertySchemas<T>
>;

export type inferRawObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
  addQuestionMarksToNullableProperties<{
    [ParsedKey in keyof T as inferRawKey<ParsedKey, T[ParsedKey]>]: inferRawPropertySchema<T[ParsedKey]>;
  }>;

export type inferParsedObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
  addQuestionMarksToNullableProperties<{
    [K in keyof T]: inferParsedPropertySchema<T[K]>;
  }>;

export type PropertySchemas<ParsedKeys extends string | number | symbol> = Record<
  ParsedKeys,
  Property<any, any, any> | Schema<any, any>
>;

export type inferRawPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
  any,
  infer Raw,
  any
>
  ? Raw
  : P extends Schema<any, any>
  ? inferRaw<P>
  : never;

export type inferParsedPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
  any,
  any,
  infer Parsed
>
  ? Parsed
  : P extends Schema<any, any>
  ? inferParsed<P>
  : never;

export type inferRawKey<
  ParsedKey extends string | number | symbol,
  P extends Property<any, any, any> | Schema<any, any>
> = P extends Property<infer Raw, any, any> ? Raw : ParsedKey;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { getSchemaUtils } from \\"../schema-utils\\";
import { BaseObjectLikeSchema, ObjectLikeSchema, ObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"./types\\";

export function getObjectLikeUtils<Raw, Parsed>(
  schema: BaseObjectLikeSchema<Raw, Parsed>
): ObjectLikeUtils<Raw, Parsed> {
  return {
    withProperties: (properties) => withProperties(schema, properties),
  };
}

/**
 * object-like utils are defined in one file to resolve issues with circular imports
 */

export function withProperties<RawObjectShape, ParsedObjectShape, Properties>(
  objectLike: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape>,
  properties: { [K in keyof Properties]: Properties[K] | ((parsed: ParsedObjectShape) => Properties[K]) }
): ObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> {
  const objectSchema: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> = {
    ...OBJECT_LIKE_BRAND,
    parse: async (raw, opts) => {
      const parsedObject = await objectLike.parse(raw, opts);
      const additionalProperties = Object.entries(properties).reduce<Record<string, any>>((processed, [key, value]) => {
        return {
          ...processed,
          [key]: typeof value === \\"function\\" ? value(parsedObject) : value,
        };
      }, {});

      return {
        ...parsedObject,
        ...(additionalProperties as Properties),
      };
    },
    json: (parsed, opts) => {
      // strip out added properties
      const addedPropertyKeys = new Set(Object.keys(properties));
      const parsedWithoutAddedProperties = Object.entries(parsed).reduce<Record<string, any>>(
        (filtered, [key, value]) => {
          if (!addedPropertyKeys.has(key)) {
            filtered[key] = value;
          }
          return filtered;
        },
        {}
      );

      return objectLike.json(parsedWithoutAddedProperties as ParsedObjectShape, opts);
    },
  };

  return {
    ...objectSchema,
    ...getSchemaUtils(objectSchema),
    ...getObjectLikeUtils(objectSchema),
  };
}
",
                        "name": "getObjectLikeUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getObjectLikeUtils, withProperties } from \\"./getObjectLikeUtils\\";
export { OBJECT_LIKE_BRAND, type BaseObjectLikeSchema, type ObjectLikeSchema, type ObjectLikeUtils } from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";

export type ObjectLikeSchema<Raw, Parsed> = Schema<Raw, Parsed> &
  BaseObjectLikeSchema<Raw, Parsed> &
  ObjectLikeUtils<Raw, Parsed>;

export type BaseObjectLikeSchema<Raw, Parsed> = BaseSchema<Raw, Parsed> & {
  _objectLike: void;
};

export interface ObjectLikeUtils<Raw, Parsed> {
  withProperties: <T extends Record<string, any>>(properties: {
    [K in keyof T]: T[K] | ((parsed: Parsed) => T[K]);
  }) => ObjectLikeSchema<Raw, Parsed & T>;
}

export const OBJECT_LIKE_BRAND = undefined as unknown as { _objectLike: void };
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object-like",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const any = createIdentitySchemaCreator<any>();
",
                        "name": "any.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const boolean = createIdentitySchemaCreator<boolean>();
",
                        "name": "boolean.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { any } from \\"./any\\";
export { boolean } from \\"./boolean\\";
export { number } from \\"./number\\";
export { string } from \\"./string\\";
export { unknown } from \\"./unknown\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const number = createIdentitySchemaCreator<number>();
",
                        "name": "number.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const string = createIdentitySchemaCreator<string>();
",
                        "name": "string.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const unknown = createIdentitySchemaCreator<unknown>();
",
                        "name": "unknown.ts",
                        "type": "file",
                      },
                    ],
                    "name": "primitives",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { record } from \\"./record\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function record<RawKey extends string | number, ParsedKey extends string | number, RawValue, ParsedValue>(
  keySchema: Schema<RawKey, ParsedKey>,
  valueSchema: Schema<RawValue, ParsedValue>
): Schema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> {
  const baseSchema: BaseSchema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> = {
    parse: (raw, opts) => {
      return entries(raw).reduce(async (parsedPromise, [key, value]) => {
        const parsed: Record<ParsedKey, ParsedValue> = await parsedPromise;
        const parsedKey = await keySchema.parse(key, opts);
        parsed[parsedKey] = await valueSchema.parse(value, opts);
        return parsedPromise;
      }, Promise.resolve({} as Record<ParsedKey, ParsedValue>));
    },
    json: (parsed, opts) => {
      return entries(parsed).reduce(async (rawPromise, [key, value]) => {
        const raw: Record<RawKey, RawValue> = await rawPromise;
        const rawKey = await keySchema.json(key, opts);
        raw[rawKey] = await valueSchema.json(value, opts);
        return rawPromise;
      }, Promise.resolve({} as Record<RawKey, RawValue>));
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "record.ts",
                        "type": "file",
                      },
                    ],
                    "name": "record",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { OptionalSchema, OPTIONAL_BRAND } from \\"./types\\";

export interface SchemaUtils<Raw, Parsed> {
  optional: () => OptionalSchema<Raw, Parsed>;
  transform: <PostTransform>(transformer: BaseSchema<Parsed, PostTransform>) => Schema<Raw, PostTransform>;
}

export function getSchemaUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): SchemaUtils<Raw, Parsed> {
  return {
    optional: () => optional(schema),
    transform: (transformer) => transform(schema, transformer),
  };
}

/**
 * schema utils are defined in one file to resolve issues with circular imports
 */

export function optional<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): OptionalSchema<Raw, Parsed> {
  const baseSchema: BaseSchema<Raw | null | undefined, Parsed | undefined> = {
    parse: (raw, opts) => (raw != null ? schema.parse(raw, opts) : undefined),
    json: (parsed, opts) => (parsed != null ? schema.json(parsed, opts) : undefined),
  };

  return {
    ...OPTIONAL_BRAND,
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function transform<PreTransformRaw, PreTransformParsed, PostTransform>(
  schema: BaseSchema<PreTransformRaw, PreTransformParsed>,
  transformer: BaseSchema<PreTransformParsed, PostTransform>
): Schema<PreTransformRaw, PostTransform> {
  const baseSchema: BaseSchema<PreTransformRaw, PostTransform> = {
    parse: async (raw, opts) => {
      const postTransformParsed = await schema.parse(raw, opts);
      return transformer.parse(postTransformParsed, opts);
    },
    json: async (parsed, opts) => {
      const preTransformParsed = await transformer.json(parsed, opts);
      return schema.json(preTransformParsed, opts);
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "getSchemaUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getSchemaUtils, optional, transform, type SchemaUtils } from \\"./getSchemaUtils\\";
export { OPTIONAL_BRAND, type OptionalSchema } from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export const OPTIONAL_BRAND = undefined as unknown as { _isOptional: void };

export type OptionalSchema<Raw, Parsed> = Schema<Raw | null | undefined, Parsed | undefined> & {
  _isOptional: void;
};
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "schema-utils",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { set } from \\"./set\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function set<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Set<Parsed>> {
  const baseSchema: BaseSchema<Raw[], Set<Parsed>> = {
    parse: async (raw, opts) => new Set(await Promise.all(raw.map((item) => schema.parse(item, opts)))),
    json: (parsed, opts) => Promise.all([...parsed].map((item) => schema.json(item, opts))),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "set.ts",
                        "type": "file",
                      },
                    ],
                    "name": "set",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export function discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string>(
  parsedDiscriminant: ParsedDiscriminant,
  rawDiscriminant: RawDiscriminant
): Discriminant<RawDiscriminant, ParsedDiscriminant> {
  return {
    parsedDiscriminant,
    rawDiscriminant,
  };
}

export interface Discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string> {
  parsedDiscriminant: ParsedDiscriminant;
  rawDiscriminant: RawDiscriminant;
}
",
                        "name": "discriminant.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { discriminant, type Discriminant } from \\"./discriminant\\";
export {
  type inferParsedDiscriminant,
  type inferParsedUnion,
  type inferRawDiscriminant,
  type inferRawUnion,
  type UnionSubtypes,
} from \\"./types\\";
export { union } from \\"./union\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsedObject, inferRawObject, ObjectSchema } from \\"../object\\";
import { Discriminant } from \\"./discriminant\\";

export type UnionSubtypes<DiscriminantValues extends string | number | symbol> = {
  [K in DiscriminantValues]: ObjectSchema<any, any>;
};

export type inferRawUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
  [K in keyof U]: Record<inferRawDiscriminant<D>, K> & inferRawObject<U[K]>;
}[keyof U];

export type inferParsedUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
  [K in keyof U]: Record<inferParsedDiscriminant<D>, K> & inferParsedObject<U[K]>;
}[keyof U];

export type inferRawDiscriminant<D extends string | Discriminant<any, any>> = D extends string
  ? D
  : D extends Discriminant<infer Raw, any>
  ? Raw
  : never;

export type inferParsedDiscriminant<D extends string | Discriminant<any, any>> = D extends string
  ? D
  : D extends Discriminant<any, infer Parsed>
  ? Parsed
  : never;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseObjectLikeSchema, getObjectLikeUtils, ObjectLikeSchema, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { Discriminant } from \\"./discriminant\\";
import { inferParsedDiscriminant, inferParsedUnion, inferRawDiscriminant, inferRawUnion, UnionSubtypes } from \\"./types\\";

export function union<D extends string | Discriminant<any, any>, U extends UnionSubtypes<any>>(
  discriminant: D,
  union: U
): ObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> {
  const rawDiscriminant =
    typeof discriminant === \\"string\\" ? discriminant : (discriminant.rawDiscriminant as inferRawDiscriminant<D>);
  const parsedDiscriminant =
    typeof discriminant === \\"string\\" ? discriminant : (discriminant.parsedDiscriminant as inferParsedDiscriminant<D>);

  const baseSchema: BaseObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> = {
    ...OBJECT_LIKE_BRAND,

    parse: async (raw, opts) => {
      const { [rawDiscriminant]: discriminantValue, ...additionalProperties } = raw;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [parsedDiscriminant]: discriminantValue,
        } as inferParsedUnion<D, U>;
      }

      return {
        ...(await additionalPropertySchemas.parse(additionalProperties, opts)),
        [parsedDiscriminant]: discriminantValue,
      } as inferParsedUnion<D, U>;
    },

    json: async (parsed, opts) => {
      const { [parsedDiscriminant]: discriminantValue, ...additionalProperties } = parsed;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [rawDiscriminant]: discriminantValue,
        } as unknown as inferRawUnion<D, U>;
      }

      return {
        ...(await additionalPropertySchemas.json(additionalProperties, opts)),
        [rawDiscriminant]: discriminantValue,
      } as inferRawUnion<D, U>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
  };
}
",
                        "name": "union.ts",
                        "type": "file",
                      },
                    ],
                    "name": "union",
                    "type": "directory",
                  },
                ],
                "name": "builders",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./builders\\";
export { type inferParsed, type inferRaw, type Schema, type SchemaOptions } from \\"./Schema\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export type addQuestionMarksToNullableProperties<T> = {
  [K in OptionalKeys<T>]?: undefined extends T[K] ? T[K] : never;
} & Pick<T, RequiredKeys<T>>;

export type OptionalKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? K : never;
}[keyof T];

export type RequiredKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? never : K;
}[keyof T];
",
                    "name": "addQuestionMarksToNullableProperties.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function entries<T>(object: T): [keyof T, T[keyof T]][] {
  return Object.entries(object) as [keyof T, T[keyof T]][];
}
",
                    "name": "entries.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function filterObject<T, K extends keyof T>(obj: T, keysToInclude: K[]): Pick<T, K> {
  const keysToIncludeSet = new Set(keysToInclude);
  return Object.entries(obj).reduce((acc, [key, value]) => {
    if (keysToIncludeSet.has(key as K)) {
      acc[key as K] = value;
    }
    return acc;
    // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
  }, {} as Pick<T, K>);
}
",
                    "name": "filterObject.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function keys<T>(object: T): (keyof T)[] {
  return Object.keys(object) as (keyof T)[];
}
",
                    "name": "keys.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function partition<T>(items: readonly T[], predicate: (item: T) => boolean): [T[], T[]] {
  const trueItems: T[] = [],
    falseItems: T[] = [];
  for (const item of items) {
    if (predicate(item)) {
      trueItems.push(item);
    } else {
      falseItems.push(item);
    }
  }
  return [trueItems, falseItems];
}
",
                    "name": "partition.ts",
                    "type": "file",
                  },
                ],
                "name": "utils",
                "type": "directory",
              },
            ],
            "name": "schemas",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export function addNonEnumerableProperty<T, K extends string, V>(object: T, key: K, value: V): T & Record<K, V> {
  const copy = { ...object };
  Object.defineProperty(copy, key, {
    enumerable: false,
    writable: true,
  });
  (copy as any)[key] = value;
  return copy as T & Record<K, V>;
}
",
                "name": "addNonEnumerableProperty.ts",
                "type": "file",
              },
              Object {
                "contents": "export { addNonEnumerableProperty } from \\"./addNonEnumerableProperty\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "utils",
            "type": "directory",
          },
        ],
        "name": "core",
        "type": "directory",
      },
      Object {
        "contents": "export * as FernApi from \\"./resources\\";
export { FernApiClient } from \\"./Client\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * as owner from \\"./owner\\";
export * from \\"./owner/types\\";
export * as token from \\"./token\\";
export * from \\"./token/types\\";
export * from \\"./owner/errors\\";
export * from \\"./owner/client/requests\\";
export * from \\"./token/client/requests\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";
import * as core from \\"../../../core\\";

export declare namespace Client {
  interface Options {
    environment: string;
    apiVersion: string;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async create(request: FernApi.CreateOwnerRequest): Promise<FernApi.owner.create.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment, \\"/owner/\\"),
      method: \\"POST\\",
      headers: {
        \\"X-API-Version\\": this.options.apiVersion,
      },
      body: await serializers.owner.create.Request.json({
        ownerId: request.ownerId,
        data: request.data,
      }),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    if (_response.error.reason === \\"status-code\\") {
      switch (_response.error.statusCode) {
        case 400:
          return {
            ok: false,
            error: FernApi.owner.create.Error.ownerAlreadyExistsError(
              await serializers.OwnerAlreadyExistsError.parse(
                _response.error.body as serializers.OwnerAlreadyExistsError.Raw
              )
            ),
          };
      }
    }

    return {
      ok: false,
      error: FernApi.owner.create.Error._unknown(_response.error),
    };
  }

  public async get(ownerId: FernApi.OwnerId): Promise<FernApi.owner.get.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment, \`/owner/\${ownerId}\`),
      method: \\"GET\\",
      headers: {
        \\"X-API-Version\\": this.options.apiVersion,
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.owner.get.Response.parse(_response.body as serializers.owner.get.Response.Raw),
      };
    }

    if (_response.error.reason === \\"status-code\\") {
      switch (_response.error.statusCode) {
        case 404:
          return {
            ok: false,
            error: FernApi.owner.get.Error.ownerNotFoundError(),
          };
      }
    }

    return {
      ok: false,
      error: FernApi.owner.get.Error._unknown(_response.error),
    };
  }

  public async update(
    ownerId: FernApi.OwnerId,
    request: FernApi.UpdateOwnerRequest
  ): Promise<FernApi.owner.update.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment, \`/owner/\${ownerId}\`),
      method: \\"PUT\\",
      headers: {
        \\"X-API-Version\\": this.options.apiVersion,
      },
      body: await serializers.owner.update.Request.json({
        data: request.data,
      }),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.owner.update.Response.parse(_response.body as serializers.owner.update.Response.Raw),
      };
    }

    if (_response.error.reason === \\"status-code\\") {
      switch (_response.error.statusCode) {
        case 404:
          return {
            ok: false,
            error: FernApi.owner.update.Error.ownerNotFoundError(),
          };
      }
    }

    return {
      ok: false,
      error: FernApi.owner.update.Error._unknown(_response.error),
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, FernApi.owner.create.Error>;
export type Error = FernApi.owner.create.Error.OwnerAlreadyExistsError | FernApi.owner.create.Error._Unknown;

export declare namespace Error {
  interface OwnerAlreadyExistsError extends _Utils {
    statusCode: 400;
    content: FernApi.OwnerAlreadyExistsError;
  }

  interface _Unknown extends _Utils {
    statusCode: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernApi.owner.create.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    ownerAlreadyExistsError: (value: FernApi.OwnerAlreadyExistsError) => _Result;
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  ownerAlreadyExistsError: (
    value: FernApi.OwnerAlreadyExistsError
  ): FernApi.owner.create.Error.OwnerAlreadyExistsError => {
    const valueWithoutVisit: Omit<FernApi.owner.create.Error.OwnerAlreadyExistsError, \\"_visit\\"> = {
      content: value,
      statusCode: 400,
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.owner.create.Error.OwnerAlreadyExistsError, visitor: FernApi.owner.create.Error._Visitor<_Result>) {
      return FernApi.owner.create.Error._visit(this, visitor);
    });
  },

  _unknown: (fetcherError: core.Fetcher.Error): FernApi.owner.create.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<FernApi.owner.create.Error._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.owner.create.Error._Unknown, visitor: FernApi.owner.create.Error._Visitor<_Result>) {
      return FernApi.owner.create.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: FernApi.owner.create.Error,
    visitor: FernApi.owner.create.Error._Visitor<_Result>
  ): _Result => {
    switch (value.statusCode) {
      case 400:
        return visitor.ownerAlreadyExistsError(value.content);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "create.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<FernApi.Owner, FernApi.owner.get.Error>;
export type Error = FernApi.owner.get.Error.OwnerNotFoundError | FernApi.owner.get.Error._Unknown;

export declare namespace Error {
  interface OwnerNotFoundError extends _Utils {
    statusCode: 404;
  }

  interface _Unknown extends _Utils {
    statusCode: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernApi.owner.get.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    ownerNotFoundError: () => _Result;
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  ownerNotFoundError: (): FernApi.owner.get.Error.OwnerNotFoundError => {
    const valueWithoutVisit: Omit<FernApi.owner.get.Error.OwnerNotFoundError, \\"_visit\\"> = {
      statusCode: 404,
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.owner.get.Error.OwnerNotFoundError, visitor: FernApi.owner.get.Error._Visitor<_Result>) {
      return FernApi.owner.get.Error._visit(this, visitor);
    });
  },

  _unknown: (fetcherError: core.Fetcher.Error): FernApi.owner.get.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<FernApi.owner.get.Error._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.owner.get.Error._Unknown, visitor: FernApi.owner.get.Error._Visitor<_Result>) {
      return FernApi.owner.get.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(value: FernApi.owner.get.Error, visitor: FernApi.owner.get.Error._Visitor<_Result>): _Result => {
    switch (value.statusCode) {
      case 404:
        return visitor.ownerNotFoundError();
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "get.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as create from \\"./create\\";
export * from \\"./requests\\";
export * as get from \\"./get\\";
export * as update from \\"./update\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";

export interface CreateOwnerRequest {
  ownerId: FernApi.OwnerId;
  data?: unknown;
}
",
                        "name": "CreateOwnerRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface UpdateOwnerRequest {
  data?: unknown;
}
",
                        "name": "UpdateOwnerRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { CreateOwnerRequest } from \\"./CreateOwnerRequest\\";
export { UpdateOwnerRequest } from \\"./UpdateOwnerRequest\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "requests",
                    "type": "directory",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<FernApi.Owner, FernApi.owner.update.Error>;
export type Error = FernApi.owner.update.Error.OwnerNotFoundError | FernApi.owner.update.Error._Unknown;

export declare namespace Error {
  interface OwnerNotFoundError extends _Utils {
    statusCode: 404;
  }

  interface _Unknown extends _Utils {
    statusCode: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernApi.owner.update.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    ownerNotFoundError: () => _Result;
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  ownerNotFoundError: (): FernApi.owner.update.Error.OwnerNotFoundError => {
    const valueWithoutVisit: Omit<FernApi.owner.update.Error.OwnerNotFoundError, \\"_visit\\"> = {
      statusCode: 404,
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.owner.update.Error.OwnerNotFoundError, visitor: FernApi.owner.update.Error._Visitor<_Result>) {
      return FernApi.owner.update.Error._visit(this, visitor);
    });
  },

  _unknown: (fetcherError: core.Fetcher.Error): FernApi.owner.update.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<FernApi.owner.update.Error._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.owner.update.Error._Unknown, visitor: FernApi.owner.update.Error._Visitor<_Result>) {
      return FernApi.owner.update.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: FernApi.owner.update.Error,
    visitor: FernApi.owner.update.Error._Visitor<_Result>
  ): _Result => {
    switch (value.statusCode) {
      case 404:
        return visitor.ownerNotFoundError();
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "update.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";

export type OwnerAlreadyExistsError = FernApi.OwnerId;
",
                    "name": "OwnerAlreadyExistsError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./OwnerAlreadyExistsError\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "errors",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./errors\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";

export interface Owner {
  ownerId: FernApi.OwnerId;
  data?: unknown;
}
",
                    "name": "Owner.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Unique id for an owner.
 */
export type OwnerId = string;
",
                    "name": "OwnerId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./OwnerId\\";
export * from \\"./Owner\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "owner",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";
import * as core from \\"../../../core\\";

export declare namespace Client {
  interface Options {
    environment: string;
    apiVersion: string;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async create(request: FernApi.CreateTokenRequest): Promise<FernApi.token.create.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment, \\"/tokens/create\\"),
      method: \\"POST\\",
      headers: {
        \\"X-API-Version\\": this.options.apiVersion,
      },
      body: await serializers.token.create.Request.json({
        ownerId: request.ownerId,
        description: request.description,
      }),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.token.create.Response.parse(_response.body as serializers.token.create.Response.Raw),
      };
    }

    if (_response.error.reason === \\"status-code\\") {
      switch (_response.error.statusCode) {
        case 404:
          return {
            ok: false,
            error: FernApi.token.create.Error.ownerNotFoundError(),
          };
      }
    }

    return {
      ok: false,
      error: FernApi.token.create.Error._unknown(_response.error),
    };
  }

  public async getTokenMetadata(
    request: FernApi.GetTokenMetadataRequest
  ): Promise<FernApi.token.getTokenMetadata.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment, \\"/tokens/metadata\\"),
      method: \\"POST\\",
      headers: {
        \\"X-API-Version\\": this.options.apiVersion,
      },
      body: await serializers.token.getTokenMetadata.Request.json({
        token: request.token,
      }),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.token.getTokenMetadata.Response.parse(
          _response.body as serializers.token.getTokenMetadata.Response.Raw
        ),
      };
    }

    if (_response.error.reason === \\"status-code\\") {
      switch (_response.error.statusCode) {
        case 404:
          return {
            ok: false,
            error: FernApi.token.getTokenMetadata.Error.tokenNotFoundError(),
          };
      }
    }

    return {
      ok: false,
      error: FernApi.token.getTokenMetadata.Error._unknown(_response.error),
    };
  }

  public async getTokensForOwner(ownerId: FernApi.OwnerId): Promise<FernApi.token.getTokensForOwner.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment, \`/tokens/owner/\${ownerId}\`),
      method: \\"GET\\",
      headers: {
        \\"X-API-Version\\": this.options.apiVersion,
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.token.getTokensForOwner.Response.parse(
          _response.body as serializers.token.getTokensForOwner.Response.Raw
        ),
      };
    }

    if (_response.error.reason === \\"status-code\\") {
      switch (_response.error.statusCode) {
        case 404:
          return {
            ok: false,
            error: FernApi.token.getTokensForOwner.Error.ownerNotFoundError(),
          };
      }
    }

    return {
      ok: false,
      error: FernApi.token.getTokensForOwner.Error._unknown(_response.error),
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<FernApi.CreateTokenResponse, FernApi.token.create.Error>;
export type Error = FernApi.token.create.Error.OwnerNotFoundError | FernApi.token.create.Error._Unknown;

export declare namespace Error {
  interface OwnerNotFoundError extends _Utils {
    statusCode: 404;
  }

  interface _Unknown extends _Utils {
    statusCode: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernApi.token.create.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    ownerNotFoundError: () => _Result;
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  ownerNotFoundError: (): FernApi.token.create.Error.OwnerNotFoundError => {
    const valueWithoutVisit: Omit<FernApi.token.create.Error.OwnerNotFoundError, \\"_visit\\"> = {
      statusCode: 404,
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.token.create.Error.OwnerNotFoundError, visitor: FernApi.token.create.Error._Visitor<_Result>) {
      return FernApi.token.create.Error._visit(this, visitor);
    });
  },

  _unknown: (fetcherError: core.Fetcher.Error): FernApi.token.create.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<FernApi.token.create.Error._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.token.create.Error._Unknown, visitor: FernApi.token.create.Error._Visitor<_Result>) {
      return FernApi.token.create.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: FernApi.token.create.Error,
    visitor: FernApi.token.create.Error._Visitor<_Result>
  ): _Result => {
    switch (value.statusCode) {
      case 404:
        return visitor.ownerNotFoundError();
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "create.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<FernApi.TokenMetadata, FernApi.token.getTokenMetadata.Error>;
export type Error =
  | FernApi.token.getTokenMetadata.Error.TokenNotFoundError
  | FernApi.token.getTokenMetadata.Error._Unknown;

export declare namespace Error {
  interface TokenNotFoundError extends _Utils {
    statusCode: 404;
  }

  interface _Unknown extends _Utils {
    statusCode: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernApi.token.getTokenMetadata.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    tokenNotFoundError: () => _Result;
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  tokenNotFoundError: (): FernApi.token.getTokenMetadata.Error.TokenNotFoundError => {
    const valueWithoutVisit: Omit<FernApi.token.getTokenMetadata.Error.TokenNotFoundError, \\"_visit\\"> = {
      statusCode: 404,
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.token.getTokenMetadata.Error.TokenNotFoundError, visitor: FernApi.token.getTokenMetadata.Error._Visitor<_Result>) {
      return FernApi.token.getTokenMetadata.Error._visit(this, visitor);
    });
  },

  _unknown: (fetcherError: core.Fetcher.Error): FernApi.token.getTokenMetadata.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<FernApi.token.getTokenMetadata.Error._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.token.getTokenMetadata.Error._Unknown, visitor: FernApi.token.getTokenMetadata.Error._Visitor<_Result>) {
      return FernApi.token.getTokenMetadata.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: FernApi.token.getTokenMetadata.Error,
    visitor: FernApi.token.getTokenMetadata.Error._Visitor<_Result>
  ): _Result => {
    switch (value.statusCode) {
      case 404:
        return visitor.tokenNotFoundError();
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "getTokenMetadata.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<FernApi.TokenMetadata[], FernApi.token.getTokensForOwner.Error>;
export type Error =
  | FernApi.token.getTokensForOwner.Error.OwnerNotFoundError
  | FernApi.token.getTokensForOwner.Error._Unknown;

export declare namespace Error {
  interface OwnerNotFoundError extends _Utils {
    statusCode: 404;
  }

  interface _Unknown extends _Utils {
    statusCode: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernApi.token.getTokensForOwner.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    ownerNotFoundError: () => _Result;
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  ownerNotFoundError: (): FernApi.token.getTokensForOwner.Error.OwnerNotFoundError => {
    const valueWithoutVisit: Omit<FernApi.token.getTokensForOwner.Error.OwnerNotFoundError, \\"_visit\\"> = {
      statusCode: 404,
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.token.getTokensForOwner.Error.OwnerNotFoundError, visitor: FernApi.token.getTokensForOwner.Error._Visitor<_Result>) {
      return FernApi.token.getTokensForOwner.Error._visit(this, visitor);
    });
  },

  _unknown: (fetcherError: core.Fetcher.Error): FernApi.token.getTokensForOwner.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<FernApi.token.getTokensForOwner.Error._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.token.getTokensForOwner.Error._Unknown, visitor: FernApi.token.getTokensForOwner.Error._Visitor<_Result>) {
      return FernApi.token.getTokensForOwner.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: FernApi.token.getTokensForOwner.Error,
    visitor: FernApi.token.getTokensForOwner.Error._Visitor<_Result>
  ): _Result => {
    switch (value.statusCode) {
      case 404:
        return visitor.ownerNotFoundError();
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "getTokensForOwner.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as create from \\"./create\\";
export * from \\"./requests\\";
export * as getTokenMetadata from \\"./getTokenMetadata\\";
export * as getTokensForOwner from \\"./getTokensForOwner\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";

export interface CreateTokenRequest {
  ownerId: FernApi.OwnerId;
  description?: string;
}
",
                        "name": "CreateTokenRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface GetTokenMetadataRequest {
  token: string;
}
",
                        "name": "GetTokenMetadataRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { CreateTokenRequest } from \\"./CreateTokenRequest\\";
export { GetTokenMetadataRequest } from \\"./GetTokenMetadataRequest\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "requests",
                    "type": "directory",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";

export interface CreateTokenResponse {
  token: string;
  tokenId: FernApi.TokenId;
}
",
                    "name": "CreateTokenResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type TokenId = string;
",
                    "name": "TokenId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";

export interface TokenMetadata {
  tokenId: FernApi.TokenId;
  ownerId: FernApi.OwnerId;
  description?: string;
  createdTime: Date;
  status: FernApi.TokenStatus;
}
",
                    "name": "TokenMetadata.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export type TokenStatus =
  | FernApi.TokenStatus.Active
  | FernApi.TokenStatus.Expired
  | FernApi.TokenStatus.Revoked
  | FernApi.TokenStatus._Unknown;

export declare namespace TokenStatus {
  interface Active extends _Utils {
    type: \\"active\\";
  }

  interface Expired extends _Utils {
    type: \\"expired\\";
  }

  interface Revoked extends _Utils {
    type: \\"revoked\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernApi.TokenStatus._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    active: () => _Result;
    expired: () => _Result;
    revoked: () => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const TokenStatus = {
  active: (): FernApi.TokenStatus.Active => {
    const valueWithoutVisit: Omit<FernApi.TokenStatus.Active, \\"_visit\\"> = {
      type: \\"active\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.TokenStatus.Active, visitor: FernApi.TokenStatus._Visitor<_Result>) {
      return FernApi.TokenStatus._visit(this, visitor);
    });
  },

  expired: (): FernApi.TokenStatus.Expired => {
    const valueWithoutVisit: Omit<FernApi.TokenStatus.Expired, \\"_visit\\"> = {
      type: \\"expired\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.TokenStatus.Expired, visitor: FernApi.TokenStatus._Visitor<_Result>) {
      return FernApi.TokenStatus._visit(this, visitor);
    });
  },

  revoked: (): FernApi.TokenStatus.Revoked => {
    const valueWithoutVisit: Omit<FernApi.TokenStatus.Revoked, \\"_visit\\"> = {
      type: \\"revoked\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.TokenStatus.Revoked, visitor: FernApi.TokenStatus._Visitor<_Result>) {
      return FernApi.TokenStatus._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): FernApi.TokenStatus._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<FernApi.TokenStatus._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.TokenStatus._Unknown, visitor: FernApi.TokenStatus._Visitor<_Result>) {
      return FernApi.TokenStatus._visit(this, visitor);
    });
  },

  _visit: <_Result>(value: FernApi.TokenStatus, visitor: FernApi.TokenStatus._Visitor<_Result>): _Result => {
    switch (value.type) {
      case \\"active\\":
        return visitor.active();
      case \\"expired\\":
        return visitor.expired();
      case \\"revoked\\":
        return visitor.revoked();
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "TokenStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./TokenId\\";
export * from \\"./CreateTokenResponse\\";
export * from \\"./TokenMetadata\\";
export * from \\"./TokenStatus\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "token",
            "type": "directory",
          },
        ],
        "name": "resources",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * as owner from \\"./owner\\";
export * from \\"./owner/types\\";
export * as token from \\"./token\\";
export * from \\"./token/types\\";
export * from \\"./owner/errors\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<serializers.owner.create.Request.Raw, FernApi.CreateOwnerRequest> =
  core.schemas.object({
    ownerId: core.schemas.lazy(async () => (await import(\\"../..\\")).OwnerId),
    data: core.schemas.unknown(),
  });

export declare namespace Request {
  interface Raw {
    ownerId: serializers.OwnerId.Raw;
    data?: unknown;
  }
}
",
                    "name": "create.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<serializers.owner.get.Response.Raw, FernApi.Owner> = core.schemas.lazyObject(
  async () => (await import(\\"../..\\")).Owner
);

export declare namespace Response {
  type Raw = serializers.Owner.Raw;
}
",
                    "name": "get.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as create from \\"./create\\";
export * as get from \\"./get\\";
export * as update from \\"./update\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<serializers.owner.update.Request.Raw, FernApi.UpdateOwnerRequest> =
  core.schemas.object({
    data: core.schemas.unknown(),
  });

export declare namespace Request {
  interface Raw {
    data?: unknown;
  }
}

export const Response: core.schemas.Schema<serializers.owner.update.Response.Raw, FernApi.Owner> =
  core.schemas.lazyObject(async () => (await import(\\"../..\\")).Owner);

export declare namespace Response {
  type Raw = serializers.Owner.Raw;
}
",
                    "name": "update.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export const OwnerAlreadyExistsError: core.schemas.Schema<
  serializers.OwnerAlreadyExistsError.Raw,
  FernApi.OwnerAlreadyExistsError
> = core.schemas.lazy(async () => (await import(\\"../..\\")).OwnerId);

export declare namespace OwnerAlreadyExistsError {
  type Raw = serializers.OwnerId.Raw;
}
",
                    "name": "OwnerAlreadyExistsError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./OwnerAlreadyExistsError\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "errors",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./errors\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export const Owner: core.schemas.ObjectSchema<serializers.Owner.Raw, FernApi.Owner> = core.schemas.object({
  ownerId: core.schemas.lazy(async () => (await import(\\"../..\\")).OwnerId),
  data: core.schemas.unknown(),
});

export declare namespace Owner {
  interface Raw {
    ownerId: serializers.OwnerId.Raw;
    data?: unknown;
  }
}
",
                    "name": "Owner.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export const OwnerId: core.schemas.Schema<serializers.OwnerId.Raw, FernApi.OwnerId> = core.schemas.string();

export declare namespace OwnerId {
  type Raw = string;
}
",
                    "name": "OwnerId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./OwnerId\\";
export * from \\"./Owner\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "owner",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<serializers.token.create.Request.Raw, FernApi.CreateTokenRequest> =
  core.schemas.object({
    ownerId: core.schemas.lazy(async () => (await import(\\"../..\\")).OwnerId),
    description: core.schemas.string().optional(),
  });

export declare namespace Request {
  interface Raw {
    ownerId: serializers.OwnerId.Raw;
    description?: string | null;
  }
}

export const Response: core.schemas.Schema<serializers.token.create.Response.Raw, FernApi.CreateTokenResponse> =
  core.schemas.lazyObject(async () => (await import(\\"../..\\")).CreateTokenResponse);

export declare namespace Response {
  type Raw = serializers.CreateTokenResponse.Raw;
}
",
                    "name": "create.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.token.getTokenMetadata.Request.Raw,
  FernApi.GetTokenMetadataRequest
> = core.schemas.object({
  token: core.schemas.string(),
});

export declare namespace Request {
  interface Raw {
    token: string;
  }
}

export const Response: core.schemas.Schema<serializers.token.getTokenMetadata.Response.Raw, FernApi.TokenMetadata> =
  core.schemas.lazyObject(async () => (await import(\\"../..\\")).TokenMetadata);

export declare namespace Response {
  type Raw = serializers.TokenMetadata.Raw;
}
",
                    "name": "getTokenMetadata.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<serializers.token.getTokensForOwner.Response.Raw, FernApi.TokenMetadata[]> =
  core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).TokenMetadata));

export declare namespace Response {
  type Raw = serializers.TokenMetadata.Raw[];
}
",
                    "name": "getTokensForOwner.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as create from \\"./create\\";
export * as getTokenMetadata from \\"./getTokenMetadata\\";
export * as getTokensForOwner from \\"./getTokensForOwner\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export const CreateTokenResponse: core.schemas.ObjectSchema<
  serializers.CreateTokenResponse.Raw,
  FernApi.CreateTokenResponse
> = core.schemas.object({
  token: core.schemas.string(),
  tokenId: core.schemas.lazy(async () => (await import(\\"../..\\")).TokenId),
});

export declare namespace CreateTokenResponse {
  interface Raw {
    token: string;
    tokenId: serializers.TokenId.Raw;
  }
}
",
                    "name": "CreateTokenResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export const TokenId: core.schemas.Schema<serializers.TokenId.Raw, FernApi.TokenId> = core.schemas.string();

export declare namespace TokenId {
  type Raw = string;
}
",
                    "name": "TokenId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export const TokenMetadata: core.schemas.ObjectSchema<serializers.TokenMetadata.Raw, FernApi.TokenMetadata> =
  core.schemas.object({
    tokenId: core.schemas.lazy(async () => (await import(\\"../..\\")).TokenId),
    ownerId: core.schemas.lazy(async () => (await import(\\"../..\\")).OwnerId),
    description: core.schemas.string().optional(),
    createdTime: core.schemas.date(),
    status: core.schemas.lazy(async () => (await import(\\"../..\\")).TokenStatus),
  });

export declare namespace TokenMetadata {
  interface Raw {
    tokenId: serializers.TokenId.Raw;
    ownerId: serializers.OwnerId.Raw;
    description?: string | null;
    createdTime: string;
    status: serializers.TokenStatus.Raw;
  }
}
",
                    "name": "TokenMetadata.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export const TokenStatus: core.schemas.Schema<serializers.TokenStatus.Raw, FernApi.TokenStatus> = core.schemas
  .union(\\"type\\", {
    active: core.schemas.object({}),
    expired: core.schemas.object({}),
    revoked: core.schemas.object({}),
  })
  .transform<FernApi.TokenStatus>({
    parse: (value) => {
      switch (value.type) {
        case \\"active\\":
          return FernApi.TokenStatus.active();
        case \\"expired\\":
          return FernApi.TokenStatus.expired();
        case \\"revoked\\":
          return FernApi.TokenStatus.revoked();
        default:
          return FernApi.TokenStatus._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace TokenStatus {
  type Raw = TokenStatus.Active | TokenStatus.Expired | TokenStatus.Revoked;

  interface Active {
    type: \\"active\\";
  }

  interface Expired {
    type: \\"expired\\";
  }

  interface Revoked {
    type: \\"revoked\\";
  }
}
",
                    "name": "TokenStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./TokenId\\";
export * from \\"./CreateTokenResponse\\";
export * from \\"./TokenMetadata\\";
export * from \\"./TokenStatus\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "token",
            "type": "directory",
          },
        ],
        "name": "serialization",
        "type": "directory",
      },
    ],
    "name": "src",
    "type": "directory",
  },
  Object {
    "contents": "{
    \\"compilerOptions\\": {
        \\"strict\\": true,
        \\"target\\": \\"esnext\\",
        \\"module\\": \\"esnext\\",
        \\"moduleResolution\\": \\"node\\",
        \\"esModuleInterop\\": true,
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"emitDeclarationOnly\\": true,
        \\"sourceMap\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true,
        \\"outDir\\": \\".\\",
        \\"rootDir\\": \\"src\\",
        \\"baseUrl\\": \\"src\\",
        \\"paths\\": {
            \\"@fern/api\\": [
                \\".\\"
            ]
        }
    },
    \\"include\\": [
        \\"src\\"
    ],
    \\"exclude\\": []
}",
    "name": "tsconfig.json",
    "type": "file",
  },
]
`;

exports[`runGenerator reserved-keywords 1`] = `
Array [
  Object {
    "contents": "node_modules
.DS_Store
*.d.ts
*.js
*.js.map
*.cjs
*.mjs

# yarn berry
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions

# these are needed to override '*.js' above
!.yarn/patches/**
!.yarn/plugins/**
!.yarn/releases/**
!.yarn/sdks/**
!.yarn/versions/**",
    "name": ".gitignore",
    "type": "file",
  },
  Object {
    "contents": ".yarn
node_modules
.npmignore
.pnp.cjs
*.js
*.d.ts",
    "name": ".prettierignore",
    "type": "file",
  },
  Object {
    "contents": "{
    \\"name\\": \\"@fern/api\\",
    \\"version\\": \\"0.0.0\\",
    \\"private\\": false,
    \\"files\\": [
        \\"index.mjs\\",
        \\"index.cjs\\",
        \\"browser.js\\",
        \\"browser.js.map\\",
        \\"*.d.ts\\"
    ],
    \\"exports\\": {
        \\".\\": {
            \\"import\\": \\"./index.mjs\\",
            \\"module\\": \\"./index.mjs\\",
            \\"require\\": \\"./index.cjs\\",
            \\"browser\\": \\"./browser.js\\",
            \\"default\\": \\"./index.cjs\\"
        }
    },
    \\"types\\": \\"./index.d.ts\\",
    \\"scripts\\": {
        \\"format\\": \\"prettier --write --print-width 120 src/**/*.ts\\",
        \\"build:esm\\": \\"esbuild src/index.ts --bundle --platform=node --format=esm --outfile=index.mjs\\",
        \\"build:cjs\\": \\"esbuild src/index.ts --bundle --platform=node --format=cjs --outfile=index.cjs\\",
        \\"build:browser\\": \\"esbuild src/index.ts --bundle --platform=browser --sourcemap --outfile=browser.js\\",
        \\"build\\": \\"yarn build:esm && yarn build:cjs && yarn build:browser && tsc && tsc-alias\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"esbuild\\": \\"0.16.13\\",
        \\"prettier\\": \\"2.7.1\\",
        \\"typescript\\": \\"4.6.4\\",
        \\"tsc-alias\\": \\"^1.7.1\\"
    }
}",
    "name": "package.json",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": Array [
          Object {
            "contents": "export * as schemas from \\"./schemas\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { SchemaUtils } from \\"./builders\\";

export type Schema<Raw = unknown, Parsed = unknown> = BaseSchema<Raw, Parsed> & SchemaUtils<Raw, Parsed>;

export type inferRaw<S extends Schema> = S extends Schema<infer Raw, any> ? Raw : never;
export type inferParsed<S extends Schema> = S extends Schema<any, infer Parsed> ? Parsed : never;

export interface BaseSchema<Raw, Parsed> {
  parse: (raw: Raw, opts?: SchemaOptions) => Parsed | Promise<Parsed>;
  json: (parsed: Parsed, opts?: SchemaOptions) => Raw | Promise<Raw>;
}

export interface SchemaOptions {
  /**
   * @default false
   */
  skipUnknownKeysOnParse?: boolean;

  /**
   * @default false
   */
  includeUnknownKeysOnJson?: boolean;
}
",
                "name": "Schema.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function date(): Schema<string, Date> {
  const baseSchema: BaseSchema<string, Date> = {
    parse: (raw) => new Date(raw),
    json: (date) => date.toISOString(),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "date.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { date } from \\"./date\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "date",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function enum_<U extends string, E extends Readonly<[U, ...U[]]>>(_values: E): Schema<E[number], E[number]> {
  return createIdentitySchemaCreator<E[number]>()();
}
",
                        "name": "enum.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { enum_ } from \\"./enum\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "enum",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { identity } from \\"./identity\\";

export function createIdentitySchemaCreator<T>(): () => Schema<T, T> {
  return <T>() => identity<T>();
}
",
                        "name": "createIdentitySchemaCreator.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function identity<T>(): Schema<T, T> {
  const baseSchema: BaseSchema<T, T> = {
    parse: (raw) => raw,
    json: (parsed) => parsed,
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "identity.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { createIdentitySchemaCreator } from \\"./createIdentitySchemaCreator\\";
export { identity } from \\"./identity\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "identity",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./date\\";
export * from \\"./enum\\";
export * from \\"./identity\\";
export * from \\"./lazy\\";
export * from \\"./list\\";
export * from \\"./literals\\";
export * from \\"./object\\";
export * from \\"./object-like\\";
export * from \\"./primitives\\";
export * from \\"./record\\";
export * from \\"./schema-utils\\";
export * from \\"./set\\";
export * from \\"./union\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { lazy, type SchemaGetter } from \\"./lazy\\";
export { lazyObject } from \\"./lazyObject\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export type SchemaGetter<SchemaType extends Schema<any, any>> = () => SchemaType | Promise<SchemaType>;

export function lazy<Raw, Parsed>(getter: SchemaGetter<Schema<Raw, Parsed>>): Schema<Raw, Parsed> {
  const baseSchema = constructLazyBaseSchema(getter);
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function constructLazyBaseSchema<Raw, Parsed>(
  getter: SchemaGetter<Schema<Raw, Parsed>>
): BaseSchema<Raw, Parsed> {
  return {
    parse: async (raw) => (await getMemoizedSchema(getter)).parse(raw),
    json: async (parsed) => (await getMemoizedSchema(getter)).json(parsed),
  };
}

type MemoizedGetter<SchemaType extends Schema<any, any>> = SchemaGetter<SchemaType> & { __zurg_memoized?: SchemaType };

export async function getMemoizedSchema<SchemaType extends Schema<any, any>>(
  getter: SchemaGetter<SchemaType>
): Promise<SchemaType> {
  const castedGetter = getter as MemoizedGetter<SchemaType>;
  if (castedGetter.__zurg_memoized == null) {
    castedGetter.__zurg_memoized = await getter();
  }
  return castedGetter.__zurg_memoized;
}
",
                        "name": "lazy.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { getObjectUtils } from \\"../object\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { BaseObjectSchema, ObjectSchema } from \\"../object/types\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { constructLazyBaseSchema, getMemoizedSchema, SchemaGetter } from \\"./lazy\\";

export function lazyObject<Raw, Parsed>(getter: SchemaGetter<ObjectSchema<Raw, Parsed>>): ObjectSchema<Raw, Parsed> {
  const baseSchema: BaseObjectSchema<Raw, Parsed> = {
    ...OBJECT_LIKE_BRAND,
    ...constructLazyBaseSchema(getter),
    _getRawProperties: async () => (await getMemoizedSchema(getter))._getRawProperties(),
    _getParsedProperties: async () => (await getMemoizedSchema(getter))._getParsedProperties(),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}
",
                        "name": "lazyObject.ts",
                        "type": "file",
                      },
                    ],
                    "name": "lazy",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { list } from \\"./list\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function list<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Parsed[]> {
  const baseSchema: BaseSchema<Raw[], Parsed[]> = {
    parse: (raw, opts) => Promise.all(raw.map((item) => schema.parse(item, opts))),
    json: (parsed, opts) => Promise.all(parsed.map((item) => schema.json(item, opts))),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "list.ts",
                        "type": "file",
                      },
                    ],
                    "name": "list",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { stringLiteral } from \\"./stringLiteral\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function stringLiteral<V extends string>(_value: V): Schema<V, V> {
  return createIdentitySchemaCreator<V>()();
}
",
                        "name": "stringLiteral.ts",
                        "type": "file",
                      },
                    ],
                    "name": "literals",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { getObjectUtils, object } from \\"./object\\";
export { isProperty, property, type Property } from \\"./property\\";
export {
  type BaseObjectSchema,
  type inferObjectSchemaFromPropertySchemas,
  type inferParsedObject,
  type inferParsedObjectFromPropertySchemas,
  type inferParsedPropertySchema,
  type inferRawKey,
  type inferRawObject,
  type inferRawObjectFromPropertySchemas,
  type inferRawPropertySchema,
  type ObjectSchema,
  type ObjectUtils,
  type PropertySchemas,
} from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { filterObject } from \\"../../utils/filterObject\\";
import { keys } from \\"../../utils/keys\\";
import { partition } from \\"../../utils/partition\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { isProperty } from \\"./property\\";
import {
  BaseObjectSchema,
  inferObjectSchemaFromPropertySchemas,
  inferParsedObjectFromPropertySchemas,
  inferRawObjectFromPropertySchemas,
  ObjectSchema,
  ObjectUtils,
  PropertySchemas,
} from \\"./types\\";

interface ObjectPropertyWithRawKey {
  rawKey: string;
  parsedKey: string | number | symbol;
  valueSchema: Schema<any, any>;
}

export function object<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(
  schemas: T
): inferObjectSchemaFromPropertySchemas<T> {
  const baseSchema: BaseObjectSchema<inferRawObjectFromPropertySchemas<T>, inferParsedObjectFromPropertySchemas<T>> = {
    ...OBJECT_LIKE_BRAND,
    _getRawProperties: () =>
      Promise.resolve(
        Object.entries(schemas).map(([parsedKey, propertySchema]) =>
          isProperty(propertySchema) ? propertySchema.rawKey : parsedKey
        ) as unknown as (keyof inferRawObjectFromPropertySchemas<T>)[]
      ),
    _getParsedProperties: () =>
      Promise.resolve(keys(schemas) as unknown as (keyof inferParsedObjectFromPropertySchemas<T>)[]),

    parse: async (raw, { skipUnknownKeysOnParse = false } = {}) => {
      const rawKeyToProperty: Record<string, ObjectPropertyWithRawKey> = {};

      for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
        const rawKey = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;

        const property: ObjectPropertyWithRawKey = {
          rawKey,
          parsedKey,
          valueSchema: isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.valueSchema : schemaOrObjectProperty,
        };

        rawKeyToProperty[rawKey] = property;
      }

      const parsed: Record<string | number | symbol, any> = {};

      for (const [rawKey, rawPropertyValue] of Object.entries(raw)) {
        const property = rawKeyToProperty[rawKey];

        if (property != null) {
          const value = await property.valueSchema.parse(rawPropertyValue);
          parsed[property.parsedKey] = value;
        } else if (!skipUnknownKeysOnParse && rawPropertyValue != null) {
          parsed[rawKey] = rawPropertyValue;
        }
      }

      return parsed as inferParsedObjectFromPropertySchemas<T>;
    },

    json: async (parsed, { includeUnknownKeysOnJson = false } = {}) => {
      const raw: Record<string | number | symbol, any> = {};

      for (const [parsedKey, parsedPropertyValue] of entries(parsed)) {
        const schemaOrObjectProperty = schemas[parsedKey as keyof T];
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (schemaOrObjectProperty != null) {
          if (isProperty(schemaOrObjectProperty)) {
            const value = await schemaOrObjectProperty.valueSchema.json(parsedPropertyValue);
            raw[schemaOrObjectProperty.rawKey] = value;
          } else {
            const value = await schemaOrObjectProperty.json(parsedPropertyValue);
            raw[parsedKey] = value;
          }
        } else if (includeUnknownKeysOnJson && parsedPropertyValue != null) {
          raw[parsedKey] = parsedPropertyValue;
        }
      }

      return raw as inferRawObjectFromPropertySchemas<T>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}

export function getObjectUtils<Raw, Parsed>(schema: BaseObjectSchema<Raw, Parsed>): ObjectUtils<Raw, Parsed> {
  return {
    extend: <RawExtension, ParsedExtension>(extension: ObjectSchema<RawExtension, ParsedExtension>) => {
      const baseSchema: BaseObjectSchema<Raw & RawExtension, Parsed & ParsedExtension> = {
        ...OBJECT_LIKE_BRAND,
        _getParsedProperties: async () => [
          ...(await schema._getParsedProperties()),
          ...(await extension._getParsedProperties()),
        ],
        _getRawProperties: async () => [
          ...(await schema._getRawProperties()),
          ...(await extension._getRawProperties()),
        ],
        parse: async (raw, opts) => {
          const rawExtensionPropertiesSet = new Set(await extension._getRawProperties());
          const [extensionProperties, otherProperties] = partition(keys(raw), (key) =>
            rawExtensionPropertiesSet.has(key as keyof RawExtension)
          );
          return {
            ...(await schema.parse(filterObject(raw, otherProperties), opts)),
            ...(await extension.parse(filterObject(raw, extensionProperties), opts)),
          };
        },
        json: async (parsed, opts) => {
          const parsedExtensionPropertiesSet = new Set(await extension._getParsedProperties());
          const [extensionProperties, otherProperties] = partition(keys(parsed), (key) =>
            parsedExtensionPropertiesSet.has(key as keyof ParsedExtension)
          );
          return {
            ...(await schema.json(filterObject(parsed, otherProperties), opts)),
            ...(await extension.json(filterObject(parsed, extensionProperties), opts)),
          };
        },
      };

      return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
      };
    },
  };
}
",
                        "name": "object.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export function property<RawKey extends string, RawValue, ParsedValue>(
  rawKey: RawKey,
  valueSchema: Schema<RawValue, ParsedValue>
): Property<RawKey, RawValue, ParsedValue> {
  return {
    rawKey,
    valueSchema,
    isProperty: true,
  };
}

export interface Property<RawKey extends string, RawValue, ParsedValue> {
  rawKey: RawKey;
  valueSchema: Schema<RawValue, ParsedValue>;
  isProperty: true;
}

export function isProperty<O extends Property<any, any, any>>(maybeProperty: unknown): maybeProperty is O {
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return (maybeProperty as O).isProperty;
}
",
                        "name": "property.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsed, inferRaw, Schema } from \\"../../Schema\\";
import { addQuestionMarksToNullableProperties } from \\"../../utils/addQuestionMarksToNullableProperties\\";
import { BaseObjectLikeSchema, ObjectLikeSchema } from \\"../object-like\\";
import { Property } from \\"./property\\";

export type ObjectSchema<Raw, Parsed> = BaseObjectSchema<Raw, Parsed> &
  ObjectLikeSchema<Raw, Parsed> &
  ObjectUtils<Raw, Parsed>;

export interface BaseObjectSchema<Raw, Parsed> extends BaseObjectLikeSchema<Raw, Parsed> {
  _getRawProperties: () => Promise<(keyof Raw)[]>;
  _getParsedProperties: () => Promise<(keyof Parsed)[]>;
}

export interface ObjectUtils<Raw, Parsed> {
  extend: <RawExtension, ParsedExtension>(
    schemas: ObjectSchema<RawExtension, ParsedExtension>
  ) => ObjectSchema<Raw & RawExtension, Parsed & ParsedExtension>;
}

export type inferRawObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<infer Raw, any> ? Raw : never;

export type inferParsedObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<any, infer Parsed>
  ? Parsed
  : never;

export type inferObjectSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> = ObjectSchema<
  inferRawObjectFromPropertySchemas<T>,
  inferParsedObjectFromPropertySchemas<T>
>;

export type inferRawObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
  addQuestionMarksToNullableProperties<{
    [ParsedKey in keyof T as inferRawKey<ParsedKey, T[ParsedKey]>]: inferRawPropertySchema<T[ParsedKey]>;
  }>;

export type inferParsedObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
  addQuestionMarksToNullableProperties<{
    [K in keyof T]: inferParsedPropertySchema<T[K]>;
  }>;

export type PropertySchemas<ParsedKeys extends string | number | symbol> = Record<
  ParsedKeys,
  Property<any, any, any> | Schema<any, any>
>;

export type inferRawPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
  any,
  infer Raw,
  any
>
  ? Raw
  : P extends Schema<any, any>
  ? inferRaw<P>
  : never;

export type inferParsedPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
  any,
  any,
  infer Parsed
>
  ? Parsed
  : P extends Schema<any, any>
  ? inferParsed<P>
  : never;

export type inferRawKey<
  ParsedKey extends string | number | symbol,
  P extends Property<any, any, any> | Schema<any, any>
> = P extends Property<infer Raw, any, any> ? Raw : ParsedKey;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { getSchemaUtils } from \\"../schema-utils\\";
import { BaseObjectLikeSchema, ObjectLikeSchema, ObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"./types\\";

export function getObjectLikeUtils<Raw, Parsed>(
  schema: BaseObjectLikeSchema<Raw, Parsed>
): ObjectLikeUtils<Raw, Parsed> {
  return {
    withProperties: (properties) => withProperties(schema, properties),
  };
}

/**
 * object-like utils are defined in one file to resolve issues with circular imports
 */

export function withProperties<RawObjectShape, ParsedObjectShape, Properties>(
  objectLike: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape>,
  properties: { [K in keyof Properties]: Properties[K] | ((parsed: ParsedObjectShape) => Properties[K]) }
): ObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> {
  const objectSchema: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> = {
    ...OBJECT_LIKE_BRAND,
    parse: async (raw, opts) => {
      const parsedObject = await objectLike.parse(raw, opts);
      const additionalProperties = Object.entries(properties).reduce<Record<string, any>>((processed, [key, value]) => {
        return {
          ...processed,
          [key]: typeof value === \\"function\\" ? value(parsedObject) : value,
        };
      }, {});

      return {
        ...parsedObject,
        ...(additionalProperties as Properties),
      };
    },
    json: (parsed, opts) => {
      // strip out added properties
      const addedPropertyKeys = new Set(Object.keys(properties));
      const parsedWithoutAddedProperties = Object.entries(parsed).reduce<Record<string, any>>(
        (filtered, [key, value]) => {
          if (!addedPropertyKeys.has(key)) {
            filtered[key] = value;
          }
          return filtered;
        },
        {}
      );

      return objectLike.json(parsedWithoutAddedProperties as ParsedObjectShape, opts);
    },
  };

  return {
    ...objectSchema,
    ...getSchemaUtils(objectSchema),
    ...getObjectLikeUtils(objectSchema),
  };
}
",
                        "name": "getObjectLikeUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getObjectLikeUtils, withProperties } from \\"./getObjectLikeUtils\\";
export { OBJECT_LIKE_BRAND, type BaseObjectLikeSchema, type ObjectLikeSchema, type ObjectLikeUtils } from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";

export type ObjectLikeSchema<Raw, Parsed> = Schema<Raw, Parsed> &
  BaseObjectLikeSchema<Raw, Parsed> &
  ObjectLikeUtils<Raw, Parsed>;

export type BaseObjectLikeSchema<Raw, Parsed> = BaseSchema<Raw, Parsed> & {
  _objectLike: void;
};

export interface ObjectLikeUtils<Raw, Parsed> {
  withProperties: <T extends Record<string, any>>(properties: {
    [K in keyof T]: T[K] | ((parsed: Parsed) => T[K]);
  }) => ObjectLikeSchema<Raw, Parsed & T>;
}

export const OBJECT_LIKE_BRAND = undefined as unknown as { _objectLike: void };
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object-like",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const any = createIdentitySchemaCreator<any>();
",
                        "name": "any.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const boolean = createIdentitySchemaCreator<boolean>();
",
                        "name": "boolean.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { any } from \\"./any\\";
export { boolean } from \\"./boolean\\";
export { number } from \\"./number\\";
export { string } from \\"./string\\";
export { unknown } from \\"./unknown\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const number = createIdentitySchemaCreator<number>();
",
                        "name": "number.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const string = createIdentitySchemaCreator<string>();
",
                        "name": "string.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const unknown = createIdentitySchemaCreator<unknown>();
",
                        "name": "unknown.ts",
                        "type": "file",
                      },
                    ],
                    "name": "primitives",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { record } from \\"./record\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function record<RawKey extends string | number, ParsedKey extends string | number, RawValue, ParsedValue>(
  keySchema: Schema<RawKey, ParsedKey>,
  valueSchema: Schema<RawValue, ParsedValue>
): Schema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> {
  const baseSchema: BaseSchema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> = {
    parse: (raw, opts) => {
      return entries(raw).reduce(async (parsedPromise, [key, value]) => {
        const parsed: Record<ParsedKey, ParsedValue> = await parsedPromise;
        const parsedKey = await keySchema.parse(key, opts);
        parsed[parsedKey] = await valueSchema.parse(value, opts);
        return parsedPromise;
      }, Promise.resolve({} as Record<ParsedKey, ParsedValue>));
    },
    json: (parsed, opts) => {
      return entries(parsed).reduce(async (rawPromise, [key, value]) => {
        const raw: Record<RawKey, RawValue> = await rawPromise;
        const rawKey = await keySchema.json(key, opts);
        raw[rawKey] = await valueSchema.json(value, opts);
        return rawPromise;
      }, Promise.resolve({} as Record<RawKey, RawValue>));
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "record.ts",
                        "type": "file",
                      },
                    ],
                    "name": "record",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { OptionalSchema, OPTIONAL_BRAND } from \\"./types\\";

export interface SchemaUtils<Raw, Parsed> {
  optional: () => OptionalSchema<Raw, Parsed>;
  transform: <PostTransform>(transformer: BaseSchema<Parsed, PostTransform>) => Schema<Raw, PostTransform>;
}

export function getSchemaUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): SchemaUtils<Raw, Parsed> {
  return {
    optional: () => optional(schema),
    transform: (transformer) => transform(schema, transformer),
  };
}

/**
 * schema utils are defined in one file to resolve issues with circular imports
 */

export function optional<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): OptionalSchema<Raw, Parsed> {
  const baseSchema: BaseSchema<Raw | null | undefined, Parsed | undefined> = {
    parse: (raw, opts) => (raw != null ? schema.parse(raw, opts) : undefined),
    json: (parsed, opts) => (parsed != null ? schema.json(parsed, opts) : undefined),
  };

  return {
    ...OPTIONAL_BRAND,
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function transform<PreTransformRaw, PreTransformParsed, PostTransform>(
  schema: BaseSchema<PreTransformRaw, PreTransformParsed>,
  transformer: BaseSchema<PreTransformParsed, PostTransform>
): Schema<PreTransformRaw, PostTransform> {
  const baseSchema: BaseSchema<PreTransformRaw, PostTransform> = {
    parse: async (raw, opts) => {
      const postTransformParsed = await schema.parse(raw, opts);
      return transformer.parse(postTransformParsed, opts);
    },
    json: async (parsed, opts) => {
      const preTransformParsed = await transformer.json(parsed, opts);
      return schema.json(preTransformParsed, opts);
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "getSchemaUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getSchemaUtils, optional, transform, type SchemaUtils } from \\"./getSchemaUtils\\";
export { OPTIONAL_BRAND, type OptionalSchema } from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export const OPTIONAL_BRAND = undefined as unknown as { _isOptional: void };

export type OptionalSchema<Raw, Parsed> = Schema<Raw | null | undefined, Parsed | undefined> & {
  _isOptional: void;
};
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "schema-utils",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { set } from \\"./set\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function set<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Set<Parsed>> {
  const baseSchema: BaseSchema<Raw[], Set<Parsed>> = {
    parse: async (raw, opts) => new Set(await Promise.all(raw.map((item) => schema.parse(item, opts)))),
    json: (parsed, opts) => Promise.all([...parsed].map((item) => schema.json(item, opts))),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "set.ts",
                        "type": "file",
                      },
                    ],
                    "name": "set",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export function discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string>(
  parsedDiscriminant: ParsedDiscriminant,
  rawDiscriminant: RawDiscriminant
): Discriminant<RawDiscriminant, ParsedDiscriminant> {
  return {
    parsedDiscriminant,
    rawDiscriminant,
  };
}

export interface Discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string> {
  parsedDiscriminant: ParsedDiscriminant;
  rawDiscriminant: RawDiscriminant;
}
",
                        "name": "discriminant.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { discriminant, type Discriminant } from \\"./discriminant\\";
export {
  type inferParsedDiscriminant,
  type inferParsedUnion,
  type inferRawDiscriminant,
  type inferRawUnion,
  type UnionSubtypes,
} from \\"./types\\";
export { union } from \\"./union\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsedObject, inferRawObject, ObjectSchema } from \\"../object\\";
import { Discriminant } from \\"./discriminant\\";

export type UnionSubtypes<DiscriminantValues extends string | number | symbol> = {
  [K in DiscriminantValues]: ObjectSchema<any, any>;
};

export type inferRawUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
  [K in keyof U]: Record<inferRawDiscriminant<D>, K> & inferRawObject<U[K]>;
}[keyof U];

export type inferParsedUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
  [K in keyof U]: Record<inferParsedDiscriminant<D>, K> & inferParsedObject<U[K]>;
}[keyof U];

export type inferRawDiscriminant<D extends string | Discriminant<any, any>> = D extends string
  ? D
  : D extends Discriminant<infer Raw, any>
  ? Raw
  : never;

export type inferParsedDiscriminant<D extends string | Discriminant<any, any>> = D extends string
  ? D
  : D extends Discriminant<any, infer Parsed>
  ? Parsed
  : never;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseObjectLikeSchema, getObjectLikeUtils, ObjectLikeSchema, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { Discriminant } from \\"./discriminant\\";
import { inferParsedDiscriminant, inferParsedUnion, inferRawDiscriminant, inferRawUnion, UnionSubtypes } from \\"./types\\";

export function union<D extends string | Discriminant<any, any>, U extends UnionSubtypes<any>>(
  discriminant: D,
  union: U
): ObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> {
  const rawDiscriminant =
    typeof discriminant === \\"string\\" ? discriminant : (discriminant.rawDiscriminant as inferRawDiscriminant<D>);
  const parsedDiscriminant =
    typeof discriminant === \\"string\\" ? discriminant : (discriminant.parsedDiscriminant as inferParsedDiscriminant<D>);

  const baseSchema: BaseObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> = {
    ...OBJECT_LIKE_BRAND,

    parse: async (raw, opts) => {
      const { [rawDiscriminant]: discriminantValue, ...additionalProperties } = raw;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [parsedDiscriminant]: discriminantValue,
        } as inferParsedUnion<D, U>;
      }

      return {
        ...(await additionalPropertySchemas.parse(additionalProperties, opts)),
        [parsedDiscriminant]: discriminantValue,
      } as inferParsedUnion<D, U>;
    },

    json: async (parsed, opts) => {
      const { [parsedDiscriminant]: discriminantValue, ...additionalProperties } = parsed;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [rawDiscriminant]: discriminantValue,
        } as unknown as inferRawUnion<D, U>;
      }

      return {
        ...(await additionalPropertySchemas.json(additionalProperties, opts)),
        [rawDiscriminant]: discriminantValue,
      } as inferRawUnion<D, U>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
  };
}
",
                        "name": "union.ts",
                        "type": "file",
                      },
                    ],
                    "name": "union",
                    "type": "directory",
                  },
                ],
                "name": "builders",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./builders\\";
export { type inferParsed, type inferRaw, type Schema, type SchemaOptions } from \\"./Schema\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export type addQuestionMarksToNullableProperties<T> = {
  [K in OptionalKeys<T>]?: undefined extends T[K] ? T[K] : never;
} & Pick<T, RequiredKeys<T>>;

export type OptionalKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? K : never;
}[keyof T];

export type RequiredKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? never : K;
}[keyof T];
",
                    "name": "addQuestionMarksToNullableProperties.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function entries<T>(object: T): [keyof T, T[keyof T]][] {
  return Object.entries(object) as [keyof T, T[keyof T]][];
}
",
                    "name": "entries.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function filterObject<T, K extends keyof T>(obj: T, keysToInclude: K[]): Pick<T, K> {
  const keysToIncludeSet = new Set(keysToInclude);
  return Object.entries(obj).reduce((acc, [key, value]) => {
    if (keysToIncludeSet.has(key as K)) {
      acc[key as K] = value;
    }
    return acc;
    // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
  }, {} as Pick<T, K>);
}
",
                    "name": "filterObject.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function keys<T>(object: T): (keyof T)[] {
  return Object.keys(object) as (keyof T)[];
}
",
                    "name": "keys.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function partition<T>(items: readonly T[], predicate: (item: T) => boolean): [T[], T[]] {
  const trueItems: T[] = [],
    falseItems: T[] = [];
  for (const item of items) {
    if (predicate(item)) {
      trueItems.push(item);
    } else {
      falseItems.push(item);
    }
  }
  return [trueItems, falseItems];
}
",
                    "name": "partition.ts",
                    "type": "file",
                  },
                ],
                "name": "utils",
                "type": "directory",
              },
            ],
            "name": "schemas",
            "type": "directory",
          },
        ],
        "name": "core",
        "type": "directory",
      },
      Object {
        "contents": "export * as FernApi from \\"./resources\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * as package_ from \\"./package\\";
export * from \\"./package/types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface Package {
  name: string;
}
",
                    "name": "Package.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./Package\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "package",
            "type": "directory",
          },
        ],
        "name": "resources",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * as package_ from \\"./package\\";
export * from \\"./package/types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernApi } from \\"@fern/api\\";
import * as core from \\"../../../core\\";

export const Package: core.schemas.ObjectSchema<serializers.Package.Raw, FernApi.Package> = core.schemas.object({
  name: core.schemas.string(),
});

export declare namespace Package {
  interface Raw {
    name: string;
  }
}
",
                    "name": "Package.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./Package\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "package",
            "type": "directory",
          },
        ],
        "name": "serialization",
        "type": "directory",
      },
    ],
    "name": "src",
    "type": "directory",
  },
  Object {
    "contents": "{
    \\"compilerOptions\\": {
        \\"strict\\": true,
        \\"target\\": \\"esnext\\",
        \\"module\\": \\"esnext\\",
        \\"moduleResolution\\": \\"node\\",
        \\"esModuleInterop\\": true,
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"emitDeclarationOnly\\": true,
        \\"sourceMap\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true,
        \\"outDir\\": \\".\\",
        \\"rootDir\\": \\"src\\",
        \\"baseUrl\\": \\"src\\",
        \\"paths\\": {
            \\"@fern/api\\": [
                \\".\\"
            ]
        }
    },
    \\"include\\": [
        \\"src\\"
    ],
    \\"exclude\\": []
}",
    "name": "tsconfig.json",
    "type": "file",
  },
]
`;

exports[`runGenerator trace 1`] = `
Array [
  Object {
    "contents": "node_modules
.DS_Store
*.d.ts
*.js
*.js.map
*.cjs
*.mjs

# yarn berry
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions

# these are needed to override '*.js' above
!.yarn/patches/**
!.yarn/plugins/**
!.yarn/releases/**
!.yarn/sdks/**
!.yarn/versions/**",
    "name": ".gitignore",
    "type": "file",
  },
  Object {
    "contents": ".yarn
node_modules
.npmignore
.pnp.cjs
*.js
*.d.ts",
    "name": ".prettierignore",
    "type": "file",
  },
  Object {
    "contents": "nodeLinker: pnp

yarnPath: .yarn/releases/yarn-3.2.4.cjs
",
    "name": ".yarnrc.yml",
    "type": "file",
  },
  Object {
    "contents": "{
    \\"name\\": \\"@fern-trace/api-sdk\\",
    \\"version\\": \\"\\",
    \\"files\\": [
        \\"index.mjs\\",
        \\"index.cjs\\",
        \\"browser.js\\",
        \\"browser.js.map\\",
        \\"*.d.ts\\"
    ],
    \\"exports\\": {
        \\".\\": {
            \\"import\\": \\"./index.mjs\\",
            \\"module\\": \\"./index.mjs\\",
            \\"require\\": \\"./index.cjs\\",
            \\"browser\\": \\"./browser.js\\",
            \\"default\\": \\"./index.cjs\\"
        }
    },
    \\"types\\": \\"./index.d.ts\\",
    \\"scripts\\": {
        \\"format\\": \\"prettier --write --print-width 120 src/**/*.ts\\",
        \\"build:esm\\": \\"esbuild src/index.ts --bundle --platform=node --format=esm --outfile=index.mjs\\",
        \\"build:cjs\\": \\"esbuild src/index.ts --bundle --platform=node --format=cjs --outfile=index.cjs\\",
        \\"build:browser\\": \\"esbuild src/index.ts --bundle --platform=browser --sourcemap --outfile=browser.js\\",
        \\"build\\": \\"yarn build:esm && yarn build:cjs && yarn build:browser && tsc && tsc-alias\\"
    },
    \\"dependencies\\": {
        \\"@types/basic-auth\\": \\"^1.1.3\\",
        \\"@types/url-join\\": \\"4.0.1\\",
        \\"axios\\": \\"^0.27.2\\",
        \\"basic-auth\\": \\"^2.0.1\\",
        \\"buffer\\": \\"^6.0.3\\",
        \\"js-base64\\": \\"^3.7.2\\",
        \\"url-join\\": \\"4.0.1\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"esbuild\\": \\"0.16.13\\",
        \\"prettier\\": \\"2.7.1\\",
        \\"tsc-alias\\": \\"^1.7.1\\",
        \\"typescript\\": \\"4.6.4\\"
    },
    \\"packageManager\\": \\"yarn@3.2.4\\"
}
",
    "name": "package.json",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"./environments\\";
import * as core from \\"./core\\";
import { Client as AdminClient } from \\"./resources/admin/client/Client\\";
import { Client as HomepageClient } from \\"./resources/homepage/client/Client\\";
import { Client as MigrationClient } from \\"./resources/migration/client/Client\\";
import { Client as PlaylistClient } from \\"./resources/playlist/client/Client\\";
import { Client as ProblemClient } from \\"./resources/problem/client/Client\\";
import { Client as SubmissionClient } from \\"./resources/submission/client/Client\\";
import { Client as SyspropClient } from \\"./resources/sysprop/client/Client\\";
import { Client as V2Client } from \\"./resources/v2/client/Client\\";

export declare namespace TraceApiClient {
  interface Options {
    environment?: environments.Environment | string;
    token?: core.Supplier<core.BearerToken>;
  }
}

export class TraceApiClient {
  constructor(private readonly options: TraceApiClient.Options) {}

  #admin: AdminClient | undefined;

  public get admin(): AdminClient {
    return (this.#admin ??= new AdminClient(this.options));
  }

  #homepage: HomepageClient | undefined;

  public get homepage(): HomepageClient {
    return (this.#homepage ??= new HomepageClient(this.options));
  }

  #migration: MigrationClient | undefined;

  public get migration(): MigrationClient {
    return (this.#migration ??= new MigrationClient(this.options));
  }

  #playlist: PlaylistClient | undefined;

  public get playlist(): PlaylistClient {
    return (this.#playlist ??= new PlaylistClient(this.options));
  }

  #problem: ProblemClient | undefined;

  public get problem(): ProblemClient {
    return (this.#problem ??= new ProblemClient(this.options));
  }

  #submission: SubmissionClient | undefined;

  public get submission(): SubmissionClient {
    return (this.#submission ??= new SubmissionClient(this.options));
  }

  #sysprop: SyspropClient | undefined;

  public get sysprop(): SyspropClient {
    return (this.#sysprop ??= new SyspropClient(this.options));
  }

  #v2: V2Client | undefined;

  public get v2(): V2Client {
    return (this.#v2 ??= new V2Client(this.options));
  }
}
",
        "name": "Client.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "import { parse } from \\"basic-auth\\";
import { Base64 } from \\"js-base64\\";

export interface BasicAuth {
  username: string;
  password: string;
}

export const BasicAuth = {
  toAuthorizationHeader: (basicAuth: BasicAuth | undefined): string | undefined => {
    if (basicAuth == null) {
      return undefined;
    }
    const token = Base64.encode(\`\${basicAuth.username}:\${basicAuth.password}\`);
    return \`Basic \${token}\`;
  },
  fromAuthorizationHeader: (header: string): BasicAuth => {
    const parsed = parse(header);
    if (parsed == null) {
      throw new Error(\\"Invalid basic auth\\");
    }
    return {
      username: parsed.name,
      password: parsed.pass,
    };
  },
};
",
                "name": "BasicAuth.ts",
                "type": "file",
              },
              Object {
                "contents": "export type BearerToken = string;

const BEARER_AUTH_HEADER_PREFIX = /^Bearer /i;

export const BearerToken = {
  toAuthorizationHeader: (token: BearerToken | undefined): string | undefined => {
    if (token == null) {
      return undefined;
    }
    return \`Bearer \${token}\`;
  },
  fromAuthorizationHeader: (header: string): BearerToken => {
    return header.replace(BEARER_AUTH_HEADER_PREFIX, \\"\\").trim() as BearerToken;
  },
};
",
                "name": "BearerToken.ts",
                "type": "file",
              },
              Object {
                "contents": "export { BasicAuth } from \\"./BasicAuth\\";
export { BearerToken } from \\"./BearerToken\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "auth",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export type APIResponse<Success, Failure> = SuccessfulResponse<Success> | FailedResponse<Failure>;

export interface SuccessfulResponse<T> {
  ok: true;
  body: T;
}

export interface FailedResponse<T> {
  ok: false;
  error: T;
}
",
                "name": "APIResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import axios, { AxiosError } from \\"axios\\";
import { APIResponse } from \\"./APIResponse\\";

export interface Fetcher {
  fetch: FetchFunction;
}

export type FetchFunction = (args: Fetcher.Args) => Promise<APIResponse<unknown, Fetcher.Error>>;

export declare namespace Fetcher {
  export interface Args {
    url: string;
    method: string;
    headers?: Record<string, string | undefined>;
    queryParameters?: URLSearchParams;
    body?: unknown;
    timeoutMs?: number;
  }

  export type Error = FailedStatusCodeError | NonJsonError | TimeoutError | UnknownError;

  export interface FailedStatusCodeError {
    reason: \\"status-code\\";
    statusCode: number;
    body: unknown;
  }

  export interface NonJsonError {
    reason: \\"non-json\\";
    statusCode: number;
    rawBody: string;
  }

  export interface TimeoutError {
    reason: \\"timeout\\";
  }

  export interface UnknownError {
    reason: \\"unknown\\";
    errorMessage: string;
  }
}

export const fetcher: FetchFunction = async (args) => {
  const headers: Record<string, string> = {
    \\"Content-Type\\": \\"application/json\\",
  };

  if (args.headers != null) {
    for (const [key, value] of Object.entries(args.headers)) {
      if (value != null) {
        headers[key] = value;
      }
    }
  }

  try {
    const response = await axios({
      url: args.url,
      params: args.queryParameters,
      method: args.method,
      headers,
      data: args.body,
      validateStatus: () => true,
      transformResponse: (response) => response,
      timeout: args.timeoutMs ?? 60_000,
      transitional: {
        clarifyTimeoutError: true,
      },
      withCredentials: true,
    });

    let body: unknown;
    if (response.data != null && response.data.length > 0) {
      try {
        body = JSON.parse(response.data) ?? undefined;
      } catch {
        return {
          ok: false,
          error: {
            reason: \\"non-json\\",
            statusCode: response.status,
            rawBody: response.data,
          },
        };
      }
    }

    if (response.status >= 200 && response.status < 300) {
      return {
        ok: true,
        body,
      };
    } else {
      return {
        ok: false,
        error: {
          reason: \\"status-code\\",
          statusCode: response.status,
          body,
        },
      };
    }
  } catch (error) {
    if ((error as AxiosError).code === \\"ETIMEDOUT\\") {
      return {
        ok: false,
        error: {
          reason: \\"timeout\\",
        },
      };
    }

    return {
      ok: false,
      error: {
        reason: \\"unknown\\",
        errorMessage: (error as AxiosError).message,
      },
    };
  }
};
",
                "name": "Fetcher.ts",
                "type": "file",
              },
              Object {
                "contents": "export type Supplier<T> = T | Promise<T> | (() => T | Promise<T>);

export const Supplier = {
  get: async <T>(supplier: Supplier<T>): Promise<T> => {
    if (typeof supplier === \\"function\\") {
      return (supplier as () => T)();
    } else {
      return supplier;
    }
  },
};
",
                "name": "Supplier.ts",
                "type": "file",
              },
              Object {
                "contents": "export { type APIResponse } from \\"./APIResponse\\";
export { fetcher, type Fetcher, type FetchFunction } from \\"./Fetcher\\";
export { Supplier } from \\"./Supplier\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "fetcher",
            "type": "directory",
          },
          Object {
            "contents": "export * from \\"./utils\\";
export * as schemas from \\"./schemas\\";
export * from \\"./fetcher\\";
export * from \\"./auth\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { SchemaUtils } from \\"./builders\\";

export type Schema<Raw = unknown, Parsed = unknown> = BaseSchema<Raw, Parsed> & SchemaUtils<Raw, Parsed>;

export type inferRaw<S extends Schema> = S extends Schema<infer Raw, any> ? Raw : never;
export type inferParsed<S extends Schema> = S extends Schema<any, infer Parsed> ? Parsed : never;

export interface BaseSchema<Raw, Parsed> {
  parse: (raw: Raw, opts?: SchemaOptions) => Parsed | Promise<Parsed>;
  json: (parsed: Parsed, opts?: SchemaOptions) => Raw | Promise<Raw>;
}

export interface SchemaOptions {
  /**
   * @default false
   */
  skipUnknownKeysOnParse?: boolean;

  /**
   * @default false
   */
  includeUnknownKeysOnJson?: boolean;
}
",
                "name": "Schema.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function date(): Schema<string, Date> {
  const baseSchema: BaseSchema<string, Date> = {
    parse: (raw) => new Date(raw),
    json: (date) => date.toISOString(),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "date.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { date } from \\"./date\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "date",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function enum_<U extends string, E extends Readonly<[U, ...U[]]>>(_values: E): Schema<E[number], E[number]> {
  return createIdentitySchemaCreator<E[number]>()();
}
",
                        "name": "enum.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { enum_ } from \\"./enum\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "enum",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { identity } from \\"./identity\\";

export function createIdentitySchemaCreator<T>(): () => Schema<T, T> {
  return <T>() => identity<T>();
}
",
                        "name": "createIdentitySchemaCreator.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function identity<T>(): Schema<T, T> {
  const baseSchema: BaseSchema<T, T> = {
    parse: (raw) => raw,
    json: (parsed) => parsed,
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "identity.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { createIdentitySchemaCreator } from \\"./createIdentitySchemaCreator\\";
export { identity } from \\"./identity\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "identity",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./date\\";
export * from \\"./enum\\";
export * from \\"./identity\\";
export * from \\"./lazy\\";
export * from \\"./list\\";
export * from \\"./literals\\";
export * from \\"./object\\";
export * from \\"./object-like\\";
export * from \\"./primitives\\";
export * from \\"./record\\";
export * from \\"./schema-utils\\";
export * from \\"./set\\";
export * from \\"./union\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { lazy, type SchemaGetter } from \\"./lazy\\";
export { lazyObject } from \\"./lazyObject\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export type SchemaGetter<SchemaType extends Schema<any, any>> = () => SchemaType | Promise<SchemaType>;

export function lazy<Raw, Parsed>(getter: SchemaGetter<Schema<Raw, Parsed>>): Schema<Raw, Parsed> {
  const baseSchema = constructLazyBaseSchema(getter);
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function constructLazyBaseSchema<Raw, Parsed>(
  getter: SchemaGetter<Schema<Raw, Parsed>>
): BaseSchema<Raw, Parsed> {
  return {
    parse: async (raw) => (await getMemoizedSchema(getter)).parse(raw),
    json: async (parsed) => (await getMemoizedSchema(getter)).json(parsed),
  };
}

type MemoizedGetter<SchemaType extends Schema<any, any>> = SchemaGetter<SchemaType> & { __zurg_memoized?: SchemaType };

export async function getMemoizedSchema<SchemaType extends Schema<any, any>>(
  getter: SchemaGetter<SchemaType>
): Promise<SchemaType> {
  const castedGetter = getter as MemoizedGetter<SchemaType>;
  if (castedGetter.__zurg_memoized == null) {
    castedGetter.__zurg_memoized = await getter();
  }
  return castedGetter.__zurg_memoized;
}
",
                        "name": "lazy.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { getObjectUtils } from \\"../object\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { BaseObjectSchema, ObjectSchema } from \\"../object/types\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { constructLazyBaseSchema, getMemoizedSchema, SchemaGetter } from \\"./lazy\\";

export function lazyObject<Raw, Parsed>(getter: SchemaGetter<ObjectSchema<Raw, Parsed>>): ObjectSchema<Raw, Parsed> {
  const baseSchema: BaseObjectSchema<Raw, Parsed> = {
    ...OBJECT_LIKE_BRAND,
    ...constructLazyBaseSchema(getter),
    _getRawProperties: async () => (await getMemoizedSchema(getter))._getRawProperties(),
    _getParsedProperties: async () => (await getMemoizedSchema(getter))._getParsedProperties(),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}
",
                        "name": "lazyObject.ts",
                        "type": "file",
                      },
                    ],
                    "name": "lazy",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { list } from \\"./list\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function list<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Parsed[]> {
  const baseSchema: BaseSchema<Raw[], Parsed[]> = {
    parse: (raw, opts) => Promise.all(raw.map((item) => schema.parse(item, opts))),
    json: (parsed, opts) => Promise.all(parsed.map((item) => schema.json(item, opts))),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "list.ts",
                        "type": "file",
                      },
                    ],
                    "name": "list",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { stringLiteral } from \\"./stringLiteral\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function stringLiteral<V extends string>(_value: V): Schema<V, V> {
  return createIdentitySchemaCreator<V>()();
}
",
                        "name": "stringLiteral.ts",
                        "type": "file",
                      },
                    ],
                    "name": "literals",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { getObjectUtils, object } from \\"./object\\";
export { isProperty, property, type Property } from \\"./property\\";
export {
  type BaseObjectSchema,
  type inferObjectSchemaFromPropertySchemas,
  type inferParsedObject,
  type inferParsedObjectFromPropertySchemas,
  type inferParsedPropertySchema,
  type inferRawKey,
  type inferRawObject,
  type inferRawObjectFromPropertySchemas,
  type inferRawPropertySchema,
  type ObjectSchema,
  type ObjectUtils,
  type PropertySchemas,
} from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { filterObject } from \\"../../utils/filterObject\\";
import { keys } from \\"../../utils/keys\\";
import { partition } from \\"../../utils/partition\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { isProperty } from \\"./property\\";
import {
  BaseObjectSchema,
  inferObjectSchemaFromPropertySchemas,
  inferParsedObjectFromPropertySchemas,
  inferRawObjectFromPropertySchemas,
  ObjectSchema,
  ObjectUtils,
  PropertySchemas,
} from \\"./types\\";

interface ObjectPropertyWithRawKey {
  rawKey: string;
  parsedKey: string | number | symbol;
  valueSchema: Schema<any, any>;
}

export function object<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(
  schemas: T
): inferObjectSchemaFromPropertySchemas<T> {
  const baseSchema: BaseObjectSchema<inferRawObjectFromPropertySchemas<T>, inferParsedObjectFromPropertySchemas<T>> = {
    ...OBJECT_LIKE_BRAND,
    _getRawProperties: () =>
      Promise.resolve(
        Object.entries(schemas).map(([parsedKey, propertySchema]) =>
          isProperty(propertySchema) ? propertySchema.rawKey : parsedKey
        ) as unknown as (keyof inferRawObjectFromPropertySchemas<T>)[]
      ),
    _getParsedProperties: () =>
      Promise.resolve(keys(schemas) as unknown as (keyof inferParsedObjectFromPropertySchemas<T>)[]),

    parse: async (raw, { skipUnknownKeysOnParse = false } = {}) => {
      const rawKeyToProperty: Record<string, ObjectPropertyWithRawKey> = {};

      for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
        const rawKey = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;

        const property: ObjectPropertyWithRawKey = {
          rawKey,
          parsedKey,
          valueSchema: isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.valueSchema : schemaOrObjectProperty,
        };

        rawKeyToProperty[rawKey] = property;
      }

      const parsed: Record<string | number | symbol, any> = {};

      for (const [rawKey, rawPropertyValue] of Object.entries(raw)) {
        const property = rawKeyToProperty[rawKey];

        if (property != null) {
          const value = await property.valueSchema.parse(rawPropertyValue);
          parsed[property.parsedKey] = value;
        } else if (!skipUnknownKeysOnParse && rawPropertyValue != null) {
          parsed[rawKey] = rawPropertyValue;
        }
      }

      return parsed as inferParsedObjectFromPropertySchemas<T>;
    },

    json: async (parsed, { includeUnknownKeysOnJson = false } = {}) => {
      const raw: Record<string | number | symbol, any> = {};

      for (const [parsedKey, parsedPropertyValue] of entries(parsed)) {
        const schemaOrObjectProperty = schemas[parsedKey as keyof T];
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (schemaOrObjectProperty != null) {
          if (isProperty(schemaOrObjectProperty)) {
            const value = await schemaOrObjectProperty.valueSchema.json(parsedPropertyValue);
            raw[schemaOrObjectProperty.rawKey] = value;
          } else {
            const value = await schemaOrObjectProperty.json(parsedPropertyValue);
            raw[parsedKey] = value;
          }
        } else if (includeUnknownKeysOnJson && parsedPropertyValue != null) {
          raw[parsedKey] = parsedPropertyValue;
        }
      }

      return raw as inferRawObjectFromPropertySchemas<T>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}

export function getObjectUtils<Raw, Parsed>(schema: BaseObjectSchema<Raw, Parsed>): ObjectUtils<Raw, Parsed> {
  return {
    extend: <RawExtension, ParsedExtension>(extension: ObjectSchema<RawExtension, ParsedExtension>) => {
      const baseSchema: BaseObjectSchema<Raw & RawExtension, Parsed & ParsedExtension> = {
        ...OBJECT_LIKE_BRAND,
        _getParsedProperties: async () => [
          ...(await schema._getParsedProperties()),
          ...(await extension._getParsedProperties()),
        ],
        _getRawProperties: async () => [
          ...(await schema._getRawProperties()),
          ...(await extension._getRawProperties()),
        ],
        parse: async (raw, opts) => {
          const rawExtensionPropertiesSet = new Set(await extension._getRawProperties());
          const [extensionProperties, otherProperties] = partition(keys(raw), (key) =>
            rawExtensionPropertiesSet.has(key as keyof RawExtension)
          );
          return {
            ...(await schema.parse(filterObject(raw, otherProperties), opts)),
            ...(await extension.parse(filterObject(raw, extensionProperties), opts)),
          };
        },
        json: async (parsed, opts) => {
          const parsedExtensionPropertiesSet = new Set(await extension._getParsedProperties());
          const [extensionProperties, otherProperties] = partition(keys(parsed), (key) =>
            parsedExtensionPropertiesSet.has(key as keyof ParsedExtension)
          );
          return {
            ...(await schema.json(filterObject(parsed, otherProperties), opts)),
            ...(await extension.json(filterObject(parsed, extensionProperties), opts)),
          };
        },
      };

      return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
      };
    },
  };
}
",
                        "name": "object.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export function property<RawKey extends string, RawValue, ParsedValue>(
  rawKey: RawKey,
  valueSchema: Schema<RawValue, ParsedValue>
): Property<RawKey, RawValue, ParsedValue> {
  return {
    rawKey,
    valueSchema,
    isProperty: true,
  };
}

export interface Property<RawKey extends string, RawValue, ParsedValue> {
  rawKey: RawKey;
  valueSchema: Schema<RawValue, ParsedValue>;
  isProperty: true;
}

export function isProperty<O extends Property<any, any, any>>(maybeProperty: unknown): maybeProperty is O {
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return (maybeProperty as O).isProperty;
}
",
                        "name": "property.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsed, inferRaw, Schema } from \\"../../Schema\\";
import { addQuestionMarksToNullableProperties } from \\"../../utils/addQuestionMarksToNullableProperties\\";
import { BaseObjectLikeSchema, ObjectLikeSchema } from \\"../object-like\\";
import { Property } from \\"./property\\";

export type ObjectSchema<Raw, Parsed> = BaseObjectSchema<Raw, Parsed> &
  ObjectLikeSchema<Raw, Parsed> &
  ObjectUtils<Raw, Parsed>;

export interface BaseObjectSchema<Raw, Parsed> extends BaseObjectLikeSchema<Raw, Parsed> {
  _getRawProperties: () => Promise<(keyof Raw)[]>;
  _getParsedProperties: () => Promise<(keyof Parsed)[]>;
}

export interface ObjectUtils<Raw, Parsed> {
  extend: <RawExtension, ParsedExtension>(
    schemas: ObjectSchema<RawExtension, ParsedExtension>
  ) => ObjectSchema<Raw & RawExtension, Parsed & ParsedExtension>;
}

export type inferRawObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<infer Raw, any> ? Raw : never;

export type inferParsedObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<any, infer Parsed>
  ? Parsed
  : never;

export type inferObjectSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> = ObjectSchema<
  inferRawObjectFromPropertySchemas<T>,
  inferParsedObjectFromPropertySchemas<T>
>;

export type inferRawObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
  addQuestionMarksToNullableProperties<{
    [ParsedKey in keyof T as inferRawKey<ParsedKey, T[ParsedKey]>]: inferRawPropertySchema<T[ParsedKey]>;
  }>;

export type inferParsedObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
  addQuestionMarksToNullableProperties<{
    [K in keyof T]: inferParsedPropertySchema<T[K]>;
  }>;

export type PropertySchemas<ParsedKeys extends string | number | symbol> = Record<
  ParsedKeys,
  Property<any, any, any> | Schema<any, any>
>;

export type inferRawPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
  any,
  infer Raw,
  any
>
  ? Raw
  : P extends Schema<any, any>
  ? inferRaw<P>
  : never;

export type inferParsedPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
  any,
  any,
  infer Parsed
>
  ? Parsed
  : P extends Schema<any, any>
  ? inferParsed<P>
  : never;

export type inferRawKey<
  ParsedKey extends string | number | symbol,
  P extends Property<any, any, any> | Schema<any, any>
> = P extends Property<infer Raw, any, any> ? Raw : ParsedKey;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { getSchemaUtils } from \\"../schema-utils\\";
import { BaseObjectLikeSchema, ObjectLikeSchema, ObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"./types\\";

export function getObjectLikeUtils<Raw, Parsed>(
  schema: BaseObjectLikeSchema<Raw, Parsed>
): ObjectLikeUtils<Raw, Parsed> {
  return {
    withProperties: (properties) => withProperties(schema, properties),
  };
}

/**
 * object-like utils are defined in one file to resolve issues with circular imports
 */

export function withProperties<RawObjectShape, ParsedObjectShape, Properties>(
  objectLike: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape>,
  properties: { [K in keyof Properties]: Properties[K] | ((parsed: ParsedObjectShape) => Properties[K]) }
): ObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> {
  const objectSchema: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> = {
    ...OBJECT_LIKE_BRAND,
    parse: async (raw, opts) => {
      const parsedObject = await objectLike.parse(raw, opts);
      const additionalProperties = Object.entries(properties).reduce<Record<string, any>>((processed, [key, value]) => {
        return {
          ...processed,
          [key]: typeof value === \\"function\\" ? value(parsedObject) : value,
        };
      }, {});

      return {
        ...parsedObject,
        ...(additionalProperties as Properties),
      };
    },
    json: (parsed, opts) => {
      // strip out added properties
      const addedPropertyKeys = new Set(Object.keys(properties));
      const parsedWithoutAddedProperties = Object.entries(parsed).reduce<Record<string, any>>(
        (filtered, [key, value]) => {
          if (!addedPropertyKeys.has(key)) {
            filtered[key] = value;
          }
          return filtered;
        },
        {}
      );

      return objectLike.json(parsedWithoutAddedProperties as ParsedObjectShape, opts);
    },
  };

  return {
    ...objectSchema,
    ...getSchemaUtils(objectSchema),
    ...getObjectLikeUtils(objectSchema),
  };
}
",
                        "name": "getObjectLikeUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getObjectLikeUtils, withProperties } from \\"./getObjectLikeUtils\\";
export { OBJECT_LIKE_BRAND, type BaseObjectLikeSchema, type ObjectLikeSchema, type ObjectLikeUtils } from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";

export type ObjectLikeSchema<Raw, Parsed> = Schema<Raw, Parsed> &
  BaseObjectLikeSchema<Raw, Parsed> &
  ObjectLikeUtils<Raw, Parsed>;

export type BaseObjectLikeSchema<Raw, Parsed> = BaseSchema<Raw, Parsed> & {
  _objectLike: void;
};

export interface ObjectLikeUtils<Raw, Parsed> {
  withProperties: <T extends Record<string, any>>(properties: {
    [K in keyof T]: T[K] | ((parsed: Parsed) => T[K]);
  }) => ObjectLikeSchema<Raw, Parsed & T>;
}

export const OBJECT_LIKE_BRAND = undefined as unknown as { _objectLike: void };
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object-like",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const any = createIdentitySchemaCreator<any>();
",
                        "name": "any.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const boolean = createIdentitySchemaCreator<boolean>();
",
                        "name": "boolean.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { any } from \\"./any\\";
export { boolean } from \\"./boolean\\";
export { number } from \\"./number\\";
export { string } from \\"./string\\";
export { unknown } from \\"./unknown\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const number = createIdentitySchemaCreator<number>();
",
                        "name": "number.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const string = createIdentitySchemaCreator<string>();
",
                        "name": "string.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const unknown = createIdentitySchemaCreator<unknown>();
",
                        "name": "unknown.ts",
                        "type": "file",
                      },
                    ],
                    "name": "primitives",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { record } from \\"./record\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function record<RawKey extends string | number, ParsedKey extends string | number, RawValue, ParsedValue>(
  keySchema: Schema<RawKey, ParsedKey>,
  valueSchema: Schema<RawValue, ParsedValue>
): Schema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> {
  const baseSchema: BaseSchema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> = {
    parse: (raw, opts) => {
      return entries(raw).reduce(async (parsedPromise, [key, value]) => {
        const parsed: Record<ParsedKey, ParsedValue> = await parsedPromise;
        const parsedKey = await keySchema.parse(key, opts);
        parsed[parsedKey] = await valueSchema.parse(value, opts);
        return parsedPromise;
      }, Promise.resolve({} as Record<ParsedKey, ParsedValue>));
    },
    json: (parsed, opts) => {
      return entries(parsed).reduce(async (rawPromise, [key, value]) => {
        const raw: Record<RawKey, RawValue> = await rawPromise;
        const rawKey = await keySchema.json(key, opts);
        raw[rawKey] = await valueSchema.json(value, opts);
        return rawPromise;
      }, Promise.resolve({} as Record<RawKey, RawValue>));
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "record.ts",
                        "type": "file",
                      },
                    ],
                    "name": "record",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { OptionalSchema, OPTIONAL_BRAND } from \\"./types\\";

export interface SchemaUtils<Raw, Parsed> {
  optional: () => OptionalSchema<Raw, Parsed>;
  transform: <PostTransform>(transformer: BaseSchema<Parsed, PostTransform>) => Schema<Raw, PostTransform>;
}

export function getSchemaUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): SchemaUtils<Raw, Parsed> {
  return {
    optional: () => optional(schema),
    transform: (transformer) => transform(schema, transformer),
  };
}

/**
 * schema utils are defined in one file to resolve issues with circular imports
 */

export function optional<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): OptionalSchema<Raw, Parsed> {
  const baseSchema: BaseSchema<Raw | null | undefined, Parsed | undefined> = {
    parse: (raw, opts) => (raw != null ? schema.parse(raw, opts) : undefined),
    json: (parsed, opts) => (parsed != null ? schema.json(parsed, opts) : undefined),
  };

  return {
    ...OPTIONAL_BRAND,
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function transform<PreTransformRaw, PreTransformParsed, PostTransform>(
  schema: BaseSchema<PreTransformRaw, PreTransformParsed>,
  transformer: BaseSchema<PreTransformParsed, PostTransform>
): Schema<PreTransformRaw, PostTransform> {
  const baseSchema: BaseSchema<PreTransformRaw, PostTransform> = {
    parse: async (raw, opts) => {
      const postTransformParsed = await schema.parse(raw, opts);
      return transformer.parse(postTransformParsed, opts);
    },
    json: async (parsed, opts) => {
      const preTransformParsed = await transformer.json(parsed, opts);
      return schema.json(preTransformParsed, opts);
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "getSchemaUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getSchemaUtils, optional, transform, type SchemaUtils } from \\"./getSchemaUtils\\";
export { OPTIONAL_BRAND, type OptionalSchema } from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export const OPTIONAL_BRAND = undefined as unknown as { _isOptional: void };

export type OptionalSchema<Raw, Parsed> = Schema<Raw | null | undefined, Parsed | undefined> & {
  _isOptional: void;
};
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "schema-utils",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { set } from \\"./set\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function set<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Set<Parsed>> {
  const baseSchema: BaseSchema<Raw[], Set<Parsed>> = {
    parse: async (raw, opts) => new Set(await Promise.all(raw.map((item) => schema.parse(item, opts)))),
    json: (parsed, opts) => Promise.all([...parsed].map((item) => schema.json(item, opts))),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "set.ts",
                        "type": "file",
                      },
                    ],
                    "name": "set",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export function discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string>(
  parsedDiscriminant: ParsedDiscriminant,
  rawDiscriminant: RawDiscriminant
): Discriminant<RawDiscriminant, ParsedDiscriminant> {
  return {
    parsedDiscriminant,
    rawDiscriminant,
  };
}

export interface Discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string> {
  parsedDiscriminant: ParsedDiscriminant;
  rawDiscriminant: RawDiscriminant;
}
",
                        "name": "discriminant.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { discriminant, type Discriminant } from \\"./discriminant\\";
export {
  type inferParsedDiscriminant,
  type inferParsedUnion,
  type inferRawDiscriminant,
  type inferRawUnion,
  type UnionSubtypes,
} from \\"./types\\";
export { union } from \\"./union\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsedObject, inferRawObject, ObjectSchema } from \\"../object\\";
import { Discriminant } from \\"./discriminant\\";

export type UnionSubtypes<DiscriminantValues extends string | number | symbol> = {
  [K in DiscriminantValues]: ObjectSchema<any, any>;
};

export type inferRawUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
  [K in keyof U]: Record<inferRawDiscriminant<D>, K> & inferRawObject<U[K]>;
}[keyof U];

export type inferParsedUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
  [K in keyof U]: Record<inferParsedDiscriminant<D>, K> & inferParsedObject<U[K]>;
}[keyof U];

export type inferRawDiscriminant<D extends string | Discriminant<any, any>> = D extends string
  ? D
  : D extends Discriminant<infer Raw, any>
  ? Raw
  : never;

export type inferParsedDiscriminant<D extends string | Discriminant<any, any>> = D extends string
  ? D
  : D extends Discriminant<any, infer Parsed>
  ? Parsed
  : never;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseObjectLikeSchema, getObjectLikeUtils, ObjectLikeSchema, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { Discriminant } from \\"./discriminant\\";
import { inferParsedDiscriminant, inferParsedUnion, inferRawDiscriminant, inferRawUnion, UnionSubtypes } from \\"./types\\";

export function union<D extends string | Discriminant<any, any>, U extends UnionSubtypes<any>>(
  discriminant: D,
  union: U
): ObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> {
  const rawDiscriminant =
    typeof discriminant === \\"string\\" ? discriminant : (discriminant.rawDiscriminant as inferRawDiscriminant<D>);
  const parsedDiscriminant =
    typeof discriminant === \\"string\\" ? discriminant : (discriminant.parsedDiscriminant as inferParsedDiscriminant<D>);

  const baseSchema: BaseObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> = {
    ...OBJECT_LIKE_BRAND,

    parse: async (raw, opts) => {
      const { [rawDiscriminant]: discriminantValue, ...additionalProperties } = raw;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [parsedDiscriminant]: discriminantValue,
        } as inferParsedUnion<D, U>;
      }

      return {
        ...(await additionalPropertySchemas.parse(additionalProperties, opts)),
        [parsedDiscriminant]: discriminantValue,
      } as inferParsedUnion<D, U>;
    },

    json: async (parsed, opts) => {
      const { [parsedDiscriminant]: discriminantValue, ...additionalProperties } = parsed;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [rawDiscriminant]: discriminantValue,
        } as unknown as inferRawUnion<D, U>;
      }

      return {
        ...(await additionalPropertySchemas.json(additionalProperties, opts)),
        [rawDiscriminant]: discriminantValue,
      } as inferRawUnion<D, U>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
  };
}
",
                        "name": "union.ts",
                        "type": "file",
                      },
                    ],
                    "name": "union",
                    "type": "directory",
                  },
                ],
                "name": "builders",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./builders\\";
export { type inferParsed, type inferRaw, type Schema, type SchemaOptions } from \\"./Schema\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export type addQuestionMarksToNullableProperties<T> = {
  [K in OptionalKeys<T>]?: undefined extends T[K] ? T[K] : never;
} & Pick<T, RequiredKeys<T>>;

export type OptionalKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? K : never;
}[keyof T];

export type RequiredKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? never : K;
}[keyof T];
",
                    "name": "addQuestionMarksToNullableProperties.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function entries<T>(object: T): [keyof T, T[keyof T]][] {
  return Object.entries(object) as [keyof T, T[keyof T]][];
}
",
                    "name": "entries.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function filterObject<T, K extends keyof T>(obj: T, keysToInclude: K[]): Pick<T, K> {
  const keysToIncludeSet = new Set(keysToInclude);
  return Object.entries(obj).reduce((acc, [key, value]) => {
    if (keysToIncludeSet.has(key as K)) {
      acc[key as K] = value;
    }
    return acc;
    // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
  }, {} as Pick<T, K>);
}
",
                    "name": "filterObject.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function keys<T>(object: T): (keyof T)[] {
  return Object.keys(object) as (keyof T)[];
}
",
                    "name": "keys.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function partition<T>(items: readonly T[], predicate: (item: T) => boolean): [T[], T[]] {
  const trueItems: T[] = [],
    falseItems: T[] = [];
  for (const item of items) {
    if (predicate(item)) {
      trueItems.push(item);
    } else {
      falseItems.push(item);
    }
  }
  return [trueItems, falseItems];
}
",
                    "name": "partition.ts",
                    "type": "file",
                  },
                ],
                "name": "utils",
                "type": "directory",
              },
            ],
            "name": "schemas",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export function addNonEnumerableProperty<T, K extends string, V>(object: T, key: K, value: V): T & Record<K, V> {
  const copy = { ...object };
  Object.defineProperty(copy, key, {
    enumerable: false,
    writable: true,
  });
  (copy as any)[key] = value;
  return copy as T & Record<K, V>;
}
",
                "name": "addNonEnumerableProperty.ts",
                "type": "file",
              },
              Object {
                "contents": "export { addNonEnumerableProperty } from \\"./addNonEnumerableProperty\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "utils",
            "type": "directory",
          },
        ],
        "name": "core",
        "type": "directory",
      },
      Object {
        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export const Environment = {
  Prod: \\"prod.trace.com\\",
  /**
   * i'm staging
   */
  Staging: \\"staging.trace.com\\",
} as const;

export type Environment = typeof Environment.Prod | typeof Environment.Staging;
",
        "name": "environments.ts",
        "type": "file",
      },
      Object {
        "contents": "export * as TraceApi from \\"./resources\\";
export { TraceApiClient } from \\"./Client\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    token?: core.Supplier<core.BearerToken>;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async updateTestSubmissionStatus(
    submissionId: TraceApi.SubmissionId,
    request: TraceApi.TestSubmissionStatus
  ): Promise<TraceApi.admin.updateTestSubmissionStatus.Response> {
    const _response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-test-submission-status/\${submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
      body: await serializers.admin.updateTestSubmissionStatus.Request.json(request),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: TraceApi.admin.updateTestSubmissionStatus.Error._unknown(_response.error),
    };
  }

  public async sendTestSubmissionUpdate(
    submissionId: TraceApi.SubmissionId,
    request: TraceApi.TestSubmissionUpdate
  ): Promise<TraceApi.admin.sendTestSubmissionUpdate.Response> {
    const _response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-test-submission-status-v2/\${submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
      body: await serializers.admin.sendTestSubmissionUpdate.Request.json(request),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: TraceApi.admin.sendTestSubmissionUpdate.Error._unknown(_response.error),
    };
  }

  public async updateWorkspaceSubmissionStatus(
    submissionId: TraceApi.SubmissionId,
    request: TraceApi.WorkspaceSubmissionStatus
  ): Promise<TraceApi.admin.updateWorkspaceSubmissionStatus.Response> {
    const _response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-workspace-submission-status/\${submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
      body: await serializers.admin.updateWorkspaceSubmissionStatus.Request.json(request),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: TraceApi.admin.updateWorkspaceSubmissionStatus.Error._unknown(_response.error),
    };
  }

  public async sendWorkspaceSubmissionUpdate(
    submissionId: TraceApi.SubmissionId,
    request: TraceApi.WorkspaceSubmissionUpdate
  ): Promise<TraceApi.admin.sendWorkspaceSubmissionUpdate.Response> {
    const _response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-workspace-submission-status-v2/\${submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
      body: await serializers.admin.sendWorkspaceSubmissionUpdate.Request.json(request),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: TraceApi.admin.sendWorkspaceSubmissionUpdate.Error._unknown(_response.error),
    };
  }

  public async storeTracedTestCase(
    submissionId: TraceApi.SubmissionId,
    testCaseId: string,
    request: TraceApi.StoreTracedTestCaseRequest
  ): Promise<TraceApi.admin.storeTracedTestCase.Response> {
    const _queryParams = new URLSearchParams();
    if (request.someQueryParam != null) {
      _queryParams.append(\\"some-query-param\\", request.someQueryParam);
    }

    const _response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-test-trace/submission/\${submissionId}/testCase/\${testCaseId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
      queryParameters: _queryParams,
      body: await serializers.admin.storeTracedTestCase.Request.json({
        result: request.result,
        traceResponses: request.traceResponses,
      }),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: TraceApi.admin.storeTracedTestCase.Error._unknown(_response.error),
    };
  }

  public async storeTracedTestCaseV2(
    submissionId: TraceApi.SubmissionId,
    testCaseId: TraceApi.v2.TestCaseId,
    request: TraceApi.TraceResponseV2[]
  ): Promise<TraceApi.admin.storeTracedTestCaseV2.Response> {
    const _response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-test-trace-v2/submission/\${submissionId}/testCase/\${testCaseId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
      body: await serializers.admin.storeTracedTestCaseV2.Request.json(request),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: TraceApi.admin.storeTracedTestCaseV2.Error._unknown(_response.error),
    };
  }

  public async storeTracedWorkspace(
    submissionId: TraceApi.SubmissionId,
    request: TraceApi.StoreTracedWorkspaceRequest
  ): Promise<TraceApi.admin.storeTracedWorkspace.Response> {
    const _response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-workspace-trace/submission/\${submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
      body: await serializers.admin.storeTracedWorkspace.Request.json({
        workspaceRunDetails: request.workspaceRunDetails,
        traceResponses: request.traceResponses,
      }),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: TraceApi.admin.storeTracedWorkspace.Error._unknown(_response.error),
    };
  }

  public async storeTracedWorkspaceV2(
    submissionId: TraceApi.SubmissionId,
    request: TraceApi.TraceResponseV2[]
  ): Promise<TraceApi.admin.storeTracedWorkspaceV2.Response> {
    const _response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-workspace-trace-v2/submission/\${submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
      body: await serializers.admin.storeTracedWorkspaceV2.Request.json(request),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: TraceApi.admin.storeTracedWorkspaceV2.Error._unknown(_response.error),
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as updateTestSubmissionStatus from \\"./updateTestSubmissionStatus\\";
export * as sendTestSubmissionUpdate from \\"./sendTestSubmissionUpdate\\";
export * as updateWorkspaceSubmissionStatus from \\"./updateWorkspaceSubmissionStatus\\";
export * as sendWorkspaceSubmissionUpdate from \\"./sendWorkspaceSubmissionUpdate\\";
export * as storeTracedTestCase from \\"./storeTracedTestCase\\";
export * from \\"./requests\\";
export * as storeTracedTestCaseV2 from \\"./storeTracedTestCaseV2\\";
export * as storeTracedWorkspace from \\"./storeTracedWorkspace\\";
export * as storeTracedWorkspaceV2 from \\"./storeTracedWorkspaceV2\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface StoreTracedTestCaseRequest {
  someQueryParam?: string;
  result: TraceApi.TestCaseResultWithStdout;
  traceResponses: TraceApi.TraceResponse[];
}
",
                        "name": "StoreTracedTestCaseRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface StoreTracedWorkspaceRequest {
  workspaceRunDetails: TraceApi.WorkspaceRunDetails;
  traceResponses: TraceApi.TraceResponse[];
}
",
                        "name": "StoreTracedWorkspaceRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { StoreTracedTestCaseRequest } from \\"./StoreTracedTestCaseRequest\\";
export { StoreTracedWorkspaceRequest } from \\"./StoreTracedWorkspaceRequest\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "requests",
                    "type": "directory",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, TraceApi.admin.sendTestSubmissionUpdate.Error>;
export type Error = TraceApi.admin.sendTestSubmissionUpdate.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.admin.sendTestSubmissionUpdate.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.admin.sendTestSubmissionUpdate.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.admin.sendTestSubmissionUpdate.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.admin.sendTestSubmissionUpdate.Error._Unknown, visitor: TraceApi.admin.sendTestSubmissionUpdate.Error._Visitor<_Result>) {
      return TraceApi.admin.sendTestSubmissionUpdate.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.admin.sendTestSubmissionUpdate.Error,
    visitor: TraceApi.admin.sendTestSubmissionUpdate.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "sendTestSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, TraceApi.admin.sendWorkspaceSubmissionUpdate.Error>;
export type Error = TraceApi.admin.sendWorkspaceSubmissionUpdate.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.admin.sendWorkspaceSubmissionUpdate.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.admin.sendWorkspaceSubmissionUpdate.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.admin.sendWorkspaceSubmissionUpdate.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.admin.sendWorkspaceSubmissionUpdate.Error._Unknown, visitor: TraceApi.admin.sendWorkspaceSubmissionUpdate.Error._Visitor<_Result>) {
      return TraceApi.admin.sendWorkspaceSubmissionUpdate.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.admin.sendWorkspaceSubmissionUpdate.Error,
    visitor: TraceApi.admin.sendWorkspaceSubmissionUpdate.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "sendWorkspaceSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, TraceApi.admin.storeTracedTestCase.Error>;
export type Error = TraceApi.admin.storeTracedTestCase.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.admin.storeTracedTestCase.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.admin.storeTracedTestCase.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.admin.storeTracedTestCase.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.admin.storeTracedTestCase.Error._Unknown, visitor: TraceApi.admin.storeTracedTestCase.Error._Visitor<_Result>) {
      return TraceApi.admin.storeTracedTestCase.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.admin.storeTracedTestCase.Error,
    visitor: TraceApi.admin.storeTracedTestCase.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "storeTracedTestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, TraceApi.admin.storeTracedTestCaseV2.Error>;
export type Error = TraceApi.admin.storeTracedTestCaseV2.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.admin.storeTracedTestCaseV2.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.admin.storeTracedTestCaseV2.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.admin.storeTracedTestCaseV2.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.admin.storeTracedTestCaseV2.Error._Unknown, visitor: TraceApi.admin.storeTracedTestCaseV2.Error._Visitor<_Result>) {
      return TraceApi.admin.storeTracedTestCaseV2.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.admin.storeTracedTestCaseV2.Error,
    visitor: TraceApi.admin.storeTracedTestCaseV2.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "storeTracedTestCaseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, TraceApi.admin.storeTracedWorkspace.Error>;
export type Error = TraceApi.admin.storeTracedWorkspace.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.admin.storeTracedWorkspace.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.admin.storeTracedWorkspace.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.admin.storeTracedWorkspace.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.admin.storeTracedWorkspace.Error._Unknown, visitor: TraceApi.admin.storeTracedWorkspace.Error._Visitor<_Result>) {
      return TraceApi.admin.storeTracedWorkspace.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.admin.storeTracedWorkspace.Error,
    visitor: TraceApi.admin.storeTracedWorkspace.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "storeTracedWorkspace.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, TraceApi.admin.storeTracedWorkspaceV2.Error>;
export type Error = TraceApi.admin.storeTracedWorkspaceV2.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.admin.storeTracedWorkspaceV2.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.admin.storeTracedWorkspaceV2.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.admin.storeTracedWorkspaceV2.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.admin.storeTracedWorkspaceV2.Error._Unknown, visitor: TraceApi.admin.storeTracedWorkspaceV2.Error._Visitor<_Result>) {
      return TraceApi.admin.storeTracedWorkspaceV2.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.admin.storeTracedWorkspaceV2.Error,
    visitor: TraceApi.admin.storeTracedWorkspaceV2.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "storeTracedWorkspaceV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, TraceApi.admin.updateTestSubmissionStatus.Error>;
export type Error = TraceApi.admin.updateTestSubmissionStatus.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.admin.updateTestSubmissionStatus.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.admin.updateTestSubmissionStatus.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.admin.updateTestSubmissionStatus.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.admin.updateTestSubmissionStatus.Error._Unknown, visitor: TraceApi.admin.updateTestSubmissionStatus.Error._Visitor<_Result>) {
      return TraceApi.admin.updateTestSubmissionStatus.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.admin.updateTestSubmissionStatus.Error,
    visitor: TraceApi.admin.updateTestSubmissionStatus.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "updateTestSubmissionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, TraceApi.admin.updateWorkspaceSubmissionStatus.Error>;
export type Error = TraceApi.admin.updateWorkspaceSubmissionStatus.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.admin.updateWorkspaceSubmissionStatus.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.admin.updateWorkspaceSubmissionStatus.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.admin.updateWorkspaceSubmissionStatus.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.admin.updateWorkspaceSubmissionStatus.Error._Unknown, visitor: TraceApi.admin.updateWorkspaceSubmissionStatus.Error._Visitor<_Result>) {
      return TraceApi.admin.updateWorkspaceSubmissionStatus.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.admin.updateWorkspaceSubmissionStatus.Error,
    visitor: TraceApi.admin.updateWorkspaceSubmissionStatus.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "updateWorkspaceSubmissionStatus.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "admin",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface BinaryTreeNodeAndTreeValue {
  nodeId: TraceApi.NodeId;
  fullTree: TraceApi.BinaryTreeValue;
}
",
                    "name": "BinaryTreeNodeAndTreeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface BinaryTreeNodeValue {
  nodeId: TraceApi.NodeId;
  val: number;
  right?: TraceApi.NodeId;
  left?: TraceApi.NodeId;
}
",
                    "name": "BinaryTreeNodeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface BinaryTreeValue {
  root?: TraceApi.NodeId;
  nodes: Record<TraceApi.NodeId, TraceApi.BinaryTreeNodeValue>;
}
",
                    "name": "BinaryTreeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface DebugKeyValuePairs {
  key: TraceApi.DebugVariableValue;
  value: TraceApi.DebugVariableValue;
}
",
                    "name": "DebugKeyValuePairs.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface DebugMapValue {
  keyValuePairs: TraceApi.DebugKeyValuePairs[];
}
",
                    "name": "DebugMapValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type DebugVariableValue =
  | TraceApi.DebugVariableValue.IntegerValue
  | TraceApi.DebugVariableValue.BooleanValue
  | TraceApi.DebugVariableValue.DoubleValue
  | TraceApi.DebugVariableValue.StringValue
  | TraceApi.DebugVariableValue.CharValue
  | TraceApi.DebugVariableValue.MapValue
  | TraceApi.DebugVariableValue.ListValue
  | TraceApi.DebugVariableValue.BinaryTreeNodeValue
  | TraceApi.DebugVariableValue.SinglyLinkedListNodeValue
  | TraceApi.DebugVariableValue.DoublyLinkedListNodeValue
  | TraceApi.DebugVariableValue.UndefinedValue
  | TraceApi.DebugVariableValue.NullValue
  | TraceApi.DebugVariableValue.GenericValue
  | TraceApi.DebugVariableValue._Unknown;

export declare namespace DebugVariableValue {
  interface IntegerValue extends _Utils {
    type: \\"integerValue\\";
    value: number;
  }

  interface BooleanValue extends _Utils {
    type: \\"booleanValue\\";
    value: boolean;
  }

  interface DoubleValue extends _Utils {
    type: \\"doubleValue\\";
    value: number;
  }

  interface StringValue extends _Utils {
    type: \\"stringValue\\";
    value: string;
  }

  interface CharValue extends _Utils {
    type: \\"charValue\\";
    value: string;
  }

  interface MapValue extends TraceApi.DebugMapValue, _Utils {
    type: \\"mapValue\\";
  }

  interface ListValue extends _Utils {
    type: \\"listValue\\";
    value: TraceApi.DebugVariableValue[];
  }

  interface BinaryTreeNodeValue extends TraceApi.BinaryTreeNodeAndTreeValue, _Utils {
    type: \\"binaryTreeNodeValue\\";
  }

  interface SinglyLinkedListNodeValue extends TraceApi.SinglyLinkedListNodeAndListValue, _Utils {
    type: \\"singlyLinkedListNodeValue\\";
  }

  interface DoublyLinkedListNodeValue extends TraceApi.DoublyLinkedListNodeAndListValue, _Utils {
    type: \\"doublyLinkedListNodeValue\\";
  }

  interface UndefinedValue extends _Utils {
    type: \\"undefinedValue\\";
  }

  interface NullValue extends _Utils {
    type: \\"nullValue\\";
  }

  interface GenericValue extends TraceApi.GenericValue, _Utils {
    type: \\"genericValue\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.DebugVariableValue._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    integerValue: (value: number) => _Result;
    booleanValue: (value: boolean) => _Result;
    doubleValue: (value: number) => _Result;
    stringValue: (value: string) => _Result;
    charValue: (value: string) => _Result;
    mapValue: (value: TraceApi.DebugMapValue) => _Result;
    listValue: (value: TraceApi.DebugVariableValue[]) => _Result;
    binaryTreeNodeValue: (value: TraceApi.BinaryTreeNodeAndTreeValue) => _Result;
    singlyLinkedListNodeValue: (value: TraceApi.SinglyLinkedListNodeAndListValue) => _Result;
    doublyLinkedListNodeValue: (value: TraceApi.DoublyLinkedListNodeAndListValue) => _Result;
    undefinedValue: () => _Result;
    nullValue: () => _Result;
    genericValue: (value: TraceApi.GenericValue) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const DebugVariableValue = {
  integerValue: (value: number): TraceApi.DebugVariableValue.IntegerValue => {
    const valueWithoutVisit: Omit<TraceApi.DebugVariableValue.IntegerValue, \\"_visit\\"> = {
      value: value,
      type: \\"integerValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.DebugVariableValue.IntegerValue, visitor: TraceApi.DebugVariableValue._Visitor<_Result>) {
      return TraceApi.DebugVariableValue._visit(this, visitor);
    });
  },

  booleanValue: (value: boolean): TraceApi.DebugVariableValue.BooleanValue => {
    const valueWithoutVisit: Omit<TraceApi.DebugVariableValue.BooleanValue, \\"_visit\\"> = {
      value: value,
      type: \\"booleanValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.DebugVariableValue.BooleanValue, visitor: TraceApi.DebugVariableValue._Visitor<_Result>) {
      return TraceApi.DebugVariableValue._visit(this, visitor);
    });
  },

  doubleValue: (value: number): TraceApi.DebugVariableValue.DoubleValue => {
    const valueWithoutVisit: Omit<TraceApi.DebugVariableValue.DoubleValue, \\"_visit\\"> = {
      value: value,
      type: \\"doubleValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.DebugVariableValue.DoubleValue, visitor: TraceApi.DebugVariableValue._Visitor<_Result>) {
      return TraceApi.DebugVariableValue._visit(this, visitor);
    });
  },

  stringValue: (value: string): TraceApi.DebugVariableValue.StringValue => {
    const valueWithoutVisit: Omit<TraceApi.DebugVariableValue.StringValue, \\"_visit\\"> = {
      value: value,
      type: \\"stringValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.DebugVariableValue.StringValue, visitor: TraceApi.DebugVariableValue._Visitor<_Result>) {
      return TraceApi.DebugVariableValue._visit(this, visitor);
    });
  },

  charValue: (value: string): TraceApi.DebugVariableValue.CharValue => {
    const valueWithoutVisit: Omit<TraceApi.DebugVariableValue.CharValue, \\"_visit\\"> = {
      value: value,
      type: \\"charValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.DebugVariableValue.CharValue, visitor: TraceApi.DebugVariableValue._Visitor<_Result>) {
      return TraceApi.DebugVariableValue._visit(this, visitor);
    });
  },

  mapValue: (value: TraceApi.DebugMapValue): TraceApi.DebugVariableValue.MapValue => {
    const valueWithoutVisit: Omit<TraceApi.DebugVariableValue.MapValue, \\"_visit\\"> = {
      ...value,
      type: \\"mapValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.DebugVariableValue.MapValue, visitor: TraceApi.DebugVariableValue._Visitor<_Result>) {
      return TraceApi.DebugVariableValue._visit(this, visitor);
    });
  },

  listValue: (value: TraceApi.DebugVariableValue[]): TraceApi.DebugVariableValue.ListValue => {
    const valueWithoutVisit: Omit<TraceApi.DebugVariableValue.ListValue, \\"_visit\\"> = {
      value: value,
      type: \\"listValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.DebugVariableValue.ListValue, visitor: TraceApi.DebugVariableValue._Visitor<_Result>) {
      return TraceApi.DebugVariableValue._visit(this, visitor);
    });
  },

  binaryTreeNodeValue: (
    value: TraceApi.BinaryTreeNodeAndTreeValue
  ): TraceApi.DebugVariableValue.BinaryTreeNodeValue => {
    const valueWithoutVisit: Omit<TraceApi.DebugVariableValue.BinaryTreeNodeValue, \\"_visit\\"> = {
      ...value,
      type: \\"binaryTreeNodeValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.DebugVariableValue.BinaryTreeNodeValue, visitor: TraceApi.DebugVariableValue._Visitor<_Result>) {
      return TraceApi.DebugVariableValue._visit(this, visitor);
    });
  },

  singlyLinkedListNodeValue: (
    value: TraceApi.SinglyLinkedListNodeAndListValue
  ): TraceApi.DebugVariableValue.SinglyLinkedListNodeValue => {
    const valueWithoutVisit: Omit<TraceApi.DebugVariableValue.SinglyLinkedListNodeValue, \\"_visit\\"> = {
      ...value,
      type: \\"singlyLinkedListNodeValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.DebugVariableValue.SinglyLinkedListNodeValue, visitor: TraceApi.DebugVariableValue._Visitor<_Result>) {
      return TraceApi.DebugVariableValue._visit(this, visitor);
    });
  },

  doublyLinkedListNodeValue: (
    value: TraceApi.DoublyLinkedListNodeAndListValue
  ): TraceApi.DebugVariableValue.DoublyLinkedListNodeValue => {
    const valueWithoutVisit: Omit<TraceApi.DebugVariableValue.DoublyLinkedListNodeValue, \\"_visit\\"> = {
      ...value,
      type: \\"doublyLinkedListNodeValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.DebugVariableValue.DoublyLinkedListNodeValue, visitor: TraceApi.DebugVariableValue._Visitor<_Result>) {
      return TraceApi.DebugVariableValue._visit(this, visitor);
    });
  },

  undefinedValue: (): TraceApi.DebugVariableValue.UndefinedValue => {
    const valueWithoutVisit: Omit<TraceApi.DebugVariableValue.UndefinedValue, \\"_visit\\"> = {
      type: \\"undefinedValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.DebugVariableValue.UndefinedValue, visitor: TraceApi.DebugVariableValue._Visitor<_Result>) {
      return TraceApi.DebugVariableValue._visit(this, visitor);
    });
  },

  nullValue: (): TraceApi.DebugVariableValue.NullValue => {
    const valueWithoutVisit: Omit<TraceApi.DebugVariableValue.NullValue, \\"_visit\\"> = {
      type: \\"nullValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.DebugVariableValue.NullValue, visitor: TraceApi.DebugVariableValue._Visitor<_Result>) {
      return TraceApi.DebugVariableValue._visit(this, visitor);
    });
  },

  genericValue: (value: TraceApi.GenericValue): TraceApi.DebugVariableValue.GenericValue => {
    const valueWithoutVisit: Omit<TraceApi.DebugVariableValue.GenericValue, \\"_visit\\"> = {
      ...value,
      type: \\"genericValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.DebugVariableValue.GenericValue, visitor: TraceApi.DebugVariableValue._Visitor<_Result>) {
      return TraceApi.DebugVariableValue._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.DebugVariableValue._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.DebugVariableValue._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.DebugVariableValue._Unknown, visitor: TraceApi.DebugVariableValue._Visitor<_Result>) {
      return TraceApi.DebugVariableValue._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.DebugVariableValue,
    visitor: TraceApi.DebugVariableValue._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"integerValue\\":
        return visitor.integerValue(value.value);
      case \\"booleanValue\\":
        return visitor.booleanValue(value.value);
      case \\"doubleValue\\":
        return visitor.doubleValue(value.value);
      case \\"stringValue\\":
        return visitor.stringValue(value.value);
      case \\"charValue\\":
        return visitor.charValue(value.value);
      case \\"mapValue\\":
        return visitor.mapValue(value);
      case \\"listValue\\":
        return visitor.listValue(value.value);
      case \\"binaryTreeNodeValue\\":
        return visitor.binaryTreeNodeValue(value);
      case \\"singlyLinkedListNodeValue\\":
        return visitor.singlyLinkedListNodeValue(value);
      case \\"doublyLinkedListNodeValue\\":
        return visitor.doublyLinkedListNodeValue(value);
      case \\"undefinedValue\\":
        return visitor.undefinedValue();
      case \\"nullValue\\":
        return visitor.nullValue();
      case \\"genericValue\\":
        return visitor.genericValue(value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "DebugVariableValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface DoublyLinkedListNodeAndListValue {
  nodeId: TraceApi.NodeId;
  fullList: TraceApi.DoublyLinkedListValue;
}
",
                    "name": "DoublyLinkedListNodeAndListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface DoublyLinkedListNodeValue {
  nodeId: TraceApi.NodeId;
  val: number;
  next?: TraceApi.NodeId;
  prev?: TraceApi.NodeId;
}
",
                    "name": "DoublyLinkedListNodeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface DoublyLinkedListValue {
  head?: TraceApi.NodeId;
  nodes: Record<TraceApi.NodeId, TraceApi.DoublyLinkedListNodeValue>;
}
",
                    "name": "DoublyLinkedListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface FileInfo {
  filename: string;
  contents: string;
}
",
                    "name": "FileInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface GenericValue {
  stringifiedType?: string;
  stringifiedValue: string;
}
",
                    "name": "GenericValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface KeyValuePair {
  key: TraceApi.VariableValue;
  value: TraceApi.VariableValue;
}
",
                    "name": "KeyValuePair.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     TraceApi.Language.Java
 */
export type Language = \\"JAVA\\" | \\"JAVASCRIPT\\" | \\"PYTHON\\";

export const Language = {
  Java: \\"JAVA\\",
  Javascript: \\"JAVASCRIPT\\",
  Python: \\"PYTHON\\",
} as const;
",
                    "name": "Language.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface ListType {
  valueType: TraceApi.VariableType;
  /** Whether this list is fixed-size (for languages that supports fixed-size lists). Defaults to false. */
  isFixedLength?: boolean;
}
",
                    "name": "ListType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface MapType {
  keyType: TraceApi.VariableType;
  valueType: TraceApi.VariableType;
}
",
                    "name": "MapType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface MapValue {
  keyValuePairs: TraceApi.KeyValuePair[];
}
",
                    "name": "MapValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type NodeId = string & {
  NodeId: void;
};

export function NodeId(value: string): TraceApi.NodeId {
  return value as unknown as TraceApi.NodeId;
}
",
                    "name": "NodeId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type ProblemId = string & {
  ProblemId: void;
};

export function ProblemId(value: string): TraceApi.ProblemId {
  return value as unknown as TraceApi.ProblemId;
}
",
                    "name": "ProblemId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * @example
 *     {
 *         \\"foo\\": \\"hello\\",
 *         \\"bar\\": {
 *             \\"yo\\": 123
 *         }
 *     }
 */
export type RandomUnknownType = unknown;
",
                    "name": "RandomUnknownType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface SinglyLinkedListNodeAndListValue {
  nodeId: TraceApi.NodeId;
  fullList: TraceApi.SinglyLinkedListValue;
}
",
                    "name": "SinglyLinkedListNodeAndListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface SinglyLinkedListNodeValue {
  nodeId: TraceApi.NodeId;
  val: number;
  next?: TraceApi.NodeId;
}
",
                    "name": "SinglyLinkedListNodeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface SinglyLinkedListValue {
  head?: TraceApi.NodeId;
  nodes: Record<TraceApi.NodeId, TraceApi.SinglyLinkedListNodeValue>;
}
",
                    "name": "SinglyLinkedListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCase {
  id: string;
  params: TraceApi.VariableValue[];
}
",
                    "name": "TestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseWithExpectedResult {
  testCase: TraceApi.TestCase;
  expectedResult: TraceApi.VariableValue;
}
",
                    "name": "TestCaseWithExpectedResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

/**
 * @example
 *     TraceApi.UserId(\\"user12345\\")
 */
export type UserId = string & {
  UserId: void;
};

export function UserId(value: string): TraceApi.UserId {
  return value as unknown as TraceApi.UserId;
}
",
                    "name": "UserId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type VariableType =
  | TraceApi.VariableType.IntegerType
  | TraceApi.VariableType.DoubleType
  | TraceApi.VariableType.BooleanType
  | TraceApi.VariableType.StringType
  | TraceApi.VariableType.CharType
  | TraceApi.VariableType.ListType
  | TraceApi.VariableType.MapType
  | TraceApi.VariableType.BinaryTreeType
  | TraceApi.VariableType.SinglyLinkedListType
  | TraceApi.VariableType.DoublyLinkedListType
  | TraceApi.VariableType._Unknown;

export declare namespace VariableType {
  interface IntegerType extends _Utils {
    type: \\"integerType\\";
  }

  interface DoubleType extends _Utils {
    type: \\"doubleType\\";
  }

  interface BooleanType extends _Utils {
    type: \\"booleanType\\";
  }

  interface StringType extends _Utils {
    type: \\"stringType\\";
  }

  interface CharType extends _Utils {
    type: \\"charType\\";
  }

  interface ListType extends TraceApi.ListType, _Utils {
    type: \\"listType\\";
  }

  interface MapType extends TraceApi.MapType, _Utils {
    type: \\"mapType\\";
  }

  interface BinaryTreeType extends _Utils {
    type: \\"binaryTreeType\\";
  }

  interface SinglyLinkedListType extends _Utils {
    type: \\"singlyLinkedListType\\";
  }

  interface DoublyLinkedListType extends _Utils {
    type: \\"doublyLinkedListType\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.VariableType._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    integerType: () => _Result;
    doubleType: () => _Result;
    booleanType: () => _Result;
    stringType: () => _Result;
    charType: () => _Result;
    listType: (value: TraceApi.ListType) => _Result;
    mapType: (value: TraceApi.MapType) => _Result;
    binaryTreeType: () => _Result;
    singlyLinkedListType: () => _Result;
    doublyLinkedListType: () => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const VariableType = {
  integerType: (): TraceApi.VariableType.IntegerType => {
    const valueWithoutVisit: Omit<TraceApi.VariableType.IntegerType, \\"_visit\\"> = {
      type: \\"integerType\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableType.IntegerType, visitor: TraceApi.VariableType._Visitor<_Result>) {
      return TraceApi.VariableType._visit(this, visitor);
    });
  },

  doubleType: (): TraceApi.VariableType.DoubleType => {
    const valueWithoutVisit: Omit<TraceApi.VariableType.DoubleType, \\"_visit\\"> = {
      type: \\"doubleType\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableType.DoubleType, visitor: TraceApi.VariableType._Visitor<_Result>) {
      return TraceApi.VariableType._visit(this, visitor);
    });
  },

  booleanType: (): TraceApi.VariableType.BooleanType => {
    const valueWithoutVisit: Omit<TraceApi.VariableType.BooleanType, \\"_visit\\"> = {
      type: \\"booleanType\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableType.BooleanType, visitor: TraceApi.VariableType._Visitor<_Result>) {
      return TraceApi.VariableType._visit(this, visitor);
    });
  },

  stringType: (): TraceApi.VariableType.StringType => {
    const valueWithoutVisit: Omit<TraceApi.VariableType.StringType, \\"_visit\\"> = {
      type: \\"stringType\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableType.StringType, visitor: TraceApi.VariableType._Visitor<_Result>) {
      return TraceApi.VariableType._visit(this, visitor);
    });
  },

  charType: (): TraceApi.VariableType.CharType => {
    const valueWithoutVisit: Omit<TraceApi.VariableType.CharType, \\"_visit\\"> = {
      type: \\"charType\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableType.CharType, visitor: TraceApi.VariableType._Visitor<_Result>) {
      return TraceApi.VariableType._visit(this, visitor);
    });
  },

  listType: (value: TraceApi.ListType): TraceApi.VariableType.ListType => {
    const valueWithoutVisit: Omit<TraceApi.VariableType.ListType, \\"_visit\\"> = {
      ...value,
      type: \\"listType\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableType.ListType, visitor: TraceApi.VariableType._Visitor<_Result>) {
      return TraceApi.VariableType._visit(this, visitor);
    });
  },

  mapType: (value: TraceApi.MapType): TraceApi.VariableType.MapType => {
    const valueWithoutVisit: Omit<TraceApi.VariableType.MapType, \\"_visit\\"> = {
      ...value,
      type: \\"mapType\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableType.MapType, visitor: TraceApi.VariableType._Visitor<_Result>) {
      return TraceApi.VariableType._visit(this, visitor);
    });
  },

  binaryTreeType: (): TraceApi.VariableType.BinaryTreeType => {
    const valueWithoutVisit: Omit<TraceApi.VariableType.BinaryTreeType, \\"_visit\\"> = {
      type: \\"binaryTreeType\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableType.BinaryTreeType, visitor: TraceApi.VariableType._Visitor<_Result>) {
      return TraceApi.VariableType._visit(this, visitor);
    });
  },

  singlyLinkedListType: (): TraceApi.VariableType.SinglyLinkedListType => {
    const valueWithoutVisit: Omit<TraceApi.VariableType.SinglyLinkedListType, \\"_visit\\"> = {
      type: \\"singlyLinkedListType\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableType.SinglyLinkedListType, visitor: TraceApi.VariableType._Visitor<_Result>) {
      return TraceApi.VariableType._visit(this, visitor);
    });
  },

  doublyLinkedListType: (): TraceApi.VariableType.DoublyLinkedListType => {
    const valueWithoutVisit: Omit<TraceApi.VariableType.DoublyLinkedListType, \\"_visit\\"> = {
      type: \\"doublyLinkedListType\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableType.DoublyLinkedListType, visitor: TraceApi.VariableType._Visitor<_Result>) {
      return TraceApi.VariableType._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.VariableType._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.VariableType._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableType._Unknown, visitor: TraceApi.VariableType._Visitor<_Result>) {
      return TraceApi.VariableType._visit(this, visitor);
    });
  },

  _visit: <_Result>(value: TraceApi.VariableType, visitor: TraceApi.VariableType._Visitor<_Result>): _Result => {
    switch (value.type) {
      case \\"integerType\\":
        return visitor.integerType();
      case \\"doubleType\\":
        return visitor.doubleType();
      case \\"booleanType\\":
        return visitor.booleanType();
      case \\"stringType\\":
        return visitor.stringType();
      case \\"charType\\":
        return visitor.charType();
      case \\"listType\\":
        return visitor.listType(value);
      case \\"mapType\\":
        return visitor.mapType(value);
      case \\"binaryTreeType\\":
        return visitor.binaryTreeType();
      case \\"singlyLinkedListType\\":
        return visitor.singlyLinkedListType();
      case \\"doublyLinkedListType\\":
        return visitor.doublyLinkedListType();
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "VariableType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type VariableValue =
  | TraceApi.VariableValue.IntegerValue
  | TraceApi.VariableValue.BooleanValue
  | TraceApi.VariableValue.DoubleValue
  | TraceApi.VariableValue.StringValue
  | TraceApi.VariableValue.CharValue
  | TraceApi.VariableValue.MapValue
  | TraceApi.VariableValue.ListValue
  | TraceApi.VariableValue.BinaryTreeValue
  | TraceApi.VariableValue.SinglyLinkedListValue
  | TraceApi.VariableValue.DoublyLinkedListValue
  | TraceApi.VariableValue.NullValue
  | TraceApi.VariableValue._Unknown;

export declare namespace VariableValue {
  interface IntegerValue extends _Utils {
    type: \\"integerValue\\";
    value: number;
  }

  interface BooleanValue extends _Utils {
    type: \\"booleanValue\\";
    value: boolean;
  }

  interface DoubleValue extends _Utils {
    type: \\"doubleValue\\";
    value: number;
  }

  interface StringValue extends _Utils {
    type: \\"stringValue\\";
    value: string;
  }

  interface CharValue extends _Utils {
    type: \\"charValue\\";
    value: string;
  }

  interface MapValue extends TraceApi.MapValue, _Utils {
    type: \\"mapValue\\";
  }

  interface ListValue extends _Utils {
    type: \\"listValue\\";
    value: TraceApi.VariableValue[];
  }

  interface BinaryTreeValue extends TraceApi.BinaryTreeValue, _Utils {
    type: \\"binaryTreeValue\\";
  }

  interface SinglyLinkedListValue extends TraceApi.SinglyLinkedListValue, _Utils {
    type: \\"singlyLinkedListValue\\";
  }

  interface DoublyLinkedListValue extends TraceApi.DoublyLinkedListValue, _Utils {
    type: \\"doublyLinkedListValue\\";
  }

  interface NullValue extends _Utils {
    type: \\"nullValue\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.VariableValue._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    integerValue: (value: number) => _Result;
    booleanValue: (value: boolean) => _Result;
    doubleValue: (value: number) => _Result;
    stringValue: (value: string) => _Result;
    charValue: (value: string) => _Result;
    mapValue: (value: TraceApi.MapValue) => _Result;
    listValue: (value: TraceApi.VariableValue[]) => _Result;
    binaryTreeValue: (value: TraceApi.BinaryTreeValue) => _Result;
    singlyLinkedListValue: (value: TraceApi.SinglyLinkedListValue) => _Result;
    doublyLinkedListValue: (value: TraceApi.DoublyLinkedListValue) => _Result;
    nullValue: () => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const VariableValue = {
  integerValue: (value: number): TraceApi.VariableValue.IntegerValue => {
    const valueWithoutVisit: Omit<TraceApi.VariableValue.IntegerValue, \\"_visit\\"> = {
      value: value,
      type: \\"integerValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableValue.IntegerValue, visitor: TraceApi.VariableValue._Visitor<_Result>) {
      return TraceApi.VariableValue._visit(this, visitor);
    });
  },

  booleanValue: (value: boolean): TraceApi.VariableValue.BooleanValue => {
    const valueWithoutVisit: Omit<TraceApi.VariableValue.BooleanValue, \\"_visit\\"> = {
      value: value,
      type: \\"booleanValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableValue.BooleanValue, visitor: TraceApi.VariableValue._Visitor<_Result>) {
      return TraceApi.VariableValue._visit(this, visitor);
    });
  },

  doubleValue: (value: number): TraceApi.VariableValue.DoubleValue => {
    const valueWithoutVisit: Omit<TraceApi.VariableValue.DoubleValue, \\"_visit\\"> = {
      value: value,
      type: \\"doubleValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableValue.DoubleValue, visitor: TraceApi.VariableValue._Visitor<_Result>) {
      return TraceApi.VariableValue._visit(this, visitor);
    });
  },

  stringValue: (value: string): TraceApi.VariableValue.StringValue => {
    const valueWithoutVisit: Omit<TraceApi.VariableValue.StringValue, \\"_visit\\"> = {
      value: value,
      type: \\"stringValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableValue.StringValue, visitor: TraceApi.VariableValue._Visitor<_Result>) {
      return TraceApi.VariableValue._visit(this, visitor);
    });
  },

  charValue: (value: string): TraceApi.VariableValue.CharValue => {
    const valueWithoutVisit: Omit<TraceApi.VariableValue.CharValue, \\"_visit\\"> = {
      value: value,
      type: \\"charValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableValue.CharValue, visitor: TraceApi.VariableValue._Visitor<_Result>) {
      return TraceApi.VariableValue._visit(this, visitor);
    });
  },

  mapValue: (value: TraceApi.MapValue): TraceApi.VariableValue.MapValue => {
    const valueWithoutVisit: Omit<TraceApi.VariableValue.MapValue, \\"_visit\\"> = {
      ...value,
      type: \\"mapValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableValue.MapValue, visitor: TraceApi.VariableValue._Visitor<_Result>) {
      return TraceApi.VariableValue._visit(this, visitor);
    });
  },

  listValue: (value: TraceApi.VariableValue[]): TraceApi.VariableValue.ListValue => {
    const valueWithoutVisit: Omit<TraceApi.VariableValue.ListValue, \\"_visit\\"> = {
      value: value,
      type: \\"listValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableValue.ListValue, visitor: TraceApi.VariableValue._Visitor<_Result>) {
      return TraceApi.VariableValue._visit(this, visitor);
    });
  },

  binaryTreeValue: (value: TraceApi.BinaryTreeValue): TraceApi.VariableValue.BinaryTreeValue => {
    const valueWithoutVisit: Omit<TraceApi.VariableValue.BinaryTreeValue, \\"_visit\\"> = {
      ...value,
      type: \\"binaryTreeValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableValue.BinaryTreeValue, visitor: TraceApi.VariableValue._Visitor<_Result>) {
      return TraceApi.VariableValue._visit(this, visitor);
    });
  },

  singlyLinkedListValue: (value: TraceApi.SinglyLinkedListValue): TraceApi.VariableValue.SinglyLinkedListValue => {
    const valueWithoutVisit: Omit<TraceApi.VariableValue.SinglyLinkedListValue, \\"_visit\\"> = {
      ...value,
      type: \\"singlyLinkedListValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableValue.SinglyLinkedListValue, visitor: TraceApi.VariableValue._Visitor<_Result>) {
      return TraceApi.VariableValue._visit(this, visitor);
    });
  },

  doublyLinkedListValue: (value: TraceApi.DoublyLinkedListValue): TraceApi.VariableValue.DoublyLinkedListValue => {
    const valueWithoutVisit: Omit<TraceApi.VariableValue.DoublyLinkedListValue, \\"_visit\\"> = {
      ...value,
      type: \\"doublyLinkedListValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableValue.DoublyLinkedListValue, visitor: TraceApi.VariableValue._Visitor<_Result>) {
      return TraceApi.VariableValue._visit(this, visitor);
    });
  },

  nullValue: (): TraceApi.VariableValue.NullValue => {
    const valueWithoutVisit: Omit<TraceApi.VariableValue.NullValue, \\"_visit\\"> = {
      type: \\"nullValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableValue.NullValue, visitor: TraceApi.VariableValue._Visitor<_Result>) {
      return TraceApi.VariableValue._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.VariableValue._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.VariableValue._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableValue._Unknown, visitor: TraceApi.VariableValue._Visitor<_Result>) {
      return TraceApi.VariableValue._visit(this, visitor);
    });
  },

  _visit: <_Result>(value: TraceApi.VariableValue, visitor: TraceApi.VariableValue._Visitor<_Result>): _Result => {
    switch (value.type) {
      case \\"integerValue\\":
        return visitor.integerValue(value.value);
      case \\"booleanValue\\":
        return visitor.booleanValue(value.value);
      case \\"doubleValue\\":
        return visitor.doubleValue(value.value);
      case \\"stringValue\\":
        return visitor.stringValue(value.value);
      case \\"charValue\\":
        return visitor.charValue(value.value);
      case \\"mapValue\\":
        return visitor.mapValue(value);
      case \\"listValue\\":
        return visitor.listValue(value.value);
      case \\"binaryTreeValue\\":
        return visitor.binaryTreeValue(value);
      case \\"singlyLinkedListValue\\":
        return visitor.singlyLinkedListValue(value);
      case \\"doublyLinkedListValue\\":
        return visitor.doublyLinkedListValue(value);
      case \\"nullValue\\":
        return visitor.nullValue();
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "VariableValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./UserId\\";
export * from \\"./ProblemId\\";
export * from \\"./NodeId\\";
export * from \\"./VariableType\\";
export * from \\"./ListType\\";
export * from \\"./MapType\\";
export * from \\"./VariableValue\\";
export * from \\"./DebugVariableValue\\";
export * from \\"./GenericValue\\";
export * from \\"./MapValue\\";
export * from \\"./KeyValuePair\\";
export * from \\"./BinaryTreeValue\\";
export * from \\"./BinaryTreeNodeValue\\";
export * from \\"./BinaryTreeNodeAndTreeValue\\";
export * from \\"./SinglyLinkedListValue\\";
export * from \\"./SinglyLinkedListNodeValue\\";
export * from \\"./SinglyLinkedListNodeAndListValue\\";
export * from \\"./DoublyLinkedListValue\\";
export * from \\"./DoublyLinkedListNodeValue\\";
export * from \\"./DoublyLinkedListNodeAndListValue\\";
export * from \\"./DebugMapValue\\";
export * from \\"./DebugKeyValuePairs\\";
export * from \\"./TestCase\\";
export * from \\"./TestCaseWithExpectedResult\\";
export * from \\"./FileInfo\\";
export * from \\"./Language\\";
export * from \\"./RandomUnknownType\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "commons",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    token?: core.Supplier<core.BearerToken>;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async getHomepageProblems(): Promise<TraceApi.homepage.getHomepageProblems.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/homepage-problems/\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.homepage.getHomepageProblems.Response.parse(
          _response.body as serializers.homepage.getHomepageProblems.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.homepage.getHomepageProblems.Error._unknown(_response.error),
    };
  }

  public async setHomepageProblems(
    request: TraceApi.ProblemId[]
  ): Promise<TraceApi.homepage.setHomepageProblems.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/homepage-problems/\\"),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
      body: await serializers.homepage.setHomepageProblems.Request.json(request),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: TraceApi.homepage.setHomepageProblems.Error._unknown(_response.error),
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<TraceApi.ProblemId[], TraceApi.homepage.getHomepageProblems.Error>;
export type Error = TraceApi.homepage.getHomepageProblems.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.homepage.getHomepageProblems.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.homepage.getHomepageProblems.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.homepage.getHomepageProblems.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.homepage.getHomepageProblems.Error._Unknown, visitor: TraceApi.homepage.getHomepageProblems.Error._Visitor<_Result>) {
      return TraceApi.homepage.getHomepageProblems.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.homepage.getHomepageProblems.Error,
    visitor: TraceApi.homepage.getHomepageProblems.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "getHomepageProblems.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getHomepageProblems from \\"./getHomepageProblems\\";
export * as setHomepageProblems from \\"./setHomepageProblems\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, TraceApi.homepage.setHomepageProblems.Error>;
export type Error = TraceApi.homepage.setHomepageProblems.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.homepage.setHomepageProblems.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.homepage.setHomepageProblems.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.homepage.setHomepageProblems.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.homepage.setHomepageProblems.Error._Unknown, visitor: TraceApi.homepage.setHomepageProblems.Error._Visitor<_Result>) {
      return TraceApi.homepage.setHomepageProblems.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.homepage.setHomepageProblems.Error,
    visitor: TraceApi.homepage.setHomepageProblems.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "setHomepageProblems.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "homepage",
            "type": "directory",
          },
          Object {
            "contents": "export * as commons from \\"./commons\\";
export * from \\"./commons/types\\";
export * as langServer from \\"./langServer\\";
export * from \\"./langServer/types\\";
export * as migration from \\"./migration\\";
export * from \\"./migration/types\\";
export * as playlist from \\"./playlist\\";
export * from \\"./playlist/types\\";
export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as submission from \\"./submission\\";
export * from \\"./submission/types\\";
export * as v2 from \\"./v2\\";
export * from \\"./playlist/errors\\";
export * as admin from \\"./admin\\";
export * from \\"./admin/client/requests\\";
export * as homepage from \\"./homepage\\";
export * from \\"./playlist/client/requests\\";
export * from \\"./problem/client/requests\\";
export * as sysprop from \\"./sysprop\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface LangServerRequest {
  request?: unknown;
}
",
                    "name": "LangServerRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface LangServerResponse {
  response?: unknown;
}
",
                    "name": "LangServerResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./LangServerRequest\\";
export * from \\"./LangServerResponse\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "langServer",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    token?: core.Supplier<core.BearerToken>;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async getAttemptedMigrations(): Promise<TraceApi.migration.getAttemptedMigrations.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/migration-info/all\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.migration.getAttemptedMigrations.Response.parse(
          _response.body as serializers.migration.getAttemptedMigrations.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.migration.getAttemptedMigrations.Error._unknown(_response.error),
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<TraceApi.Migration[], TraceApi.migration.getAttemptedMigrations.Error>;
export type Error = TraceApi.migration.getAttemptedMigrations.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.migration.getAttemptedMigrations.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.migration.getAttemptedMigrations.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.migration.getAttemptedMigrations.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.migration.getAttemptedMigrations.Error._Unknown, visitor: TraceApi.migration.getAttemptedMigrations.Error._Visitor<_Result>) {
      return TraceApi.migration.getAttemptedMigrations.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.migration.getAttemptedMigrations.Error,
    visitor: TraceApi.migration.getAttemptedMigrations.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "getAttemptedMigrations.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getAttemptedMigrations from \\"./getAttemptedMigrations\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface Migration {
  name: string;
  status: TraceApi.MigrationStatus;
}
",
                    "name": "Migration.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type MigrationStatus = \\"RUNNING\\" | \\"FAILED\\" | \\"FINISHED\\";

export const MigrationStatus = {
  Running: \\"RUNNING\\",
  Failed: \\"FAILED\\",
  Finished: \\"FINISHED\\",
} as const;
",
                    "name": "MigrationStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./MigrationStatus\\";
export * from \\"./Migration\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "migration",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    token?: core.Supplier<core.BearerToken>;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async createPlaylist(
    serviceParam: number,
    request: TraceApi.PlaylistCreateRequestWrapper
  ): Promise<TraceApi.playlist.createPlaylist.Response> {
    const _queryParams = new URLSearchParams();
    if (Array.isArray(request.multiple)) {
      for (const _item of request.multiple) {
        _queryParams.append(\\"multiple\\", _item.toString());
      }
    } else {
      _queryParams.append(\\"multiple\\", request.multiple.toString());
    }

    if (request.multipleOptional != null) {
      if (Array.isArray(request.multipleOptional)) {
        for (const _item of request.multipleOptional) {
          _queryParams.append(\\"multipleOptional\\", _item.toString());
        }
      } else {
        _queryParams.append(\\"multipleOptional\\", request.multipleOptional.toString());
      }
    }

    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \`/v2/playlist/\${serviceParam}/create\`),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
      queryParameters: _queryParams,
      body: await serializers.playlist.createPlaylist.Request.json(request.body),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.playlist.createPlaylist.Response.parse(
          _response.body as serializers.playlist.createPlaylist.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.playlist.createPlaylist.Error._unknown(_response.error),
    };
  }

  public async getPlaylists(
    serviceParam: number,
    request: TraceApi.GetPlaylistsRequest
  ): Promise<TraceApi.playlist.getPlaylists.Response> {
    const _queryParams = new URLSearchParams();
    if (request.limit != null) {
      _queryParams.append(\\"limit\\", request.limit.toString());
    }

    _queryParams.append(\\"otherField\\", request.otherField);
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \`/v2/playlist/\${serviceParam}/all\`),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
      queryParameters: _queryParams,
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.playlist.getPlaylists.Response.parse(
          _response.body as serializers.playlist.getPlaylists.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.playlist.getPlaylists.Error._unknown(_response.error),
    };
  }

  public async getPlaylist(
    serviceParam: number,
    playlistId: TraceApi.PlaylistId
  ): Promise<TraceApi.playlist.getPlaylist.Response> {
    const _response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/v2/playlist/\${serviceParam}/\${playlistId}\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.playlist.getPlaylist.Response.parse(
          _response.body as serializers.playlist.getPlaylist.Response.Raw
        ),
      };
    }

    if (_response.error.reason === \\"status-code\\") {
      switch ((_response.error.body as serializers.playlist.getPlaylist.Error.Raw)?.errorName) {
        case \\"PlaylistIdNotFoundError\\":
        case \\"UnauthorizedError\\":
          return {
            ok: false,
            error: await serializers.playlist.getPlaylist.Error.parse(
              _response.error.body as serializers.playlist.getPlaylist.Error.Raw
            ),
          };
      }
    }

    return {
      ok: false,
      error: TraceApi.playlist.getPlaylist.Error._unknown(_response.error),
    };
  }

  public async updatePlaylist(
    serviceParam: number,
    playlistId: TraceApi.PlaylistId,
    request?: TraceApi.UpdatePlaylistRequest
  ): Promise<TraceApi.playlist.updatePlaylist.Response> {
    const _response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/v2/playlist/\${serviceParam}/\${playlistId}\`
      ),
      method: \\"PUT\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
      body: await serializers.playlist.updatePlaylist.Request.json(request),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.playlist.updatePlaylist.Response.parse(
          _response.body as serializers.playlist.updatePlaylist.Response.Raw
        ),
      };
    }

    if (_response.error.reason === \\"status-code\\") {
      switch ((_response.error.body as serializers.playlist.updatePlaylist.Error.Raw)?.errorName) {
        case \\"PlaylistIdNotFoundError\\":
          return {
            ok: false,
            error: await serializers.playlist.updatePlaylist.Error.parse(
              _response.error.body as serializers.playlist.updatePlaylist.Error.Raw
            ),
          };
      }
    }

    return {
      ok: false,
      error: TraceApi.playlist.updatePlaylist.Error._unknown(_response.error),
    };
  }

  public async deletePlaylist(
    serviceParam: number,
    playlistId: TraceApi.PlaylistId
  ): Promise<TraceApi.playlist.deletePlaylist.Response> {
    const _response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/v2/playlist/\${serviceParam}/\${playlistId}\`
      ),
      method: \\"DELETE\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: TraceApi.playlist.deletePlaylist.Error._unknown(_response.error),
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<TraceApi.Playlist, TraceApi.playlist.createPlaylist.Error>;
export type Error = TraceApi.playlist.createPlaylist.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.playlist.createPlaylist.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.playlist.createPlaylist.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.playlist.createPlaylist.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.playlist.createPlaylist.Error._Unknown, visitor: TraceApi.playlist.createPlaylist.Error._Visitor<_Result>) {
      return TraceApi.playlist.createPlaylist.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.playlist.createPlaylist.Error,
    visitor: TraceApi.playlist.createPlaylist.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "createPlaylist.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, TraceApi.playlist.deletePlaylist.Error>;
export type Error = TraceApi.playlist.deletePlaylist.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.playlist.deletePlaylist.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.playlist.deletePlaylist.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.playlist.deletePlaylist.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.playlist.deletePlaylist.Error._Unknown, visitor: TraceApi.playlist.deletePlaylist.Error._Visitor<_Result>) {
      return TraceApi.playlist.deletePlaylist.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.playlist.deletePlaylist.Error,
    visitor: TraceApi.playlist.deletePlaylist.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "deletePlaylist.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<TraceApi.Playlist, TraceApi.playlist.getPlaylist.Error>;
export type Error =
  | TraceApi.playlist.getPlaylist.Error.PlaylistIdNotFoundError
  | TraceApi.playlist.getPlaylist.Error.UnauthorizedError
  | TraceApi.playlist.getPlaylist.Error._Unknown;

export declare namespace Error {
  interface PlaylistIdNotFoundError extends _Utils {
    errorName: \\"PlaylistIdNotFoundError\\";
    content: TraceApi.PlaylistIdNotFoundError;
  }

  interface UnauthorizedError extends _Utils {
    errorName: \\"UnauthorizedError\\";
  }

  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.playlist.getPlaylist.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    playlistIdNotFoundError: (value: TraceApi.PlaylistIdNotFoundError) => _Result;
    unauthorizedError: () => _Result;
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  playlistIdNotFoundError: (
    value: TraceApi.PlaylistIdNotFoundError
  ): TraceApi.playlist.getPlaylist.Error.PlaylistIdNotFoundError => {
    const valueWithoutVisit: Omit<TraceApi.playlist.getPlaylist.Error.PlaylistIdNotFoundError, \\"_visit\\"> = {
      content: value,
      errorName: \\"PlaylistIdNotFoundError\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.playlist.getPlaylist.Error.PlaylistIdNotFoundError, visitor: TraceApi.playlist.getPlaylist.Error._Visitor<_Result>) {
      return TraceApi.playlist.getPlaylist.Error._visit(this, visitor);
    });
  },

  unauthorizedError: (): TraceApi.playlist.getPlaylist.Error.UnauthorizedError => {
    const valueWithoutVisit: Omit<TraceApi.playlist.getPlaylist.Error.UnauthorizedError, \\"_visit\\"> = {
      errorName: \\"UnauthorizedError\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.playlist.getPlaylist.Error.UnauthorizedError, visitor: TraceApi.playlist.getPlaylist.Error._Visitor<_Result>) {
      return TraceApi.playlist.getPlaylist.Error._visit(this, visitor);
    });
  },

  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.playlist.getPlaylist.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<TraceApi.playlist.getPlaylist.Error._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.playlist.getPlaylist.Error._Unknown, visitor: TraceApi.playlist.getPlaylist.Error._Visitor<_Result>) {
      return TraceApi.playlist.getPlaylist.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.playlist.getPlaylist.Error,
    visitor: TraceApi.playlist.getPlaylist.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      case \\"PlaylistIdNotFoundError\\":
        return visitor.playlistIdNotFoundError(value.content);
      case \\"UnauthorizedError\\":
        return visitor.unauthorizedError();
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "getPlaylist.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<TraceApi.Playlist[], TraceApi.playlist.getPlaylists.Error>;
export type Error = TraceApi.playlist.getPlaylists.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.playlist.getPlaylists.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.playlist.getPlaylists.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<TraceApi.playlist.getPlaylists.Error._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.playlist.getPlaylists.Error._Unknown, visitor: TraceApi.playlist.getPlaylists.Error._Visitor<_Result>) {
      return TraceApi.playlist.getPlaylists.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.playlist.getPlaylists.Error,
    visitor: TraceApi.playlist.getPlaylists.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "getPlaylists.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as createPlaylist from \\"./createPlaylist\\";
export * from \\"./requests\\";
export * as getPlaylists from \\"./getPlaylists\\";
export * as getPlaylist from \\"./getPlaylist\\";
export * as updatePlaylist from \\"./updatePlaylist\\";
export * as deletePlaylist from \\"./deletePlaylist\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface GetPlaylistsRequest {
  limit?: number;
  otherField: string;
}
",
                        "name": "GetPlaylistsRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface PlaylistCreateRequestWrapper {
  multiple: number | number[];
  multipleOptional?: boolean | boolean[];
  body: TraceApi.PlaylistCreateRequest;
}
",
                        "name": "PlaylistCreateRequestWrapper.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { PlaylistCreateRequestWrapper } from \\"./PlaylistCreateRequestWrapper\\";
export { GetPlaylistsRequest } from \\"./GetPlaylistsRequest\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "requests",
                    "type": "directory",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<TraceApi.Playlist | undefined, TraceApi.playlist.updatePlaylist.Error>;
export type Error =
  | TraceApi.playlist.updatePlaylist.Error.PlaylistIdNotFoundError
  | TraceApi.playlist.updatePlaylist.Error._Unknown;

export declare namespace Error {
  interface PlaylistIdNotFoundError extends _Utils {
    errorName: \\"PlaylistIdNotFoundError\\";
    content: TraceApi.PlaylistIdNotFoundError;
  }

  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.playlist.updatePlaylist.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    playlistIdNotFoundError: (value: TraceApi.PlaylistIdNotFoundError) => _Result;
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  playlistIdNotFoundError: (
    value: TraceApi.PlaylistIdNotFoundError
  ): TraceApi.playlist.updatePlaylist.Error.PlaylistIdNotFoundError => {
    const valueWithoutVisit: Omit<TraceApi.playlist.updatePlaylist.Error.PlaylistIdNotFoundError, \\"_visit\\"> = {
      content: value,
      errorName: \\"PlaylistIdNotFoundError\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.playlist.updatePlaylist.Error.PlaylistIdNotFoundError, visitor: TraceApi.playlist.updatePlaylist.Error._Visitor<_Result>) {
      return TraceApi.playlist.updatePlaylist.Error._visit(this, visitor);
    });
  },

  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.playlist.updatePlaylist.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.playlist.updatePlaylist.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.playlist.updatePlaylist.Error._Unknown, visitor: TraceApi.playlist.updatePlaylist.Error._Visitor<_Result>) {
      return TraceApi.playlist.updatePlaylist.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.playlist.updatePlaylist.Error,
    visitor: TraceApi.playlist.updatePlaylist.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      case \\"PlaylistIdNotFoundError\\":
        return visitor.playlistIdNotFoundError(value.content);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "updatePlaylist.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type PlaylistIdNotFoundError = TraceApi.PlaylistIdNotFoundErrorBody;
",
                    "name": "PlaylistIdNotFoundError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./PlaylistIdNotFoundError\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "errors",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./errors\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface Playlist extends TraceApi.PlaylistCreateRequest {
  playlistId: TraceApi.PlaylistId;
  ownerId: TraceApi.UserId;
}
",
                    "name": "Playlist.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface PlaylistCreateRequest {
  name: string;
  problems: TraceApi.ProblemId[];
}
",
                    "name": "PlaylistCreateRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type PlaylistId = string & {
  PlaylistId: void;
};

export function PlaylistId(value: string): TraceApi.PlaylistId {
  return value as unknown as TraceApi.PlaylistId;
}
",
                    "name": "PlaylistId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type PlaylistIdNotFoundErrorBody =
  | TraceApi.PlaylistIdNotFoundErrorBody.PlaylistId
  | TraceApi.PlaylistIdNotFoundErrorBody._Unknown;

export declare namespace PlaylistIdNotFoundErrorBody {
  interface PlaylistId extends _Utils {
    type: \\"playlistId\\";
    value: TraceApi.PlaylistId;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.PlaylistIdNotFoundErrorBody._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    playlistId: (value: TraceApi.PlaylistId) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const PlaylistIdNotFoundErrorBody = {
  playlistId: (value: TraceApi.PlaylistId): TraceApi.PlaylistIdNotFoundErrorBody.PlaylistId => {
    const valueWithoutVisit: Omit<TraceApi.PlaylistIdNotFoundErrorBody.PlaylistId, \\"_visit\\"> = {
      value: value,
      type: \\"playlistId\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.PlaylistIdNotFoundErrorBody.PlaylistId, visitor: TraceApi.PlaylistIdNotFoundErrorBody._Visitor<_Result>) {
      return TraceApi.PlaylistIdNotFoundErrorBody._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.PlaylistIdNotFoundErrorBody._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.PlaylistIdNotFoundErrorBody._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.PlaylistIdNotFoundErrorBody._Unknown, visitor: TraceApi.PlaylistIdNotFoundErrorBody._Visitor<_Result>) {
      return TraceApi.PlaylistIdNotFoundErrorBody._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.PlaylistIdNotFoundErrorBody,
    visitor: TraceApi.PlaylistIdNotFoundErrorBody._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"playlistId\\":
        return visitor.playlistId(value.value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "PlaylistIdNotFoundErrorBody.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type ReservedKeywordEnum = \\"is\\" | \\"as\\";

export const ReservedKeywordEnum = {
  Is: \\"is\\",
  As: \\"as\\",
} as const;
",
                    "name": "ReservedKeywordEnum.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface UpdatePlaylistRequest {
  name: string;
  problems: TraceApi.ProblemId[];
}
",
                    "name": "UpdatePlaylistRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./PlaylistId\\";
export * from \\"./Playlist\\";
export * from \\"./PlaylistCreateRequest\\";
export * from \\"./UpdatePlaylistRequest\\";
export * from \\"./PlaylistIdNotFoundErrorBody\\";
export * from \\"./ReservedKeywordEnum\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "playlist",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    token?: core.Supplier<core.BearerToken>;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async createProblem(request: TraceApi.CreateProblemRequest): Promise<TraceApi.problem.createProblem.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/problem-crud/create\\"),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
      body: await serializers.problem.createProblem.Request.json(request),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.problem.createProblem.Response.parse(
          _response.body as serializers.problem.createProblem.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.problem.createProblem.Error._unknown(_response.error),
    };
  }

  public async updateProblem(
    problemId: TraceApi.ProblemId,
    request: TraceApi.CreateProblemRequest
  ): Promise<TraceApi.problem.updateProblem.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \`/problem-crud/update/\${problemId}\`),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
      body: await serializers.problem.updateProblem.Request.json(request),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.problem.updateProblem.Response.parse(
          _response.body as serializers.problem.updateProblem.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.problem.updateProblem.Error._unknown(_response.error),
    };
  }

  public async deleteProblem(problemId: TraceApi.ProblemId): Promise<TraceApi.problem.deleteProblem.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \`/problem-crud/delete/\${problemId}\`),
      method: \\"DELETE\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: TraceApi.problem.deleteProblem.Error._unknown(_response.error),
    };
  }

  public async getDefaultStarterFiles(
    request: TraceApi.GetDefaultStarterFilesRequest
  ): Promise<TraceApi.problem.getDefaultStarterFiles.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/problem-crud/default-starter-files\\"),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
      body: await serializers.problem.getDefaultStarterFiles.Request.json({
        inputParams: request.inputParams,
        outputType: request.outputType,
        methodName: request.methodName,
      }),
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.problem.getDefaultStarterFiles.Response.parse(
          _response.body as serializers.problem.getDefaultStarterFiles.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.problem.getDefaultStarterFiles.Error._unknown(_response.error),
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<TraceApi.CreateProblemResponse, TraceApi.problem.createProblem.Error>;
export type Error = TraceApi.problem.createProblem.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.problem.createProblem.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.problem.createProblem.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<TraceApi.problem.createProblem.Error._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.problem.createProblem.Error._Unknown, visitor: TraceApi.problem.createProblem.Error._Visitor<_Result>) {
      return TraceApi.problem.createProblem.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.problem.createProblem.Error,
    visitor: TraceApi.problem.createProblem.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "createProblem.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, TraceApi.problem.deleteProblem.Error>;
export type Error = TraceApi.problem.deleteProblem.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.problem.deleteProblem.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.problem.deleteProblem.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<TraceApi.problem.deleteProblem.Error._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.problem.deleteProblem.Error._Unknown, visitor: TraceApi.problem.deleteProblem.Error._Visitor<_Result>) {
      return TraceApi.problem.deleteProblem.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.problem.deleteProblem.Error,
    visitor: TraceApi.problem.deleteProblem.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "deleteProblem.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  TraceApi.GetDefaultStarterFilesResponse,
  TraceApi.problem.getDefaultStarterFiles.Error
>;
export type Error = TraceApi.problem.getDefaultStarterFiles.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.problem.getDefaultStarterFiles.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.problem.getDefaultStarterFiles.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.problem.getDefaultStarterFiles.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.problem.getDefaultStarterFiles.Error._Unknown, visitor: TraceApi.problem.getDefaultStarterFiles.Error._Visitor<_Result>) {
      return TraceApi.problem.getDefaultStarterFiles.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.problem.getDefaultStarterFiles.Error,
    visitor: TraceApi.problem.getDefaultStarterFiles.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "getDefaultStarterFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as createProblem from \\"./createProblem\\";
export * as updateProblem from \\"./updateProblem\\";
export * as deleteProblem from \\"./deleteProblem\\";
export * as getDefaultStarterFiles from \\"./getDefaultStarterFiles\\";
export * from \\"./requests\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetDefaultStarterFilesRequest {
  inputParams: TraceApi.VariableTypeAndName[];
  outputType: TraceApi.VariableType;
  methodName: string;
}
",
                        "name": "GetDefaultStarterFilesRequest.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { GetDefaultStarterFilesRequest } from \\"./GetDefaultStarterFilesRequest\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "requests",
                    "type": "directory",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<TraceApi.UpdateProblemResponse, TraceApi.problem.updateProblem.Error>;
export type Error = TraceApi.problem.updateProblem.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.problem.updateProblem.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.problem.updateProblem.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<TraceApi.problem.updateProblem.Error._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.problem.updateProblem.Error._Unknown, visitor: TraceApi.problem.updateProblem.Error._Visitor<_Result>) {
      return TraceApi.problem.updateProblem.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.problem.updateProblem.Error,
    visitor: TraceApi.problem.updateProblem.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "updateProblem.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type CreateProblemError = TraceApi.CreateProblemError.Generic | TraceApi.CreateProblemError._Unknown;

export declare namespace CreateProblemError {
  interface Generic extends TraceApi.GenericCreateProblemError, _Utils {
    errorType: \\"generic\\";
  }

  interface _Unknown extends _Utils {
    errorType: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.CreateProblemError._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    generic: (value: TraceApi.GenericCreateProblemError) => _Result;
    _other: (value: { errorType: string }) => _Result;
  }
}

export const CreateProblemError = {
  generic: (value: TraceApi.GenericCreateProblemError): TraceApi.CreateProblemError.Generic => {
    const valueWithoutVisit: Omit<TraceApi.CreateProblemError.Generic, \\"_visit\\"> = {
      ...value,
      errorType: \\"generic\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CreateProblemError.Generic, visitor: TraceApi.CreateProblemError._Visitor<_Result>) {
      return TraceApi.CreateProblemError._visit(this, visitor);
    });
  },

  _unknown: (value: { errorType: string }): TraceApi.CreateProblemError._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.CreateProblemError._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CreateProblemError._Unknown, visitor: TraceApi.CreateProblemError._Visitor<_Result>) {
      return TraceApi.CreateProblemError._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.CreateProblemError,
    visitor: TraceApi.CreateProblemError._Visitor<_Result>
  ): _Result => {
    switch (value.errorType) {
      case \\"generic\\":
        return visitor.generic(value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "CreateProblemError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface CreateProblemRequest {
  problemName: string;
  problemDescription: TraceApi.ProblemDescription;
  files: Record<TraceApi.Language, TraceApi.ProblemFiles>;
  inputParams: TraceApi.VariableTypeAndName[];
  outputType: TraceApi.VariableType;
  testcases: TraceApi.TestCaseWithExpectedResult[];
  methodName: string;
}
",
                    "name": "CreateProblemRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type CreateProblemResponse =
  | TraceApi.CreateProblemResponse.Success
  | TraceApi.CreateProblemResponse.Error
  | TraceApi.CreateProblemResponse._Unknown;

export declare namespace CreateProblemResponse {
  interface Success extends _Utils {
    type: \\"success\\";
    value: TraceApi.ProblemId;
  }

  interface Error extends _Utils {
    type: \\"error\\";
    value: TraceApi.CreateProblemError;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.CreateProblemResponse._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    success: (value: TraceApi.ProblemId) => _Result;
    error: (value: TraceApi.CreateProblemError) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const CreateProblemResponse = {
  success: (value: TraceApi.ProblemId): TraceApi.CreateProblemResponse.Success => {
    const valueWithoutVisit: Omit<TraceApi.CreateProblemResponse.Success, \\"_visit\\"> = {
      value: value,
      type: \\"success\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CreateProblemResponse.Success, visitor: TraceApi.CreateProblemResponse._Visitor<_Result>) {
      return TraceApi.CreateProblemResponse._visit(this, visitor);
    });
  },

  error: (value: TraceApi.CreateProblemError): TraceApi.CreateProblemResponse.Error => {
    const valueWithoutVisit: Omit<TraceApi.CreateProblemResponse.Error, \\"_visit\\"> = {
      value: value,
      type: \\"error\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CreateProblemResponse.Error, visitor: TraceApi.CreateProblemResponse._Visitor<_Result>) {
      return TraceApi.CreateProblemResponse._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.CreateProblemResponse._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.CreateProblemResponse._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CreateProblemResponse._Unknown, visitor: TraceApi.CreateProblemResponse._Visitor<_Result>) {
      return TraceApi.CreateProblemResponse._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.CreateProblemResponse,
    visitor: TraceApi.CreateProblemResponse._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"success\\":
        return visitor.success(value.value);
      case \\"error\\":
        return visitor.error(value.value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "CreateProblemResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface GenericCreateProblemError {
  message: string;
  type: string;
  stacktrace: string;
}
",
                    "name": "GenericCreateProblemError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetDefaultStarterFilesResponse {
  files: Record<TraceApi.Language, TraceApi.ProblemFiles>;
}
",
                    "name": "GetDefaultStarterFilesResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface ProblemDescription {
  boards: TraceApi.ProblemDescriptionBoard[];
}
",
                    "name": "ProblemDescription.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

/**
 * @example
 *     TraceApi.ProblemDescriptionBoard.html(\\"<div>hello world</div>\\")
 *
 * @example
 *     TraceApi.ProblemDescriptionBoard.testCaseId(\\"test-case-id-1\\")
 */
export type ProblemDescriptionBoard =
  | TraceApi.ProblemDescriptionBoard.Html
  | TraceApi.ProblemDescriptionBoard.Variable
  | TraceApi.ProblemDescriptionBoard.TestCaseId
  | TraceApi.ProblemDescriptionBoard._Unknown;

export declare namespace ProblemDescriptionBoard {
  interface Html extends _Utils {
    type: \\"html\\";
    value: string;
  }

  interface Variable extends _Utils {
    type: \\"variable\\";
    value: TraceApi.VariableValue;
  }

  interface TestCaseId extends _Utils {
    type: \\"testCaseId\\";
    value: string;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.ProblemDescriptionBoard._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    html: (value: string) => _Result;
    variable: (value: TraceApi.VariableValue) => _Result;
    testCaseId: (value: string) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const ProblemDescriptionBoard = {
  html: (value: string): TraceApi.ProblemDescriptionBoard.Html => {
    const valueWithoutVisit: Omit<TraceApi.ProblemDescriptionBoard.Html, \\"_visit\\"> = {
      value: value,
      type: \\"html\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.ProblemDescriptionBoard.Html, visitor: TraceApi.ProblemDescriptionBoard._Visitor<_Result>) {
      return TraceApi.ProblemDescriptionBoard._visit(this, visitor);
    });
  },

  variable: (value: TraceApi.VariableValue): TraceApi.ProblemDescriptionBoard.Variable => {
    const valueWithoutVisit: Omit<TraceApi.ProblemDescriptionBoard.Variable, \\"_visit\\"> = {
      value: value,
      type: \\"variable\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.ProblemDescriptionBoard.Variable, visitor: TraceApi.ProblemDescriptionBoard._Visitor<_Result>) {
      return TraceApi.ProblemDescriptionBoard._visit(this, visitor);
    });
  },

  testCaseId: (value: string): TraceApi.ProblemDescriptionBoard.TestCaseId => {
    const valueWithoutVisit: Omit<TraceApi.ProblemDescriptionBoard.TestCaseId, \\"_visit\\"> = {
      value: value,
      type: \\"testCaseId\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.ProblemDescriptionBoard.TestCaseId, visitor: TraceApi.ProblemDescriptionBoard._Visitor<_Result>) {
      return TraceApi.ProblemDescriptionBoard._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.ProblemDescriptionBoard._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.ProblemDescriptionBoard._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.ProblemDescriptionBoard._Unknown, visitor: TraceApi.ProblemDescriptionBoard._Visitor<_Result>) {
      return TraceApi.ProblemDescriptionBoard._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.ProblemDescriptionBoard,
    visitor: TraceApi.ProblemDescriptionBoard._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"html\\":
        return visitor.html(value.value);
      case \\"variable\\":
        return visitor.variable(value.value);
      case \\"testCaseId\\":
        return visitor.testCaseId(value.value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "ProblemDescriptionBoard.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

/**
 * @example
 *     {
 *         solutionFile: {
 *             filename: \\"hello.txt\\",
 *             contents: \\"I'm some file content\\"
 *         },
 *         readOnlyFiles: []
 *     }
 */
export interface ProblemFiles {
  solutionFile: TraceApi.FileInfo;
  readOnlyFiles: TraceApi.FileInfo[];
}
",
                    "name": "ProblemFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface ProblemInfo {
  problemId: TraceApi.ProblemId;
  problemDescription: TraceApi.ProblemDescription;
  problemName: string;
  problemVersion: number;
  files: Record<TraceApi.Language, TraceApi.ProblemFiles>;
  inputParams: TraceApi.VariableTypeAndName[];
  outputType: TraceApi.VariableType;
  testcases: TraceApi.TestCaseWithExpectedResult[];
  methodName: string;
  supportsCustomTestCases: boolean;
}
",
                    "name": "ProblemInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface ProblemsMap {
  problemsById: Record<TraceApi.ProblemId, TraceApi.ProblemInfo>;
}
",
                    "name": "ProblemsMap.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface UpdateProblemResponse {
  problemVersion: number;
}
",
                    "name": "UpdateProblemResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface VariableTypeAndName {
  variableType: TraceApi.VariableType;
  name: string;
}
",
                    "name": "VariableTypeAndName.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./ProblemInfo\\";
export * from \\"./ProblemsMap\\";
export * from \\"./ProblemDescription\\";
export * from \\"./ProblemDescriptionBoard\\";
export * from \\"./ProblemFiles\\";
export * from \\"./VariableTypeAndName\\";
export * from \\"./CreateProblemRequest\\";
export * from \\"./CreateProblemResponse\\";
export * from \\"./UpdateProblemResponse\\";
export * from \\"./CreateProblemError\\";
export * from \\"./GenericCreateProblemError\\";
export * from \\"./GetDefaultStarterFilesResponse\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "problem",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    token?: core.Supplier<core.BearerToken>;
  }
}

/**
 * Responsible for spinning up and spinning down execution.
 */
export class Client {
  constructor(private readonly options: Client.Options) {}

  public async createExecutionSession(
    language: TraceApi.Language
  ): Promise<TraceApi.submission.createExecutionSession.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \`/sessions/create-session/\${language}\`),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.submission.createExecutionSession.Response.parse(
          _response.body as serializers.submission.createExecutionSession.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.submission.createExecutionSession.Error._unknown(_response.error),
    };
  }

  public async getExecutionSession(sessionId: string): Promise<TraceApi.submission.getExecutionSession.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \`/sessions/\${sessionId}\`),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.submission.getExecutionSession.Response.parse(
          _response.body as serializers.submission.getExecutionSession.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.submission.getExecutionSession.Error._unknown(_response.error),
    };
  }

  public async stopExecutionSession(sessionId: string): Promise<TraceApi.submission.stopExecutionSession.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \`/sessions/stop/\${sessionId}\`),
      method: \\"DELETE\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: TraceApi.submission.stopExecutionSession.Error._unknown(_response.error),
    };
  }

  public async getExecutionSessionsState(): Promise<TraceApi.submission.getExecutionSessionsState.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/sessions/execution-sessions-state\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.submission.getExecutionSessionsState.Response.parse(
          _response.body as serializers.submission.getExecutionSessionsState.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.submission.getExecutionSessionsState.Error._unknown(_response.error),
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  TraceApi.ExecutionSessionResponse,
  TraceApi.submission.createExecutionSession.Error
>;
export type Error = TraceApi.submission.createExecutionSession.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.submission.createExecutionSession.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.submission.createExecutionSession.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.submission.createExecutionSession.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.submission.createExecutionSession.Error._Unknown, visitor: TraceApi.submission.createExecutionSession.Error._Visitor<_Result>) {
      return TraceApi.submission.createExecutionSession.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.submission.createExecutionSession.Error,
    visitor: TraceApi.submission.createExecutionSession.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "createExecutionSession.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  TraceApi.ExecutionSessionResponse | undefined,
  TraceApi.submission.getExecutionSession.Error
>;
export type Error = TraceApi.submission.getExecutionSession.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.submission.getExecutionSession.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.submission.getExecutionSession.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.submission.getExecutionSession.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.submission.getExecutionSession.Error._Unknown, visitor: TraceApi.submission.getExecutionSession.Error._Visitor<_Result>) {
      return TraceApi.submission.getExecutionSession.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.submission.getExecutionSession.Error,
    visitor: TraceApi.submission.getExecutionSession.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "getExecutionSession.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  TraceApi.GetExecutionSessionStateResponse,
  TraceApi.submission.getExecutionSessionsState.Error
>;
export type Error = TraceApi.submission.getExecutionSessionsState.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.submission.getExecutionSessionsState.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.submission.getExecutionSessionsState.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.submission.getExecutionSessionsState.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.submission.getExecutionSessionsState.Error._Unknown, visitor: TraceApi.submission.getExecutionSessionsState.Error._Visitor<_Result>) {
      return TraceApi.submission.getExecutionSessionsState.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.submission.getExecutionSessionsState.Error,
    visitor: TraceApi.submission.getExecutionSessionsState.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "getExecutionSessionsState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as createExecutionSession from \\"./createExecutionSession\\";
export * as getExecutionSession from \\"./getExecutionSession\\";
export * as stopExecutionSession from \\"./stopExecutionSession\\";
export * as getExecutionSessionsState from \\"./getExecutionSessionsState\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, TraceApi.submission.stopExecutionSession.Error>;
export type Error = TraceApi.submission.stopExecutionSession.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.submission.stopExecutionSession.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.submission.stopExecutionSession.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.submission.stopExecutionSession.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.submission.stopExecutionSession.Error._Unknown, visitor: TraceApi.submission.stopExecutionSession.Error._Visitor<_Result>) {
      return TraceApi.submission.stopExecutionSession.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.submission.stopExecutionSession.Error,
    visitor: TraceApi.submission.stopExecutionSession.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "stopExecutionSession.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type ActualResult =
  | TraceApi.ActualResult.Value
  | TraceApi.ActualResult.Exception
  | TraceApi.ActualResult.ExceptionV2
  | TraceApi.ActualResult._Unknown;

export declare namespace ActualResult {
  interface Value extends _Utils {
    type: \\"value\\";
    value: TraceApi.VariableValue;
  }

  interface Exception extends TraceApi.ExceptionInfo, _Utils {
    type: \\"exception\\";
  }

  interface ExceptionV2 extends _Utils {
    type: \\"exceptionV2\\";
    value: TraceApi.ExceptionV2;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.ActualResult._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    value: (value: TraceApi.VariableValue) => _Result;
    exception: (value: TraceApi.ExceptionInfo) => _Result;
    exceptionV2: (value: TraceApi.ExceptionV2) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const ActualResult = {
  value: (value: TraceApi.VariableValue): TraceApi.ActualResult.Value => {
    const valueWithoutVisit: Omit<TraceApi.ActualResult.Value, \\"_visit\\"> = {
      value: value,
      type: \\"value\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.ActualResult.Value, visitor: TraceApi.ActualResult._Visitor<_Result>) {
      return TraceApi.ActualResult._visit(this, visitor);
    });
  },

  exception: (value: TraceApi.ExceptionInfo): TraceApi.ActualResult.Exception => {
    const valueWithoutVisit: Omit<TraceApi.ActualResult.Exception, \\"_visit\\"> = {
      ...value,
      type: \\"exception\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.ActualResult.Exception, visitor: TraceApi.ActualResult._Visitor<_Result>) {
      return TraceApi.ActualResult._visit(this, visitor);
    });
  },

  exceptionV2: (value: TraceApi.ExceptionV2): TraceApi.ActualResult.ExceptionV2 => {
    const valueWithoutVisit: Omit<TraceApi.ActualResult.ExceptionV2, \\"_visit\\"> = {
      value: value,
      type: \\"exceptionV2\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.ActualResult.ExceptionV2, visitor: TraceApi.ActualResult._Visitor<_Result>) {
      return TraceApi.ActualResult._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.ActualResult._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.ActualResult._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.ActualResult._Unknown, visitor: TraceApi.ActualResult._Visitor<_Result>) {
      return TraceApi.ActualResult._visit(this, visitor);
    });
  },

  _visit: <_Result>(value: TraceApi.ActualResult, visitor: TraceApi.ActualResult._Visitor<_Result>): _Result => {
    switch (value.type) {
      case \\"value\\":
        return visitor.value(value.value);
      case \\"exception\\":
        return visitor.exception(value);
      case \\"exceptionV2\\":
        return visitor.exceptionV2(value.value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "ActualResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface BuildingExecutorResponse {
  submissionId: TraceApi.SubmissionId;
  status: TraceApi.ExecutionSessionStatus;
}
",
                    "name": "BuildingExecutorResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type CodeExecutionUpdate =
  /**
   * Statuses if an executor for the session isn't ready (Before RunningResponse). */
  | TraceApi.CodeExecutionUpdate.BuildingExecutor
  /**
   * Sent once a test submission is executing. */
  | TraceApi.CodeExecutionUpdate.Running
  /**
   * Sent if a submission cannot be run (i.e. Compile Error). */
  | TraceApi.CodeExecutionUpdate.Errored
  /**
   * Sent if a submission is stopped. */
  | TraceApi.CodeExecutionUpdate.Stopped
  /**
   * Graded testcases without trace information. */
  | TraceApi.CodeExecutionUpdate.Graded
  /**
   * Graded submission for v2 problems. */
  | TraceApi.CodeExecutionUpdate.GradedV2
  /**
   * Workspace run without trace information. */
  | TraceApi.CodeExecutionUpdate.WorkspaceRan
  /**
   * Gives progress about what is being recorded. */
  | TraceApi.CodeExecutionUpdate.Recording
  /**
   * Graded testcases with trace information. */
  | TraceApi.CodeExecutionUpdate.Recorded
  /**
   * Sent if an invalid request is sent for a submission. */
  | TraceApi.CodeExecutionUpdate.InvalidRequest
  /**
   * Sent once a submission is graded and fully recorded. */
  | TraceApi.CodeExecutionUpdate.Finished
  | TraceApi.CodeExecutionUpdate._Unknown;

export declare namespace CodeExecutionUpdate {
  interface BuildingExecutor extends TraceApi.BuildingExecutorResponse, _Utils {
    type: \\"buildingExecutor\\";
  }

  interface Running extends TraceApi.RunningResponse, _Utils {
    type: \\"running\\";
  }

  interface Errored extends TraceApi.ErroredResponse, _Utils {
    type: \\"errored\\";
  }

  interface Stopped extends TraceApi.StoppedResponse, _Utils {
    type: \\"stopped\\";
  }

  interface Graded extends TraceApi.GradedResponse, _Utils {
    type: \\"graded\\";
  }

  interface GradedV2 extends TraceApi.GradedResponseV2, _Utils {
    type: \\"gradedV2\\";
  }

  interface WorkspaceRan extends TraceApi.WorkspaceRanResponse, _Utils {
    type: \\"workspaceRan\\";
  }

  interface Recording extends TraceApi.RecordingResponseNotification, _Utils {
    type: \\"recording\\";
  }

  interface Recorded extends TraceApi.RecordedResponseNotification, _Utils {
    type: \\"recorded\\";
  }

  interface InvalidRequest extends TraceApi.InvalidRequestResponse, _Utils {
    type: \\"invalidRequest\\";
  }

  interface Finished extends TraceApi.FinishedResponse, _Utils {
    type: \\"finished\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    buildingExecutor: (value: TraceApi.BuildingExecutorResponse) => _Result;
    running: (value: TraceApi.RunningResponse) => _Result;
    errored: (value: TraceApi.ErroredResponse) => _Result;
    stopped: (value: TraceApi.StoppedResponse) => _Result;
    graded: (value: TraceApi.GradedResponse) => _Result;
    gradedV2: (value: TraceApi.GradedResponseV2) => _Result;
    workspaceRan: (value: TraceApi.WorkspaceRanResponse) => _Result;
    recording: (value: TraceApi.RecordingResponseNotification) => _Result;
    recorded: (value: TraceApi.RecordedResponseNotification) => _Result;
    invalidRequest: (value: TraceApi.InvalidRequestResponse) => _Result;
    finished: (value: TraceApi.FinishedResponse) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const CodeExecutionUpdate = {
  buildingExecutor: (value: TraceApi.BuildingExecutorResponse): TraceApi.CodeExecutionUpdate.BuildingExecutor => {
    const valueWithoutVisit: Omit<TraceApi.CodeExecutionUpdate.BuildingExecutor, \\"_visit\\"> = {
      ...value,
      type: \\"buildingExecutor\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CodeExecutionUpdate.BuildingExecutor, visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>) {
      return TraceApi.CodeExecutionUpdate._visit(this, visitor);
    });
  },

  running: (value: TraceApi.RunningResponse): TraceApi.CodeExecutionUpdate.Running => {
    const valueWithoutVisit: Omit<TraceApi.CodeExecutionUpdate.Running, \\"_visit\\"> = {
      ...value,
      type: \\"running\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CodeExecutionUpdate.Running, visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>) {
      return TraceApi.CodeExecutionUpdate._visit(this, visitor);
    });
  },

  errored: (value: TraceApi.ErroredResponse): TraceApi.CodeExecutionUpdate.Errored => {
    const valueWithoutVisit: Omit<TraceApi.CodeExecutionUpdate.Errored, \\"_visit\\"> = {
      ...value,
      type: \\"errored\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CodeExecutionUpdate.Errored, visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>) {
      return TraceApi.CodeExecutionUpdate._visit(this, visitor);
    });
  },

  stopped: (value: TraceApi.StoppedResponse): TraceApi.CodeExecutionUpdate.Stopped => {
    const valueWithoutVisit: Omit<TraceApi.CodeExecutionUpdate.Stopped, \\"_visit\\"> = {
      ...value,
      type: \\"stopped\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CodeExecutionUpdate.Stopped, visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>) {
      return TraceApi.CodeExecutionUpdate._visit(this, visitor);
    });
  },

  graded: (value: TraceApi.GradedResponse): TraceApi.CodeExecutionUpdate.Graded => {
    const valueWithoutVisit: Omit<TraceApi.CodeExecutionUpdate.Graded, \\"_visit\\"> = {
      ...value,
      type: \\"graded\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CodeExecutionUpdate.Graded, visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>) {
      return TraceApi.CodeExecutionUpdate._visit(this, visitor);
    });
  },

  gradedV2: (value: TraceApi.GradedResponseV2): TraceApi.CodeExecutionUpdate.GradedV2 => {
    const valueWithoutVisit: Omit<TraceApi.CodeExecutionUpdate.GradedV2, \\"_visit\\"> = {
      ...value,
      type: \\"gradedV2\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CodeExecutionUpdate.GradedV2, visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>) {
      return TraceApi.CodeExecutionUpdate._visit(this, visitor);
    });
  },

  workspaceRan: (value: TraceApi.WorkspaceRanResponse): TraceApi.CodeExecutionUpdate.WorkspaceRan => {
    const valueWithoutVisit: Omit<TraceApi.CodeExecutionUpdate.WorkspaceRan, \\"_visit\\"> = {
      ...value,
      type: \\"workspaceRan\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CodeExecutionUpdate.WorkspaceRan, visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>) {
      return TraceApi.CodeExecutionUpdate._visit(this, visitor);
    });
  },

  recording: (value: TraceApi.RecordingResponseNotification): TraceApi.CodeExecutionUpdate.Recording => {
    const valueWithoutVisit: Omit<TraceApi.CodeExecutionUpdate.Recording, \\"_visit\\"> = {
      ...value,
      type: \\"recording\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CodeExecutionUpdate.Recording, visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>) {
      return TraceApi.CodeExecutionUpdate._visit(this, visitor);
    });
  },

  recorded: (value: TraceApi.RecordedResponseNotification): TraceApi.CodeExecutionUpdate.Recorded => {
    const valueWithoutVisit: Omit<TraceApi.CodeExecutionUpdate.Recorded, \\"_visit\\"> = {
      ...value,
      type: \\"recorded\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CodeExecutionUpdate.Recorded, visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>) {
      return TraceApi.CodeExecutionUpdate._visit(this, visitor);
    });
  },

  invalidRequest: (value: TraceApi.InvalidRequestResponse): TraceApi.CodeExecutionUpdate.InvalidRequest => {
    const valueWithoutVisit: Omit<TraceApi.CodeExecutionUpdate.InvalidRequest, \\"_visit\\"> = {
      ...value,
      type: \\"invalidRequest\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CodeExecutionUpdate.InvalidRequest, visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>) {
      return TraceApi.CodeExecutionUpdate._visit(this, visitor);
    });
  },

  finished: (value: TraceApi.FinishedResponse): TraceApi.CodeExecutionUpdate.Finished => {
    const valueWithoutVisit: Omit<TraceApi.CodeExecutionUpdate.Finished, \\"_visit\\"> = {
      ...value,
      type: \\"finished\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CodeExecutionUpdate.Finished, visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>) {
      return TraceApi.CodeExecutionUpdate._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.CodeExecutionUpdate._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.CodeExecutionUpdate._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CodeExecutionUpdate._Unknown, visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>) {
      return TraceApi.CodeExecutionUpdate._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.CodeExecutionUpdate,
    visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"buildingExecutor\\":
        return visitor.buildingExecutor(value);
      case \\"running\\":
        return visitor.running(value);
      case \\"errored\\":
        return visitor.errored(value);
      case \\"stopped\\":
        return visitor.stopped(value);
      case \\"graded\\":
        return visitor.graded(value);
      case \\"gradedV2\\":
        return visitor.gradedV2(value);
      case \\"workspaceRan\\":
        return visitor.workspaceRan(value);
      case \\"recording\\":
        return visitor.recording(value);
      case \\"recorded\\":
        return visitor.recorded(value);
      case \\"invalidRequest\\":
        return visitor.invalidRequest(value);
      case \\"finished\\":
        return visitor.finished(value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "CodeExecutionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface CompileError {
  message: string;
}
",
                    "name": "CompileError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface CustomTestCasesUnsupported {
  problemId: TraceApi.ProblemId;
  submissionId: TraceApi.SubmissionId;
}
",
                    "name": "CustomTestCasesUnsupported.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type ErrorInfo =
  | TraceApi.ErrorInfo.CompileError
  /**
   * If the submission cannot be executed and throws a runtime error before getting to any of the testcases.
   *  */
  | TraceApi.ErrorInfo.RuntimeError
  /**
   * If the trace backend encounters an unexpected error.
   *  */
  | TraceApi.ErrorInfo.InternalError
  | TraceApi.ErrorInfo._Unknown;

export declare namespace ErrorInfo {
  interface CompileError extends TraceApi.CompileError, _Utils {
    type: \\"compileError\\";
  }

  interface RuntimeError extends TraceApi.RuntimeError, _Utils {
    type: \\"runtimeError\\";
  }

  interface InternalError extends TraceApi.InternalError, _Utils {
    type: \\"internalError\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.ErrorInfo._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    compileError: (value: TraceApi.CompileError) => _Result;
    runtimeError: (value: TraceApi.RuntimeError) => _Result;
    internalError: (value: TraceApi.InternalError) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const ErrorInfo = {
  compileError: (value: TraceApi.CompileError): TraceApi.ErrorInfo.CompileError => {
    const valueWithoutVisit: Omit<TraceApi.ErrorInfo.CompileError, \\"_visit\\"> = {
      ...value,
      type: \\"compileError\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.ErrorInfo.CompileError, visitor: TraceApi.ErrorInfo._Visitor<_Result>) {
      return TraceApi.ErrorInfo._visit(this, visitor);
    });
  },

  runtimeError: (value: TraceApi.RuntimeError): TraceApi.ErrorInfo.RuntimeError => {
    const valueWithoutVisit: Omit<TraceApi.ErrorInfo.RuntimeError, \\"_visit\\"> = {
      ...value,
      type: \\"runtimeError\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.ErrorInfo.RuntimeError, visitor: TraceApi.ErrorInfo._Visitor<_Result>) {
      return TraceApi.ErrorInfo._visit(this, visitor);
    });
  },

  internalError: (value: TraceApi.InternalError): TraceApi.ErrorInfo.InternalError => {
    const valueWithoutVisit: Omit<TraceApi.ErrorInfo.InternalError, \\"_visit\\"> = {
      ...value,
      type: \\"internalError\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.ErrorInfo.InternalError, visitor: TraceApi.ErrorInfo._Visitor<_Result>) {
      return TraceApi.ErrorInfo._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.ErrorInfo._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.ErrorInfo._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.ErrorInfo._Unknown, visitor: TraceApi.ErrorInfo._Visitor<_Result>) {
      return TraceApi.ErrorInfo._visit(this, visitor);
    });
  },

  _visit: <_Result>(value: TraceApi.ErrorInfo, visitor: TraceApi.ErrorInfo._Visitor<_Result>): _Result => {
    switch (value.type) {
      case \\"compileError\\":
        return visitor.compileError(value);
      case \\"runtimeError\\":
        return visitor.runtimeError(value);
      case \\"internalError\\":
        return visitor.internalError(value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "ErrorInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface ErroredResponse {
  submissionId: TraceApi.SubmissionId;
  errorInfo: TraceApi.ErrorInfo;
}
",
                    "name": "ErroredResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface ExceptionInfo {
  exceptionType: string;
  exceptionMessage: string;
  exceptionStacktrace: string;
}
",
                    "name": "ExceptionInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type ExceptionV2 = TraceApi.ExceptionV2.Generic | TraceApi.ExceptionV2.Timeout | TraceApi.ExceptionV2._Unknown;

export declare namespace ExceptionV2 {
  interface Generic extends TraceApi.ExceptionInfo, _Utils {
    type: \\"generic\\";
  }

  interface Timeout extends _Utils {
    type: \\"timeout\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.ExceptionV2._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    generic: (value: TraceApi.ExceptionInfo) => _Result;
    timeout: () => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const ExceptionV2 = {
  generic: (value: TraceApi.ExceptionInfo): TraceApi.ExceptionV2.Generic => {
    const valueWithoutVisit: Omit<TraceApi.ExceptionV2.Generic, \\"_visit\\"> = {
      ...value,
      type: \\"generic\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.ExceptionV2.Generic, visitor: TraceApi.ExceptionV2._Visitor<_Result>) {
      return TraceApi.ExceptionV2._visit(this, visitor);
    });
  },

  timeout: (): TraceApi.ExceptionV2.Timeout => {
    const valueWithoutVisit: Omit<TraceApi.ExceptionV2.Timeout, \\"_visit\\"> = {
      type: \\"timeout\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.ExceptionV2.Timeout, visitor: TraceApi.ExceptionV2._Visitor<_Result>) {
      return TraceApi.ExceptionV2._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.ExceptionV2._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.ExceptionV2._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.ExceptionV2._Unknown, visitor: TraceApi.ExceptionV2._Visitor<_Result>) {
      return TraceApi.ExceptionV2._visit(this, visitor);
    });
  },

  _visit: <_Result>(value: TraceApi.ExceptionV2, visitor: TraceApi.ExceptionV2._Visitor<_Result>): _Result => {
    switch (value.type) {
      case \\"generic\\":
        return visitor.generic(value);
      case \\"timeout\\":
        return visitor.timeout();
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "ExceptionV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface ExecutionSessionResponse {
  sessionId: string;
  executionSessionUrl?: string;
  language: TraceApi.Language;
  status: TraceApi.ExecutionSessionStatus;
}
",
                    "name": "ExecutionSessionResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface ExecutionSessionState {
  lastTimeContacted?: string;
  sessionId: string;
  isWarmInstance: boolean;
  awsTaskId?: string;
  language: TraceApi.Language;
  status: TraceApi.ExecutionSessionStatus;
}
",
                    "name": "ExecutionSessionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type ExecutionSessionStatus =
  | \\"CREATING_CONTAINER\\"
  | \\"PROVISIONING_CONTAINER\\"
  | \\"PENDING_CONTAINER\\"
  | \\"RUNNING_CONTAINER\\"
  | \\"LIVE_CONTAINER\\"
  | \\"FAILED_TO_LAUNCH\\";

export const ExecutionSessionStatus = {
  CreatingContainer: \\"CREATING_CONTAINER\\",
  ProvisioningContainer: \\"PROVISIONING_CONTAINER\\",
  PendingContainer: \\"PENDING_CONTAINER\\",
  RunningContainer: \\"RUNNING_CONTAINER\\",
  LiveContainer: \\"LIVE_CONTAINER\\",
  FailedToLaunch: \\"FAILED_TO_LAUNCH\\",
} as const;
",
                    "name": "ExecutionSessionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface ExistingSubmissionExecuting {
  submissionId: TraceApi.SubmissionId;
}
",
                    "name": "ExistingSubmissionExecuting.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface ExpressionLocation {
  start: number;
  offset: number;
}
",
                    "name": "ExpressionLocation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface FinishedResponse {
  submissionId: TraceApi.SubmissionId;
}
",
                    "name": "FinishedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetExecutionSessionStateResponse {
  states: Record<string, TraceApi.ExecutionSessionState>;
  numWarmingInstances?: number;
  warmingSessionIds: string[];
}
",
                    "name": "GetExecutionSessionStateResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetSubmissionStateResponse {
  timeSubmitted?: Date;
  submission: string;
  language: TraceApi.Language;
  submissionTypeState: TraceApi.SubmissionTypeState;
}
",
                    "name": "GetSubmissionStateResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface GetTraceResponsesPageRequest {
  offset?: number;
}
",
                    "name": "GetTraceResponsesPageRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GradedResponse {
  submissionId: TraceApi.SubmissionId;
  testCases: Record<string, TraceApi.TestCaseResultWithStdout>;
}
",
                    "name": "GradedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GradedResponseV2 {
  submissionId: TraceApi.SubmissionId;
  testCases: Record<TraceApi.v2.TestCaseId, TraceApi.TestCaseGrade>;
}
",
                    "name": "GradedResponseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GradedTestCaseUpdate {
  testCaseId: TraceApi.v2.TestCaseId;
  grade: TraceApi.TestCaseGrade;
}
",
                    "name": "GradedTestCaseUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface InitializeProblemRequest {
  problemId: TraceApi.ProblemId;
  problemVersion?: number;
}
",
                    "name": "InitializeProblemRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface InternalError {
  exceptionInfo: TraceApi.ExceptionInfo;
}
",
                    "name": "InternalError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type InvalidRequestCause =
  /**
   * The submission request references a submission id that doesn't exist. */
  | TraceApi.InvalidRequestCause.SubmissionIdNotFound
  | TraceApi.InvalidRequestCause.CustomTestCasesUnsupported
  /**
   * The submission request was routed to an incorrect language executor. */
  | TraceApi.InvalidRequestCause.UnexpectedLanguage
  | TraceApi.InvalidRequestCause._Unknown;

export declare namespace InvalidRequestCause {
  interface SubmissionIdNotFound extends TraceApi.SubmissionIdNotFound, _Utils {
    type: \\"submissionIdNotFound\\";
  }

  interface CustomTestCasesUnsupported extends TraceApi.CustomTestCasesUnsupported, _Utils {
    type: \\"customTestCasesUnsupported\\";
  }

  interface UnexpectedLanguage extends TraceApi.UnexpectedLanguageError, _Utils {
    type: \\"unexpectedLanguage\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.InvalidRequestCause._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    submissionIdNotFound: (value: TraceApi.SubmissionIdNotFound) => _Result;
    customTestCasesUnsupported: (value: TraceApi.CustomTestCasesUnsupported) => _Result;
    unexpectedLanguage: (value: TraceApi.UnexpectedLanguageError) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const InvalidRequestCause = {
  submissionIdNotFound: (value: TraceApi.SubmissionIdNotFound): TraceApi.InvalidRequestCause.SubmissionIdNotFound => {
    const valueWithoutVisit: Omit<TraceApi.InvalidRequestCause.SubmissionIdNotFound, \\"_visit\\"> = {
      ...value,
      type: \\"submissionIdNotFound\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.InvalidRequestCause.SubmissionIdNotFound, visitor: TraceApi.InvalidRequestCause._Visitor<_Result>) {
      return TraceApi.InvalidRequestCause._visit(this, visitor);
    });
  },

  customTestCasesUnsupported: (
    value: TraceApi.CustomTestCasesUnsupported
  ): TraceApi.InvalidRequestCause.CustomTestCasesUnsupported => {
    const valueWithoutVisit: Omit<TraceApi.InvalidRequestCause.CustomTestCasesUnsupported, \\"_visit\\"> = {
      ...value,
      type: \\"customTestCasesUnsupported\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.InvalidRequestCause.CustomTestCasesUnsupported, visitor: TraceApi.InvalidRequestCause._Visitor<_Result>) {
      return TraceApi.InvalidRequestCause._visit(this, visitor);
    });
  },

  unexpectedLanguage: (value: TraceApi.UnexpectedLanguageError): TraceApi.InvalidRequestCause.UnexpectedLanguage => {
    const valueWithoutVisit: Omit<TraceApi.InvalidRequestCause.UnexpectedLanguage, \\"_visit\\"> = {
      ...value,
      type: \\"unexpectedLanguage\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.InvalidRequestCause.UnexpectedLanguage, visitor: TraceApi.InvalidRequestCause._Visitor<_Result>) {
      return TraceApi.InvalidRequestCause._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.InvalidRequestCause._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.InvalidRequestCause._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.InvalidRequestCause._Unknown, visitor: TraceApi.InvalidRequestCause._Visitor<_Result>) {
      return TraceApi.InvalidRequestCause._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.InvalidRequestCause,
    visitor: TraceApi.InvalidRequestCause._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"submissionIdNotFound\\":
        return visitor.submissionIdNotFound(value);
      case \\"customTestCasesUnsupported\\":
        return visitor.customTestCasesUnsupported(value);
      case \\"unexpectedLanguage\\":
        return visitor.unexpectedLanguage(value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "InvalidRequestCause.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface InvalidRequestResponse {
  request: TraceApi.SubmissionRequest;
  cause: TraceApi.InvalidRequestCause;
}
",
                    "name": "InvalidRequestResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface LightweightStackframeInformation {
  numStackFrames: number;
  topStackFrameMethodName: string;
}
",
                    "name": "LightweightStackframeInformation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface RecordedResponseNotification {
  submissionId: TraceApi.SubmissionId;
  traceResponsesSize: number;
  testCaseId?: string;
}
",
                    "name": "RecordedResponseNotification.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface RecordedTestCaseUpdate {
  testCaseId: TraceApi.v2.TestCaseId;
  traceResponsesSize: number;
}
",
                    "name": "RecordedTestCaseUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface RecordingResponseNotification {
  submissionId: TraceApi.SubmissionId;
  testCaseId?: string;
  lineNumber: number;
  lightweightStackInfo: TraceApi.LightweightStackframeInformation;
  tracedFile?: TraceApi.TracedFile;
}
",
                    "name": "RecordingResponseNotification.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface RunningResponse {
  submissionId: TraceApi.SubmissionId;
  state: TraceApi.RunningSubmissionState;
}
",
                    "name": "RunningResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export type RunningSubmissionState =
  | \\"QUEUEING_SUBMISSION\\"
  | \\"KILLING_HISTORICAL_SUBMISSIONS\\"
  | \\"WRITING_SUBMISSION_TO_FILE\\"
  | \\"COMPILING_SUBMISSION\\"
  | \\"RUNNING_SUBMISSION\\";

export const RunningSubmissionState = {
  QueueingSubmission: \\"QUEUEING_SUBMISSION\\",
  KillingHistoricalSubmissions: \\"KILLING_HISTORICAL_SUBMISSIONS\\",
  WritingSubmissionToFile: \\"WRITING_SUBMISSION_TO_FILE\\",
  CompilingSubmission: \\"COMPILING_SUBMISSION\\",
  RunningSubmission: \\"RUNNING_SUBMISSION\\",
} as const;
",
                    "name": "RunningSubmissionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface RuntimeError {
  message: string;
}
",
                    "name": "RuntimeError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface Scope {
  variables: Record<string, TraceApi.DebugVariableValue>;
}
",
                    "name": "Scope.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type ShareId = string & {
  ShareId: void;
};

export function ShareId(value: string): TraceApi.ShareId {
  return value as unknown as TraceApi.ShareId;
}
",
                    "name": "ShareId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface StackFrame {
  methodName: string;
  lineNumber: number;
  scopes: TraceApi.Scope[];
}
",
                    "name": "StackFrame.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface StackInformation {
  numStackFrames: number;
  topStackFrame?: TraceApi.StackFrame;
}
",
                    "name": "StackInformation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface StderrResponse {
  submissionId: TraceApi.SubmissionId;
  stderr: string;
}
",
                    "name": "StderrResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface StdoutResponse {
  submissionId: TraceApi.SubmissionId;
  stdout: string;
}
",
                    "name": "StdoutResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface StopRequest {
  submissionId: TraceApi.SubmissionId;
}
",
                    "name": "StopRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface StoppedResponse {
  submissionId: TraceApi.SubmissionId;
}
",
                    "name": "StoppedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface SubmissionFileInfo {
  directory: string;
  filename: string;
  contents: string;
}
",
                    "name": "SubmissionFileInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type SubmissionId = string & {
  SubmissionId: void;
};

export function SubmissionId(value: string): TraceApi.SubmissionId {
  return value as unknown as TraceApi.SubmissionId;
}
",
                    "name": "SubmissionId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface SubmissionIdNotFound {
  missingSubmissionId: TraceApi.SubmissionId;
}
",
                    "name": "SubmissionIdNotFound.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type SubmissionRequest =
  | TraceApi.SubmissionRequest.InitializeProblemRequest
  | TraceApi.SubmissionRequest.InitializeWorkspaceRequest
  | TraceApi.SubmissionRequest.SubmitV2
  | TraceApi.SubmissionRequest.WorkspaceSubmit
  | TraceApi.SubmissionRequest.Stop
  | TraceApi.SubmissionRequest._Unknown;

export declare namespace SubmissionRequest {
  interface InitializeProblemRequest extends TraceApi.InitializeProblemRequest, _Utils {
    type: \\"initializeProblemRequest\\";
  }

  interface InitializeWorkspaceRequest extends _Utils {
    type: \\"initializeWorkspaceRequest\\";
  }

  interface SubmitV2 extends TraceApi.SubmitRequestV2, _Utils {
    type: \\"submitV2\\";
  }

  interface WorkspaceSubmit extends TraceApi.WorkspaceSubmitRequest, _Utils {
    type: \\"workspaceSubmit\\";
  }

  interface Stop extends TraceApi.StopRequest, _Utils {
    type: \\"stop\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.SubmissionRequest._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    initializeProblemRequest: (value: TraceApi.InitializeProblemRequest) => _Result;
    initializeWorkspaceRequest: () => _Result;
    submitV2: (value: TraceApi.SubmitRequestV2) => _Result;
    workspaceSubmit: (value: TraceApi.WorkspaceSubmitRequest) => _Result;
    stop: (value: TraceApi.StopRequest) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const SubmissionRequest = {
  initializeProblemRequest: (
    value: TraceApi.InitializeProblemRequest
  ): TraceApi.SubmissionRequest.InitializeProblemRequest => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionRequest.InitializeProblemRequest, \\"_visit\\"> = {
      ...value,
      type: \\"initializeProblemRequest\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionRequest.InitializeProblemRequest, visitor: TraceApi.SubmissionRequest._Visitor<_Result>) {
      return TraceApi.SubmissionRequest._visit(this, visitor);
    });
  },

  initializeWorkspaceRequest: (): TraceApi.SubmissionRequest.InitializeWorkspaceRequest => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionRequest.InitializeWorkspaceRequest, \\"_visit\\"> = {
      type: \\"initializeWorkspaceRequest\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionRequest.InitializeWorkspaceRequest, visitor: TraceApi.SubmissionRequest._Visitor<_Result>) {
      return TraceApi.SubmissionRequest._visit(this, visitor);
    });
  },

  submitV2: (value: TraceApi.SubmitRequestV2): TraceApi.SubmissionRequest.SubmitV2 => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionRequest.SubmitV2, \\"_visit\\"> = {
      ...value,
      type: \\"submitV2\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionRequest.SubmitV2, visitor: TraceApi.SubmissionRequest._Visitor<_Result>) {
      return TraceApi.SubmissionRequest._visit(this, visitor);
    });
  },

  workspaceSubmit: (value: TraceApi.WorkspaceSubmitRequest): TraceApi.SubmissionRequest.WorkspaceSubmit => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionRequest.WorkspaceSubmit, \\"_visit\\"> = {
      ...value,
      type: \\"workspaceSubmit\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionRequest.WorkspaceSubmit, visitor: TraceApi.SubmissionRequest._Visitor<_Result>) {
      return TraceApi.SubmissionRequest._visit(this, visitor);
    });
  },

  stop: (value: TraceApi.StopRequest): TraceApi.SubmissionRequest.Stop => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionRequest.Stop, \\"_visit\\"> = {
      ...value,
      type: \\"stop\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionRequest.Stop, visitor: TraceApi.SubmissionRequest._Visitor<_Result>) {
      return TraceApi.SubmissionRequest._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.SubmissionRequest._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.SubmissionRequest._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionRequest._Unknown, visitor: TraceApi.SubmissionRequest._Visitor<_Result>) {
      return TraceApi.SubmissionRequest._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.SubmissionRequest,
    visitor: TraceApi.SubmissionRequest._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"initializeProblemRequest\\":
        return visitor.initializeProblemRequest(value);
      case \\"initializeWorkspaceRequest\\":
        return visitor.initializeWorkspaceRequest();
      case \\"submitV2\\":
        return visitor.submitV2(value);
      case \\"workspaceSubmit\\":
        return visitor.workspaceSubmit(value);
      case \\"stop\\":
        return visitor.stop(value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "SubmissionRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type SubmissionResponse =
  | TraceApi.SubmissionResponse.ServerInitialized
  | TraceApi.SubmissionResponse.ProblemInitialized
  | TraceApi.SubmissionResponse.WorkspaceInitialized
  | TraceApi.SubmissionResponse.ServerErrored
  | TraceApi.SubmissionResponse.CodeExecutionUpdate
  | TraceApi.SubmissionResponse.Terminated
  | TraceApi.SubmissionResponse._Unknown;

export declare namespace SubmissionResponse {
  interface ServerInitialized extends _Utils {
    type: \\"serverInitialized\\";
  }

  interface ProblemInitialized extends _Utils {
    type: \\"problemInitialized\\";
    value: TraceApi.ProblemId;
  }

  interface WorkspaceInitialized extends _Utils {
    type: \\"workspaceInitialized\\";
  }

  interface ServerErrored extends TraceApi.ExceptionInfo, _Utils {
    type: \\"serverErrored\\";
  }

  interface CodeExecutionUpdate extends _Utils {
    type: \\"codeExecutionUpdate\\";
    value: TraceApi.CodeExecutionUpdate;
  }

  interface Terminated extends TraceApi.TerminatedResponse, _Utils {
    type: \\"terminated\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.SubmissionResponse._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    serverInitialized: () => _Result;
    problemInitialized: (value: TraceApi.ProblemId) => _Result;
    workspaceInitialized: () => _Result;
    serverErrored: (value: TraceApi.ExceptionInfo) => _Result;
    codeExecutionUpdate: (value: TraceApi.CodeExecutionUpdate) => _Result;
    terminated: (value: TraceApi.TerminatedResponse) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const SubmissionResponse = {
  serverInitialized: (): TraceApi.SubmissionResponse.ServerInitialized => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionResponse.ServerInitialized, \\"_visit\\"> = {
      type: \\"serverInitialized\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionResponse.ServerInitialized, visitor: TraceApi.SubmissionResponse._Visitor<_Result>) {
      return TraceApi.SubmissionResponse._visit(this, visitor);
    });
  },

  problemInitialized: (value: TraceApi.ProblemId): TraceApi.SubmissionResponse.ProblemInitialized => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionResponse.ProblemInitialized, \\"_visit\\"> = {
      value: value,
      type: \\"problemInitialized\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionResponse.ProblemInitialized, visitor: TraceApi.SubmissionResponse._Visitor<_Result>) {
      return TraceApi.SubmissionResponse._visit(this, visitor);
    });
  },

  workspaceInitialized: (): TraceApi.SubmissionResponse.WorkspaceInitialized => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionResponse.WorkspaceInitialized, \\"_visit\\"> = {
      type: \\"workspaceInitialized\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionResponse.WorkspaceInitialized, visitor: TraceApi.SubmissionResponse._Visitor<_Result>) {
      return TraceApi.SubmissionResponse._visit(this, visitor);
    });
  },

  serverErrored: (value: TraceApi.ExceptionInfo): TraceApi.SubmissionResponse.ServerErrored => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionResponse.ServerErrored, \\"_visit\\"> = {
      ...value,
      type: \\"serverErrored\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionResponse.ServerErrored, visitor: TraceApi.SubmissionResponse._Visitor<_Result>) {
      return TraceApi.SubmissionResponse._visit(this, visitor);
    });
  },

  codeExecutionUpdate: (value: TraceApi.CodeExecutionUpdate): TraceApi.SubmissionResponse.CodeExecutionUpdate => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionResponse.CodeExecutionUpdate, \\"_visit\\"> = {
      value: value,
      type: \\"codeExecutionUpdate\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionResponse.CodeExecutionUpdate, visitor: TraceApi.SubmissionResponse._Visitor<_Result>) {
      return TraceApi.SubmissionResponse._visit(this, visitor);
    });
  },

  terminated: (value: TraceApi.TerminatedResponse): TraceApi.SubmissionResponse.Terminated => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionResponse.Terminated, \\"_visit\\"> = {
      ...value,
      type: \\"terminated\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionResponse.Terminated, visitor: TraceApi.SubmissionResponse._Visitor<_Result>) {
      return TraceApi.SubmissionResponse._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.SubmissionResponse._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.SubmissionResponse._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionResponse._Unknown, visitor: TraceApi.SubmissionResponse._Visitor<_Result>) {
      return TraceApi.SubmissionResponse._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.SubmissionResponse,
    visitor: TraceApi.SubmissionResponse._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"serverInitialized\\":
        return visitor.serverInitialized();
      case \\"problemInitialized\\":
        return visitor.problemInitialized(value.value);
      case \\"workspaceInitialized\\":
        return visitor.workspaceInitialized();
      case \\"serverErrored\\":
        return visitor.serverErrored(value);
      case \\"codeExecutionUpdate\\":
        return visitor.codeExecutionUpdate(value.value);
      case \\"terminated\\":
        return visitor.terminated(value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "SubmissionResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type SubmissionStatusForTestCase =
  | TraceApi.SubmissionStatusForTestCase.Graded
  | TraceApi.SubmissionStatusForTestCase.GradedV2
  | TraceApi.SubmissionStatusForTestCase.Traced
  | TraceApi.SubmissionStatusForTestCase._Unknown;

export declare namespace SubmissionStatusForTestCase {
  interface Graded extends TraceApi.TestCaseResultWithStdout, _Utils {
    type: \\"graded\\";
  }

  interface GradedV2 extends _Utils {
    type: \\"gradedV2\\";
    value: TraceApi.TestCaseGrade;
  }

  interface Traced extends TraceApi.TracedTestCase, _Utils {
    type: \\"traced\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.SubmissionStatusForTestCase._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    graded: (value: TraceApi.TestCaseResultWithStdout) => _Result;
    gradedV2: (value: TraceApi.TestCaseGrade) => _Result;
    traced: (value: TraceApi.TracedTestCase) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const SubmissionStatusForTestCase = {
  graded: (value: TraceApi.TestCaseResultWithStdout): TraceApi.SubmissionStatusForTestCase.Graded => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionStatusForTestCase.Graded, \\"_visit\\"> = {
      ...value,
      type: \\"graded\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionStatusForTestCase.Graded, visitor: TraceApi.SubmissionStatusForTestCase._Visitor<_Result>) {
      return TraceApi.SubmissionStatusForTestCase._visit(this, visitor);
    });
  },

  gradedV2: (value: TraceApi.TestCaseGrade): TraceApi.SubmissionStatusForTestCase.GradedV2 => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionStatusForTestCase.GradedV2, \\"_visit\\"> = {
      value: value,
      type: \\"gradedV2\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionStatusForTestCase.GradedV2, visitor: TraceApi.SubmissionStatusForTestCase._Visitor<_Result>) {
      return TraceApi.SubmissionStatusForTestCase._visit(this, visitor);
    });
  },

  traced: (value: TraceApi.TracedTestCase): TraceApi.SubmissionStatusForTestCase.Traced => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionStatusForTestCase.Traced, \\"_visit\\"> = {
      ...value,
      type: \\"traced\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionStatusForTestCase.Traced, visitor: TraceApi.SubmissionStatusForTestCase._Visitor<_Result>) {
      return TraceApi.SubmissionStatusForTestCase._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.SubmissionStatusForTestCase._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.SubmissionStatusForTestCase._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionStatusForTestCase._Unknown, visitor: TraceApi.SubmissionStatusForTestCase._Visitor<_Result>) {
      return TraceApi.SubmissionStatusForTestCase._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.SubmissionStatusForTestCase,
    visitor: TraceApi.SubmissionStatusForTestCase._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"graded\\":
        return visitor.graded(value);
      case \\"gradedV2\\":
        return visitor.gradedV2(value.value);
      case \\"traced\\":
        return visitor.traced(value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "SubmissionStatusForTestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type SubmissionStatusV2 =
  | TraceApi.SubmissionStatusV2.Test
  | TraceApi.SubmissionStatusV2.Workspace
  | TraceApi.SubmissionStatusV2._Unknown;

export declare namespace SubmissionStatusV2 {
  interface Test extends TraceApi.TestSubmissionStatusV2, _Utils {
    type: \\"test\\";
  }

  interface Workspace extends TraceApi.WorkspaceSubmissionStatusV2, _Utils {
    type: \\"workspace\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.SubmissionStatusV2._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    test: (value: TraceApi.TestSubmissionStatusV2) => _Result;
    workspace: (value: TraceApi.WorkspaceSubmissionStatusV2) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const SubmissionStatusV2 = {
  test: (value: TraceApi.TestSubmissionStatusV2): TraceApi.SubmissionStatusV2.Test => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionStatusV2.Test, \\"_visit\\"> = {
      ...value,
      type: \\"test\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionStatusV2.Test, visitor: TraceApi.SubmissionStatusV2._Visitor<_Result>) {
      return TraceApi.SubmissionStatusV2._visit(this, visitor);
    });
  },

  workspace: (value: TraceApi.WorkspaceSubmissionStatusV2): TraceApi.SubmissionStatusV2.Workspace => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionStatusV2.Workspace, \\"_visit\\"> = {
      ...value,
      type: \\"workspace\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionStatusV2.Workspace, visitor: TraceApi.SubmissionStatusV2._Visitor<_Result>) {
      return TraceApi.SubmissionStatusV2._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.SubmissionStatusV2._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.SubmissionStatusV2._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionStatusV2._Unknown, visitor: TraceApi.SubmissionStatusV2._Visitor<_Result>) {
      return TraceApi.SubmissionStatusV2._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.SubmissionStatusV2,
    visitor: TraceApi.SubmissionStatusV2._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"test\\":
        return visitor.test(value);
      case \\"workspace\\":
        return visitor.workspace(value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "SubmissionStatusV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

/**
 * Keep in sync with SubmissionType.
 */
export type SubmissionTypeEnum = \\"TEST\\";

export const SubmissionTypeEnum = {
  Test: \\"TEST\\",
} as const;
",
                    "name": "SubmissionTypeEnum.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type SubmissionTypeState =
  | TraceApi.SubmissionTypeState.Test
  | TraceApi.SubmissionTypeState.Workspace
  | TraceApi.SubmissionTypeState._Unknown;

export declare namespace SubmissionTypeState {
  interface Test extends TraceApi.TestSubmissionState, _Utils {
    type: \\"test\\";
  }

  interface Workspace extends TraceApi.WorkspaceSubmissionState, _Utils {
    type: \\"workspace\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.SubmissionTypeState._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    test: (value: TraceApi.TestSubmissionState) => _Result;
    workspace: (value: TraceApi.WorkspaceSubmissionState) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const SubmissionTypeState = {
  test: (value: TraceApi.TestSubmissionState): TraceApi.SubmissionTypeState.Test => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionTypeState.Test, \\"_visit\\"> = {
      ...value,
      type: \\"test\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionTypeState.Test, visitor: TraceApi.SubmissionTypeState._Visitor<_Result>) {
      return TraceApi.SubmissionTypeState._visit(this, visitor);
    });
  },

  workspace: (value: TraceApi.WorkspaceSubmissionState): TraceApi.SubmissionTypeState.Workspace => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionTypeState.Workspace, \\"_visit\\"> = {
      ...value,
      type: \\"workspace\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionTypeState.Workspace, visitor: TraceApi.SubmissionTypeState._Visitor<_Result>) {
      return TraceApi.SubmissionTypeState._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.SubmissionTypeState._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.SubmissionTypeState._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionTypeState._Unknown, visitor: TraceApi.SubmissionTypeState._Visitor<_Result>) {
      return TraceApi.SubmissionTypeState._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.SubmissionTypeState,
    visitor: TraceApi.SubmissionTypeState._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"test\\":
        return visitor.test(value);
      case \\"workspace\\":
        return visitor.workspace(value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "SubmissionTypeState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface SubmitRequestV2 {
  submissionId: TraceApi.SubmissionId;
  language: TraceApi.Language;
  submissionFiles: TraceApi.SubmissionFileInfo[];
  problemId: TraceApi.ProblemId;
  problemVersion?: number;
  userId?: string;
}
",
                    "name": "SubmitRequestV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface TerminatedResponse {}
",
                    "name": "TerminatedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type TestCaseGrade =
  | TraceApi.TestCaseGrade.Hidden
  | TraceApi.TestCaseGrade.NonHidden
  | TraceApi.TestCaseGrade._Unknown;

export declare namespace TestCaseGrade {
  interface Hidden extends TraceApi.TestCaseHiddenGrade, _Utils {
    type: \\"hidden\\";
  }

  interface NonHidden extends TraceApi.TestCaseNonHiddenGrade, _Utils {
    type: \\"nonHidden\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.TestCaseGrade._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    hidden: (value: TraceApi.TestCaseHiddenGrade) => _Result;
    nonHidden: (value: TraceApi.TestCaseNonHiddenGrade) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const TestCaseGrade = {
  hidden: (value: TraceApi.TestCaseHiddenGrade): TraceApi.TestCaseGrade.Hidden => {
    const valueWithoutVisit: Omit<TraceApi.TestCaseGrade.Hidden, \\"_visit\\"> = {
      ...value,
      type: \\"hidden\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.TestCaseGrade.Hidden, visitor: TraceApi.TestCaseGrade._Visitor<_Result>) {
      return TraceApi.TestCaseGrade._visit(this, visitor);
    });
  },

  nonHidden: (value: TraceApi.TestCaseNonHiddenGrade): TraceApi.TestCaseGrade.NonHidden => {
    const valueWithoutVisit: Omit<TraceApi.TestCaseGrade.NonHidden, \\"_visit\\"> = {
      ...value,
      type: \\"nonHidden\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.TestCaseGrade.NonHidden, visitor: TraceApi.TestCaseGrade._Visitor<_Result>) {
      return TraceApi.TestCaseGrade._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.TestCaseGrade._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.TestCaseGrade._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.TestCaseGrade._Unknown, visitor: TraceApi.TestCaseGrade._Visitor<_Result>) {
      return TraceApi.TestCaseGrade._visit(this, visitor);
    });
  },

  _visit: <_Result>(value: TraceApi.TestCaseGrade, visitor: TraceApi.TestCaseGrade._Visitor<_Result>): _Result => {
    switch (value.type) {
      case \\"hidden\\":
        return visitor.hidden(value);
      case \\"nonHidden\\":
        return visitor.nonHidden(value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "TestCaseGrade.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface TestCaseHiddenGrade {
  passed: boolean;
}
",
                    "name": "TestCaseHiddenGrade.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseNonHiddenGrade {
  passed: boolean;
  actualResult?: TraceApi.VariableValue;
  exception?: TraceApi.ExceptionV2;
  stdout: string;
}
",
                    "name": "TestCaseNonHiddenGrade.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseResult {
  expectedResult: TraceApi.VariableValue;
  actualResult: TraceApi.ActualResult;
  passed: boolean;
}
",
                    "name": "TestCaseResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseResultWithStdout {
  result: TraceApi.TestCaseResult;
  stdout: string;
}
",
                    "name": "TestCaseResultWithStdout.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestSubmissionState {
  problemId: TraceApi.ProblemId;
  defaultTestCases: TraceApi.TestCase[];
  customTestCases: TraceApi.TestCase[];
  status: TraceApi.TestSubmissionStatus;
}
",
                    "name": "TestSubmissionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type TestSubmissionStatus =
  | TraceApi.TestSubmissionStatus.Stopped
  | TraceApi.TestSubmissionStatus.Errored
  | TraceApi.TestSubmissionStatus.Running
  | TraceApi.TestSubmissionStatus.TestCaseIdToState
  | TraceApi.TestSubmissionStatus._Unknown;

export declare namespace TestSubmissionStatus {
  interface Stopped extends _Utils {
    type: \\"stopped\\";
  }

  interface Errored extends _Utils {
    type: \\"errored\\";
    value: TraceApi.ErrorInfo;
  }

  interface Running extends _Utils {
    type: \\"running\\";
    value: TraceApi.RunningSubmissionState;
  }

  interface TestCaseIdToState extends _Utils {
    type: \\"testCaseIdToState\\";
    value: Record<string, TraceApi.SubmissionStatusForTestCase>;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.TestSubmissionStatus._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    stopped: () => _Result;
    errored: (value: TraceApi.ErrorInfo) => _Result;
    running: (value: TraceApi.RunningSubmissionState) => _Result;
    testCaseIdToState: (value: Record<string, TraceApi.SubmissionStatusForTestCase>) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const TestSubmissionStatus = {
  stopped: (): TraceApi.TestSubmissionStatus.Stopped => {
    const valueWithoutVisit: Omit<TraceApi.TestSubmissionStatus.Stopped, \\"_visit\\"> = {
      type: \\"stopped\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.TestSubmissionStatus.Stopped, visitor: TraceApi.TestSubmissionStatus._Visitor<_Result>) {
      return TraceApi.TestSubmissionStatus._visit(this, visitor);
    });
  },

  errored: (value: TraceApi.ErrorInfo): TraceApi.TestSubmissionStatus.Errored => {
    const valueWithoutVisit: Omit<TraceApi.TestSubmissionStatus.Errored, \\"_visit\\"> = {
      value: value,
      type: \\"errored\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.TestSubmissionStatus.Errored, visitor: TraceApi.TestSubmissionStatus._Visitor<_Result>) {
      return TraceApi.TestSubmissionStatus._visit(this, visitor);
    });
  },

  running: (value: TraceApi.RunningSubmissionState): TraceApi.TestSubmissionStatus.Running => {
    const valueWithoutVisit: Omit<TraceApi.TestSubmissionStatus.Running, \\"_visit\\"> = {
      value: value,
      type: \\"running\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.TestSubmissionStatus.Running, visitor: TraceApi.TestSubmissionStatus._Visitor<_Result>) {
      return TraceApi.TestSubmissionStatus._visit(this, visitor);
    });
  },

  testCaseIdToState: (
    value: Record<string, TraceApi.SubmissionStatusForTestCase>
  ): TraceApi.TestSubmissionStatus.TestCaseIdToState => {
    const valueWithoutVisit: Omit<TraceApi.TestSubmissionStatus.TestCaseIdToState, \\"_visit\\"> = {
      value: value,
      type: \\"testCaseIdToState\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.TestSubmissionStatus.TestCaseIdToState, visitor: TraceApi.TestSubmissionStatus._Visitor<_Result>) {
      return TraceApi.TestSubmissionStatus._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.TestSubmissionStatus._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.TestSubmissionStatus._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.TestSubmissionStatus._Unknown, visitor: TraceApi.TestSubmissionStatus._Visitor<_Result>) {
      return TraceApi.TestSubmissionStatus._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.TestSubmissionStatus,
    visitor: TraceApi.TestSubmissionStatus._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"stopped\\":
        return visitor.stopped();
      case \\"errored\\":
        return visitor.errored(value.value);
      case \\"running\\":
        return visitor.running(value.value);
      case \\"testCaseIdToState\\":
        return visitor.testCaseIdToState(value.value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "TestSubmissionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestSubmissionStatusV2 {
  updates: TraceApi.TestSubmissionUpdate[];
  problemId: TraceApi.ProblemId;
  problemVersion: number;
  problemInfo: TraceApi.v2.ProblemInfoV2;
}
",
                    "name": "TestSubmissionStatusV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestSubmissionUpdate {
  updateTime: Date;
  updateInfo: TraceApi.TestSubmissionUpdateInfo;
}
",
                    "name": "TestSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type TestSubmissionUpdateInfo =
  | TraceApi.TestSubmissionUpdateInfo.Running
  | TraceApi.TestSubmissionUpdateInfo.Stopped
  | TraceApi.TestSubmissionUpdateInfo.Errored
  | TraceApi.TestSubmissionUpdateInfo.GradedTestCase
  | TraceApi.TestSubmissionUpdateInfo.RecordedTestCase
  | TraceApi.TestSubmissionUpdateInfo.Finished
  | TraceApi.TestSubmissionUpdateInfo._Unknown;

export declare namespace TestSubmissionUpdateInfo {
  interface Running extends _Utils {
    type: \\"running\\";
    value: TraceApi.RunningSubmissionState;
  }

  interface Stopped extends _Utils {
    type: \\"stopped\\";
  }

  interface Errored extends _Utils {
    type: \\"errored\\";
    value: TraceApi.ErrorInfo;
  }

  interface GradedTestCase extends TraceApi.GradedTestCaseUpdate, _Utils {
    type: \\"gradedTestCase\\";
  }

  interface RecordedTestCase extends TraceApi.RecordedTestCaseUpdate, _Utils {
    type: \\"recordedTestCase\\";
  }

  interface Finished extends _Utils {
    type: \\"finished\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.TestSubmissionUpdateInfo._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    running: (value: TraceApi.RunningSubmissionState) => _Result;
    stopped: () => _Result;
    errored: (value: TraceApi.ErrorInfo) => _Result;
    gradedTestCase: (value: TraceApi.GradedTestCaseUpdate) => _Result;
    recordedTestCase: (value: TraceApi.RecordedTestCaseUpdate) => _Result;
    finished: () => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const TestSubmissionUpdateInfo = {
  running: (value: TraceApi.RunningSubmissionState): TraceApi.TestSubmissionUpdateInfo.Running => {
    const valueWithoutVisit: Omit<TraceApi.TestSubmissionUpdateInfo.Running, \\"_visit\\"> = {
      value: value,
      type: \\"running\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.TestSubmissionUpdateInfo.Running, visitor: TraceApi.TestSubmissionUpdateInfo._Visitor<_Result>) {
      return TraceApi.TestSubmissionUpdateInfo._visit(this, visitor);
    });
  },

  stopped: (): TraceApi.TestSubmissionUpdateInfo.Stopped => {
    const valueWithoutVisit: Omit<TraceApi.TestSubmissionUpdateInfo.Stopped, \\"_visit\\"> = {
      type: \\"stopped\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.TestSubmissionUpdateInfo.Stopped, visitor: TraceApi.TestSubmissionUpdateInfo._Visitor<_Result>) {
      return TraceApi.TestSubmissionUpdateInfo._visit(this, visitor);
    });
  },

  errored: (value: TraceApi.ErrorInfo): TraceApi.TestSubmissionUpdateInfo.Errored => {
    const valueWithoutVisit: Omit<TraceApi.TestSubmissionUpdateInfo.Errored, \\"_visit\\"> = {
      value: value,
      type: \\"errored\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.TestSubmissionUpdateInfo.Errored, visitor: TraceApi.TestSubmissionUpdateInfo._Visitor<_Result>) {
      return TraceApi.TestSubmissionUpdateInfo._visit(this, visitor);
    });
  },

  gradedTestCase: (value: TraceApi.GradedTestCaseUpdate): TraceApi.TestSubmissionUpdateInfo.GradedTestCase => {
    const valueWithoutVisit: Omit<TraceApi.TestSubmissionUpdateInfo.GradedTestCase, \\"_visit\\"> = {
      ...value,
      type: \\"gradedTestCase\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.TestSubmissionUpdateInfo.GradedTestCase, visitor: TraceApi.TestSubmissionUpdateInfo._Visitor<_Result>) {
      return TraceApi.TestSubmissionUpdateInfo._visit(this, visitor);
    });
  },

  recordedTestCase: (value: TraceApi.RecordedTestCaseUpdate): TraceApi.TestSubmissionUpdateInfo.RecordedTestCase => {
    const valueWithoutVisit: Omit<TraceApi.TestSubmissionUpdateInfo.RecordedTestCase, \\"_visit\\"> = {
      ...value,
      type: \\"recordedTestCase\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.TestSubmissionUpdateInfo.RecordedTestCase, visitor: TraceApi.TestSubmissionUpdateInfo._Visitor<_Result>) {
      return TraceApi.TestSubmissionUpdateInfo._visit(this, visitor);
    });
  },

  finished: (): TraceApi.TestSubmissionUpdateInfo.Finished => {
    const valueWithoutVisit: Omit<TraceApi.TestSubmissionUpdateInfo.Finished, \\"_visit\\"> = {
      type: \\"finished\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.TestSubmissionUpdateInfo.Finished, visitor: TraceApi.TestSubmissionUpdateInfo._Visitor<_Result>) {
      return TraceApi.TestSubmissionUpdateInfo._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.TestSubmissionUpdateInfo._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.TestSubmissionUpdateInfo._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.TestSubmissionUpdateInfo._Unknown, visitor: TraceApi.TestSubmissionUpdateInfo._Visitor<_Result>) {
      return TraceApi.TestSubmissionUpdateInfo._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.TestSubmissionUpdateInfo,
    visitor: TraceApi.TestSubmissionUpdateInfo._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"running\\":
        return visitor.running(value.value);
      case \\"stopped\\":
        return visitor.stopped();
      case \\"errored\\":
        return visitor.errored(value.value);
      case \\"gradedTestCase\\":
        return visitor.gradedTestCase(value);
      case \\"recordedTestCase\\":
        return visitor.recordedTestCase(value);
      case \\"finished\\":
        return visitor.finished();
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "TestSubmissionUpdateInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TraceResponse {
  submissionId: TraceApi.SubmissionId;
  lineNumber: number;
  returnValue?: TraceApi.DebugVariableValue;
  expressionLocation?: TraceApi.ExpressionLocation;
  stack: TraceApi.StackInformation;
  stdout?: string;
}
",
                    "name": "TraceResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TraceResponseV2 {
  submissionId: TraceApi.SubmissionId;
  lineNumber: number;
  file: TraceApi.TracedFile;
  returnValue?: TraceApi.DebugVariableValue;
  expressionLocation?: TraceApi.ExpressionLocation;
  stack: TraceApi.StackInformation;
  stdout?: string;
}
",
                    "name": "TraceResponseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TraceResponsesPage {
  /**
   * If present, use this to load subseqent pages.
   * The offset is the id of the next trace response to load.
   *
   */
  offset?: number;
  traceResponses: TraceApi.TraceResponse[];
}
",
                    "name": "TraceResponsesPage.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TraceResponsesPageV2 {
  /**
   * If present, use this to load subseqent pages.
   * The offset is the id of the next trace response to load.
   *
   */
  offset?: number;
  traceResponses: TraceApi.TraceResponseV2[];
}
",
                    "name": "TraceResponsesPageV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface TracedFile {
  filename: string;
  directory: string;
}
",
                    "name": "TracedFile.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TracedTestCase {
  result: TraceApi.TestCaseResultWithStdout;
  traceResponsesSize: number;
}
",
                    "name": "TracedTestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface UnexpectedLanguageError {
  expectedLanguage: TraceApi.Language;
  actualLanguage: TraceApi.Language;
}
",
                    "name": "UnexpectedLanguageError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface WorkspaceFiles {
  mainFile: TraceApi.FileInfo;
  readOnlyFiles: TraceApi.FileInfo[];
}
",
                    "name": "WorkspaceFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface WorkspaceRanResponse {
  submissionId: TraceApi.SubmissionId;
  runDetails: TraceApi.WorkspaceRunDetails;
}
",
                    "name": "WorkspaceRanResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface WorkspaceRunDetails {
  exceptionV2?: TraceApi.ExceptionV2;
  exception?: TraceApi.ExceptionInfo;
  stdout: string;
}
",
                    "name": "WorkspaceRunDetails.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface WorkspaceStarterFilesResponse {
  files: Record<TraceApi.Language, TraceApi.WorkspaceFiles>;
}
",
                    "name": "WorkspaceStarterFilesResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface WorkspaceStarterFilesResponseV2 {
  filesByLanguage: Record<TraceApi.Language, TraceApi.v2.Files>;
}
",
                    "name": "WorkspaceStarterFilesResponseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface WorkspaceSubmissionState {
  status: TraceApi.WorkspaceSubmissionStatus;
}
",
                    "name": "WorkspaceSubmissionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type WorkspaceSubmissionStatus =
  | TraceApi.WorkspaceSubmissionStatus.Stopped
  | TraceApi.WorkspaceSubmissionStatus.Errored
  | TraceApi.WorkspaceSubmissionStatus.Running
  | TraceApi.WorkspaceSubmissionStatus.Ran
  | TraceApi.WorkspaceSubmissionStatus.Traced
  | TraceApi.WorkspaceSubmissionStatus._Unknown;

export declare namespace WorkspaceSubmissionStatus {
  interface Stopped extends _Utils {
    type: \\"stopped\\";
  }

  interface Errored extends _Utils {
    type: \\"errored\\";
    value: TraceApi.ErrorInfo;
  }

  interface Running extends _Utils {
    type: \\"running\\";
    value: TraceApi.RunningSubmissionState;
  }

  interface Ran extends TraceApi.WorkspaceRunDetails, _Utils {
    type: \\"ran\\";
  }

  interface Traced extends TraceApi.WorkspaceRunDetails, _Utils {
    type: \\"traced\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.WorkspaceSubmissionStatus._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    stopped: () => _Result;
    errored: (value: TraceApi.ErrorInfo) => _Result;
    running: (value: TraceApi.RunningSubmissionState) => _Result;
    ran: (value: TraceApi.WorkspaceRunDetails) => _Result;
    traced: (value: TraceApi.WorkspaceRunDetails) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const WorkspaceSubmissionStatus = {
  stopped: (): TraceApi.WorkspaceSubmissionStatus.Stopped => {
    const valueWithoutVisit: Omit<TraceApi.WorkspaceSubmissionStatus.Stopped, \\"_visit\\"> = {
      type: \\"stopped\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.WorkspaceSubmissionStatus.Stopped, visitor: TraceApi.WorkspaceSubmissionStatus._Visitor<_Result>) {
      return TraceApi.WorkspaceSubmissionStatus._visit(this, visitor);
    });
  },

  errored: (value: TraceApi.ErrorInfo): TraceApi.WorkspaceSubmissionStatus.Errored => {
    const valueWithoutVisit: Omit<TraceApi.WorkspaceSubmissionStatus.Errored, \\"_visit\\"> = {
      value: value,
      type: \\"errored\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.WorkspaceSubmissionStatus.Errored, visitor: TraceApi.WorkspaceSubmissionStatus._Visitor<_Result>) {
      return TraceApi.WorkspaceSubmissionStatus._visit(this, visitor);
    });
  },

  running: (value: TraceApi.RunningSubmissionState): TraceApi.WorkspaceSubmissionStatus.Running => {
    const valueWithoutVisit: Omit<TraceApi.WorkspaceSubmissionStatus.Running, \\"_visit\\"> = {
      value: value,
      type: \\"running\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.WorkspaceSubmissionStatus.Running, visitor: TraceApi.WorkspaceSubmissionStatus._Visitor<_Result>) {
      return TraceApi.WorkspaceSubmissionStatus._visit(this, visitor);
    });
  },

  ran: (value: TraceApi.WorkspaceRunDetails): TraceApi.WorkspaceSubmissionStatus.Ran => {
    const valueWithoutVisit: Omit<TraceApi.WorkspaceSubmissionStatus.Ran, \\"_visit\\"> = {
      ...value,
      type: \\"ran\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.WorkspaceSubmissionStatus.Ran, visitor: TraceApi.WorkspaceSubmissionStatus._Visitor<_Result>) {
      return TraceApi.WorkspaceSubmissionStatus._visit(this, visitor);
    });
  },

  traced: (value: TraceApi.WorkspaceRunDetails): TraceApi.WorkspaceSubmissionStatus.Traced => {
    const valueWithoutVisit: Omit<TraceApi.WorkspaceSubmissionStatus.Traced, \\"_visit\\"> = {
      ...value,
      type: \\"traced\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.WorkspaceSubmissionStatus.Traced, visitor: TraceApi.WorkspaceSubmissionStatus._Visitor<_Result>) {
      return TraceApi.WorkspaceSubmissionStatus._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.WorkspaceSubmissionStatus._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.WorkspaceSubmissionStatus._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.WorkspaceSubmissionStatus._Unknown, visitor: TraceApi.WorkspaceSubmissionStatus._Visitor<_Result>) {
      return TraceApi.WorkspaceSubmissionStatus._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.WorkspaceSubmissionStatus,
    visitor: TraceApi.WorkspaceSubmissionStatus._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"stopped\\":
        return visitor.stopped();
      case \\"errored\\":
        return visitor.errored(value.value);
      case \\"running\\":
        return visitor.running(value.value);
      case \\"ran\\":
        return visitor.ran(value);
      case \\"traced\\":
        return visitor.traced(value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "WorkspaceSubmissionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface WorkspaceSubmissionStatusV2 {
  updates: TraceApi.WorkspaceSubmissionUpdate[];
}
",
                    "name": "WorkspaceSubmissionStatusV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface WorkspaceSubmissionUpdate {
  updateTime: Date;
  updateInfo: TraceApi.WorkspaceSubmissionUpdateInfo;
}
",
                    "name": "WorkspaceSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type WorkspaceSubmissionUpdateInfo =
  | TraceApi.WorkspaceSubmissionUpdateInfo.Running
  | TraceApi.WorkspaceSubmissionUpdateInfo.Ran
  | TraceApi.WorkspaceSubmissionUpdateInfo.Stopped
  | TraceApi.WorkspaceSubmissionUpdateInfo.Traced
  | TraceApi.WorkspaceSubmissionUpdateInfo.TracedV2
  | TraceApi.WorkspaceSubmissionUpdateInfo.Errored
  | TraceApi.WorkspaceSubmissionUpdateInfo.Finished
  | TraceApi.WorkspaceSubmissionUpdateInfo._Unknown;

export declare namespace WorkspaceSubmissionUpdateInfo {
  interface Running extends _Utils {
    type: \\"running\\";
    value: TraceApi.RunningSubmissionState;
  }

  interface Ran extends TraceApi.WorkspaceRunDetails, _Utils {
    type: \\"ran\\";
  }

  interface Stopped extends _Utils {
    type: \\"stopped\\";
  }

  interface Traced extends _Utils {
    type: \\"traced\\";
  }

  interface TracedV2 extends TraceApi.WorkspaceTracedUpdate, _Utils {
    type: \\"tracedV2\\";
  }

  interface Errored extends _Utils {
    type: \\"errored\\";
    value: TraceApi.ErrorInfo;
  }

  interface Finished extends _Utils {
    type: \\"finished\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.WorkspaceSubmissionUpdateInfo._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    running: (value: TraceApi.RunningSubmissionState) => _Result;
    ran: (value: TraceApi.WorkspaceRunDetails) => _Result;
    stopped: () => _Result;
    traced: () => _Result;
    tracedV2: (value: TraceApi.WorkspaceTracedUpdate) => _Result;
    errored: (value: TraceApi.ErrorInfo) => _Result;
    finished: () => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const WorkspaceSubmissionUpdateInfo = {
  running: (value: TraceApi.RunningSubmissionState): TraceApi.WorkspaceSubmissionUpdateInfo.Running => {
    const valueWithoutVisit: Omit<TraceApi.WorkspaceSubmissionUpdateInfo.Running, \\"_visit\\"> = {
      value: value,
      type: \\"running\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.WorkspaceSubmissionUpdateInfo.Running, visitor: TraceApi.WorkspaceSubmissionUpdateInfo._Visitor<_Result>) {
      return TraceApi.WorkspaceSubmissionUpdateInfo._visit(this, visitor);
    });
  },

  ran: (value: TraceApi.WorkspaceRunDetails): TraceApi.WorkspaceSubmissionUpdateInfo.Ran => {
    const valueWithoutVisit: Omit<TraceApi.WorkspaceSubmissionUpdateInfo.Ran, \\"_visit\\"> = {
      ...value,
      type: \\"ran\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.WorkspaceSubmissionUpdateInfo.Ran, visitor: TraceApi.WorkspaceSubmissionUpdateInfo._Visitor<_Result>) {
      return TraceApi.WorkspaceSubmissionUpdateInfo._visit(this, visitor);
    });
  },

  stopped: (): TraceApi.WorkspaceSubmissionUpdateInfo.Stopped => {
    const valueWithoutVisit: Omit<TraceApi.WorkspaceSubmissionUpdateInfo.Stopped, \\"_visit\\"> = {
      type: \\"stopped\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.WorkspaceSubmissionUpdateInfo.Stopped, visitor: TraceApi.WorkspaceSubmissionUpdateInfo._Visitor<_Result>) {
      return TraceApi.WorkspaceSubmissionUpdateInfo._visit(this, visitor);
    });
  },

  traced: (): TraceApi.WorkspaceSubmissionUpdateInfo.Traced => {
    const valueWithoutVisit: Omit<TraceApi.WorkspaceSubmissionUpdateInfo.Traced, \\"_visit\\"> = {
      type: \\"traced\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.WorkspaceSubmissionUpdateInfo.Traced, visitor: TraceApi.WorkspaceSubmissionUpdateInfo._Visitor<_Result>) {
      return TraceApi.WorkspaceSubmissionUpdateInfo._visit(this, visitor);
    });
  },

  tracedV2: (value: TraceApi.WorkspaceTracedUpdate): TraceApi.WorkspaceSubmissionUpdateInfo.TracedV2 => {
    const valueWithoutVisit: Omit<TraceApi.WorkspaceSubmissionUpdateInfo.TracedV2, \\"_visit\\"> = {
      ...value,
      type: \\"tracedV2\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.WorkspaceSubmissionUpdateInfo.TracedV2, visitor: TraceApi.WorkspaceSubmissionUpdateInfo._Visitor<_Result>) {
      return TraceApi.WorkspaceSubmissionUpdateInfo._visit(this, visitor);
    });
  },

  errored: (value: TraceApi.ErrorInfo): TraceApi.WorkspaceSubmissionUpdateInfo.Errored => {
    const valueWithoutVisit: Omit<TraceApi.WorkspaceSubmissionUpdateInfo.Errored, \\"_visit\\"> = {
      value: value,
      type: \\"errored\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.WorkspaceSubmissionUpdateInfo.Errored, visitor: TraceApi.WorkspaceSubmissionUpdateInfo._Visitor<_Result>) {
      return TraceApi.WorkspaceSubmissionUpdateInfo._visit(this, visitor);
    });
  },

  finished: (): TraceApi.WorkspaceSubmissionUpdateInfo.Finished => {
    const valueWithoutVisit: Omit<TraceApi.WorkspaceSubmissionUpdateInfo.Finished, \\"_visit\\"> = {
      type: \\"finished\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.WorkspaceSubmissionUpdateInfo.Finished, visitor: TraceApi.WorkspaceSubmissionUpdateInfo._Visitor<_Result>) {
      return TraceApi.WorkspaceSubmissionUpdateInfo._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.WorkspaceSubmissionUpdateInfo._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.WorkspaceSubmissionUpdateInfo._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.WorkspaceSubmissionUpdateInfo._Unknown, visitor: TraceApi.WorkspaceSubmissionUpdateInfo._Visitor<_Result>) {
      return TraceApi.WorkspaceSubmissionUpdateInfo._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.WorkspaceSubmissionUpdateInfo,
    visitor: TraceApi.WorkspaceSubmissionUpdateInfo._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"running\\":
        return visitor.running(value.value);
      case \\"ran\\":
        return visitor.ran(value);
      case \\"stopped\\":
        return visitor.stopped();
      case \\"traced\\":
        return visitor.traced();
      case \\"tracedV2\\":
        return visitor.tracedV2(value);
      case \\"errored\\":
        return visitor.errored(value.value);
      case \\"finished\\":
        return visitor.finished();
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "WorkspaceSubmissionUpdateInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface WorkspaceSubmitRequest {
  submissionId: TraceApi.SubmissionId;
  language: TraceApi.Language;
  submissionFiles: TraceApi.SubmissionFileInfo[];
  userId?: string;
}
",
                    "name": "WorkspaceSubmitRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface WorkspaceTracedUpdate {
  traceResponsesSize: number;
}
",
                    "name": "WorkspaceTracedUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./SubmissionId\\";
export * from \\"./ShareId\\";
export * from \\"./SubmissionRequest\\";
export * from \\"./InitializeProblemRequest\\";
export * from \\"./SubmitRequestV2\\";
export * from \\"./WorkspaceSubmitRequest\\";
export * from \\"./SubmissionFileInfo\\";
export * from \\"./SubmissionTypeEnum\\";
export * from \\"./StopRequest\\";
export * from \\"./SubmissionResponse\\";
export * from \\"./CodeExecutionUpdate\\";
export * from \\"./BuildingExecutorResponse\\";
export * from \\"./RunningResponse\\";
export * from \\"./RunningSubmissionState\\";
export * from \\"./ErroredResponse\\";
export * from \\"./ErrorInfo\\";
export * from \\"./CompileError\\";
export * from \\"./RuntimeError\\";
export * from \\"./InternalError\\";
export * from \\"./StoppedResponse\\";
export * from \\"./WorkspaceRanResponse\\";
export * from \\"./WorkspaceRunDetails\\";
export * from \\"./GradedResponse\\";
export * from \\"./GradedResponseV2\\";
export * from \\"./TestCaseGrade\\";
export * from \\"./TestCaseHiddenGrade\\";
export * from \\"./TestCaseNonHiddenGrade\\";
export * from \\"./RecordedResponseNotification\\";
export * from \\"./RecordingResponseNotification\\";
export * from \\"./LightweightStackframeInformation\\";
export * from \\"./TestCaseResultWithStdout\\";
export * from \\"./TestCaseResult\\";
export * from \\"./ActualResult\\";
export * from \\"./ExceptionV2\\";
export * from \\"./ExceptionInfo\\";
export * from \\"./InvalidRequestResponse\\";
export * from \\"./InvalidRequestCause\\";
export * from \\"./ExistingSubmissionExecuting\\";
export * from \\"./SubmissionIdNotFound\\";
export * from \\"./CustomTestCasesUnsupported\\";
export * from \\"./UnexpectedLanguageError\\";
export * from \\"./TerminatedResponse\\";
export * from \\"./FinishedResponse\\";
export * from \\"./StdoutResponse\\";
export * from \\"./StderrResponse\\";
export * from \\"./TraceResponse\\";
export * from \\"./TraceResponseV2\\";
export * from \\"./TracedFile\\";
export * from \\"./ExpressionLocation\\";
export * from \\"./StackInformation\\";
export * from \\"./StackFrame\\";
export * from \\"./Scope\\";
export * from \\"./ExecutionSessionResponse\\";
export * from \\"./ExecutionSessionStatus\\";
export * from \\"./SubmissionStatusV2\\";
export * from \\"./TestSubmissionStatusV2\\";
export * from \\"./WorkspaceSubmissionStatusV2\\";
export * from \\"./TestSubmissionUpdate\\";
export * from \\"./TestSubmissionUpdateInfo\\";
export * from \\"./WorkspaceSubmissionUpdate\\";
export * from \\"./WorkspaceSubmissionUpdateInfo\\";
export * from \\"./GradedTestCaseUpdate\\";
export * from \\"./RecordedTestCaseUpdate\\";
export * from \\"./WorkspaceTracedUpdate\\";
export * from \\"./SubmissionTypeState\\";
export * from \\"./WorkspaceSubmissionState\\";
export * from \\"./WorkspaceSubmissionStatus\\";
export * from \\"./TestSubmissionState\\";
export * from \\"./TestSubmissionStatus\\";
export * from \\"./SubmissionStatusForTestCase\\";
export * from \\"./TracedTestCase\\";
export * from \\"./TraceResponsesPage\\";
export * from \\"./TraceResponsesPageV2\\";
export * from \\"./GetTraceResponsesPageRequest\\";
export * from \\"./WorkspaceStarterFilesResponse\\";
export * from \\"./WorkspaceStarterFilesResponseV2\\";
export * from \\"./WorkspaceFiles\\";
export * from \\"./ExecutionSessionState\\";
export * from \\"./GetExecutionSessionStateResponse\\";
export * from \\"./GetSubmissionStateResponse\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "submission",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    token?: core.Supplier<core.BearerToken>;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async setNumWarmInstances(
    language: TraceApi.Language,
    numWarmInstances: number
  ): Promise<TraceApi.sysprop.setNumWarmInstances.Response> {
    const _response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/sysprop/num-warm-instances/\${language}/\${numWarmInstances}\`
      ),
      method: \\"PUT\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: TraceApi.sysprop.setNumWarmInstances.Error._unknown(_response.error),
    };
  }

  public async getNumWarmInstances(): Promise<TraceApi.sysprop.getNumWarmInstances.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/sysprop/num-warm-instances\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.sysprop.getNumWarmInstances.Response.parse(
          _response.body as serializers.sysprop.getNumWarmInstances.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.sysprop.getNumWarmInstances.Error._unknown(_response.error),
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<Record<TraceApi.Language, number>, TraceApi.sysprop.getNumWarmInstances.Error>;
export type Error = TraceApi.sysprop.getNumWarmInstances.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.sysprop.getNumWarmInstances.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.sysprop.getNumWarmInstances.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.sysprop.getNumWarmInstances.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.sysprop.getNumWarmInstances.Error._Unknown, visitor: TraceApi.sysprop.getNumWarmInstances.Error._Visitor<_Result>) {
      return TraceApi.sysprop.getNumWarmInstances.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.sysprop.getNumWarmInstances.Error,
    visitor: TraceApi.sysprop.getNumWarmInstances.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "getNumWarmInstances.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as setNumWarmInstances from \\"./setNumWarmInstances\\";
export * as getNumWarmInstances from \\"./getNumWarmInstances\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, TraceApi.sysprop.setNumWarmInstances.Error>;
export type Error = TraceApi.sysprop.setNumWarmInstances.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.sysprop.setNumWarmInstances.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.sysprop.setNumWarmInstances.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.sysprop.setNumWarmInstances.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.sysprop.setNumWarmInstances.Error._Unknown, visitor: TraceApi.sysprop.setNumWarmInstances.Error._Visitor<_Result>) {
      return TraceApi.sysprop.setNumWarmInstances.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.sysprop.setNumWarmInstances.Error,
    visitor: TraceApi.sysprop.setNumWarmInstances.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                    "name": "setNumWarmInstances.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "sysprop",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { Client as ProblemClient } from \\"../resources/problem/client/Client\\";
import { Client as V3Client } from \\"../resources/v3/client/Client\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    token?: core.Supplier<core.BearerToken>;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  #problem: ProblemClient | undefined;

  public get problem(): ProblemClient {
    return (this.#problem ??= new ProblemClient(this.options));
  }

  #v3: V3Client | undefined;

  public get v3(): V3Client {
    return (this.#v3 ??= new V3Client(this.options));
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export {};
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./resources\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as v3 from \\"./v3\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../../environments\\";
import * as core from \\"../../../../../core\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    token?: core.Supplier<core.BearerToken>;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async getLightweightProblems(): Promise<TraceApi.v2.problem.getLightweightProblems.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/problems-v2/lightweight-problem-info\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.v2.problem.getLightweightProblems.Response.parse(
          _response.body as serializers.v2.problem.getLightweightProblems.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.v2.problem.getLightweightProblems.Error._unknown(_response.error),
    };
  }

  public async getProblems(): Promise<TraceApi.v2.problem.getProblems.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/problems-v2/problem-info\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.v2.problem.getProblems.Response.parse(
          _response.body as serializers.v2.problem.getProblems.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.v2.problem.getProblems.Error._unknown(_response.error),
    };
  }

  public async getLatestProblem(problemId: TraceApi.ProblemId): Promise<TraceApi.v2.problem.getLatestProblem.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \`/problems-v2/problem-info/\${problemId}\`),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.v2.problem.getLatestProblem.Response.parse(
          _response.body as serializers.v2.problem.getLatestProblem.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.v2.problem.getLatestProblem.Error._unknown(_response.error),
    };
  }

  public async getProblemVersion(
    problemId: TraceApi.ProblemId,
    problemVersion: number
  ): Promise<TraceApi.v2.problem.getProblemVersion.Response> {
    const _response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/problems-v2/problem-info/\${problemId}/version/\${problemVersion}\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.v2.problem.getProblemVersion.Response.parse(
          _response.body as serializers.v2.problem.getProblemVersion.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.v2.problem.getProblemVersion.Error._unknown(_response.error),
    };
  }
}
",
                            "name": "Client.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export type Response = core.APIResponse<TraceApi.v2.ProblemInfoV2, TraceApi.v2.problem.getLatestProblem.Error>;
export type Error = TraceApi.v2.problem.getLatestProblem.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.problem.getLatestProblem.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.v2.problem.getLatestProblem.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.v2.problem.getLatestProblem.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.problem.getLatestProblem.Error._Unknown, visitor: TraceApi.v2.problem.getLatestProblem.Error._Visitor<_Result>) {
      return TraceApi.v2.problem.getLatestProblem.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.problem.getLatestProblem.Error,
    visitor: TraceApi.v2.problem.getLatestProblem.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                            "name": "getLatestProblem.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export type Response = core.APIResponse<
  TraceApi.v2.LightweightProblemInfoV2[],
  TraceApi.v2.problem.getLightweightProblems.Error
>;
export type Error = TraceApi.v2.problem.getLightweightProblems.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.problem.getLightweightProblems.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.v2.problem.getLightweightProblems.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.v2.problem.getLightweightProblems.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.problem.getLightweightProblems.Error._Unknown, visitor: TraceApi.v2.problem.getLightweightProblems.Error._Visitor<_Result>) {
      return TraceApi.v2.problem.getLightweightProblems.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.problem.getLightweightProblems.Error,
    visitor: TraceApi.v2.problem.getLightweightProblems.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                            "name": "getLightweightProblems.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export type Response = core.APIResponse<TraceApi.v2.ProblemInfoV2, TraceApi.v2.problem.getProblemVersion.Error>;
export type Error = TraceApi.v2.problem.getProblemVersion.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.problem.getProblemVersion.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.v2.problem.getProblemVersion.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.v2.problem.getProblemVersion.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.problem.getProblemVersion.Error._Unknown, visitor: TraceApi.v2.problem.getProblemVersion.Error._Visitor<_Result>) {
      return TraceApi.v2.problem.getProblemVersion.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.problem.getProblemVersion.Error,
    visitor: TraceApi.v2.problem.getProblemVersion.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                            "name": "getProblemVersion.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export type Response = core.APIResponse<TraceApi.v2.ProblemInfoV2[], TraceApi.v2.problem.getProblems.Error>;
export type Error = TraceApi.v2.problem.getProblems.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.problem.getProblems.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.v2.problem.getProblems.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<TraceApi.v2.problem.getProblems.Error._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.problem.getProblems.Error._Unknown, visitor: TraceApi.v2.problem.getProblems.Error._Visitor<_Result>) {
      return TraceApi.v2.problem.getProblems.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.problem.getProblems.Error,
    visitor: TraceApi.v2.problem.getProblems.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                            "name": "getProblems.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
export * as getLatestProblem from \\"./getLatestProblem\\";
export * as getProblemVersion from \\"./getProblemVersion\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "client",
                        "type": "directory",
                      },
                      Object {
                        "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export type AssertCorrectnessCheck =
  | TraceApi.v2.AssertCorrectnessCheck.DeepEquality
  | TraceApi.v2.AssertCorrectnessCheck.Custom
  | TraceApi.v2.AssertCorrectnessCheck._Unknown;

export declare namespace AssertCorrectnessCheck {
  interface DeepEquality extends TraceApi.v2.DeepEqualityCorrectnessCheck, _Utils {
    type: \\"deepEquality\\";
  }

  interface Custom extends TraceApi.v2.VoidFunctionDefinitionThatTakesActualResult, _Utils {
    type: \\"custom\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.AssertCorrectnessCheck._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    deepEquality: (value: TraceApi.v2.DeepEqualityCorrectnessCheck) => _Result;
    custom: (value: TraceApi.v2.VoidFunctionDefinitionThatTakesActualResult) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const AssertCorrectnessCheck = {
  deepEquality: (value: TraceApi.v2.DeepEqualityCorrectnessCheck): TraceApi.v2.AssertCorrectnessCheck.DeepEquality => {
    const valueWithoutVisit: Omit<TraceApi.v2.AssertCorrectnessCheck.DeepEquality, \\"_visit\\"> = {
      ...value,
      type: \\"deepEquality\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.AssertCorrectnessCheck.DeepEquality, visitor: TraceApi.v2.AssertCorrectnessCheck._Visitor<_Result>) {
      return TraceApi.v2.AssertCorrectnessCheck._visit(this, visitor);
    });
  },

  custom: (
    value: TraceApi.v2.VoidFunctionDefinitionThatTakesActualResult
  ): TraceApi.v2.AssertCorrectnessCheck.Custom => {
    const valueWithoutVisit: Omit<TraceApi.v2.AssertCorrectnessCheck.Custom, \\"_visit\\"> = {
      ...value,
      type: \\"custom\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.AssertCorrectnessCheck.Custom, visitor: TraceApi.v2.AssertCorrectnessCheck._Visitor<_Result>) {
      return TraceApi.v2.AssertCorrectnessCheck._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.v2.AssertCorrectnessCheck._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.v2.AssertCorrectnessCheck._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.AssertCorrectnessCheck._Unknown, visitor: TraceApi.v2.AssertCorrectnessCheck._Visitor<_Result>) {
      return TraceApi.v2.AssertCorrectnessCheck._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.AssertCorrectnessCheck,
    visitor: TraceApi.v2.AssertCorrectnessCheck._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"deepEquality\\":
        return visitor.deepEquality(value);
      case \\"custom\\":
        return visitor.custom(value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                            "name": "AssertCorrectnessCheck.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface BasicCustomFiles {
  methodName: string;
  signature: TraceApi.v2.NonVoidFunctionSignature;
  additionalFiles: Record<TraceApi.Language, TraceApi.v2.Files>;
  basicTestCaseTemplate: TraceApi.v2.BasicTestCaseTemplate;
}
",
                            "name": "BasicCustomFiles.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface BasicTestCaseTemplate {
  templateId: TraceApi.v2.TestCaseTemplateId;
  name: string;
  description: TraceApi.v2.TestCaseImplementationDescription;
  expectedValueParameterId: TraceApi.v2.ParameterId;
}
",
                            "name": "BasicTestCaseTemplate.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface CreateProblemRequestV2 {
  problemName: string;
  problemDescription: TraceApi.ProblemDescription;
  customFiles: TraceApi.v2.CustomFiles;
  customTestCaseTemplates: TraceApi.v2.TestCaseTemplate[];
  testcases: TraceApi.v2.TestCaseV2[];
  supportedLanguages: TraceApi.Language[];
  isPublic: boolean;
}
",
                            "name": "CreateProblemRequestV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export type CustomFiles =
  | TraceApi.v2.CustomFiles.Basic
  | TraceApi.v2.CustomFiles.Custom
  | TraceApi.v2.CustomFiles._Unknown;

export declare namespace CustomFiles {
  interface Basic extends TraceApi.v2.BasicCustomFiles, _Utils {
    type: \\"basic\\";
  }

  interface Custom extends _Utils {
    type: \\"custom\\";
    value: Record<TraceApi.Language, TraceApi.v2.Files>;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.CustomFiles._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    basic: (value: TraceApi.v2.BasicCustomFiles) => _Result;
    custom: (value: Record<TraceApi.Language, TraceApi.v2.Files>) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const CustomFiles = {
  basic: (value: TraceApi.v2.BasicCustomFiles): TraceApi.v2.CustomFiles.Basic => {
    const valueWithoutVisit: Omit<TraceApi.v2.CustomFiles.Basic, \\"_visit\\"> = {
      ...value,
      type: \\"basic\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.CustomFiles.Basic, visitor: TraceApi.v2.CustomFiles._Visitor<_Result>) {
      return TraceApi.v2.CustomFiles._visit(this, visitor);
    });
  },

  custom: (value: Record<TraceApi.Language, TraceApi.v2.Files>): TraceApi.v2.CustomFiles.Custom => {
    const valueWithoutVisit: Omit<TraceApi.v2.CustomFiles.Custom, \\"_visit\\"> = {
      value: value,
      type: \\"custom\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.CustomFiles.Custom, visitor: TraceApi.v2.CustomFiles._Visitor<_Result>) {
      return TraceApi.v2.CustomFiles._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.v2.CustomFiles._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.v2.CustomFiles._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.CustomFiles._Unknown, visitor: TraceApi.v2.CustomFiles._Visitor<_Result>) {
      return TraceApi.v2.CustomFiles._visit(this, visitor);
    });
  },

  _visit: <_Result>(value: TraceApi.v2.CustomFiles, visitor: TraceApi.v2.CustomFiles._Visitor<_Result>): _Result => {
    switch (value.type) {
      case \\"basic\\":
        return visitor.basic(value);
      case \\"custom\\":
        return visitor.custom(value.value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                            "name": "CustomFiles.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface DeepEqualityCorrectnessCheck {
  expectedValueParameterId: TraceApi.v2.ParameterId;
}
",
                            "name": "DeepEqualityCorrectnessCheck.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface DefaultProvidedFile {
  file: TraceApi.v2.FileInfoV2;
  relatedTypes: TraceApi.VariableType[];
}
",
                            "name": "DefaultProvidedFile.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface FileInfoV2 {
  filename: string;
  directory: string;
  contents: string;
  editable: boolean;
}
",
                            "name": "FileInfoV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface Files {
  files: TraceApi.v2.FileInfoV2[];
}
",
                            "name": "Files.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface FunctionImplementation {
  impl: string;
  imports?: string;
}
",
                            "name": "FunctionImplementation.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface FunctionImplementationForMultipleLanguages {
  codeByLanguage: Record<TraceApi.Language, TraceApi.v2.FunctionImplementation>;
}
",
                            "name": "FunctionImplementationForMultipleLanguages.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export type FunctionSignature =
  | TraceApi.v2.FunctionSignature.Void
  | TraceApi.v2.FunctionSignature.NonVoid
  /**
   * Useful when specifying custom grading for a testcase where actualResult is defined. */
  | TraceApi.v2.FunctionSignature.VoidThatTakesActualResult
  | TraceApi.v2.FunctionSignature._Unknown;

export declare namespace FunctionSignature {
  interface Void extends TraceApi.v2.VoidFunctionSignature, _Utils {
    type: \\"void\\";
  }

  interface NonVoid extends TraceApi.v2.NonVoidFunctionSignature, _Utils {
    type: \\"nonVoid\\";
  }

  interface VoidThatTakesActualResult extends TraceApi.v2.VoidFunctionSignatureThatTakesActualResult, _Utils {
    type: \\"voidThatTakesActualResult\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.FunctionSignature._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    void: (value: TraceApi.v2.VoidFunctionSignature) => _Result;
    nonVoid: (value: TraceApi.v2.NonVoidFunctionSignature) => _Result;
    voidThatTakesActualResult: (value: TraceApi.v2.VoidFunctionSignatureThatTakesActualResult) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const FunctionSignature = {
  void: (value: TraceApi.v2.VoidFunctionSignature): TraceApi.v2.FunctionSignature.Void => {
    const valueWithoutVisit: Omit<TraceApi.v2.FunctionSignature.Void, \\"_visit\\"> = {
      ...value,
      type: \\"void\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.FunctionSignature.Void, visitor: TraceApi.v2.FunctionSignature._Visitor<_Result>) {
      return TraceApi.v2.FunctionSignature._visit(this, visitor);
    });
  },

  nonVoid: (value: TraceApi.v2.NonVoidFunctionSignature): TraceApi.v2.FunctionSignature.NonVoid => {
    const valueWithoutVisit: Omit<TraceApi.v2.FunctionSignature.NonVoid, \\"_visit\\"> = {
      ...value,
      type: \\"nonVoid\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.FunctionSignature.NonVoid, visitor: TraceApi.v2.FunctionSignature._Visitor<_Result>) {
      return TraceApi.v2.FunctionSignature._visit(this, visitor);
    });
  },

  voidThatTakesActualResult: (
    value: TraceApi.v2.VoidFunctionSignatureThatTakesActualResult
  ): TraceApi.v2.FunctionSignature.VoidThatTakesActualResult => {
    const valueWithoutVisit: Omit<TraceApi.v2.FunctionSignature.VoidThatTakesActualResult, \\"_visit\\"> = {
      ...value,
      type: \\"voidThatTakesActualResult\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.FunctionSignature.VoidThatTakesActualResult, visitor: TraceApi.v2.FunctionSignature._Visitor<_Result>) {
      return TraceApi.v2.FunctionSignature._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.v2.FunctionSignature._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.v2.FunctionSignature._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.FunctionSignature._Unknown, visitor: TraceApi.v2.FunctionSignature._Visitor<_Result>) {
      return TraceApi.v2.FunctionSignature._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.FunctionSignature,
    visitor: TraceApi.v2.FunctionSignature._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"void\\":
        return visitor.void(value);
      case \\"nonVoid\\":
        return visitor.nonVoid(value);
      case \\"voidThatTakesActualResult\\":
        return visitor.voidThatTakesActualResult(value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                            "name": "FunctionSignature.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GeneratedFiles {
  generatedTestCaseFiles: Record<TraceApi.Language, TraceApi.v2.Files>;
  generatedTemplateFiles: Record<TraceApi.Language, TraceApi.v2.Files>;
  other: Record<TraceApi.Language, TraceApi.v2.Files>;
}
",
                            "name": "GeneratedFiles.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetBasicSolutionFileRequest {
  methodName: string;
  signature: TraceApi.v2.NonVoidFunctionSignature;
}
",
                            "name": "GetBasicSolutionFileRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetBasicSolutionFileResponse {
  solutionFileByLanguage: Record<TraceApi.Language, TraceApi.v2.FileInfoV2>;
}
",
                            "name": "GetBasicSolutionFileResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetFunctionSignatureRequest {
  functionSignature: TraceApi.v2.FunctionSignature;
}
",
                            "name": "GetFunctionSignatureRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetFunctionSignatureResponse {
  functionByLanguage: Record<TraceApi.Language, string>;
}
",
                            "name": "GetFunctionSignatureResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetGeneratedTestCaseFileRequest {
  template?: TraceApi.v2.TestCaseTemplate;
  testCase: TraceApi.v2.TestCaseV2;
}
",
                            "name": "GetGeneratedTestCaseFileRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetGeneratedTestCaseTemplateFileRequest {
  template: TraceApi.v2.TestCaseTemplate;
}
",
                            "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface LightweightProblemInfoV2 {
  problemId: TraceApi.ProblemId;
  problemName: string;
  problemVersion: number;
  variableTypes: TraceApi.VariableType[];
}
",
                            "name": "LightweightProblemInfoV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface NonVoidFunctionDefinition {
  signature: TraceApi.v2.NonVoidFunctionSignature;
  code: TraceApi.v2.FunctionImplementationForMultipleLanguages;
}
",
                            "name": "NonVoidFunctionDefinition.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface NonVoidFunctionSignature {
  parameters: TraceApi.v2.Parameter[];
  returnType: TraceApi.VariableType;
}
",
                            "name": "NonVoidFunctionSignature.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface Parameter {
  parameterId: TraceApi.v2.ParameterId;
  name: string;
  variableType: TraceApi.VariableType;
}
",
                            "name": "Parameter.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type ParameterId = string & {
  v2_ParameterId: void;
};

export function ParameterId(value: string): TraceApi.v2.ParameterId {
  return value as unknown as TraceApi.v2.ParameterId;
}
",
                            "name": "ParameterId.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface ProblemInfoV2 {
  problemId: TraceApi.ProblemId;
  problemDescription: TraceApi.ProblemDescription;
  problemName: string;
  problemVersion: number;
  supportedLanguages: TraceApi.Language[];
  customFiles: TraceApi.v2.CustomFiles;
  generatedFiles: TraceApi.v2.GeneratedFiles;
  customTestCaseTemplates: TraceApi.v2.TestCaseTemplate[];
  testcases: TraceApi.v2.TestCaseV2[];
  isPublic: boolean;
}
",
                            "name": "ProblemInfoV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface TestCaseExpects {
  expectedStdout?: string;
}
",
                            "name": "TestCaseExpects.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export type TestCaseFunction =
  | TraceApi.v2.TestCaseFunction.WithActualResult
  | TraceApi.v2.TestCaseFunction.Custom
  | TraceApi.v2.TestCaseFunction._Unknown;

export declare namespace TestCaseFunction {
  interface WithActualResult extends TraceApi.v2.TestCaseWithActualResultImplementation, _Utils {
    type: \\"withActualResult\\";
  }

  interface Custom extends TraceApi.v2.VoidFunctionDefinition, _Utils {
    type: \\"custom\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.TestCaseFunction._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    withActualResult: (value: TraceApi.v2.TestCaseWithActualResultImplementation) => _Result;
    custom: (value: TraceApi.v2.VoidFunctionDefinition) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const TestCaseFunction = {
  withActualResult: (
    value: TraceApi.v2.TestCaseWithActualResultImplementation
  ): TraceApi.v2.TestCaseFunction.WithActualResult => {
    const valueWithoutVisit: Omit<TraceApi.v2.TestCaseFunction.WithActualResult, \\"_visit\\"> = {
      ...value,
      type: \\"withActualResult\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.TestCaseFunction.WithActualResult, visitor: TraceApi.v2.TestCaseFunction._Visitor<_Result>) {
      return TraceApi.v2.TestCaseFunction._visit(this, visitor);
    });
  },

  custom: (value: TraceApi.v2.VoidFunctionDefinition): TraceApi.v2.TestCaseFunction.Custom => {
    const valueWithoutVisit: Omit<TraceApi.v2.TestCaseFunction.Custom, \\"_visit\\"> = {
      ...value,
      type: \\"custom\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.TestCaseFunction.Custom, visitor: TraceApi.v2.TestCaseFunction._Visitor<_Result>) {
      return TraceApi.v2.TestCaseFunction._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.v2.TestCaseFunction._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.v2.TestCaseFunction._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.TestCaseFunction._Unknown, visitor: TraceApi.v2.TestCaseFunction._Visitor<_Result>) {
      return TraceApi.v2.TestCaseFunction._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.TestCaseFunction,
    visitor: TraceApi.v2.TestCaseFunction._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"withActualResult\\":
        return visitor.withActualResult(value);
      case \\"custom\\":
        return visitor.custom(value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                            "name": "TestCaseFunction.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type TestCaseId = string & {
  v2_TestCaseId: void;
};

export function TestCaseId(value: string): TraceApi.v2.TestCaseId {
  return value as unknown as TraceApi.v2.TestCaseId;
}
",
                            "name": "TestCaseId.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseImplementation {
  description: TraceApi.v2.TestCaseImplementationDescription;
  function: TraceApi.v2.TestCaseFunction;
}
",
                            "name": "TestCaseImplementation.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseImplementationDescription {
  boards: TraceApi.v2.TestCaseImplementationDescriptionBoard[];
}
",
                            "name": "TestCaseImplementationDescription.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export type TestCaseImplementationDescriptionBoard =
  | TraceApi.v2.TestCaseImplementationDescriptionBoard.Html
  | TraceApi.v2.TestCaseImplementationDescriptionBoard.ParamId
  | TraceApi.v2.TestCaseImplementationDescriptionBoard._Unknown;

export declare namespace TestCaseImplementationDescriptionBoard {
  interface Html extends _Utils {
    type: \\"html\\";
    value: string;
  }

  interface ParamId extends _Utils {
    type: \\"paramId\\";
    value: TraceApi.v2.ParameterId;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.TestCaseImplementationDescriptionBoard._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    html: (value: string) => _Result;
    paramId: (value: TraceApi.v2.ParameterId) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const TestCaseImplementationDescriptionBoard = {
  html: (value: string): TraceApi.v2.TestCaseImplementationDescriptionBoard.Html => {
    const valueWithoutVisit: Omit<TraceApi.v2.TestCaseImplementationDescriptionBoard.Html, \\"_visit\\"> = {
      value: value,
      type: \\"html\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.TestCaseImplementationDescriptionBoard.Html, visitor: TraceApi.v2.TestCaseImplementationDescriptionBoard._Visitor<_Result>) {
      return TraceApi.v2.TestCaseImplementationDescriptionBoard._visit(this, visitor);
    });
  },

  paramId: (value: TraceApi.v2.ParameterId): TraceApi.v2.TestCaseImplementationDescriptionBoard.ParamId => {
    const valueWithoutVisit: Omit<TraceApi.v2.TestCaseImplementationDescriptionBoard.ParamId, \\"_visit\\"> = {
      value: value,
      type: \\"paramId\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.TestCaseImplementationDescriptionBoard.ParamId, visitor: TraceApi.v2.TestCaseImplementationDescriptionBoard._Visitor<_Result>) {
      return TraceApi.v2.TestCaseImplementationDescriptionBoard._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.v2.TestCaseImplementationDescriptionBoard._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<
      TraceApi.v2.TestCaseImplementationDescriptionBoard._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.TestCaseImplementationDescriptionBoard._Unknown, visitor: TraceApi.v2.TestCaseImplementationDescriptionBoard._Visitor<_Result>) {
      return TraceApi.v2.TestCaseImplementationDescriptionBoard._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.TestCaseImplementationDescriptionBoard,
    visitor: TraceApi.v2.TestCaseImplementationDescriptionBoard._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"html\\":
        return visitor.html(value.value);
      case \\"paramId\\":
        return visitor.paramId(value.value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                            "name": "TestCaseImplementationDescriptionBoard.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export type TestCaseImplementationReference =
  | TraceApi.v2.TestCaseImplementationReference.TemplateId
  | TraceApi.v2.TestCaseImplementationReference.Implementation
  | TraceApi.v2.TestCaseImplementationReference._Unknown;

export declare namespace TestCaseImplementationReference {
  interface TemplateId extends _Utils {
    type: \\"templateId\\";
    value: TraceApi.v2.TestCaseTemplateId;
  }

  interface Implementation extends TraceApi.v2.TestCaseImplementation, _Utils {
    type: \\"implementation\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.TestCaseImplementationReference._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    templateId: (value: TraceApi.v2.TestCaseTemplateId) => _Result;
    implementation: (value: TraceApi.v2.TestCaseImplementation) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const TestCaseImplementationReference = {
  templateId: (value: TraceApi.v2.TestCaseTemplateId): TraceApi.v2.TestCaseImplementationReference.TemplateId => {
    const valueWithoutVisit: Omit<TraceApi.v2.TestCaseImplementationReference.TemplateId, \\"_visit\\"> = {
      value: value,
      type: \\"templateId\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.TestCaseImplementationReference.TemplateId, visitor: TraceApi.v2.TestCaseImplementationReference._Visitor<_Result>) {
      return TraceApi.v2.TestCaseImplementationReference._visit(this, visitor);
    });
  },

  implementation: (
    value: TraceApi.v2.TestCaseImplementation
  ): TraceApi.v2.TestCaseImplementationReference.Implementation => {
    const valueWithoutVisit: Omit<TraceApi.v2.TestCaseImplementationReference.Implementation, \\"_visit\\"> = {
      ...value,
      type: \\"implementation\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.TestCaseImplementationReference.Implementation, visitor: TraceApi.v2.TestCaseImplementationReference._Visitor<_Result>) {
      return TraceApi.v2.TestCaseImplementationReference._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.v2.TestCaseImplementationReference._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.v2.TestCaseImplementationReference._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.TestCaseImplementationReference._Unknown, visitor: TraceApi.v2.TestCaseImplementationReference._Visitor<_Result>) {
      return TraceApi.v2.TestCaseImplementationReference._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.TestCaseImplementationReference,
    visitor: TraceApi.v2.TestCaseImplementationReference._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"templateId\\":
        return visitor.templateId(value.value);
      case \\"implementation\\":
        return visitor.implementation(value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                            "name": "TestCaseImplementationReference.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseMetadata {
  id: TraceApi.v2.TestCaseId;
  name: string;
  hidden: boolean;
}
",
                            "name": "TestCaseMetadata.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseTemplate {
  templateId: TraceApi.v2.TestCaseTemplateId;
  name: string;
  implementation: TraceApi.v2.TestCaseImplementation;
}
",
                            "name": "TestCaseTemplate.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type TestCaseTemplateId = string & {
  v2_TestCaseTemplateId: void;
};

export function TestCaseTemplateId(value: string): TraceApi.v2.TestCaseTemplateId {
  return value as unknown as TraceApi.v2.TestCaseTemplateId;
}
",
                            "name": "TestCaseTemplateId.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseV2 {
  metadata: TraceApi.v2.TestCaseMetadata;
  implementation: TraceApi.v2.TestCaseImplementationReference;
  arguments: Record<TraceApi.v2.ParameterId, TraceApi.VariableValue>;
  expects?: TraceApi.v2.TestCaseExpects;
}
",
                            "name": "TestCaseV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseWithActualResultImplementation {
  getActualResult: TraceApi.v2.NonVoidFunctionDefinition;
  assertCorrectnessCheck: TraceApi.v2.AssertCorrectnessCheck;
}
",
                            "name": "TestCaseWithActualResultImplementation.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface VoidFunctionDefinition {
  parameters: TraceApi.v2.Parameter[];
  code: TraceApi.v2.FunctionImplementationForMultipleLanguages;
}
",
                            "name": "VoidFunctionDefinition.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

/**
 * The generated signature will include an additional param, actualResult
 */
export interface VoidFunctionDefinitionThatTakesActualResult {
  additionalParameters: TraceApi.v2.Parameter[];
  code: TraceApi.v2.FunctionImplementationForMultipleLanguages;
}
",
                            "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface VoidFunctionSignature {
  parameters: TraceApi.v2.Parameter[];
}
",
                            "name": "VoidFunctionSignature.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface VoidFunctionSignatureThatTakesActualResult {
  parameters: TraceApi.v2.Parameter[];
  actualResultType: TraceApi.VariableType;
}
",
                            "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "types",
                        "type": "directory",
                      },
                    ],
                    "name": "problem",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../../environments\\";
import * as core from \\"../../../../../core\\";
import { Client as ProblemClient } from \\"../resources/problem/client/Client\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    token?: core.Supplier<core.BearerToken>;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  #problem: ProblemClient | undefined;

  public get problem(): ProblemClient {
    return (this.#problem ??= new ProblemClient(this.options));
  }
}
",
                            "name": "Client.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export {};
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "client",
                        "type": "directory",
                      },
                      Object {
                        "contents": "export * from \\"./resources\\";
export * from \\"./client\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": Array [
                              Object {
                                "contents": Array [
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../../../../environments\\";
import * as core from \\"../../../../../../../core\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../../../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    token?: core.Supplier<core.BearerToken>;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async getLightweightProblems(): Promise<TraceApi.v2.v3.problem.getLightweightProblems.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/problems-v2/lightweight-problem-info\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.v2.v3.problem.getLightweightProblems.Response.parse(
          _response.body as serializers.v2.v3.problem.getLightweightProblems.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.v2.v3.problem.getLightweightProblems.Error._unknown(_response.error),
    };
  }

  public async getProblems(): Promise<TraceApi.v2.v3.problem.getProblems.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/problems-v2/problem-info\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.v2.v3.problem.getProblems.Response.parse(
          _response.body as serializers.v2.v3.problem.getProblems.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.v2.v3.problem.getProblems.Error._unknown(_response.error),
    };
  }

  public async getLatestProblem(
    problemId: TraceApi.ProblemId
  ): Promise<TraceApi.v2.v3.problem.getLatestProblem.Response> {
    const _response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \`/problems-v2/problem-info/\${problemId}\`),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.v2.v3.problem.getLatestProblem.Response.parse(
          _response.body as serializers.v2.v3.problem.getLatestProblem.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.v2.v3.problem.getLatestProblem.Error._unknown(_response.error),
    };
  }

  public async getProblemVersion(
    problemId: TraceApi.ProblemId,
    problemVersion: number
  ): Promise<TraceApi.v2.v3.problem.getProblemVersion.Response> {
    const _response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/problems-v2/problem-info/\${problemId}/version/\${problemVersion}\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
      },
    });
    if (_response.ok) {
      return {
        ok: true,
        body: await serializers.v2.v3.problem.getProblemVersion.Response.parse(
          _response.body as serializers.v2.v3.problem.getProblemVersion.Response.Raw
        ),
      };
    }

    return {
      ok: false,
      error: TraceApi.v2.v3.problem.getProblemVersion.Error._unknown(_response.error),
    };
  }
}
",
                                    "name": "Client.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export type Response = core.APIResponse<TraceApi.v2.v3.ProblemInfoV2, TraceApi.v2.v3.problem.getLatestProblem.Error>;
export type Error = TraceApi.v2.v3.problem.getLatestProblem.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.v3.problem.getLatestProblem.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.v2.v3.problem.getLatestProblem.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.v2.v3.problem.getLatestProblem.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.problem.getLatestProblem.Error._Unknown, visitor: TraceApi.v2.v3.problem.getLatestProblem.Error._Visitor<_Result>) {
      return TraceApi.v2.v3.problem.getLatestProblem.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.v3.problem.getLatestProblem.Error,
    visitor: TraceApi.v2.v3.problem.getLatestProblem.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                                    "name": "getLatestProblem.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export type Response = core.APIResponse<
  TraceApi.v2.v3.LightweightProblemInfoV2[],
  TraceApi.v2.v3.problem.getLightweightProblems.Error
>;
export type Error = TraceApi.v2.v3.problem.getLightweightProblems.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.v3.problem.getLightweightProblems.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.v2.v3.problem.getLightweightProblems.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.v2.v3.problem.getLightweightProblems.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.problem.getLightweightProblems.Error._Unknown, visitor: TraceApi.v2.v3.problem.getLightweightProblems.Error._Visitor<_Result>) {
      return TraceApi.v2.v3.problem.getLightweightProblems.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.v3.problem.getLightweightProblems.Error,
    visitor: TraceApi.v2.v3.problem.getLightweightProblems.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                                    "name": "getLightweightProblems.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export type Response = core.APIResponse<TraceApi.v2.v3.ProblemInfoV2, TraceApi.v2.v3.problem.getProblemVersion.Error>;
export type Error = TraceApi.v2.v3.problem.getProblemVersion.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.v3.problem.getProblemVersion.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.v2.v3.problem.getProblemVersion.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.v2.v3.problem.getProblemVersion.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.problem.getProblemVersion.Error._Unknown, visitor: TraceApi.v2.v3.problem.getProblemVersion.Error._Visitor<_Result>) {
      return TraceApi.v2.v3.problem.getProblemVersion.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.v3.problem.getProblemVersion.Error,
    visitor: TraceApi.v2.v3.problem.getProblemVersion.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                                    "name": "getProblemVersion.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export type Response = core.APIResponse<TraceApi.v2.v3.ProblemInfoV2[], TraceApi.v2.v3.problem.getProblems.Error>;
export type Error = TraceApi.v2.v3.problem.getProblems.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.v3.problem.getProblems.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  _unknown: (fetcherError: core.Fetcher.Error): TraceApi.v2.v3.problem.getProblems.Error._Unknown => {
    const valueWithoutVisit = fetcherError as unknown as Omit<
      TraceApi.v2.v3.problem.getProblems.Error._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.problem.getProblems.Error._Unknown, visitor: TraceApi.v2.v3.problem.getProblems.Error._Visitor<_Result>) {
      return TraceApi.v2.v3.problem.getProblems.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.v3.problem.getProblems.Error,
    visitor: TraceApi.v2.v3.problem.getProblems.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                                    "name": "getProblems.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
export * as getLatestProblem from \\"./getLatestProblem\\";
export * as getProblemVersion from \\"./getProblemVersion\\";
",
                                    "name": "index.ts",
                                    "type": "file",
                                  },
                                ],
                                "name": "client",
                                "type": "directory",
                              },
                              Object {
                                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                                "name": "index.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": Array [
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export type AssertCorrectnessCheck =
  | TraceApi.v2.v3.AssertCorrectnessCheck.DeepEquality
  | TraceApi.v2.v3.AssertCorrectnessCheck.Custom
  | TraceApi.v2.v3.AssertCorrectnessCheck._Unknown;

export declare namespace AssertCorrectnessCheck {
  interface DeepEquality extends TraceApi.v2.v3.DeepEqualityCorrectnessCheck, _Utils {
    type: \\"deepEquality\\";
  }

  interface Custom extends TraceApi.v2.v3.VoidFunctionDefinitionThatTakesActualResult, _Utils {
    type: \\"custom\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.v3.AssertCorrectnessCheck._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    deepEquality: (value: TraceApi.v2.v3.DeepEqualityCorrectnessCheck) => _Result;
    custom: (value: TraceApi.v2.v3.VoidFunctionDefinitionThatTakesActualResult) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const AssertCorrectnessCheck = {
  deepEquality: (
    value: TraceApi.v2.v3.DeepEqualityCorrectnessCheck
  ): TraceApi.v2.v3.AssertCorrectnessCheck.DeepEquality => {
    const valueWithoutVisit: Omit<TraceApi.v2.v3.AssertCorrectnessCheck.DeepEquality, \\"_visit\\"> = {
      ...value,
      type: \\"deepEquality\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.AssertCorrectnessCheck.DeepEquality, visitor: TraceApi.v2.v3.AssertCorrectnessCheck._Visitor<_Result>) {
      return TraceApi.v2.v3.AssertCorrectnessCheck._visit(this, visitor);
    });
  },

  custom: (
    value: TraceApi.v2.v3.VoidFunctionDefinitionThatTakesActualResult
  ): TraceApi.v2.v3.AssertCorrectnessCheck.Custom => {
    const valueWithoutVisit: Omit<TraceApi.v2.v3.AssertCorrectnessCheck.Custom, \\"_visit\\"> = {
      ...value,
      type: \\"custom\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.AssertCorrectnessCheck.Custom, visitor: TraceApi.v2.v3.AssertCorrectnessCheck._Visitor<_Result>) {
      return TraceApi.v2.v3.AssertCorrectnessCheck._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.v2.v3.AssertCorrectnessCheck._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.v2.v3.AssertCorrectnessCheck._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.AssertCorrectnessCheck._Unknown, visitor: TraceApi.v2.v3.AssertCorrectnessCheck._Visitor<_Result>) {
      return TraceApi.v2.v3.AssertCorrectnessCheck._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.v3.AssertCorrectnessCheck,
    visitor: TraceApi.v2.v3.AssertCorrectnessCheck._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"deepEquality\\":
        return visitor.deepEquality(value);
      case \\"custom\\":
        return visitor.custom(value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                                    "name": "AssertCorrectnessCheck.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface BasicCustomFiles {
  methodName: string;
  signature: TraceApi.v2.v3.NonVoidFunctionSignature;
  additionalFiles: Record<TraceApi.Language, TraceApi.v2.v3.Files>;
  basicTestCaseTemplate: TraceApi.v2.v3.BasicTestCaseTemplate;
}
",
                                    "name": "BasicCustomFiles.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface BasicTestCaseTemplate {
  templateId: TraceApi.v2.v3.TestCaseTemplateId;
  name: string;
  description: TraceApi.v2.v3.TestCaseImplementationDescription;
  expectedValueParameterId: TraceApi.v2.v3.ParameterId;
}
",
                                    "name": "BasicTestCaseTemplate.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface CreateProblemRequestV2 {
  problemName: string;
  problemDescription: TraceApi.ProblemDescription;
  customFiles: TraceApi.v2.v3.CustomFiles;
  customTestCaseTemplates: TraceApi.v2.v3.TestCaseTemplate[];
  testcases: TraceApi.v2.v3.TestCaseV2[];
  supportedLanguages: TraceApi.Language[];
  isPublic: boolean;
}
",
                                    "name": "CreateProblemRequestV2.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export type CustomFiles =
  | TraceApi.v2.v3.CustomFiles.Basic
  | TraceApi.v2.v3.CustomFiles.Custom
  | TraceApi.v2.v3.CustomFiles._Unknown;

export declare namespace CustomFiles {
  interface Basic extends TraceApi.v2.v3.BasicCustomFiles, _Utils {
    type: \\"basic\\";
  }

  interface Custom extends _Utils {
    type: \\"custom\\";
    value: Record<TraceApi.Language, TraceApi.v2.v3.Files>;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.v3.CustomFiles._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    basic: (value: TraceApi.v2.v3.BasicCustomFiles) => _Result;
    custom: (value: Record<TraceApi.Language, TraceApi.v2.v3.Files>) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const CustomFiles = {
  basic: (value: TraceApi.v2.v3.BasicCustomFiles): TraceApi.v2.v3.CustomFiles.Basic => {
    const valueWithoutVisit: Omit<TraceApi.v2.v3.CustomFiles.Basic, \\"_visit\\"> = {
      ...value,
      type: \\"basic\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.CustomFiles.Basic, visitor: TraceApi.v2.v3.CustomFiles._Visitor<_Result>) {
      return TraceApi.v2.v3.CustomFiles._visit(this, visitor);
    });
  },

  custom: (value: Record<TraceApi.Language, TraceApi.v2.v3.Files>): TraceApi.v2.v3.CustomFiles.Custom => {
    const valueWithoutVisit: Omit<TraceApi.v2.v3.CustomFiles.Custom, \\"_visit\\"> = {
      value: value,
      type: \\"custom\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.CustomFiles.Custom, visitor: TraceApi.v2.v3.CustomFiles._Visitor<_Result>) {
      return TraceApi.v2.v3.CustomFiles._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.v2.v3.CustomFiles._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.v2.v3.CustomFiles._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.CustomFiles._Unknown, visitor: TraceApi.v2.v3.CustomFiles._Visitor<_Result>) {
      return TraceApi.v2.v3.CustomFiles._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.v3.CustomFiles,
    visitor: TraceApi.v2.v3.CustomFiles._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"basic\\":
        return visitor.basic(value);
      case \\"custom\\":
        return visitor.custom(value.value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                                    "name": "CustomFiles.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface DeepEqualityCorrectnessCheck {
  expectedValueParameterId: TraceApi.v2.v3.ParameterId;
}
",
                                    "name": "DeepEqualityCorrectnessCheck.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface DefaultProvidedFile {
  file: TraceApi.v2.v3.FileInfoV2;
  relatedTypes: TraceApi.VariableType[];
}
",
                                    "name": "DefaultProvidedFile.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface FileInfoV2 {
  filename: string;
  directory: string;
  contents: string;
  editable: boolean;
}
",
                                    "name": "FileInfoV2.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface Files {
  files: TraceApi.v2.v3.FileInfoV2[];
}
",
                                    "name": "Files.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface FunctionImplementation {
  impl: string;
  imports?: string;
}
",
                                    "name": "FunctionImplementation.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface FunctionImplementationForMultipleLanguages {
  codeByLanguage: Record<TraceApi.Language, TraceApi.v2.v3.FunctionImplementation>;
}
",
                                    "name": "FunctionImplementationForMultipleLanguages.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export type FunctionSignature =
  | TraceApi.v2.v3.FunctionSignature.Void
  | TraceApi.v2.v3.FunctionSignature.NonVoid
  /**
   * Useful when specifying custom grading for a testcase where actualResult is defined. */
  | TraceApi.v2.v3.FunctionSignature.VoidThatTakesActualResult
  | TraceApi.v2.v3.FunctionSignature._Unknown;

export declare namespace FunctionSignature {
  interface Void extends TraceApi.v2.v3.VoidFunctionSignature, _Utils {
    type: \\"void\\";
  }

  interface NonVoid extends TraceApi.v2.v3.NonVoidFunctionSignature, _Utils {
    type: \\"nonVoid\\";
  }

  interface VoidThatTakesActualResult extends TraceApi.v2.v3.VoidFunctionSignatureThatTakesActualResult, _Utils {
    type: \\"voidThatTakesActualResult\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.v3.FunctionSignature._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    void: (value: TraceApi.v2.v3.VoidFunctionSignature) => _Result;
    nonVoid: (value: TraceApi.v2.v3.NonVoidFunctionSignature) => _Result;
    voidThatTakesActualResult: (value: TraceApi.v2.v3.VoidFunctionSignatureThatTakesActualResult) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const FunctionSignature = {
  void: (value: TraceApi.v2.v3.VoidFunctionSignature): TraceApi.v2.v3.FunctionSignature.Void => {
    const valueWithoutVisit: Omit<TraceApi.v2.v3.FunctionSignature.Void, \\"_visit\\"> = {
      ...value,
      type: \\"void\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.FunctionSignature.Void, visitor: TraceApi.v2.v3.FunctionSignature._Visitor<_Result>) {
      return TraceApi.v2.v3.FunctionSignature._visit(this, visitor);
    });
  },

  nonVoid: (value: TraceApi.v2.v3.NonVoidFunctionSignature): TraceApi.v2.v3.FunctionSignature.NonVoid => {
    const valueWithoutVisit: Omit<TraceApi.v2.v3.FunctionSignature.NonVoid, \\"_visit\\"> = {
      ...value,
      type: \\"nonVoid\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.FunctionSignature.NonVoid, visitor: TraceApi.v2.v3.FunctionSignature._Visitor<_Result>) {
      return TraceApi.v2.v3.FunctionSignature._visit(this, visitor);
    });
  },

  voidThatTakesActualResult: (
    value: TraceApi.v2.v3.VoidFunctionSignatureThatTakesActualResult
  ): TraceApi.v2.v3.FunctionSignature.VoidThatTakesActualResult => {
    const valueWithoutVisit: Omit<TraceApi.v2.v3.FunctionSignature.VoidThatTakesActualResult, \\"_visit\\"> = {
      ...value,
      type: \\"voidThatTakesActualResult\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.FunctionSignature.VoidThatTakesActualResult, visitor: TraceApi.v2.v3.FunctionSignature._Visitor<_Result>) {
      return TraceApi.v2.v3.FunctionSignature._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.v2.v3.FunctionSignature._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.v2.v3.FunctionSignature._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.FunctionSignature._Unknown, visitor: TraceApi.v2.v3.FunctionSignature._Visitor<_Result>) {
      return TraceApi.v2.v3.FunctionSignature._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.v3.FunctionSignature,
    visitor: TraceApi.v2.v3.FunctionSignature._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"void\\":
        return visitor.void(value);
      case \\"nonVoid\\":
        return visitor.nonVoid(value);
      case \\"voidThatTakesActualResult\\":
        return visitor.voidThatTakesActualResult(value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                                    "name": "FunctionSignature.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GeneratedFiles {
  generatedTestCaseFiles: Record<TraceApi.Language, TraceApi.v2.v3.Files>;
  generatedTemplateFiles: Record<TraceApi.Language, TraceApi.v2.v3.Files>;
  other: Record<TraceApi.Language, TraceApi.v2.v3.Files>;
}
",
                                    "name": "GeneratedFiles.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetBasicSolutionFileRequest {
  methodName: string;
  signature: TraceApi.v2.v3.NonVoidFunctionSignature;
}
",
                                    "name": "GetBasicSolutionFileRequest.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetBasicSolutionFileResponse {
  solutionFileByLanguage: Record<TraceApi.Language, TraceApi.v2.v3.FileInfoV2>;
}
",
                                    "name": "GetBasicSolutionFileResponse.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetFunctionSignatureRequest {
  functionSignature: TraceApi.v2.v3.FunctionSignature;
}
",
                                    "name": "GetFunctionSignatureRequest.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetFunctionSignatureResponse {
  functionByLanguage: Record<TraceApi.Language, string>;
}
",
                                    "name": "GetFunctionSignatureResponse.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetGeneratedTestCaseFileRequest {
  template?: TraceApi.v2.v3.TestCaseTemplate;
  testCase: TraceApi.v2.v3.TestCaseV2;
}
",
                                    "name": "GetGeneratedTestCaseFileRequest.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface GetGeneratedTestCaseTemplateFileRequest {
  template: TraceApi.v2.v3.TestCaseTemplate;
}
",
                                    "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface LightweightProblemInfoV2 {
  problemId: TraceApi.ProblemId;
  problemName: string;
  problemVersion: number;
  variableTypes: TraceApi.VariableType[];
}
",
                                    "name": "LightweightProblemInfoV2.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface NonVoidFunctionDefinition {
  signature: TraceApi.v2.v3.NonVoidFunctionSignature;
  code: TraceApi.v2.v3.FunctionImplementationForMultipleLanguages;
}
",
                                    "name": "NonVoidFunctionDefinition.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface NonVoidFunctionSignature {
  parameters: TraceApi.v2.v3.Parameter[];
  returnType: TraceApi.VariableType;
}
",
                                    "name": "NonVoidFunctionSignature.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface Parameter {
  parameterId: TraceApi.v2.v3.ParameterId;
  name: string;
  variableType: TraceApi.VariableType;
}
",
                                    "name": "Parameter.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type ParameterId = string & {
  v2_v3_ParameterId: void;
};

export function ParameterId(value: string): TraceApi.v2.v3.ParameterId {
  return value as unknown as TraceApi.v2.v3.ParameterId;
}
",
                                    "name": "ParameterId.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface ProblemInfoV2 {
  problemId: TraceApi.ProblemId;
  problemDescription: TraceApi.ProblemDescription;
  problemName: string;
  problemVersion: number;
  supportedLanguages: TraceApi.Language[];
  customFiles: TraceApi.v2.v3.CustomFiles;
  generatedFiles: TraceApi.v2.v3.GeneratedFiles;
  customTestCaseTemplates: TraceApi.v2.v3.TestCaseTemplate[];
  testcases: TraceApi.v2.v3.TestCaseV2[];
  isPublic: boolean;
}
",
                                    "name": "ProblemInfoV2.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

export interface TestCaseExpects {
  expectedStdout?: string;
}
",
                                    "name": "TestCaseExpects.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export type TestCaseFunction =
  | TraceApi.v2.v3.TestCaseFunction.WithActualResult
  | TraceApi.v2.v3.TestCaseFunction.Custom
  | TraceApi.v2.v3.TestCaseFunction._Unknown;

export declare namespace TestCaseFunction {
  interface WithActualResult extends TraceApi.v2.v3.TestCaseWithActualResultImplementation, _Utils {
    type: \\"withActualResult\\";
  }

  interface Custom extends TraceApi.v2.v3.VoidFunctionDefinition, _Utils {
    type: \\"custom\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.v3.TestCaseFunction._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    withActualResult: (value: TraceApi.v2.v3.TestCaseWithActualResultImplementation) => _Result;
    custom: (value: TraceApi.v2.v3.VoidFunctionDefinition) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const TestCaseFunction = {
  withActualResult: (
    value: TraceApi.v2.v3.TestCaseWithActualResultImplementation
  ): TraceApi.v2.v3.TestCaseFunction.WithActualResult => {
    const valueWithoutVisit: Omit<TraceApi.v2.v3.TestCaseFunction.WithActualResult, \\"_visit\\"> = {
      ...value,
      type: \\"withActualResult\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.TestCaseFunction.WithActualResult, visitor: TraceApi.v2.v3.TestCaseFunction._Visitor<_Result>) {
      return TraceApi.v2.v3.TestCaseFunction._visit(this, visitor);
    });
  },

  custom: (value: TraceApi.v2.v3.VoidFunctionDefinition): TraceApi.v2.v3.TestCaseFunction.Custom => {
    const valueWithoutVisit: Omit<TraceApi.v2.v3.TestCaseFunction.Custom, \\"_visit\\"> = {
      ...value,
      type: \\"custom\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.TestCaseFunction.Custom, visitor: TraceApi.v2.v3.TestCaseFunction._Visitor<_Result>) {
      return TraceApi.v2.v3.TestCaseFunction._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.v2.v3.TestCaseFunction._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<TraceApi.v2.v3.TestCaseFunction._Unknown, \\"_visit\\">;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.TestCaseFunction._Unknown, visitor: TraceApi.v2.v3.TestCaseFunction._Visitor<_Result>) {
      return TraceApi.v2.v3.TestCaseFunction._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.v3.TestCaseFunction,
    visitor: TraceApi.v2.v3.TestCaseFunction._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"withActualResult\\":
        return visitor.withActualResult(value);
      case \\"custom\\":
        return visitor.custom(value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                                    "name": "TestCaseFunction.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type TestCaseId = string & {
  v2_v3_TestCaseId: void;
};

export function TestCaseId(value: string): TraceApi.v2.v3.TestCaseId {
  return value as unknown as TraceApi.v2.v3.TestCaseId;
}
",
                                    "name": "TestCaseId.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseImplementation {
  description: TraceApi.v2.v3.TestCaseImplementationDescription;
  function: TraceApi.v2.v3.TestCaseFunction;
}
",
                                    "name": "TestCaseImplementation.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseImplementationDescription {
  boards: TraceApi.v2.v3.TestCaseImplementationDescriptionBoard[];
}
",
                                    "name": "TestCaseImplementationDescription.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export type TestCaseImplementationDescriptionBoard =
  | TraceApi.v2.v3.TestCaseImplementationDescriptionBoard.Html
  | TraceApi.v2.v3.TestCaseImplementationDescriptionBoard.ParamId
  | TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._Unknown;

export declare namespace TestCaseImplementationDescriptionBoard {
  interface Html extends _Utils {
    type: \\"html\\";
    value: string;
  }

  interface ParamId extends _Utils {
    type: \\"paramId\\";
    value: TraceApi.v2.v3.ParameterId;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    html: (value: string) => _Result;
    paramId: (value: TraceApi.v2.v3.ParameterId) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const TestCaseImplementationDescriptionBoard = {
  html: (value: string): TraceApi.v2.v3.TestCaseImplementationDescriptionBoard.Html => {
    const valueWithoutVisit: Omit<TraceApi.v2.v3.TestCaseImplementationDescriptionBoard.Html, \\"_visit\\"> = {
      value: value,
      type: \\"html\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.TestCaseImplementationDescriptionBoard.Html, visitor: TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._Visitor<_Result>) {
      return TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._visit(this, visitor);
    });
  },

  paramId: (value: TraceApi.v2.v3.ParameterId): TraceApi.v2.v3.TestCaseImplementationDescriptionBoard.ParamId => {
    const valueWithoutVisit: Omit<TraceApi.v2.v3.TestCaseImplementationDescriptionBoard.ParamId, \\"_visit\\"> = {
      value: value,
      type: \\"paramId\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.TestCaseImplementationDescriptionBoard.ParamId, visitor: TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._Visitor<_Result>) {
      return TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<
      TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._Unknown, visitor: TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._Visitor<_Result>) {
      return TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.v3.TestCaseImplementationDescriptionBoard,
    visitor: TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"html\\":
        return visitor.html(value.value);
      case \\"paramId\\":
        return visitor.paramId(value.value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                                    "name": "TestCaseImplementationDescriptionBoard.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export type TestCaseImplementationReference =
  | TraceApi.v2.v3.TestCaseImplementationReference.TemplateId
  | TraceApi.v2.v3.TestCaseImplementationReference.Implementation
  | TraceApi.v2.v3.TestCaseImplementationReference._Unknown;

export declare namespace TestCaseImplementationReference {
  interface TemplateId extends _Utils {
    type: \\"templateId\\";
    value: TraceApi.v2.v3.TestCaseTemplateId;
  }

  interface Implementation extends TraceApi.v2.v3.TestCaseImplementation, _Utils {
    type: \\"implementation\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.v3.TestCaseImplementationReference._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    templateId: (value: TraceApi.v2.v3.TestCaseTemplateId) => _Result;
    implementation: (value: TraceApi.v2.v3.TestCaseImplementation) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const TestCaseImplementationReference = {
  templateId: (value: TraceApi.v2.v3.TestCaseTemplateId): TraceApi.v2.v3.TestCaseImplementationReference.TemplateId => {
    const valueWithoutVisit: Omit<TraceApi.v2.v3.TestCaseImplementationReference.TemplateId, \\"_visit\\"> = {
      value: value,
      type: \\"templateId\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.TestCaseImplementationReference.TemplateId, visitor: TraceApi.v2.v3.TestCaseImplementationReference._Visitor<_Result>) {
      return TraceApi.v2.v3.TestCaseImplementationReference._visit(this, visitor);
    });
  },

  implementation: (
    value: TraceApi.v2.v3.TestCaseImplementation
  ): TraceApi.v2.v3.TestCaseImplementationReference.Implementation => {
    const valueWithoutVisit: Omit<TraceApi.v2.v3.TestCaseImplementationReference.Implementation, \\"_visit\\"> = {
      ...value,
      type: \\"implementation\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.TestCaseImplementationReference.Implementation, visitor: TraceApi.v2.v3.TestCaseImplementationReference._Visitor<_Result>) {
      return TraceApi.v2.v3.TestCaseImplementationReference._visit(this, visitor);
    });
  },

  _unknown: (value: { type: string }): TraceApi.v2.v3.TestCaseImplementationReference._Unknown => {
    const valueWithoutVisit = value as unknown as Omit<
      TraceApi.v2.v3.TestCaseImplementationReference._Unknown,
      \\"_visit\\"
    >;
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.TestCaseImplementationReference._Unknown, visitor: TraceApi.v2.v3.TestCaseImplementationReference._Visitor<_Result>) {
      return TraceApi.v2.v3.TestCaseImplementationReference._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.v3.TestCaseImplementationReference,
    visitor: TraceApi.v2.v3.TestCaseImplementationReference._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"templateId\\":
        return visitor.templateId(value.value);
      case \\"implementation\\":
        return visitor.implementation(value);
      default:
        return visitor._other(value as any);
    }
  },
} as const;
",
                                    "name": "TestCaseImplementationReference.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseMetadata {
  id: TraceApi.v2.v3.TestCaseId;
  name: string;
  hidden: boolean;
}
",
                                    "name": "TestCaseMetadata.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseTemplate {
  templateId: TraceApi.v2.v3.TestCaseTemplateId;
  name: string;
  implementation: TraceApi.v2.v3.TestCaseImplementation;
}
",
                                    "name": "TestCaseTemplate.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export type TestCaseTemplateId = string & {
  v2_v3_TestCaseTemplateId: void;
};

export function TestCaseTemplateId(value: string): TraceApi.v2.v3.TestCaseTemplateId {
  return value as unknown as TraceApi.v2.v3.TestCaseTemplateId;
}
",
                                    "name": "TestCaseTemplateId.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseV2 {
  metadata: TraceApi.v2.v3.TestCaseMetadata;
  implementation: TraceApi.v2.v3.TestCaseImplementationReference;
  arguments: Record<TraceApi.v2.v3.ParameterId, TraceApi.VariableValue>;
  expects?: TraceApi.v2.v3.TestCaseExpects;
}
",
                                    "name": "TestCaseV2.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface TestCaseWithActualResultImplementation {
  getActualResult: TraceApi.v2.v3.NonVoidFunctionDefinition;
  assertCorrectnessCheck: TraceApi.v2.v3.AssertCorrectnessCheck;
}
",
                                    "name": "TestCaseWithActualResultImplementation.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface VoidFunctionDefinition {
  parameters: TraceApi.v2.v3.Parameter[];
  code: TraceApi.v2.v3.FunctionImplementationForMultipleLanguages;
}
",
                                    "name": "VoidFunctionDefinition.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

/**
 * The generated signature will include an additional param, actualResult
 */
export interface VoidFunctionDefinitionThatTakesActualResult {
  additionalParameters: TraceApi.v2.v3.Parameter[];
  code: TraceApi.v2.v3.FunctionImplementationForMultipleLanguages;
}
",
                                    "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface VoidFunctionSignature {
  parameters: TraceApi.v2.v3.Parameter[];
}
",
                                    "name": "VoidFunctionSignature.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"@fern-trace/api-sdk\\";

export interface VoidFunctionSignatureThatTakesActualResult {
  parameters: TraceApi.v2.v3.Parameter[];
  actualResultType: TraceApi.VariableType;
}
",
                                    "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                                    "name": "index.ts",
                                    "type": "file",
                                  },
                                ],
                                "name": "types",
                                "type": "directory",
                              },
                            ],
                            "name": "problem",
                            "type": "directory",
                          },
                        ],
                        "name": "resources",
                        "type": "directory",
                      },
                    ],
                    "name": "v3",
                    "type": "directory",
                  },
                ],
                "name": "resources",
                "type": "directory",
              },
            ],
            "name": "v2",
            "type": "directory",
          },
        ],
        "name": "resources",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "export * as updateTestSubmissionStatus from \\"./updateTestSubmissionStatus\\";
export * as sendTestSubmissionUpdate from \\"./sendTestSubmissionUpdate\\";
export * as updateWorkspaceSubmissionStatus from \\"./updateWorkspaceSubmissionStatus\\";
export * as sendWorkspaceSubmissionUpdate from \\"./sendWorkspaceSubmissionUpdate\\";
export * as storeTracedTestCase from \\"./storeTracedTestCase\\";
export * as storeTracedTestCaseV2 from \\"./storeTracedTestCaseV2\\";
export * as storeTracedWorkspace from \\"./storeTracedWorkspace\\";
export * as storeTracedWorkspaceV2 from \\"./storeTracedWorkspaceV2\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.admin.sendTestSubmissionUpdate.Request.Raw,
  TraceApi.TestSubmissionUpdate
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).TestSubmissionUpdate);

export declare namespace Request {
  type Raw = serializers.TestSubmissionUpdate.Raw;
}
",
                    "name": "sendTestSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.admin.sendWorkspaceSubmissionUpdate.Request.Raw,
  TraceApi.WorkspaceSubmissionUpdate
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).WorkspaceSubmissionUpdate);

export declare namespace Request {
  type Raw = serializers.WorkspaceSubmissionUpdate.Raw;
}
",
                    "name": "sendWorkspaceSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.admin.storeTracedTestCase.Request.Raw,
  Omit<TraceApi.StoreTracedTestCaseRequest, \\"someQueryParam\\">
> = core.schemas.object({
  result: core.schemas.lazyObject(async () => (await import(\\"../..\\")).TestCaseResultWithStdout),
  traceResponses: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).TraceResponse)),
});

export declare namespace Request {
  interface Raw {
    result: serializers.TestCaseResultWithStdout.Raw;
    traceResponses: serializers.TraceResponse.Raw[];
  }
}
",
                    "name": "storeTracedTestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.admin.storeTracedTestCaseV2.Request.Raw,
  TraceApi.TraceResponseV2[]
> = core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).TraceResponseV2));

export declare namespace Request {
  type Raw = serializers.TraceResponseV2.Raw[];
}
",
                    "name": "storeTracedTestCaseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.admin.storeTracedWorkspace.Request.Raw,
  TraceApi.StoreTracedWorkspaceRequest
> = core.schemas.object({
  workspaceRunDetails: core.schemas.lazyObject(async () => (await import(\\"../..\\")).WorkspaceRunDetails),
  traceResponses: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).TraceResponse)),
});

export declare namespace Request {
  interface Raw {
    workspaceRunDetails: serializers.WorkspaceRunDetails.Raw;
    traceResponses: serializers.TraceResponse.Raw[];
  }
}
",
                    "name": "storeTracedWorkspace.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.admin.storeTracedWorkspaceV2.Request.Raw,
  TraceApi.TraceResponseV2[]
> = core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).TraceResponseV2));

export declare namespace Request {
  type Raw = serializers.TraceResponseV2.Raw[];
}
",
                    "name": "storeTracedWorkspaceV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.admin.updateTestSubmissionStatus.Request.Raw,
  TraceApi.TestSubmissionStatus
> = core.schemas.lazy(async () => (await import(\\"../..\\")).TestSubmissionStatus);

export declare namespace Request {
  type Raw = serializers.TestSubmissionStatus.Raw;
}
",
                    "name": "updateTestSubmissionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.admin.updateWorkspaceSubmissionStatus.Request.Raw,
  TraceApi.WorkspaceSubmissionStatus
> = core.schemas.lazy(async () => (await import(\\"../..\\")).WorkspaceSubmissionStatus);

export declare namespace Request {
  type Raw = serializers.WorkspaceSubmissionStatus.Raw;
}
",
                    "name": "updateWorkspaceSubmissionStatus.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "admin",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const BinaryTreeNodeAndTreeValue: core.schemas.ObjectSchema<
  serializers.BinaryTreeNodeAndTreeValue.Raw,
  TraceApi.BinaryTreeNodeAndTreeValue
> = core.schemas.object({
  nodeId: core.schemas.lazy(async () => (await import(\\"../..\\")).NodeId),
  fullTree: core.schemas.lazyObject(async () => (await import(\\"../..\\")).BinaryTreeValue),
});

export declare namespace BinaryTreeNodeAndTreeValue {
  interface Raw {
    nodeId: serializers.NodeId.Raw;
    fullTree: serializers.BinaryTreeValue.Raw;
  }
}
",
                    "name": "BinaryTreeNodeAndTreeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const BinaryTreeNodeValue: core.schemas.ObjectSchema<
  serializers.BinaryTreeNodeValue.Raw,
  TraceApi.BinaryTreeNodeValue
> = core.schemas.object({
  nodeId: core.schemas.lazy(async () => (await import(\\"../..\\")).NodeId),
  val: core.schemas.number(),
  right: core.schemas.lazy(async () => (await import(\\"../..\\")).NodeId).optional(),
  left: core.schemas.lazy(async () => (await import(\\"../..\\")).NodeId).optional(),
});

export declare namespace BinaryTreeNodeValue {
  interface Raw {
    nodeId: serializers.NodeId.Raw;
    val: number;
    right?: serializers.NodeId.Raw | null;
    left?: serializers.NodeId.Raw | null;
  }
}
",
                    "name": "BinaryTreeNodeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const BinaryTreeValue: core.schemas.ObjectSchema<serializers.BinaryTreeValue.Raw, TraceApi.BinaryTreeValue> =
  core.schemas.object({
    root: core.schemas.lazy(async () => (await import(\\"../..\\")).NodeId).optional(),
    nodes: core.schemas.record(
      core.schemas.lazy(async () => (await import(\\"../..\\")).NodeId),
      core.schemas.lazyObject(async () => (await import(\\"../..\\")).BinaryTreeNodeValue)
    ),
  });

export declare namespace BinaryTreeValue {
  interface Raw {
    root?: serializers.NodeId.Raw | null;
    nodes: Record<serializers.NodeId.Raw, serializers.BinaryTreeNodeValue.Raw>;
  }
}
",
                    "name": "BinaryTreeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const DebugKeyValuePairs: core.schemas.ObjectSchema<
  serializers.DebugKeyValuePairs.Raw,
  TraceApi.DebugKeyValuePairs
> = core.schemas.object({
  key: core.schemas.lazy(async () => (await import(\\"../..\\")).DebugVariableValue),
  value: core.schemas.lazy(async () => (await import(\\"../..\\")).DebugVariableValue),
});

export declare namespace DebugKeyValuePairs {
  interface Raw {
    key: serializers.DebugVariableValue.Raw;
    value: serializers.DebugVariableValue.Raw;
  }
}
",
                    "name": "DebugKeyValuePairs.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const DebugMapValue: core.schemas.ObjectSchema<serializers.DebugMapValue.Raw, TraceApi.DebugMapValue> =
  core.schemas.object({
    keyValuePairs: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).DebugKeyValuePairs)),
  });

export declare namespace DebugMapValue {
  interface Raw {
    keyValuePairs: serializers.DebugKeyValuePairs.Raw[];
  }
}
",
                    "name": "DebugMapValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const DebugVariableValue: core.schemas.Schema<serializers.DebugVariableValue.Raw, TraceApi.DebugVariableValue> =
  core.schemas
    .union(\\"type\\", {
      integerValue: core.schemas.object({
        value: core.schemas.number(),
      }),
      booleanValue: core.schemas.object({
        value: core.schemas.boolean(),
      }),
      doubleValue: core.schemas.object({
        value: core.schemas.number(),
      }),
      stringValue: core.schemas.object({
        value: core.schemas.string(),
      }),
      charValue: core.schemas.object({
        value: core.schemas.string(),
      }),
      mapValue: core.schemas.lazyObject(async () => (await import(\\"../..\\")).DebugMapValue),
      listValue: core.schemas.object({
        value: core.schemas.list(core.schemas.lazy(async () => (await import(\\"../..\\")).DebugVariableValue)),
      }),
      binaryTreeNodeValue: core.schemas.lazyObject(async () => (await import(\\"../..\\")).BinaryTreeNodeAndTreeValue),
      singlyLinkedListNodeValue: core.schemas.lazyObject(
        async () => (await import(\\"../..\\")).SinglyLinkedListNodeAndListValue
      ),
      doublyLinkedListNodeValue: core.schemas.lazyObject(
        async () => (await import(\\"../..\\")).DoublyLinkedListNodeAndListValue
      ),
      undefinedValue: core.schemas.object({}),
      nullValue: core.schemas.object({}),
      genericValue: core.schemas.lazyObject(async () => (await import(\\"../..\\")).GenericValue),
    })
    .transform<TraceApi.DebugVariableValue>({
      parse: (value) => {
        switch (value.type) {
          case \\"integerValue\\":
            return TraceApi.DebugVariableValue.integerValue(value.value);
          case \\"booleanValue\\":
            return TraceApi.DebugVariableValue.booleanValue(value.value);
          case \\"doubleValue\\":
            return TraceApi.DebugVariableValue.doubleValue(value.value);
          case \\"stringValue\\":
            return TraceApi.DebugVariableValue.stringValue(value.value);
          case \\"charValue\\":
            return TraceApi.DebugVariableValue.charValue(value.value);
          case \\"mapValue\\":
            return TraceApi.DebugVariableValue.mapValue(value);
          case \\"listValue\\":
            return TraceApi.DebugVariableValue.listValue(value.value);
          case \\"binaryTreeNodeValue\\":
            return TraceApi.DebugVariableValue.binaryTreeNodeValue(value);
          case \\"singlyLinkedListNodeValue\\":
            return TraceApi.DebugVariableValue.singlyLinkedListNodeValue(value);
          case \\"doublyLinkedListNodeValue\\":
            return TraceApi.DebugVariableValue.doublyLinkedListNodeValue(value);
          case \\"undefinedValue\\":
            return TraceApi.DebugVariableValue.undefinedValue();
          case \\"nullValue\\":
            return TraceApi.DebugVariableValue.nullValue();
          case \\"genericValue\\":
            return TraceApi.DebugVariableValue.genericValue(value);
          default:
            return TraceApi.DebugVariableValue._unknown(value);
        }
      },
      json: (value) => value as any,
    });

export declare namespace DebugVariableValue {
  type Raw =
    | DebugVariableValue.IntegerValue
    | DebugVariableValue.BooleanValue
    | DebugVariableValue.DoubleValue
    | DebugVariableValue.StringValue
    | DebugVariableValue.CharValue
    | DebugVariableValue.MapValue
    | DebugVariableValue.ListValue
    | DebugVariableValue.BinaryTreeNodeValue
    | DebugVariableValue.SinglyLinkedListNodeValue
    | DebugVariableValue.DoublyLinkedListNodeValue
    | DebugVariableValue.UndefinedValue
    | DebugVariableValue.NullValue
    | DebugVariableValue.GenericValue;

  interface IntegerValue {
    type: \\"integerValue\\";
    value: number;
  }

  interface BooleanValue {
    type: \\"booleanValue\\";
    value: boolean;
  }

  interface DoubleValue {
    type: \\"doubleValue\\";
    value: number;
  }

  interface StringValue {
    type: \\"stringValue\\";
    value: string;
  }

  interface CharValue {
    type: \\"charValue\\";
    value: string;
  }

  interface MapValue extends serializers.DebugMapValue.Raw {
    type: \\"mapValue\\";
  }

  interface ListValue {
    type: \\"listValue\\";
    value: serializers.DebugVariableValue.Raw[];
  }

  interface BinaryTreeNodeValue extends serializers.BinaryTreeNodeAndTreeValue.Raw {
    type: \\"binaryTreeNodeValue\\";
  }

  interface SinglyLinkedListNodeValue extends serializers.SinglyLinkedListNodeAndListValue.Raw {
    type: \\"singlyLinkedListNodeValue\\";
  }

  interface DoublyLinkedListNodeValue extends serializers.DoublyLinkedListNodeAndListValue.Raw {
    type: \\"doublyLinkedListNodeValue\\";
  }

  interface UndefinedValue {
    type: \\"undefinedValue\\";
  }

  interface NullValue {
    type: \\"nullValue\\";
  }

  interface GenericValue extends serializers.GenericValue.Raw {
    type: \\"genericValue\\";
  }
}
",
                    "name": "DebugVariableValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const DoublyLinkedListNodeAndListValue: core.schemas.ObjectSchema<
  serializers.DoublyLinkedListNodeAndListValue.Raw,
  TraceApi.DoublyLinkedListNodeAndListValue
> = core.schemas.object({
  nodeId: core.schemas.lazy(async () => (await import(\\"../..\\")).NodeId),
  fullList: core.schemas.lazyObject(async () => (await import(\\"../..\\")).DoublyLinkedListValue),
});

export declare namespace DoublyLinkedListNodeAndListValue {
  interface Raw {
    nodeId: serializers.NodeId.Raw;
    fullList: serializers.DoublyLinkedListValue.Raw;
  }
}
",
                    "name": "DoublyLinkedListNodeAndListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const DoublyLinkedListNodeValue: core.schemas.ObjectSchema<
  serializers.DoublyLinkedListNodeValue.Raw,
  TraceApi.DoublyLinkedListNodeValue
> = core.schemas.object({
  nodeId: core.schemas.lazy(async () => (await import(\\"../..\\")).NodeId),
  val: core.schemas.number(),
  next: core.schemas.lazy(async () => (await import(\\"../..\\")).NodeId).optional(),
  prev: core.schemas.lazy(async () => (await import(\\"../..\\")).NodeId).optional(),
});

export declare namespace DoublyLinkedListNodeValue {
  interface Raw {
    nodeId: serializers.NodeId.Raw;
    val: number;
    next?: serializers.NodeId.Raw | null;
    prev?: serializers.NodeId.Raw | null;
  }
}
",
                    "name": "DoublyLinkedListNodeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const DoublyLinkedListValue: core.schemas.ObjectSchema<
  serializers.DoublyLinkedListValue.Raw,
  TraceApi.DoublyLinkedListValue
> = core.schemas.object({
  head: core.schemas.lazy(async () => (await import(\\"../..\\")).NodeId).optional(),
  nodes: core.schemas.record(
    core.schemas.lazy(async () => (await import(\\"../..\\")).NodeId),
    core.schemas.lazyObject(async () => (await import(\\"../..\\")).DoublyLinkedListNodeValue)
  ),
});

export declare namespace DoublyLinkedListValue {
  interface Raw {
    head?: serializers.NodeId.Raw | null;
    nodes: Record<serializers.NodeId.Raw, serializers.DoublyLinkedListNodeValue.Raw>;
  }
}
",
                    "name": "DoublyLinkedListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const FileInfo: core.schemas.ObjectSchema<serializers.FileInfo.Raw, TraceApi.FileInfo> = core.schemas.object({
  filename: core.schemas.string(),
  contents: core.schemas.string(),
});

export declare namespace FileInfo {
  interface Raw {
    filename: string;
    contents: string;
  }
}
",
                    "name": "FileInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const GenericValue: core.schemas.ObjectSchema<serializers.GenericValue.Raw, TraceApi.GenericValue> =
  core.schemas.object({
    stringifiedType: core.schemas.string().optional(),
    stringifiedValue: core.schemas.string(),
  });

export declare namespace GenericValue {
  interface Raw {
    stringifiedType?: string | null;
    stringifiedValue: string;
  }
}
",
                    "name": "GenericValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const KeyValuePair: core.schemas.ObjectSchema<serializers.KeyValuePair.Raw, TraceApi.KeyValuePair> =
  core.schemas.object({
    key: core.schemas.lazy(async () => (await import(\\"../..\\")).VariableValue),
    value: core.schemas.lazy(async () => (await import(\\"../..\\")).VariableValue),
  });

export declare namespace KeyValuePair {
  interface Raw {
    key: serializers.VariableValue.Raw;
    value: serializers.VariableValue.Raw;
  }
}
",
                    "name": "KeyValuePair.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Language: core.schemas.Schema<serializers.Language.Raw, TraceApi.Language> = core.schemas.enum_([
  \\"JAVA\\",
  \\"JAVASCRIPT\\",
  \\"PYTHON\\",
]);

export declare namespace Language {
  type Raw = \\"JAVA\\" | \\"JAVASCRIPT\\" | \\"PYTHON\\";
}
",
                    "name": "Language.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const ListType: core.schemas.ObjectSchema<serializers.ListType.Raw, TraceApi.ListType> = core.schemas.object({
  valueType: core.schemas.lazy(async () => (await import(\\"../..\\")).VariableType),
  isFixedLength: core.schemas.boolean().optional(),
});

export declare namespace ListType {
  interface Raw {
    valueType: serializers.VariableType.Raw;
    isFixedLength?: boolean | null;
  }
}
",
                    "name": "ListType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const MapType: core.schemas.ObjectSchema<serializers.MapType.Raw, TraceApi.MapType> = core.schemas.object({
  keyType: core.schemas.lazy(async () => (await import(\\"../..\\")).VariableType),
  valueType: core.schemas.lazy(async () => (await import(\\"../..\\")).VariableType),
});

export declare namespace MapType {
  interface Raw {
    keyType: serializers.VariableType.Raw;
    valueType: serializers.VariableType.Raw;
  }
}
",
                    "name": "MapType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const MapValue: core.schemas.ObjectSchema<serializers.MapValue.Raw, TraceApi.MapValue> = core.schemas.object({
  keyValuePairs: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).KeyValuePair)),
});

export declare namespace MapValue {
  interface Raw {
    keyValuePairs: serializers.KeyValuePair.Raw[];
  }
}
",
                    "name": "MapValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const NodeId: core.schemas.Schema<serializers.NodeId.Raw, TraceApi.NodeId> = core.schemas.string().transform({
  parse: TraceApi.NodeId,
  json: (value) => value,
});

export declare namespace NodeId {
  type Raw = string;
}
",
                    "name": "NodeId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const ProblemId: core.schemas.Schema<serializers.ProblemId.Raw, TraceApi.ProblemId> = core.schemas
  .string()
  .transform({
    parse: TraceApi.ProblemId,
    json: (value) => value,
  });

export declare namespace ProblemId {
  type Raw = string;
}
",
                    "name": "ProblemId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const RandomUnknownType: core.schemas.Schema<serializers.RandomUnknownType.Raw, TraceApi.RandomUnknownType> =
  core.schemas.unknown();

export declare namespace RandomUnknownType {
  type Raw = unknown;
}
",
                    "name": "RandomUnknownType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const SinglyLinkedListNodeAndListValue: core.schemas.ObjectSchema<
  serializers.SinglyLinkedListNodeAndListValue.Raw,
  TraceApi.SinglyLinkedListNodeAndListValue
> = core.schemas.object({
  nodeId: core.schemas.lazy(async () => (await import(\\"../..\\")).NodeId),
  fullList: core.schemas.lazyObject(async () => (await import(\\"../..\\")).SinglyLinkedListValue),
});

export declare namespace SinglyLinkedListNodeAndListValue {
  interface Raw {
    nodeId: serializers.NodeId.Raw;
    fullList: serializers.SinglyLinkedListValue.Raw;
  }
}
",
                    "name": "SinglyLinkedListNodeAndListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const SinglyLinkedListNodeValue: core.schemas.ObjectSchema<
  serializers.SinglyLinkedListNodeValue.Raw,
  TraceApi.SinglyLinkedListNodeValue
> = core.schemas.object({
  nodeId: core.schemas.lazy(async () => (await import(\\"../..\\")).NodeId),
  val: core.schemas.number(),
  next: core.schemas.lazy(async () => (await import(\\"../..\\")).NodeId).optional(),
});

export declare namespace SinglyLinkedListNodeValue {
  interface Raw {
    nodeId: serializers.NodeId.Raw;
    val: number;
    next?: serializers.NodeId.Raw | null;
  }
}
",
                    "name": "SinglyLinkedListNodeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const SinglyLinkedListValue: core.schemas.ObjectSchema<
  serializers.SinglyLinkedListValue.Raw,
  TraceApi.SinglyLinkedListValue
> = core.schemas.object({
  head: core.schemas.lazy(async () => (await import(\\"../..\\")).NodeId).optional(),
  nodes: core.schemas.record(
    core.schemas.lazy(async () => (await import(\\"../..\\")).NodeId),
    core.schemas.lazyObject(async () => (await import(\\"../..\\")).SinglyLinkedListNodeValue)
  ),
});

export declare namespace SinglyLinkedListValue {
  interface Raw {
    head?: serializers.NodeId.Raw | null;
    nodes: Record<serializers.NodeId.Raw, serializers.SinglyLinkedListNodeValue.Raw>;
  }
}
",
                    "name": "SinglyLinkedListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const TestCase: core.schemas.ObjectSchema<serializers.TestCase.Raw, TraceApi.TestCase> = core.schemas.object({
  id: core.schemas.string(),
  params: core.schemas.list(core.schemas.lazy(async () => (await import(\\"../..\\")).VariableValue)),
});

export declare namespace TestCase {
  interface Raw {
    id: string;
    params: serializers.VariableValue.Raw[];
  }
}
",
                    "name": "TestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const TestCaseWithExpectedResult: core.schemas.ObjectSchema<
  serializers.TestCaseWithExpectedResult.Raw,
  TraceApi.TestCaseWithExpectedResult
> = core.schemas.object({
  testCase: core.schemas.lazyObject(async () => (await import(\\"../..\\")).TestCase),
  expectedResult: core.schemas.lazy(async () => (await import(\\"../..\\")).VariableValue),
});

export declare namespace TestCaseWithExpectedResult {
  interface Raw {
    testCase: serializers.TestCase.Raw;
    expectedResult: serializers.VariableValue.Raw;
  }
}
",
                    "name": "TestCaseWithExpectedResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const UserId: core.schemas.Schema<serializers.UserId.Raw, TraceApi.UserId> = core.schemas.string().transform({
  parse: TraceApi.UserId,
  json: (value) => value,
});

export declare namespace UserId {
  type Raw = string;
}
",
                    "name": "UserId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const VariableType: core.schemas.Schema<serializers.VariableType.Raw, TraceApi.VariableType> = core.schemas
  .union(\\"type\\", {
    integerType: core.schemas.object({}),
    doubleType: core.schemas.object({}),
    booleanType: core.schemas.object({}),
    stringType: core.schemas.object({}),
    charType: core.schemas.object({}),
    listType: core.schemas.lazyObject(async () => (await import(\\"../..\\")).ListType),
    mapType: core.schemas.lazyObject(async () => (await import(\\"../..\\")).MapType),
    binaryTreeType: core.schemas.object({}),
    singlyLinkedListType: core.schemas.object({}),
    doublyLinkedListType: core.schemas.object({}),
  })
  .transform<TraceApi.VariableType>({
    parse: (value) => {
      switch (value.type) {
        case \\"integerType\\":
          return TraceApi.VariableType.integerType();
        case \\"doubleType\\":
          return TraceApi.VariableType.doubleType();
        case \\"booleanType\\":
          return TraceApi.VariableType.booleanType();
        case \\"stringType\\":
          return TraceApi.VariableType.stringType();
        case \\"charType\\":
          return TraceApi.VariableType.charType();
        case \\"listType\\":
          return TraceApi.VariableType.listType(value);
        case \\"mapType\\":
          return TraceApi.VariableType.mapType(value);
        case \\"binaryTreeType\\":
          return TraceApi.VariableType.binaryTreeType();
        case \\"singlyLinkedListType\\":
          return TraceApi.VariableType.singlyLinkedListType();
        case \\"doublyLinkedListType\\":
          return TraceApi.VariableType.doublyLinkedListType();
        default:
          return TraceApi.VariableType._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace VariableType {
  type Raw =
    | VariableType.IntegerType
    | VariableType.DoubleType
    | VariableType.BooleanType
    | VariableType.StringType
    | VariableType.CharType
    | VariableType.ListType
    | VariableType.MapType
    | VariableType.BinaryTreeType
    | VariableType.SinglyLinkedListType
    | VariableType.DoublyLinkedListType;

  interface IntegerType {
    type: \\"integerType\\";
  }

  interface DoubleType {
    type: \\"doubleType\\";
  }

  interface BooleanType {
    type: \\"booleanType\\";
  }

  interface StringType {
    type: \\"stringType\\";
  }

  interface CharType {
    type: \\"charType\\";
  }

  interface ListType extends serializers.ListType.Raw {
    type: \\"listType\\";
  }

  interface MapType extends serializers.MapType.Raw {
    type: \\"mapType\\";
  }

  interface BinaryTreeType {
    type: \\"binaryTreeType\\";
  }

  interface SinglyLinkedListType {
    type: \\"singlyLinkedListType\\";
  }

  interface DoublyLinkedListType {
    type: \\"doublyLinkedListType\\";
  }
}
",
                    "name": "VariableType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const VariableValue: core.schemas.Schema<serializers.VariableValue.Raw, TraceApi.VariableValue> = core.schemas
  .union(\\"type\\", {
    integerValue: core.schemas.object({
      value: core.schemas.number(),
    }),
    booleanValue: core.schemas.object({
      value: core.schemas.boolean(),
    }),
    doubleValue: core.schemas.object({
      value: core.schemas.number(),
    }),
    stringValue: core.schemas.object({
      value: core.schemas.string(),
    }),
    charValue: core.schemas.object({
      value: core.schemas.string(),
    }),
    mapValue: core.schemas.lazyObject(async () => (await import(\\"../..\\")).MapValue),
    listValue: core.schemas.object({
      value: core.schemas.list(core.schemas.lazy(async () => (await import(\\"../..\\")).VariableValue)),
    }),
    binaryTreeValue: core.schemas.lazyObject(async () => (await import(\\"../..\\")).BinaryTreeValue),
    singlyLinkedListValue: core.schemas.lazyObject(async () => (await import(\\"../..\\")).SinglyLinkedListValue),
    doublyLinkedListValue: core.schemas.lazyObject(async () => (await import(\\"../..\\")).DoublyLinkedListValue),
    nullValue: core.schemas.object({}),
  })
  .transform<TraceApi.VariableValue>({
    parse: (value) => {
      switch (value.type) {
        case \\"integerValue\\":
          return TraceApi.VariableValue.integerValue(value.value);
        case \\"booleanValue\\":
          return TraceApi.VariableValue.booleanValue(value.value);
        case \\"doubleValue\\":
          return TraceApi.VariableValue.doubleValue(value.value);
        case \\"stringValue\\":
          return TraceApi.VariableValue.stringValue(value.value);
        case \\"charValue\\":
          return TraceApi.VariableValue.charValue(value.value);
        case \\"mapValue\\":
          return TraceApi.VariableValue.mapValue(value);
        case \\"listValue\\":
          return TraceApi.VariableValue.listValue(value.value);
        case \\"binaryTreeValue\\":
          return TraceApi.VariableValue.binaryTreeValue(value);
        case \\"singlyLinkedListValue\\":
          return TraceApi.VariableValue.singlyLinkedListValue(value);
        case \\"doublyLinkedListValue\\":
          return TraceApi.VariableValue.doublyLinkedListValue(value);
        case \\"nullValue\\":
          return TraceApi.VariableValue.nullValue();
        default:
          return TraceApi.VariableValue._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace VariableValue {
  type Raw =
    | VariableValue.IntegerValue
    | VariableValue.BooleanValue
    | VariableValue.DoubleValue
    | VariableValue.StringValue
    | VariableValue.CharValue
    | VariableValue.MapValue
    | VariableValue.ListValue
    | VariableValue.BinaryTreeValue
    | VariableValue.SinglyLinkedListValue
    | VariableValue.DoublyLinkedListValue
    | VariableValue.NullValue;

  interface IntegerValue {
    type: \\"integerValue\\";
    value: number;
  }

  interface BooleanValue {
    type: \\"booleanValue\\";
    value: boolean;
  }

  interface DoubleValue {
    type: \\"doubleValue\\";
    value: number;
  }

  interface StringValue {
    type: \\"stringValue\\";
    value: string;
  }

  interface CharValue {
    type: \\"charValue\\";
    value: string;
  }

  interface MapValue extends serializers.MapValue.Raw {
    type: \\"mapValue\\";
  }

  interface ListValue {
    type: \\"listValue\\";
    value: serializers.VariableValue.Raw[];
  }

  interface BinaryTreeValue extends serializers.BinaryTreeValue.Raw {
    type: \\"binaryTreeValue\\";
  }

  interface SinglyLinkedListValue extends serializers.SinglyLinkedListValue.Raw {
    type: \\"singlyLinkedListValue\\";
  }

  interface DoublyLinkedListValue extends serializers.DoublyLinkedListValue.Raw {
    type: \\"doublyLinkedListValue\\";
  }

  interface NullValue {
    type: \\"nullValue\\";
  }
}
",
                    "name": "VariableValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./UserId\\";
export * from \\"./ProblemId\\";
export * from \\"./NodeId\\";
export * from \\"./VariableType\\";
export * from \\"./ListType\\";
export * from \\"./MapType\\";
export * from \\"./VariableValue\\";
export * from \\"./DebugVariableValue\\";
export * from \\"./GenericValue\\";
export * from \\"./MapValue\\";
export * from \\"./KeyValuePair\\";
export * from \\"./BinaryTreeValue\\";
export * from \\"./BinaryTreeNodeValue\\";
export * from \\"./BinaryTreeNodeAndTreeValue\\";
export * from \\"./SinglyLinkedListValue\\";
export * from \\"./SinglyLinkedListNodeValue\\";
export * from \\"./SinglyLinkedListNodeAndListValue\\";
export * from \\"./DoublyLinkedListValue\\";
export * from \\"./DoublyLinkedListNodeValue\\";
export * from \\"./DoublyLinkedListNodeAndListValue\\";
export * from \\"./DebugMapValue\\";
export * from \\"./DebugKeyValuePairs\\";
export * from \\"./TestCase\\";
export * from \\"./TestCaseWithExpectedResult\\";
export * from \\"./FileInfo\\";
export * from \\"./Language\\";
export * from \\"./RandomUnknownType\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "commons",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  serializers.homepage.getHomepageProblems.Response.Raw,
  TraceApi.ProblemId[]
> = core.schemas.list(core.schemas.lazy(async () => (await import(\\"../..\\")).ProblemId));

export declare namespace Response {
  type Raw = serializers.ProblemId.Raw[];
}
",
                    "name": "getHomepageProblems.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getHomepageProblems from \\"./getHomepageProblems\\";
export * as setHomepageProblems from \\"./setHomepageProblems\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<serializers.homepage.setHomepageProblems.Request.Raw, TraceApi.ProblemId[]> =
  core.schemas.list(core.schemas.lazy(async () => (await import(\\"../..\\")).ProblemId));

export declare namespace Request {
  type Raw = serializers.ProblemId.Raw[];
}
",
                    "name": "setHomepageProblems.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "homepage",
            "type": "directory",
          },
          Object {
            "contents": "export * as commons from \\"./commons\\";
export * from \\"./commons/types\\";
export * as langServer from \\"./langServer\\";
export * from \\"./langServer/types\\";
export * as migration from \\"./migration\\";
export * from \\"./migration/types\\";
export * as playlist from \\"./playlist\\";
export * from \\"./playlist/types\\";
export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as submission from \\"./submission\\";
export * from \\"./submission/types\\";
export * as v2 from \\"./v2\\";
export * from \\"./playlist/errors\\";
export * as admin from \\"./admin\\";
export * as homepage from \\"./homepage\\";
export * as sysprop from \\"./sysprop\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const LangServerRequest: core.schemas.ObjectSchema<
  serializers.LangServerRequest.Raw,
  TraceApi.LangServerRequest
> = core.schemas.object({
  request: core.schemas.unknown(),
});

export declare namespace LangServerRequest {
  interface Raw {
    request?: unknown;
  }
}
",
                    "name": "LangServerRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const LangServerResponse: core.schemas.ObjectSchema<
  serializers.LangServerResponse.Raw,
  TraceApi.LangServerResponse
> = core.schemas.object({
  response: core.schemas.unknown(),
});

export declare namespace LangServerResponse {
  interface Raw {
    response?: unknown;
  }
}
",
                    "name": "LangServerResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./LangServerRequest\\";
export * from \\"./LangServerResponse\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "langServer",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  serializers.migration.getAttemptedMigrations.Response.Raw,
  TraceApi.Migration[]
> = core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).Migration));

export declare namespace Response {
  type Raw = serializers.Migration.Raw[];
}
",
                    "name": "getAttemptedMigrations.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getAttemptedMigrations from \\"./getAttemptedMigrations\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Migration: core.schemas.ObjectSchema<serializers.Migration.Raw, TraceApi.Migration> = core.schemas.object({
  name: core.schemas.string(),
  status: core.schemas.lazy(async () => (await import(\\"../..\\")).MigrationStatus),
});

export declare namespace Migration {
  interface Raw {
    name: string;
    status: serializers.MigrationStatus.Raw;
  }
}
",
                    "name": "Migration.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const MigrationStatus: core.schemas.Schema<serializers.MigrationStatus.Raw, TraceApi.MigrationStatus> =
  core.schemas.enum_([\\"RUNNING\\", \\"FAILED\\", \\"FINISHED\\"]);

export declare namespace MigrationStatus {
  type Raw = \\"RUNNING\\" | \\"FAILED\\" | \\"FINISHED\\";
}
",
                    "name": "MigrationStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./MigrationStatus\\";
export * from \\"./Migration\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "migration",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.playlist.createPlaylist.Request.Raw,
  TraceApi.PlaylistCreateRequest
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).PlaylistCreateRequest);

export declare namespace Request {
  type Raw = serializers.PlaylistCreateRequest.Raw;
}

export const Response: core.schemas.Schema<serializers.playlist.createPlaylist.Response.Raw, TraceApi.Playlist> =
  core.schemas.lazyObject(async () => (await import(\\"../..\\")).Playlist);

export declare namespace Response {
  type Raw = serializers.Playlist.Raw;
}
",
                    "name": "createPlaylist.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<serializers.playlist.getPlaylist.Response.Raw, TraceApi.Playlist> =
  core.schemas.lazyObject(async () => (await import(\\"../..\\")).Playlist);

export declare namespace Response {
  type Raw = serializers.Playlist.Raw;
}

export const Error: core.schemas.Schema<
  serializers.playlist.getPlaylist.Error.Raw,
  TraceApi.playlist.getPlaylist.Error
> = core.schemas
  .union(\\"errorName\\", {
    PlaylistIdNotFoundError: core.schemas.object({
      content: core.schemas.lazy(async () => (await import(\\"../..\\")).PlaylistIdNotFoundError),
    }),
    UnauthorizedError: core.schemas.object({}),
  })
  .transform<TraceApi.playlist.getPlaylist.Error>({
    parse: (value) => {
      switch (value.errorName) {
        case \\"PlaylistIdNotFoundError\\":
          return TraceApi.playlist.getPlaylist.Error.playlistIdNotFoundError(value.content);
        case \\"UnauthorizedError\\":
          return TraceApi.playlist.getPlaylist.Error.unauthorizedError();
      }
    },
    json: (value) => value as any,
  });

export declare namespace Error {
  type Raw = Error.PlaylistIdNotFoundError | Error.UnauthorizedError;

  interface PlaylistIdNotFoundError {
    errorName: \\"PlaylistIdNotFoundError\\";
    content: serializers.PlaylistIdNotFoundError.Raw;
  }

  interface UnauthorizedError {
    errorName: \\"UnauthorizedError\\";
  }
}
",
                    "name": "getPlaylist.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<serializers.playlist.getPlaylists.Response.Raw, TraceApi.Playlist[]> =
  core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).Playlist));

export declare namespace Response {
  type Raw = serializers.Playlist.Raw[];
}
",
                    "name": "getPlaylists.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as createPlaylist from \\"./createPlaylist\\";
export * as getPlaylists from \\"./getPlaylists\\";
export * as getPlaylist from \\"./getPlaylist\\";
export * as updatePlaylist from \\"./updatePlaylist\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.playlist.updatePlaylist.Request.Raw,
  TraceApi.UpdatePlaylistRequest | undefined
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).UpdatePlaylistRequest).optional();

export declare namespace Request {
  type Raw = serializers.UpdatePlaylistRequest.Raw | null | undefined;
}

export const Response: core.schemas.Schema<
  serializers.playlist.updatePlaylist.Response.Raw,
  TraceApi.Playlist | undefined
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).Playlist).optional();

export declare namespace Response {
  type Raw = serializers.Playlist.Raw | null | undefined;
}

export const Error: core.schemas.Schema<
  serializers.playlist.updatePlaylist.Error.Raw,
  TraceApi.playlist.updatePlaylist.Error
> = core.schemas
  .union(\\"errorName\\", {
    PlaylistIdNotFoundError: core.schemas.object({
      content: core.schemas.lazy(async () => (await import(\\"../..\\")).PlaylistIdNotFoundError),
    }),
  })
  .transform<TraceApi.playlist.updatePlaylist.Error>({
    parse: (value) => {
      switch (value.errorName) {
        case \\"PlaylistIdNotFoundError\\":
          return TraceApi.playlist.updatePlaylist.Error.playlistIdNotFoundError(value.content);
      }
    },
    json: (value) => value as any,
  });

export declare namespace Error {
  type Raw = Error.PlaylistIdNotFoundError;

  interface PlaylistIdNotFoundError {
    errorName: \\"PlaylistIdNotFoundError\\";
    content: serializers.PlaylistIdNotFoundError.Raw;
  }
}
",
                    "name": "updatePlaylist.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const PlaylistIdNotFoundError: core.schemas.Schema<
  serializers.PlaylistIdNotFoundError.Raw,
  TraceApi.PlaylistIdNotFoundError
> = core.schemas.lazy(async () => (await import(\\"../..\\")).PlaylistIdNotFoundErrorBody);

export declare namespace PlaylistIdNotFoundError {
  type Raw = serializers.PlaylistIdNotFoundErrorBody.Raw;
}
",
                    "name": "PlaylistIdNotFoundError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./PlaylistIdNotFoundError\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "errors",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./errors\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Playlist: core.schemas.ObjectSchema<serializers.Playlist.Raw, TraceApi.Playlist> = core.schemas
  .object({
    playlistId: core.schemas.property(
      \\"playlist_id\\",
      core.schemas.lazy(async () => (await import(\\"../..\\")).PlaylistId)
    ),
    ownerId: core.schemas.property(
      \\"owner-id\\",
      core.schemas.lazy(async () => (await import(\\"../..\\")).UserId)
    ),
  })
  .extend(core.schemas.lazyObject(async () => (await import(\\"../..\\")).PlaylistCreateRequest));

export declare namespace Playlist {
  interface Raw extends serializers.PlaylistCreateRequest.Raw {
    playlist_id: serializers.PlaylistId.Raw;
    \\"owner-id\\": serializers.UserId.Raw;
  }
}
",
                    "name": "Playlist.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const PlaylistCreateRequest: core.schemas.ObjectSchema<
  serializers.PlaylistCreateRequest.Raw,
  TraceApi.PlaylistCreateRequest
> = core.schemas.object({
  name: core.schemas.string(),
  problems: core.schemas.list(core.schemas.lazy(async () => (await import(\\"../..\\")).ProblemId)),
});

export declare namespace PlaylistCreateRequest {
  interface Raw {
    name: string;
    problems: serializers.ProblemId.Raw[];
  }
}
",
                    "name": "PlaylistCreateRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const PlaylistId: core.schemas.Schema<serializers.PlaylistId.Raw, TraceApi.PlaylistId> = core.schemas
  .string()
  .transform({
    parse: TraceApi.PlaylistId,
    json: (value) => value,
  });

export declare namespace PlaylistId {
  type Raw = string;
}
",
                    "name": "PlaylistId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const PlaylistIdNotFoundErrorBody: core.schemas.Schema<
  serializers.PlaylistIdNotFoundErrorBody.Raw,
  TraceApi.PlaylistIdNotFoundErrorBody
> = core.schemas
  .union(\\"type\\", {
    playlistId: core.schemas.object({
      value: core.schemas.lazy(async () => (await import(\\"../..\\")).PlaylistId),
    }),
  })
  .transform<TraceApi.PlaylistIdNotFoundErrorBody>({
    parse: (value) => {
      switch (value.type) {
        case \\"playlistId\\":
          return TraceApi.PlaylistIdNotFoundErrorBody.playlistId(value.value);
        default:
          return TraceApi.PlaylistIdNotFoundErrorBody._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace PlaylistIdNotFoundErrorBody {
  type Raw = PlaylistIdNotFoundErrorBody.PlaylistId;

  interface PlaylistId {
    type: \\"playlistId\\";
    value: serializers.PlaylistId.Raw;
  }
}
",
                    "name": "PlaylistIdNotFoundErrorBody.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const ReservedKeywordEnum: core.schemas.Schema<
  serializers.ReservedKeywordEnum.Raw,
  TraceApi.ReservedKeywordEnum
> = core.schemas.enum_([\\"is\\", \\"as\\"]);

export declare namespace ReservedKeywordEnum {
  type Raw = \\"is\\" | \\"as\\";
}
",
                    "name": "ReservedKeywordEnum.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const UpdatePlaylistRequest: core.schemas.ObjectSchema<
  serializers.UpdatePlaylistRequest.Raw,
  TraceApi.UpdatePlaylistRequest
> = core.schemas.object({
  name: core.schemas.string(),
  problems: core.schemas.list(core.schemas.lazy(async () => (await import(\\"../..\\")).ProblemId)),
});

export declare namespace UpdatePlaylistRequest {
  interface Raw {
    name: string;
    problems: serializers.ProblemId.Raw[];
  }
}
",
                    "name": "UpdatePlaylistRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./PlaylistId\\";
export * from \\"./Playlist\\";
export * from \\"./PlaylistCreateRequest\\";
export * from \\"./UpdatePlaylistRequest\\";
export * from \\"./PlaylistIdNotFoundErrorBody\\";
export * from \\"./ReservedKeywordEnum\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "playlist",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.problem.createProblem.Request.Raw,
  TraceApi.CreateProblemRequest
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).CreateProblemRequest);

export declare namespace Request {
  type Raw = serializers.CreateProblemRequest.Raw;
}

export const Response: core.schemas.Schema<
  serializers.problem.createProblem.Response.Raw,
  TraceApi.CreateProblemResponse
> = core.schemas.lazy(async () => (await import(\\"../..\\")).CreateProblemResponse);

export declare namespace Response {
  type Raw = serializers.CreateProblemResponse.Raw;
}
",
                    "name": "createProblem.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.problem.getDefaultStarterFiles.Request.Raw,
  TraceApi.GetDefaultStarterFilesRequest
> = core.schemas.object({
  inputParams: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).VariableTypeAndName)),
  outputType: core.schemas.lazy(async () => (await import(\\"../..\\")).VariableType),
  methodName: core.schemas.string(),
});

export declare namespace Request {
  interface Raw {
    inputParams: serializers.VariableTypeAndName.Raw[];
    outputType: serializers.VariableType.Raw;
    methodName: string;
  }
}

export const Response: core.schemas.Schema<
  serializers.problem.getDefaultStarterFiles.Response.Raw,
  TraceApi.GetDefaultStarterFilesResponse
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).GetDefaultStarterFilesResponse);

export declare namespace Response {
  type Raw = serializers.GetDefaultStarterFilesResponse.Raw;
}
",
                    "name": "getDefaultStarterFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as createProblem from \\"./createProblem\\";
export * as updateProblem from \\"./updateProblem\\";
export * as getDefaultStarterFiles from \\"./getDefaultStarterFiles\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.problem.updateProblem.Request.Raw,
  TraceApi.CreateProblemRequest
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).CreateProblemRequest);

export declare namespace Request {
  type Raw = serializers.CreateProblemRequest.Raw;
}

export const Response: core.schemas.Schema<
  serializers.problem.updateProblem.Response.Raw,
  TraceApi.UpdateProblemResponse
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).UpdateProblemResponse);

export declare namespace Response {
  type Raw = serializers.UpdateProblemResponse.Raw;
}
",
                    "name": "updateProblem.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const CreateProblemError: core.schemas.Schema<serializers.CreateProblemError.Raw, TraceApi.CreateProblemError> =
  core.schemas
    .union(core.schemas.discriminant(\\"errorType\\", \\"_type\\"), {
      generic: core.schemas.lazyObject(async () => (await import(\\"../..\\")).GenericCreateProblemError),
    })
    .transform<TraceApi.CreateProblemError>({
      parse: (value) => {
        switch (value.errorType) {
          case \\"generic\\":
            return TraceApi.CreateProblemError.generic(value);
          default:
            return TraceApi.CreateProblemError._unknown(value);
        }
      },
      json: (value) => value as any,
    });

export declare namespace CreateProblemError {
  type Raw = CreateProblemError.Generic;

  interface Generic extends serializers.GenericCreateProblemError.Raw {
    _type: \\"generic\\";
  }
}
",
                    "name": "CreateProblemError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const CreateProblemRequest: core.schemas.ObjectSchema<
  serializers.CreateProblemRequest.Raw,
  TraceApi.CreateProblemRequest
> = core.schemas.object({
  problemName: core.schemas.string(),
  problemDescription: core.schemas.lazyObject(async () => (await import(\\"../..\\")).ProblemDescription),
  files: core.schemas.record(
    core.schemas.lazy(async () => (await import(\\"../..\\")).Language),
    core.schemas.lazyObject(async () => (await import(\\"../..\\")).ProblemFiles)
  ),
  inputParams: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).VariableTypeAndName)),
  outputType: core.schemas.lazy(async () => (await import(\\"../..\\")).VariableType),
  testcases: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).TestCaseWithExpectedResult)),
  methodName: core.schemas.string(),
});

export declare namespace CreateProblemRequest {
  interface Raw {
    problemName: string;
    problemDescription: serializers.ProblemDescription.Raw;
    files: Record<serializers.Language.Raw, serializers.ProblemFiles.Raw>;
    inputParams: serializers.VariableTypeAndName.Raw[];
    outputType: serializers.VariableType.Raw;
    testcases: serializers.TestCaseWithExpectedResult.Raw[];
    methodName: string;
  }
}
",
                    "name": "CreateProblemRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const CreateProblemResponse: core.schemas.Schema<
  serializers.CreateProblemResponse.Raw,
  TraceApi.CreateProblemResponse
> = core.schemas
  .union(\\"type\\", {
    success: core.schemas.object({
      value: core.schemas.lazy(async () => (await import(\\"../..\\")).ProblemId),
    }),
    error: core.schemas.object({
      value: core.schemas.lazy(async () => (await import(\\"../..\\")).CreateProblemError),
    }),
  })
  .transform<TraceApi.CreateProblemResponse>({
    parse: (value) => {
      switch (value.type) {
        case \\"success\\":
          return TraceApi.CreateProblemResponse.success(value.value);
        case \\"error\\":
          return TraceApi.CreateProblemResponse.error(value.value);
        default:
          return TraceApi.CreateProblemResponse._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace CreateProblemResponse {
  type Raw = CreateProblemResponse.Success | CreateProblemResponse.Error;

  interface Success {
    type: \\"success\\";
    value: serializers.ProblemId.Raw;
  }

  interface Error {
    type: \\"error\\";
    value: serializers.CreateProblemError.Raw;
  }
}
",
                    "name": "CreateProblemResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const GenericCreateProblemError: core.schemas.ObjectSchema<
  serializers.GenericCreateProblemError.Raw,
  TraceApi.GenericCreateProblemError
> = core.schemas.object({
  message: core.schemas.string(),
  type: core.schemas.string(),
  stacktrace: core.schemas.string(),
});

export declare namespace GenericCreateProblemError {
  interface Raw {
    message: string;
    type: string;
    stacktrace: string;
  }
}
",
                    "name": "GenericCreateProblemError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const GetDefaultStarterFilesResponse: core.schemas.ObjectSchema<
  serializers.GetDefaultStarterFilesResponse.Raw,
  TraceApi.GetDefaultStarterFilesResponse
> = core.schemas.object({
  files: core.schemas.record(
    core.schemas.lazy(async () => (await import(\\"../..\\")).Language),
    core.schemas.lazyObject(async () => (await import(\\"../..\\")).ProblemFiles)
  ),
});

export declare namespace GetDefaultStarterFilesResponse {
  interface Raw {
    files: Record<serializers.Language.Raw, serializers.ProblemFiles.Raw>;
  }
}
",
                    "name": "GetDefaultStarterFilesResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const ProblemDescription: core.schemas.ObjectSchema<
  serializers.ProblemDescription.Raw,
  TraceApi.ProblemDescription
> = core.schemas.object({
  boards: core.schemas.list(core.schemas.lazy(async () => (await import(\\"../..\\")).ProblemDescriptionBoard)),
});

export declare namespace ProblemDescription {
  interface Raw {
    boards: serializers.ProblemDescriptionBoard.Raw[];
  }
}
",
                    "name": "ProblemDescription.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const ProblemDescriptionBoard: core.schemas.Schema<
  serializers.ProblemDescriptionBoard.Raw,
  TraceApi.ProblemDescriptionBoard
> = core.schemas
  .union(\\"type\\", {
    html: core.schemas.object({
      value: core.schemas.string(),
    }),
    variable: core.schemas.object({
      value: core.schemas.lazy(async () => (await import(\\"../..\\")).VariableValue),
    }),
    testCaseId: core.schemas.object({
      value: core.schemas.string(),
    }),
  })
  .transform<TraceApi.ProblemDescriptionBoard>({
    parse: (value) => {
      switch (value.type) {
        case \\"html\\":
          return TraceApi.ProblemDescriptionBoard.html(value.value);
        case \\"variable\\":
          return TraceApi.ProblemDescriptionBoard.variable(value.value);
        case \\"testCaseId\\":
          return TraceApi.ProblemDescriptionBoard.testCaseId(value.value);
        default:
          return TraceApi.ProblemDescriptionBoard._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace ProblemDescriptionBoard {
  type Raw = ProblemDescriptionBoard.Html | ProblemDescriptionBoard.Variable | ProblemDescriptionBoard.TestCaseId;

  interface Html {
    type: \\"html\\";
    value: string;
  }

  interface Variable {
    type: \\"variable\\";
    value: serializers.VariableValue.Raw;
  }

  interface TestCaseId {
    type: \\"testCaseId\\";
    value: string;
  }
}
",
                    "name": "ProblemDescriptionBoard.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const ProblemFiles: core.schemas.ObjectSchema<serializers.ProblemFiles.Raw, TraceApi.ProblemFiles> =
  core.schemas.object({
    solutionFile: core.schemas.lazyObject(async () => (await import(\\"../..\\")).FileInfo),
    readOnlyFiles: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).FileInfo)),
  });

export declare namespace ProblemFiles {
  interface Raw {
    solutionFile: serializers.FileInfo.Raw;
    readOnlyFiles: serializers.FileInfo.Raw[];
  }
}
",
                    "name": "ProblemFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const ProblemInfo: core.schemas.ObjectSchema<serializers.ProblemInfo.Raw, TraceApi.ProblemInfo> =
  core.schemas.object({
    problemId: core.schemas.lazy(async () => (await import(\\"../..\\")).ProblemId),
    problemDescription: core.schemas.lazyObject(async () => (await import(\\"../..\\")).ProblemDescription),
    problemName: core.schemas.string(),
    problemVersion: core.schemas.number(),
    files: core.schemas.record(
      core.schemas.lazy(async () => (await import(\\"../..\\")).Language),
      core.schemas.lazyObject(async () => (await import(\\"../..\\")).ProblemFiles)
    ),
    inputParams: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).VariableTypeAndName)),
    outputType: core.schemas.lazy(async () => (await import(\\"../..\\")).VariableType),
    testcases: core.schemas.list(
      core.schemas.lazyObject(async () => (await import(\\"../..\\")).TestCaseWithExpectedResult)
    ),
    methodName: core.schemas.string(),
    supportsCustomTestCases: core.schemas.boolean(),
  });

export declare namespace ProblemInfo {
  interface Raw {
    problemId: serializers.ProblemId.Raw;
    problemDescription: serializers.ProblemDescription.Raw;
    problemName: string;
    problemVersion: number;
    files: Record<serializers.Language.Raw, serializers.ProblemFiles.Raw>;
    inputParams: serializers.VariableTypeAndName.Raw[];
    outputType: serializers.VariableType.Raw;
    testcases: serializers.TestCaseWithExpectedResult.Raw[];
    methodName: string;
    supportsCustomTestCases: boolean;
  }
}
",
                    "name": "ProblemInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const ProblemsMap: core.schemas.ObjectSchema<serializers.ProblemsMap.Raw, TraceApi.ProblemsMap> =
  core.schemas.object({
    problemsById: core.schemas.record(
      core.schemas.lazy(async () => (await import(\\"../..\\")).ProblemId),
      core.schemas.lazyObject(async () => (await import(\\"../..\\")).ProblemInfo)
    ),
  });

export declare namespace ProblemsMap {
  interface Raw {
    problemsById: Record<serializers.ProblemId.Raw, serializers.ProblemInfo.Raw>;
  }
}
",
                    "name": "ProblemsMap.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const UpdateProblemResponse: core.schemas.ObjectSchema<
  serializers.UpdateProblemResponse.Raw,
  TraceApi.UpdateProblemResponse
> = core.schemas.object({
  problemVersion: core.schemas.number(),
});

export declare namespace UpdateProblemResponse {
  interface Raw {
    problemVersion: number;
  }
}
",
                    "name": "UpdateProblemResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const VariableTypeAndName: core.schemas.ObjectSchema<
  serializers.VariableTypeAndName.Raw,
  TraceApi.VariableTypeAndName
> = core.schemas.object({
  variableType: core.schemas.lazy(async () => (await import(\\"../..\\")).VariableType),
  name: core.schemas.string(),
});

export declare namespace VariableTypeAndName {
  interface Raw {
    variableType: serializers.VariableType.Raw;
    name: string;
  }
}
",
                    "name": "VariableTypeAndName.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./ProblemInfo\\";
export * from \\"./ProblemsMap\\";
export * from \\"./ProblemDescription\\";
export * from \\"./ProblemDescriptionBoard\\";
export * from \\"./ProblemFiles\\";
export * from \\"./VariableTypeAndName\\";
export * from \\"./CreateProblemRequest\\";
export * from \\"./CreateProblemResponse\\";
export * from \\"./UpdateProblemResponse\\";
export * from \\"./CreateProblemError\\";
export * from \\"./GenericCreateProblemError\\";
export * from \\"./GetDefaultStarterFilesResponse\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "problem",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  serializers.submission.createExecutionSession.Response.Raw,
  TraceApi.ExecutionSessionResponse
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).ExecutionSessionResponse);

export declare namespace Response {
  type Raw = serializers.ExecutionSessionResponse.Raw;
}
",
                    "name": "createExecutionSession.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  serializers.submission.getExecutionSession.Response.Raw,
  TraceApi.ExecutionSessionResponse | undefined
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).ExecutionSessionResponse).optional();

export declare namespace Response {
  type Raw = serializers.ExecutionSessionResponse.Raw | null | undefined;
}
",
                    "name": "getExecutionSession.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  serializers.submission.getExecutionSessionsState.Response.Raw,
  TraceApi.GetExecutionSessionStateResponse
> = core.schemas.lazyObject(async () => (await import(\\"../..\\")).GetExecutionSessionStateResponse);

export declare namespace Response {
  type Raw = serializers.GetExecutionSessionStateResponse.Raw;
}
",
                    "name": "getExecutionSessionsState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as createExecutionSession from \\"./createExecutionSession\\";
export * as getExecutionSession from \\"./getExecutionSession\\";
export * as getExecutionSessionsState from \\"./getExecutionSessionsState\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const ActualResult: core.schemas.Schema<serializers.ActualResult.Raw, TraceApi.ActualResult> = core.schemas
  .union(\\"type\\", {
    value: core.schemas.object({
      value: core.schemas.lazy(async () => (await import(\\"../..\\")).VariableValue),
    }),
    exception: core.schemas.lazyObject(async () => (await import(\\"../..\\")).ExceptionInfo),
    exceptionV2: core.schemas.object({
      value: core.schemas.lazy(async () => (await import(\\"../..\\")).ExceptionV2),
    }),
  })
  .transform<TraceApi.ActualResult>({
    parse: (value) => {
      switch (value.type) {
        case \\"value\\":
          return TraceApi.ActualResult.value(value.value);
        case \\"exception\\":
          return TraceApi.ActualResult.exception(value);
        case \\"exceptionV2\\":
          return TraceApi.ActualResult.exceptionV2(value.value);
        default:
          return TraceApi.ActualResult._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace ActualResult {
  type Raw = ActualResult.Value | ActualResult.Exception | ActualResult.ExceptionV2;

  interface Value {
    type: \\"value\\";
    value: serializers.VariableValue.Raw;
  }

  interface Exception extends serializers.ExceptionInfo.Raw {
    type: \\"exception\\";
  }

  interface ExceptionV2 {
    type: \\"exceptionV2\\";
    value: serializers.ExceptionV2.Raw;
  }
}
",
                    "name": "ActualResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const BuildingExecutorResponse: core.schemas.ObjectSchema<
  serializers.BuildingExecutorResponse.Raw,
  TraceApi.BuildingExecutorResponse
> = core.schemas.object({
  submissionId: core.schemas.lazy(async () => (await import(\\"../..\\")).SubmissionId),
  status: core.schemas.lazy(async () => (await import(\\"../..\\")).ExecutionSessionStatus),
});

export declare namespace BuildingExecutorResponse {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
    status: serializers.ExecutionSessionStatus.Raw;
  }
}
",
                    "name": "BuildingExecutorResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const CodeExecutionUpdate: core.schemas.Schema<
  serializers.CodeExecutionUpdate.Raw,
  TraceApi.CodeExecutionUpdate
> = core.schemas
  .union(\\"type\\", {
    buildingExecutor: core.schemas.lazyObject(async () => (await import(\\"../..\\")).BuildingExecutorResponse),
    running: core.schemas.lazyObject(async () => (await import(\\"../..\\")).RunningResponse),
    errored: core.schemas.lazyObject(async () => (await import(\\"../..\\")).ErroredResponse),
    stopped: core.schemas.lazyObject(async () => (await import(\\"../..\\")).StoppedResponse),
    graded: core.schemas.lazyObject(async () => (await import(\\"../..\\")).GradedResponse),
    gradedV2: core.schemas.lazyObject(async () => (await import(\\"../..\\")).GradedResponseV2),
    workspaceRan: core.schemas.lazyObject(async () => (await import(\\"../..\\")).WorkspaceRanResponse),
    recording: core.schemas.lazyObject(async () => (await import(\\"../..\\")).RecordingResponseNotification),
    recorded: core.schemas.lazyObject(async () => (await import(\\"../..\\")).RecordedResponseNotification),
    invalidRequest: core.schemas.lazyObject(async () => (await import(\\"../..\\")).InvalidRequestResponse),
    finished: core.schemas.lazyObject(async () => (await import(\\"../..\\")).FinishedResponse),
  })
  .transform<TraceApi.CodeExecutionUpdate>({
    parse: (value) => {
      switch (value.type) {
        case \\"buildingExecutor\\":
          return TraceApi.CodeExecutionUpdate.buildingExecutor(value);
        case \\"running\\":
          return TraceApi.CodeExecutionUpdate.running(value);
        case \\"errored\\":
          return TraceApi.CodeExecutionUpdate.errored(value);
        case \\"stopped\\":
          return TraceApi.CodeExecutionUpdate.stopped(value);
        case \\"graded\\":
          return TraceApi.CodeExecutionUpdate.graded(value);
        case \\"gradedV2\\":
          return TraceApi.CodeExecutionUpdate.gradedV2(value);
        case \\"workspaceRan\\":
          return TraceApi.CodeExecutionUpdate.workspaceRan(value);
        case \\"recording\\":
          return TraceApi.CodeExecutionUpdate.recording(value);
        case \\"recorded\\":
          return TraceApi.CodeExecutionUpdate.recorded(value);
        case \\"invalidRequest\\":
          return TraceApi.CodeExecutionUpdate.invalidRequest(value);
        case \\"finished\\":
          return TraceApi.CodeExecutionUpdate.finished(value);
        default:
          return TraceApi.CodeExecutionUpdate._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace CodeExecutionUpdate {
  type Raw =
    | CodeExecutionUpdate.BuildingExecutor
    | CodeExecutionUpdate.Running
    | CodeExecutionUpdate.Errored
    | CodeExecutionUpdate.Stopped
    | CodeExecutionUpdate.Graded
    | CodeExecutionUpdate.GradedV2
    | CodeExecutionUpdate.WorkspaceRan
    | CodeExecutionUpdate.Recording
    | CodeExecutionUpdate.Recorded
    | CodeExecutionUpdate.InvalidRequest
    | CodeExecutionUpdate.Finished;

  interface BuildingExecutor extends serializers.BuildingExecutorResponse.Raw {
    type: \\"buildingExecutor\\";
  }

  interface Running extends serializers.RunningResponse.Raw {
    type: \\"running\\";
  }

  interface Errored extends serializers.ErroredResponse.Raw {
    type: \\"errored\\";
  }

  interface Stopped extends serializers.StoppedResponse.Raw {
    type: \\"stopped\\";
  }

  interface Graded extends serializers.GradedResponse.Raw {
    type: \\"graded\\";
  }

  interface GradedV2 extends serializers.GradedResponseV2.Raw {
    type: \\"gradedV2\\";
  }

  interface WorkspaceRan extends serializers.WorkspaceRanResponse.Raw {
    type: \\"workspaceRan\\";
  }

  interface Recording extends serializers.RecordingResponseNotification.Raw {
    type: \\"recording\\";
  }

  interface Recorded extends serializers.RecordedResponseNotification.Raw {
    type: \\"recorded\\";
  }

  interface InvalidRequest extends serializers.InvalidRequestResponse.Raw {
    type: \\"invalidRequest\\";
  }

  interface Finished extends serializers.FinishedResponse.Raw {
    type: \\"finished\\";
  }
}
",
                    "name": "CodeExecutionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const CompileError: core.schemas.ObjectSchema<serializers.CompileError.Raw, TraceApi.CompileError> =
  core.schemas.object({
    message: core.schemas.string(),
  });

export declare namespace CompileError {
  interface Raw {
    message: string;
  }
}
",
                    "name": "CompileError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const CustomTestCasesUnsupported: core.schemas.ObjectSchema<
  serializers.CustomTestCasesUnsupported.Raw,
  TraceApi.CustomTestCasesUnsupported
> = core.schemas.object({
  problemId: core.schemas.lazy(async () => (await import(\\"../..\\")).ProblemId),
  submissionId: core.schemas.lazy(async () => (await import(\\"../..\\")).SubmissionId),
});

export declare namespace CustomTestCasesUnsupported {
  interface Raw {
    problemId: serializers.ProblemId.Raw;
    submissionId: serializers.SubmissionId.Raw;
  }
}
",
                    "name": "CustomTestCasesUnsupported.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const ErrorInfo: core.schemas.Schema<serializers.ErrorInfo.Raw, TraceApi.ErrorInfo> = core.schemas
  .union(\\"type\\", {
    compileError: core.schemas.lazyObject(async () => (await import(\\"../..\\")).CompileError),
    runtimeError: core.schemas.lazyObject(async () => (await import(\\"../..\\")).RuntimeError),
    internalError: core.schemas.lazyObject(async () => (await import(\\"../..\\")).InternalError),
  })
  .transform<TraceApi.ErrorInfo>({
    parse: (value) => {
      switch (value.type) {
        case \\"compileError\\":
          return TraceApi.ErrorInfo.compileError(value);
        case \\"runtimeError\\":
          return TraceApi.ErrorInfo.runtimeError(value);
        case \\"internalError\\":
          return TraceApi.ErrorInfo.internalError(value);
        default:
          return TraceApi.ErrorInfo._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace ErrorInfo {
  type Raw = ErrorInfo.CompileError | ErrorInfo.RuntimeError | ErrorInfo.InternalError;

  interface CompileError extends serializers.CompileError.Raw {
    type: \\"compileError\\";
  }

  interface RuntimeError extends serializers.RuntimeError.Raw {
    type: \\"runtimeError\\";
  }

  interface InternalError extends serializers.InternalError.Raw {
    type: \\"internalError\\";
  }
}
",
                    "name": "ErrorInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const ErroredResponse: core.schemas.ObjectSchema<serializers.ErroredResponse.Raw, TraceApi.ErroredResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(async () => (await import(\\"../..\\")).SubmissionId),
    errorInfo: core.schemas.lazy(async () => (await import(\\"../..\\")).ErrorInfo),
  });

export declare namespace ErroredResponse {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
    errorInfo: serializers.ErrorInfo.Raw;
  }
}
",
                    "name": "ErroredResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const ExceptionInfo: core.schemas.ObjectSchema<serializers.ExceptionInfo.Raw, TraceApi.ExceptionInfo> =
  core.schemas.object({
    exceptionType: core.schemas.string(),
    exceptionMessage: core.schemas.string(),
    exceptionStacktrace: core.schemas.string(),
  });

export declare namespace ExceptionInfo {
  interface Raw {
    exceptionType: string;
    exceptionMessage: string;
    exceptionStacktrace: string;
  }
}
",
                    "name": "ExceptionInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const ExceptionV2: core.schemas.Schema<serializers.ExceptionV2.Raw, TraceApi.ExceptionV2> = core.schemas
  .union(\\"type\\", {
    generic: core.schemas.lazyObject(async () => (await import(\\"../..\\")).ExceptionInfo),
    timeout: core.schemas.object({}),
  })
  .transform<TraceApi.ExceptionV2>({
    parse: (value) => {
      switch (value.type) {
        case \\"generic\\":
          return TraceApi.ExceptionV2.generic(value);
        case \\"timeout\\":
          return TraceApi.ExceptionV2.timeout();
        default:
          return TraceApi.ExceptionV2._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace ExceptionV2 {
  type Raw = ExceptionV2.Generic | ExceptionV2.Timeout;

  interface Generic extends serializers.ExceptionInfo.Raw {
    type: \\"generic\\";
  }

  interface Timeout {
    type: \\"timeout\\";
  }
}
",
                    "name": "ExceptionV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const ExecutionSessionResponse: core.schemas.ObjectSchema<
  serializers.ExecutionSessionResponse.Raw,
  TraceApi.ExecutionSessionResponse
> = core.schemas.object({
  sessionId: core.schemas.string(),
  executionSessionUrl: core.schemas.string().optional(),
  language: core.schemas.lazy(async () => (await import(\\"../..\\")).Language),
  status: core.schemas.lazy(async () => (await import(\\"../..\\")).ExecutionSessionStatus),
});

export declare namespace ExecutionSessionResponse {
  interface Raw {
    sessionId: string;
    executionSessionUrl?: string | null;
    language: serializers.Language.Raw;
    status: serializers.ExecutionSessionStatus.Raw;
  }
}
",
                    "name": "ExecutionSessionResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const ExecutionSessionState: core.schemas.ObjectSchema<
  serializers.ExecutionSessionState.Raw,
  TraceApi.ExecutionSessionState
> = core.schemas.object({
  lastTimeContacted: core.schemas.string().optional(),
  sessionId: core.schemas.string(),
  isWarmInstance: core.schemas.boolean(),
  awsTaskId: core.schemas.string().optional(),
  language: core.schemas.lazy(async () => (await import(\\"../..\\")).Language),
  status: core.schemas.lazy(async () => (await import(\\"../..\\")).ExecutionSessionStatus),
});

export declare namespace ExecutionSessionState {
  interface Raw {
    lastTimeContacted?: string | null;
    sessionId: string;
    isWarmInstance: boolean;
    awsTaskId?: string | null;
    language: serializers.Language.Raw;
    status: serializers.ExecutionSessionStatus.Raw;
  }
}
",
                    "name": "ExecutionSessionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const ExecutionSessionStatus: core.schemas.Schema<
  serializers.ExecutionSessionStatus.Raw,
  TraceApi.ExecutionSessionStatus
> = core.schemas.enum_([
  \\"CREATING_CONTAINER\\",
  \\"PROVISIONING_CONTAINER\\",
  \\"PENDING_CONTAINER\\",
  \\"RUNNING_CONTAINER\\",
  \\"LIVE_CONTAINER\\",
  \\"FAILED_TO_LAUNCH\\",
]);

export declare namespace ExecutionSessionStatus {
  type Raw =
    | \\"CREATING_CONTAINER\\"
    | \\"PROVISIONING_CONTAINER\\"
    | \\"PENDING_CONTAINER\\"
    | \\"RUNNING_CONTAINER\\"
    | \\"LIVE_CONTAINER\\"
    | \\"FAILED_TO_LAUNCH\\";
}
",
                    "name": "ExecutionSessionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const ExistingSubmissionExecuting: core.schemas.ObjectSchema<
  serializers.ExistingSubmissionExecuting.Raw,
  TraceApi.ExistingSubmissionExecuting
> = core.schemas.object({
  submissionId: core.schemas.lazy(async () => (await import(\\"../..\\")).SubmissionId),
});

export declare namespace ExistingSubmissionExecuting {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
  }
}
",
                    "name": "ExistingSubmissionExecuting.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const ExpressionLocation: core.schemas.ObjectSchema<
  serializers.ExpressionLocation.Raw,
  TraceApi.ExpressionLocation
> = core.schemas.object({
  start: core.schemas.number(),
  offset: core.schemas.number(),
});

export declare namespace ExpressionLocation {
  interface Raw {
    start: number;
    offset: number;
  }
}
",
                    "name": "ExpressionLocation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const FinishedResponse: core.schemas.ObjectSchema<serializers.FinishedResponse.Raw, TraceApi.FinishedResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(async () => (await import(\\"../..\\")).SubmissionId),
  });

export declare namespace FinishedResponse {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
  }
}
",
                    "name": "FinishedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const GetExecutionSessionStateResponse: core.schemas.ObjectSchema<
  serializers.GetExecutionSessionStateResponse.Raw,
  TraceApi.GetExecutionSessionStateResponse
> = core.schemas.object({
  states: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(async () => (await import(\\"../..\\")).ExecutionSessionState)
  ),
  numWarmingInstances: core.schemas.number().optional(),
  warmingSessionIds: core.schemas.list(core.schemas.string()),
});

export declare namespace GetExecutionSessionStateResponse {
  interface Raw {
    states: Record<string, serializers.ExecutionSessionState.Raw>;
    numWarmingInstances?: number | null;
    warmingSessionIds: string[];
  }
}
",
                    "name": "GetExecutionSessionStateResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const GetSubmissionStateResponse: core.schemas.ObjectSchema<
  serializers.GetSubmissionStateResponse.Raw,
  TraceApi.GetSubmissionStateResponse
> = core.schemas.object({
  timeSubmitted: core.schemas.date().optional(),
  submission: core.schemas.string(),
  language: core.schemas.lazy(async () => (await import(\\"../..\\")).Language),
  submissionTypeState: core.schemas.lazy(async () => (await import(\\"../..\\")).SubmissionTypeState),
});

export declare namespace GetSubmissionStateResponse {
  interface Raw {
    timeSubmitted?: string | null;
    submission: string;
    language: serializers.Language.Raw;
    submissionTypeState: serializers.SubmissionTypeState.Raw;
  }
}
",
                    "name": "GetSubmissionStateResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const GetTraceResponsesPageRequest: core.schemas.ObjectSchema<
  serializers.GetTraceResponsesPageRequest.Raw,
  TraceApi.GetTraceResponsesPageRequest
> = core.schemas.object({
  offset: core.schemas.number().optional(),
});

export declare namespace GetTraceResponsesPageRequest {
  interface Raw {
    offset?: number | null;
  }
}
",
                    "name": "GetTraceResponsesPageRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const GradedResponse: core.schemas.ObjectSchema<serializers.GradedResponse.Raw, TraceApi.GradedResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(async () => (await import(\\"../..\\")).SubmissionId),
    testCases: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(async () => (await import(\\"../..\\")).TestCaseResultWithStdout)
    ),
  });

export declare namespace GradedResponse {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
    testCases: Record<string, serializers.TestCaseResultWithStdout.Raw>;
  }
}
",
                    "name": "GradedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const GradedResponseV2: core.schemas.ObjectSchema<serializers.GradedResponseV2.Raw, TraceApi.GradedResponseV2> =
  core.schemas.object({
    submissionId: core.schemas.lazy(async () => (await import(\\"../..\\")).SubmissionId),
    testCases: core.schemas.record(
      core.schemas.lazy(async () => (await import(\\"../..\\")).v2.TestCaseId),
      core.schemas.lazy(async () => (await import(\\"../..\\")).TestCaseGrade)
    ),
  });

export declare namespace GradedResponseV2 {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
    testCases: Record<serializers.v2.TestCaseId.Raw, serializers.TestCaseGrade.Raw>;
  }
}
",
                    "name": "GradedResponseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const GradedTestCaseUpdate: core.schemas.ObjectSchema<
  serializers.GradedTestCaseUpdate.Raw,
  TraceApi.GradedTestCaseUpdate
> = core.schemas.object({
  testCaseId: core.schemas.lazy(async () => (await import(\\"../..\\")).v2.TestCaseId),
  grade: core.schemas.lazy(async () => (await import(\\"../..\\")).TestCaseGrade),
});

export declare namespace GradedTestCaseUpdate {
  interface Raw {
    testCaseId: serializers.v2.TestCaseId.Raw;
    grade: serializers.TestCaseGrade.Raw;
  }
}
",
                    "name": "GradedTestCaseUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const InitializeProblemRequest: core.schemas.ObjectSchema<
  serializers.InitializeProblemRequest.Raw,
  TraceApi.InitializeProblemRequest
> = core.schemas.object({
  problemId: core.schemas.lazy(async () => (await import(\\"../..\\")).ProblemId),
  problemVersion: core.schemas.number().optional(),
});

export declare namespace InitializeProblemRequest {
  interface Raw {
    problemId: serializers.ProblemId.Raw;
    problemVersion?: number | null;
  }
}
",
                    "name": "InitializeProblemRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const InternalError: core.schemas.ObjectSchema<serializers.InternalError.Raw, TraceApi.InternalError> =
  core.schemas.object({
    exceptionInfo: core.schemas.lazyObject(async () => (await import(\\"../..\\")).ExceptionInfo),
  });

export declare namespace InternalError {
  interface Raw {
    exceptionInfo: serializers.ExceptionInfo.Raw;
  }
}
",
                    "name": "InternalError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const InvalidRequestCause: core.schemas.Schema<
  serializers.InvalidRequestCause.Raw,
  TraceApi.InvalidRequestCause
> = core.schemas
  .union(\\"type\\", {
    submissionIdNotFound: core.schemas.lazyObject(async () => (await import(\\"../..\\")).SubmissionIdNotFound),
    customTestCasesUnsupported: core.schemas.lazyObject(async () => (await import(\\"../..\\")).CustomTestCasesUnsupported),
    unexpectedLanguage: core.schemas.lazyObject(async () => (await import(\\"../..\\")).UnexpectedLanguageError),
  })
  .transform<TraceApi.InvalidRequestCause>({
    parse: (value) => {
      switch (value.type) {
        case \\"submissionIdNotFound\\":
          return TraceApi.InvalidRequestCause.submissionIdNotFound(value);
        case \\"customTestCasesUnsupported\\":
          return TraceApi.InvalidRequestCause.customTestCasesUnsupported(value);
        case \\"unexpectedLanguage\\":
          return TraceApi.InvalidRequestCause.unexpectedLanguage(value);
        default:
          return TraceApi.InvalidRequestCause._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace InvalidRequestCause {
  type Raw =
    | InvalidRequestCause.SubmissionIdNotFound
    | InvalidRequestCause.CustomTestCasesUnsupported
    | InvalidRequestCause.UnexpectedLanguage;

  interface SubmissionIdNotFound extends serializers.SubmissionIdNotFound.Raw {
    type: \\"submissionIdNotFound\\";
  }

  interface CustomTestCasesUnsupported extends serializers.CustomTestCasesUnsupported.Raw {
    type: \\"customTestCasesUnsupported\\";
  }

  interface UnexpectedLanguage extends serializers.UnexpectedLanguageError.Raw {
    type: \\"unexpectedLanguage\\";
  }
}
",
                    "name": "InvalidRequestCause.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const InvalidRequestResponse: core.schemas.ObjectSchema<
  serializers.InvalidRequestResponse.Raw,
  TraceApi.InvalidRequestResponse
> = core.schemas.object({
  request: core.schemas.lazy(async () => (await import(\\"../..\\")).SubmissionRequest),
  cause: core.schemas.lazy(async () => (await import(\\"../..\\")).InvalidRequestCause),
});

export declare namespace InvalidRequestResponse {
  interface Raw {
    request: serializers.SubmissionRequest.Raw;
    cause: serializers.InvalidRequestCause.Raw;
  }
}
",
                    "name": "InvalidRequestResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const LightweightStackframeInformation: core.schemas.ObjectSchema<
  serializers.LightweightStackframeInformation.Raw,
  TraceApi.LightweightStackframeInformation
> = core.schemas.object({
  numStackFrames: core.schemas.number(),
  topStackFrameMethodName: core.schemas.string(),
});

export declare namespace LightweightStackframeInformation {
  interface Raw {
    numStackFrames: number;
    topStackFrameMethodName: string;
  }
}
",
                    "name": "LightweightStackframeInformation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const RecordedResponseNotification: core.schemas.ObjectSchema<
  serializers.RecordedResponseNotification.Raw,
  TraceApi.RecordedResponseNotification
> = core.schemas.object({
  submissionId: core.schemas.lazy(async () => (await import(\\"../..\\")).SubmissionId),
  traceResponsesSize: core.schemas.number(),
  testCaseId: core.schemas.string().optional(),
});

export declare namespace RecordedResponseNotification {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
    traceResponsesSize: number;
    testCaseId?: string | null;
  }
}
",
                    "name": "RecordedResponseNotification.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const RecordedTestCaseUpdate: core.schemas.ObjectSchema<
  serializers.RecordedTestCaseUpdate.Raw,
  TraceApi.RecordedTestCaseUpdate
> = core.schemas.object({
  testCaseId: core.schemas.lazy(async () => (await import(\\"../..\\")).v2.TestCaseId),
  traceResponsesSize: core.schemas.number(),
});

export declare namespace RecordedTestCaseUpdate {
  interface Raw {
    testCaseId: serializers.v2.TestCaseId.Raw;
    traceResponsesSize: number;
  }
}
",
                    "name": "RecordedTestCaseUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const RecordingResponseNotification: core.schemas.ObjectSchema<
  serializers.RecordingResponseNotification.Raw,
  TraceApi.RecordingResponseNotification
> = core.schemas.object({
  submissionId: core.schemas.lazy(async () => (await import(\\"../..\\")).SubmissionId),
  testCaseId: core.schemas.string().optional(),
  lineNumber: core.schemas.number(),
  lightweightStackInfo: core.schemas.lazyObject(async () => (await import(\\"../..\\")).LightweightStackframeInformation),
  tracedFile: core.schemas.lazyObject(async () => (await import(\\"../..\\")).TracedFile).optional(),
});

export declare namespace RecordingResponseNotification {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
    testCaseId?: string | null;
    lineNumber: number;
    lightweightStackInfo: serializers.LightweightStackframeInformation.Raw;
    tracedFile?: serializers.TracedFile.Raw | null;
  }
}
",
                    "name": "RecordingResponseNotification.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const RunningResponse: core.schemas.ObjectSchema<serializers.RunningResponse.Raw, TraceApi.RunningResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(async () => (await import(\\"../..\\")).SubmissionId),
    state: core.schemas.lazy(async () => (await import(\\"../..\\")).RunningSubmissionState),
  });

export declare namespace RunningResponse {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
    state: serializers.RunningSubmissionState.Raw;
  }
}
",
                    "name": "RunningResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const RunningSubmissionState: core.schemas.Schema<
  serializers.RunningSubmissionState.Raw,
  TraceApi.RunningSubmissionState
> = core.schemas.enum_([
  \\"QUEUEING_SUBMISSION\\",
  \\"KILLING_HISTORICAL_SUBMISSIONS\\",
  \\"WRITING_SUBMISSION_TO_FILE\\",
  \\"COMPILING_SUBMISSION\\",
  \\"RUNNING_SUBMISSION\\",
]);

export declare namespace RunningSubmissionState {
  type Raw =
    | \\"QUEUEING_SUBMISSION\\"
    | \\"KILLING_HISTORICAL_SUBMISSIONS\\"
    | \\"WRITING_SUBMISSION_TO_FILE\\"
    | \\"COMPILING_SUBMISSION\\"
    | \\"RUNNING_SUBMISSION\\";
}
",
                    "name": "RunningSubmissionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const RuntimeError: core.schemas.ObjectSchema<serializers.RuntimeError.Raw, TraceApi.RuntimeError> =
  core.schemas.object({
    message: core.schemas.string(),
  });

export declare namespace RuntimeError {
  interface Raw {
    message: string;
  }
}
",
                    "name": "RuntimeError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Scope: core.schemas.ObjectSchema<serializers.Scope.Raw, TraceApi.Scope> = core.schemas.object({
  variables: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazy(async () => (await import(\\"../..\\")).DebugVariableValue)
  ),
});

export declare namespace Scope {
  interface Raw {
    variables: Record<string, serializers.DebugVariableValue.Raw>;
  }
}
",
                    "name": "Scope.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const ShareId: core.schemas.Schema<serializers.ShareId.Raw, TraceApi.ShareId> = core.schemas.string().transform({
  parse: TraceApi.ShareId,
  json: (value) => value,
});

export declare namespace ShareId {
  type Raw = string;
}
",
                    "name": "ShareId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const StackFrame: core.schemas.ObjectSchema<serializers.StackFrame.Raw, TraceApi.StackFrame> =
  core.schemas.object({
    methodName: core.schemas.string(),
    lineNumber: core.schemas.number(),
    scopes: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).Scope)),
  });

export declare namespace StackFrame {
  interface Raw {
    methodName: string;
    lineNumber: number;
    scopes: serializers.Scope.Raw[];
  }
}
",
                    "name": "StackFrame.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const StackInformation: core.schemas.ObjectSchema<serializers.StackInformation.Raw, TraceApi.StackInformation> =
  core.schemas.object({
    numStackFrames: core.schemas.number(),
    topStackFrame: core.schemas.lazyObject(async () => (await import(\\"../..\\")).StackFrame).optional(),
  });

export declare namespace StackInformation {
  interface Raw {
    numStackFrames: number;
    topStackFrame?: serializers.StackFrame.Raw | null;
  }
}
",
                    "name": "StackInformation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const StderrResponse: core.schemas.ObjectSchema<serializers.StderrResponse.Raw, TraceApi.StderrResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(async () => (await import(\\"../..\\")).SubmissionId),
    stderr: core.schemas.string(),
  });

export declare namespace StderrResponse {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
    stderr: string;
  }
}
",
                    "name": "StderrResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const StdoutResponse: core.schemas.ObjectSchema<serializers.StdoutResponse.Raw, TraceApi.StdoutResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(async () => (await import(\\"../..\\")).SubmissionId),
    stdout: core.schemas.string(),
  });

export declare namespace StdoutResponse {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
    stdout: string;
  }
}
",
                    "name": "StdoutResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const StopRequest: core.schemas.ObjectSchema<serializers.StopRequest.Raw, TraceApi.StopRequest> =
  core.schemas.object({
    submissionId: core.schemas.lazy(async () => (await import(\\"../..\\")).SubmissionId),
  });

export declare namespace StopRequest {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
  }
}
",
                    "name": "StopRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const StoppedResponse: core.schemas.ObjectSchema<serializers.StoppedResponse.Raw, TraceApi.StoppedResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(async () => (await import(\\"../..\\")).SubmissionId),
  });

export declare namespace StoppedResponse {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
  }
}
",
                    "name": "StoppedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const SubmissionFileInfo: core.schemas.ObjectSchema<
  serializers.SubmissionFileInfo.Raw,
  TraceApi.SubmissionFileInfo
> = core.schemas.object({
  directory: core.schemas.string(),
  filename: core.schemas.string(),
  contents: core.schemas.string(),
});

export declare namespace SubmissionFileInfo {
  interface Raw {
    directory: string;
    filename: string;
    contents: string;
  }
}
",
                    "name": "SubmissionFileInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const SubmissionId: core.schemas.Schema<serializers.SubmissionId.Raw, TraceApi.SubmissionId> = core.schemas
  .string()
  .transform({
    parse: TraceApi.SubmissionId,
    json: (value) => value,
  });

export declare namespace SubmissionId {
  type Raw = string;
}
",
                    "name": "SubmissionId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const SubmissionIdNotFound: core.schemas.ObjectSchema<
  serializers.SubmissionIdNotFound.Raw,
  TraceApi.SubmissionIdNotFound
> = core.schemas.object({
  missingSubmissionId: core.schemas.lazy(async () => (await import(\\"../..\\")).SubmissionId),
});

export declare namespace SubmissionIdNotFound {
  interface Raw {
    missingSubmissionId: serializers.SubmissionId.Raw;
  }
}
",
                    "name": "SubmissionIdNotFound.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const SubmissionRequest: core.schemas.Schema<serializers.SubmissionRequest.Raw, TraceApi.SubmissionRequest> =
  core.schemas
    .union(\\"type\\", {
      initializeProblemRequest: core.schemas.lazyObject(async () => (await import(\\"../..\\")).InitializeProblemRequest),
      initializeWorkspaceRequest: core.schemas.object({}),
      submitV2: core.schemas.lazyObject(async () => (await import(\\"../..\\")).SubmitRequestV2),
      workspaceSubmit: core.schemas.lazyObject(async () => (await import(\\"../..\\")).WorkspaceSubmitRequest),
      stop: core.schemas.lazyObject(async () => (await import(\\"../..\\")).StopRequest),
    })
    .transform<TraceApi.SubmissionRequest>({
      parse: (value) => {
        switch (value.type) {
          case \\"initializeProblemRequest\\":
            return TraceApi.SubmissionRequest.initializeProblemRequest(value);
          case \\"initializeWorkspaceRequest\\":
            return TraceApi.SubmissionRequest.initializeWorkspaceRequest();
          case \\"submitV2\\":
            return TraceApi.SubmissionRequest.submitV2(value);
          case \\"workspaceSubmit\\":
            return TraceApi.SubmissionRequest.workspaceSubmit(value);
          case \\"stop\\":
            return TraceApi.SubmissionRequest.stop(value);
          default:
            return TraceApi.SubmissionRequest._unknown(value);
        }
      },
      json: (value) => value as any,
    });

export declare namespace SubmissionRequest {
  type Raw =
    | SubmissionRequest.InitializeProblemRequest
    | SubmissionRequest.InitializeWorkspaceRequest
    | SubmissionRequest.SubmitV2
    | SubmissionRequest.WorkspaceSubmit
    | SubmissionRequest.Stop;

  interface InitializeProblemRequest extends serializers.InitializeProblemRequest.Raw {
    type: \\"initializeProblemRequest\\";
  }

  interface InitializeWorkspaceRequest {
    type: \\"initializeWorkspaceRequest\\";
  }

  interface SubmitV2 extends serializers.SubmitRequestV2.Raw {
    type: \\"submitV2\\";
  }

  interface WorkspaceSubmit extends serializers.WorkspaceSubmitRequest.Raw {
    type: \\"workspaceSubmit\\";
  }

  interface Stop extends serializers.StopRequest.Raw {
    type: \\"stop\\";
  }
}
",
                    "name": "SubmissionRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const SubmissionResponse: core.schemas.Schema<serializers.SubmissionResponse.Raw, TraceApi.SubmissionResponse> =
  core.schemas
    .union(\\"type\\", {
      serverInitialized: core.schemas.object({}),
      problemInitialized: core.schemas.object({
        value: core.schemas.lazy(async () => (await import(\\"../..\\")).ProblemId),
      }),
      workspaceInitialized: core.schemas.object({}),
      serverErrored: core.schemas.lazyObject(async () => (await import(\\"../..\\")).ExceptionInfo),
      codeExecutionUpdate: core.schemas.object({
        value: core.schemas.lazy(async () => (await import(\\"../..\\")).CodeExecutionUpdate),
      }),
      terminated: core.schemas.lazyObject(async () => (await import(\\"../..\\")).TerminatedResponse),
    })
    .transform<TraceApi.SubmissionResponse>({
      parse: (value) => {
        switch (value.type) {
          case \\"serverInitialized\\":
            return TraceApi.SubmissionResponse.serverInitialized();
          case \\"problemInitialized\\":
            return TraceApi.SubmissionResponse.problemInitialized(value.value);
          case \\"workspaceInitialized\\":
            return TraceApi.SubmissionResponse.workspaceInitialized();
          case \\"serverErrored\\":
            return TraceApi.SubmissionResponse.serverErrored(value);
          case \\"codeExecutionUpdate\\":
            return TraceApi.SubmissionResponse.codeExecutionUpdate(value.value);
          case \\"terminated\\":
            return TraceApi.SubmissionResponse.terminated(value);
          default:
            return TraceApi.SubmissionResponse._unknown(value);
        }
      },
      json: (value) => value as any,
    });

export declare namespace SubmissionResponse {
  type Raw =
    | SubmissionResponse.ServerInitialized
    | SubmissionResponse.ProblemInitialized
    | SubmissionResponse.WorkspaceInitialized
    | SubmissionResponse.ServerErrored
    | SubmissionResponse.CodeExecutionUpdate
    | SubmissionResponse.Terminated;

  interface ServerInitialized {
    type: \\"serverInitialized\\";
  }

  interface ProblemInitialized {
    type: \\"problemInitialized\\";
    value: serializers.ProblemId.Raw;
  }

  interface WorkspaceInitialized {
    type: \\"workspaceInitialized\\";
  }

  interface ServerErrored extends serializers.ExceptionInfo.Raw {
    type: \\"serverErrored\\";
  }

  interface CodeExecutionUpdate {
    type: \\"codeExecutionUpdate\\";
    value: serializers.CodeExecutionUpdate.Raw;
  }

  interface Terminated extends serializers.TerminatedResponse.Raw {
    type: \\"terminated\\";
  }
}
",
                    "name": "SubmissionResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const SubmissionStatusForTestCase: core.schemas.Schema<
  serializers.SubmissionStatusForTestCase.Raw,
  TraceApi.SubmissionStatusForTestCase
> = core.schemas
  .union(\\"type\\", {
    graded: core.schemas.lazyObject(async () => (await import(\\"../..\\")).TestCaseResultWithStdout),
    gradedV2: core.schemas.object({
      value: core.schemas.lazy(async () => (await import(\\"../..\\")).TestCaseGrade),
    }),
    traced: core.schemas.lazyObject(async () => (await import(\\"../..\\")).TracedTestCase),
  })
  .transform<TraceApi.SubmissionStatusForTestCase>({
    parse: (value) => {
      switch (value.type) {
        case \\"graded\\":
          return TraceApi.SubmissionStatusForTestCase.graded(value);
        case \\"gradedV2\\":
          return TraceApi.SubmissionStatusForTestCase.gradedV2(value.value);
        case \\"traced\\":
          return TraceApi.SubmissionStatusForTestCase.traced(value);
        default:
          return TraceApi.SubmissionStatusForTestCase._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace SubmissionStatusForTestCase {
  type Raw =
    | SubmissionStatusForTestCase.Graded
    | SubmissionStatusForTestCase.GradedV2
    | SubmissionStatusForTestCase.Traced;

  interface Graded extends serializers.TestCaseResultWithStdout.Raw {
    type: \\"graded\\";
  }

  interface GradedV2 {
    type: \\"gradedV2\\";
    value: serializers.TestCaseGrade.Raw;
  }

  interface Traced extends serializers.TracedTestCase.Raw {
    type: \\"traced\\";
  }
}
",
                    "name": "SubmissionStatusForTestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const SubmissionStatusV2: core.schemas.Schema<serializers.SubmissionStatusV2.Raw, TraceApi.SubmissionStatusV2> =
  core.schemas
    .union(\\"type\\", {
      test: core.schemas.lazyObject(async () => (await import(\\"../..\\")).TestSubmissionStatusV2),
      workspace: core.schemas.lazyObject(async () => (await import(\\"../..\\")).WorkspaceSubmissionStatusV2),
    })
    .transform<TraceApi.SubmissionStatusV2>({
      parse: (value) => {
        switch (value.type) {
          case \\"test\\":
            return TraceApi.SubmissionStatusV2.test(value);
          case \\"workspace\\":
            return TraceApi.SubmissionStatusV2.workspace(value);
          default:
            return TraceApi.SubmissionStatusV2._unknown(value);
        }
      },
      json: (value) => value as any,
    });

export declare namespace SubmissionStatusV2 {
  type Raw = SubmissionStatusV2.Test | SubmissionStatusV2.Workspace;

  interface Test extends serializers.TestSubmissionStatusV2.Raw {
    type: \\"test\\";
  }

  interface Workspace extends serializers.WorkspaceSubmissionStatusV2.Raw {
    type: \\"workspace\\";
  }
}
",
                    "name": "SubmissionStatusV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const SubmissionTypeEnum: core.schemas.Schema<serializers.SubmissionTypeEnum.Raw, TraceApi.SubmissionTypeEnum> =
  core.schemas.enum_([\\"TEST\\"]);

export declare namespace SubmissionTypeEnum {
  type Raw = \\"TEST\\";
}
",
                    "name": "SubmissionTypeEnum.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const SubmissionTypeState: core.schemas.Schema<
  serializers.SubmissionTypeState.Raw,
  TraceApi.SubmissionTypeState
> = core.schemas
  .union(\\"type\\", {
    test: core.schemas.lazyObject(async () => (await import(\\"../..\\")).TestSubmissionState),
    workspace: core.schemas.lazyObject(async () => (await import(\\"../..\\")).WorkspaceSubmissionState),
  })
  .transform<TraceApi.SubmissionTypeState>({
    parse: (value) => {
      switch (value.type) {
        case \\"test\\":
          return TraceApi.SubmissionTypeState.test(value);
        case \\"workspace\\":
          return TraceApi.SubmissionTypeState.workspace(value);
        default:
          return TraceApi.SubmissionTypeState._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace SubmissionTypeState {
  type Raw = SubmissionTypeState.Test | SubmissionTypeState.Workspace;

  interface Test extends serializers.TestSubmissionState.Raw {
    type: \\"test\\";
  }

  interface Workspace extends serializers.WorkspaceSubmissionState.Raw {
    type: \\"workspace\\";
  }
}
",
                    "name": "SubmissionTypeState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const SubmitRequestV2: core.schemas.ObjectSchema<serializers.SubmitRequestV2.Raw, TraceApi.SubmitRequestV2> =
  core.schemas.object({
    submissionId: core.schemas.lazy(async () => (await import(\\"../..\\")).SubmissionId),
    language: core.schemas.lazy(async () => (await import(\\"../..\\")).Language),
    submissionFiles: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).SubmissionFileInfo)),
    problemId: core.schemas.lazy(async () => (await import(\\"../..\\")).ProblemId),
    problemVersion: core.schemas.number().optional(),
    userId: core.schemas.string().optional(),
  });

export declare namespace SubmitRequestV2 {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
    language: serializers.Language.Raw;
    submissionFiles: serializers.SubmissionFileInfo.Raw[];
    problemId: serializers.ProblemId.Raw;
    problemVersion?: number | null;
    userId?: string | null;
  }
}
",
                    "name": "SubmitRequestV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const TerminatedResponse: core.schemas.ObjectSchema<
  serializers.TerminatedResponse.Raw,
  TraceApi.TerminatedResponse
> = core.schemas.object({});

export declare namespace TerminatedResponse {
  interface Raw {}
}
",
                    "name": "TerminatedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const TestCaseGrade: core.schemas.Schema<serializers.TestCaseGrade.Raw, TraceApi.TestCaseGrade> = core.schemas
  .union(\\"type\\", {
    hidden: core.schemas.lazyObject(async () => (await import(\\"../..\\")).TestCaseHiddenGrade),
    nonHidden: core.schemas.lazyObject(async () => (await import(\\"../..\\")).TestCaseNonHiddenGrade),
  })
  .transform<TraceApi.TestCaseGrade>({
    parse: (value) => {
      switch (value.type) {
        case \\"hidden\\":
          return TraceApi.TestCaseGrade.hidden(value);
        case \\"nonHidden\\":
          return TraceApi.TestCaseGrade.nonHidden(value);
        default:
          return TraceApi.TestCaseGrade._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestCaseGrade {
  type Raw = TestCaseGrade.Hidden | TestCaseGrade.NonHidden;

  interface Hidden extends serializers.TestCaseHiddenGrade.Raw {
    type: \\"hidden\\";
  }

  interface NonHidden extends serializers.TestCaseNonHiddenGrade.Raw {
    type: \\"nonHidden\\";
  }
}
",
                    "name": "TestCaseGrade.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const TestCaseHiddenGrade: core.schemas.ObjectSchema<
  serializers.TestCaseHiddenGrade.Raw,
  TraceApi.TestCaseHiddenGrade
> = core.schemas.object({
  passed: core.schemas.boolean(),
});

export declare namespace TestCaseHiddenGrade {
  interface Raw {
    passed: boolean;
  }
}
",
                    "name": "TestCaseHiddenGrade.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const TestCaseNonHiddenGrade: core.schemas.ObjectSchema<
  serializers.TestCaseNonHiddenGrade.Raw,
  TraceApi.TestCaseNonHiddenGrade
> = core.schemas.object({
  passed: core.schemas.boolean(),
  actualResult: core.schemas.lazy(async () => (await import(\\"../..\\")).VariableValue).optional(),
  exception: core.schemas.lazy(async () => (await import(\\"../..\\")).ExceptionV2).optional(),
  stdout: core.schemas.string(),
});

export declare namespace TestCaseNonHiddenGrade {
  interface Raw {
    passed: boolean;
    actualResult?: serializers.VariableValue.Raw | null;
    exception?: serializers.ExceptionV2.Raw | null;
    stdout: string;
  }
}
",
                    "name": "TestCaseNonHiddenGrade.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const TestCaseResult: core.schemas.ObjectSchema<serializers.TestCaseResult.Raw, TraceApi.TestCaseResult> =
  core.schemas.object({
    expectedResult: core.schemas.lazy(async () => (await import(\\"../..\\")).VariableValue),
    actualResult: core.schemas.lazy(async () => (await import(\\"../..\\")).ActualResult),
    passed: core.schemas.boolean(),
  });

export declare namespace TestCaseResult {
  interface Raw {
    expectedResult: serializers.VariableValue.Raw;
    actualResult: serializers.ActualResult.Raw;
    passed: boolean;
  }
}
",
                    "name": "TestCaseResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const TestCaseResultWithStdout: core.schemas.ObjectSchema<
  serializers.TestCaseResultWithStdout.Raw,
  TraceApi.TestCaseResultWithStdout
> = core.schemas.object({
  result: core.schemas.lazyObject(async () => (await import(\\"../..\\")).TestCaseResult),
  stdout: core.schemas.string(),
});

export declare namespace TestCaseResultWithStdout {
  interface Raw {
    result: serializers.TestCaseResult.Raw;
    stdout: string;
  }
}
",
                    "name": "TestCaseResultWithStdout.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const TestSubmissionState: core.schemas.ObjectSchema<
  serializers.TestSubmissionState.Raw,
  TraceApi.TestSubmissionState
> = core.schemas.object({
  problemId: core.schemas.lazy(async () => (await import(\\"../..\\")).ProblemId),
  defaultTestCases: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).TestCase)),
  customTestCases: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).TestCase)),
  status: core.schemas.lazy(async () => (await import(\\"../..\\")).TestSubmissionStatus),
});

export declare namespace TestSubmissionState {
  interface Raw {
    problemId: serializers.ProblemId.Raw;
    defaultTestCases: serializers.TestCase.Raw[];
    customTestCases: serializers.TestCase.Raw[];
    status: serializers.TestSubmissionStatus.Raw;
  }
}
",
                    "name": "TestSubmissionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const TestSubmissionStatus: core.schemas.Schema<
  serializers.TestSubmissionStatus.Raw,
  TraceApi.TestSubmissionStatus
> = core.schemas
  .union(\\"type\\", {
    stopped: core.schemas.object({}),
    errored: core.schemas.object({
      value: core.schemas.lazy(async () => (await import(\\"../..\\")).ErrorInfo),
    }),
    running: core.schemas.object({
      value: core.schemas.lazy(async () => (await import(\\"../..\\")).RunningSubmissionState),
    }),
    testCaseIdToState: core.schemas.object({
      value: core.schemas.record(
        core.schemas.string(),
        core.schemas.lazy(async () => (await import(\\"../..\\")).SubmissionStatusForTestCase)
      ),
    }),
  })
  .transform<TraceApi.TestSubmissionStatus>({
    parse: (value) => {
      switch (value.type) {
        case \\"stopped\\":
          return TraceApi.TestSubmissionStatus.stopped();
        case \\"errored\\":
          return TraceApi.TestSubmissionStatus.errored(value.value);
        case \\"running\\":
          return TraceApi.TestSubmissionStatus.running(value.value);
        case \\"testCaseIdToState\\":
          return TraceApi.TestSubmissionStatus.testCaseIdToState(value.value);
        default:
          return TraceApi.TestSubmissionStatus._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestSubmissionStatus {
  type Raw =
    | TestSubmissionStatus.Stopped
    | TestSubmissionStatus.Errored
    | TestSubmissionStatus.Running
    | TestSubmissionStatus.TestCaseIdToState;

  interface Stopped {
    type: \\"stopped\\";
  }

  interface Errored {
    type: \\"errored\\";
    value: serializers.ErrorInfo.Raw;
  }

  interface Running {
    type: \\"running\\";
    value: serializers.RunningSubmissionState.Raw;
  }

  interface TestCaseIdToState {
    type: \\"testCaseIdToState\\";
    value: Record<string, serializers.SubmissionStatusForTestCase.Raw>;
  }
}
",
                    "name": "TestSubmissionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const TestSubmissionStatusV2: core.schemas.ObjectSchema<
  serializers.TestSubmissionStatusV2.Raw,
  TraceApi.TestSubmissionStatusV2
> = core.schemas.object({
  updates: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).TestSubmissionUpdate)),
  problemId: core.schemas.lazy(async () => (await import(\\"../..\\")).ProblemId),
  problemVersion: core.schemas.number(),
  problemInfo: core.schemas.lazyObject(async () => (await import(\\"../..\\")).v2.ProblemInfoV2),
});

export declare namespace TestSubmissionStatusV2 {
  interface Raw {
    updates: serializers.TestSubmissionUpdate.Raw[];
    problemId: serializers.ProblemId.Raw;
    problemVersion: number;
    problemInfo: serializers.v2.ProblemInfoV2.Raw;
  }
}
",
                    "name": "TestSubmissionStatusV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const TestSubmissionUpdate: core.schemas.ObjectSchema<
  serializers.TestSubmissionUpdate.Raw,
  TraceApi.TestSubmissionUpdate
> = core.schemas.object({
  updateTime: core.schemas.date(),
  updateInfo: core.schemas.lazy(async () => (await import(\\"../..\\")).TestSubmissionUpdateInfo),
});

export declare namespace TestSubmissionUpdate {
  interface Raw {
    updateTime: string;
    updateInfo: serializers.TestSubmissionUpdateInfo.Raw;
  }
}
",
                    "name": "TestSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const TestSubmissionUpdateInfo: core.schemas.Schema<
  serializers.TestSubmissionUpdateInfo.Raw,
  TraceApi.TestSubmissionUpdateInfo
> = core.schemas
  .union(\\"type\\", {
    running: core.schemas.object({
      value: core.schemas.lazy(async () => (await import(\\"../..\\")).RunningSubmissionState),
    }),
    stopped: core.schemas.object({}),
    errored: core.schemas.object({
      value: core.schemas.lazy(async () => (await import(\\"../..\\")).ErrorInfo),
    }),
    gradedTestCase: core.schemas.lazyObject(async () => (await import(\\"../..\\")).GradedTestCaseUpdate),
    recordedTestCase: core.schemas.lazyObject(async () => (await import(\\"../..\\")).RecordedTestCaseUpdate),
    finished: core.schemas.object({}),
  })
  .transform<TraceApi.TestSubmissionUpdateInfo>({
    parse: (value) => {
      switch (value.type) {
        case \\"running\\":
          return TraceApi.TestSubmissionUpdateInfo.running(value.value);
        case \\"stopped\\":
          return TraceApi.TestSubmissionUpdateInfo.stopped();
        case \\"errored\\":
          return TraceApi.TestSubmissionUpdateInfo.errored(value.value);
        case \\"gradedTestCase\\":
          return TraceApi.TestSubmissionUpdateInfo.gradedTestCase(value);
        case \\"recordedTestCase\\":
          return TraceApi.TestSubmissionUpdateInfo.recordedTestCase(value);
        case \\"finished\\":
          return TraceApi.TestSubmissionUpdateInfo.finished();
        default:
          return TraceApi.TestSubmissionUpdateInfo._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestSubmissionUpdateInfo {
  type Raw =
    | TestSubmissionUpdateInfo.Running
    | TestSubmissionUpdateInfo.Stopped
    | TestSubmissionUpdateInfo.Errored
    | TestSubmissionUpdateInfo.GradedTestCase
    | TestSubmissionUpdateInfo.RecordedTestCase
    | TestSubmissionUpdateInfo.Finished;

  interface Running {
    type: \\"running\\";
    value: serializers.RunningSubmissionState.Raw;
  }

  interface Stopped {
    type: \\"stopped\\";
  }

  interface Errored {
    type: \\"errored\\";
    value: serializers.ErrorInfo.Raw;
  }

  interface GradedTestCase extends serializers.GradedTestCaseUpdate.Raw {
    type: \\"gradedTestCase\\";
  }

  interface RecordedTestCase extends serializers.RecordedTestCaseUpdate.Raw {
    type: \\"recordedTestCase\\";
  }

  interface Finished {
    type: \\"finished\\";
  }
}
",
                    "name": "TestSubmissionUpdateInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const TraceResponse: core.schemas.ObjectSchema<serializers.TraceResponse.Raw, TraceApi.TraceResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(async () => (await import(\\"../..\\")).SubmissionId),
    lineNumber: core.schemas.number(),
    returnValue: core.schemas.lazy(async () => (await import(\\"../..\\")).DebugVariableValue).optional(),
    expressionLocation: core.schemas.lazyObject(async () => (await import(\\"../..\\")).ExpressionLocation).optional(),
    stack: core.schemas.lazyObject(async () => (await import(\\"../..\\")).StackInformation),
    stdout: core.schemas.string().optional(),
  });

export declare namespace TraceResponse {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
    lineNumber: number;
    returnValue?: serializers.DebugVariableValue.Raw | null;
    expressionLocation?: serializers.ExpressionLocation.Raw | null;
    stack: serializers.StackInformation.Raw;
    stdout?: string | null;
  }
}
",
                    "name": "TraceResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const TraceResponseV2: core.schemas.ObjectSchema<serializers.TraceResponseV2.Raw, TraceApi.TraceResponseV2> =
  core.schemas.object({
    submissionId: core.schemas.lazy(async () => (await import(\\"../..\\")).SubmissionId),
    lineNumber: core.schemas.number(),
    file: core.schemas.lazyObject(async () => (await import(\\"../..\\")).TracedFile),
    returnValue: core.schemas.lazy(async () => (await import(\\"../..\\")).DebugVariableValue).optional(),
    expressionLocation: core.schemas.lazyObject(async () => (await import(\\"../..\\")).ExpressionLocation).optional(),
    stack: core.schemas.lazyObject(async () => (await import(\\"../..\\")).StackInformation),
    stdout: core.schemas.string().optional(),
  });

export declare namespace TraceResponseV2 {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
    lineNumber: number;
    file: serializers.TracedFile.Raw;
    returnValue?: serializers.DebugVariableValue.Raw | null;
    expressionLocation?: serializers.ExpressionLocation.Raw | null;
    stack: serializers.StackInformation.Raw;
    stdout?: string | null;
  }
}
",
                    "name": "TraceResponseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const TraceResponsesPage: core.schemas.ObjectSchema<
  serializers.TraceResponsesPage.Raw,
  TraceApi.TraceResponsesPage
> = core.schemas.object({
  offset: core.schemas.number().optional(),
  traceResponses: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).TraceResponse)),
});

export declare namespace TraceResponsesPage {
  interface Raw {
    offset?: number | null;
    traceResponses: serializers.TraceResponse.Raw[];
  }
}
",
                    "name": "TraceResponsesPage.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const TraceResponsesPageV2: core.schemas.ObjectSchema<
  serializers.TraceResponsesPageV2.Raw,
  TraceApi.TraceResponsesPageV2
> = core.schemas.object({
  offset: core.schemas.number().optional(),
  traceResponses: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).TraceResponseV2)),
});

export declare namespace TraceResponsesPageV2 {
  interface Raw {
    offset?: number | null;
    traceResponses: serializers.TraceResponseV2.Raw[];
  }
}
",
                    "name": "TraceResponsesPageV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const TracedFile: core.schemas.ObjectSchema<serializers.TracedFile.Raw, TraceApi.TracedFile> =
  core.schemas.object({
    filename: core.schemas.string(),
    directory: core.schemas.string(),
  });

export declare namespace TracedFile {
  interface Raw {
    filename: string;
    directory: string;
  }
}
",
                    "name": "TracedFile.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const TracedTestCase: core.schemas.ObjectSchema<serializers.TracedTestCase.Raw, TraceApi.TracedTestCase> =
  core.schemas.object({
    result: core.schemas.lazyObject(async () => (await import(\\"../..\\")).TestCaseResultWithStdout),
    traceResponsesSize: core.schemas.number(),
  });

export declare namespace TracedTestCase {
  interface Raw {
    result: serializers.TestCaseResultWithStdout.Raw;
    traceResponsesSize: number;
  }
}
",
                    "name": "TracedTestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const UnexpectedLanguageError: core.schemas.ObjectSchema<
  serializers.UnexpectedLanguageError.Raw,
  TraceApi.UnexpectedLanguageError
> = core.schemas.object({
  expectedLanguage: core.schemas.lazy(async () => (await import(\\"../..\\")).Language),
  actualLanguage: core.schemas.lazy(async () => (await import(\\"../..\\")).Language),
});

export declare namespace UnexpectedLanguageError {
  interface Raw {
    expectedLanguage: serializers.Language.Raw;
    actualLanguage: serializers.Language.Raw;
  }
}
",
                    "name": "UnexpectedLanguageError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const WorkspaceFiles: core.schemas.ObjectSchema<serializers.WorkspaceFiles.Raw, TraceApi.WorkspaceFiles> =
  core.schemas.object({
    mainFile: core.schemas.lazyObject(async () => (await import(\\"../..\\")).FileInfo),
    readOnlyFiles: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).FileInfo)),
  });

export declare namespace WorkspaceFiles {
  interface Raw {
    mainFile: serializers.FileInfo.Raw;
    readOnlyFiles: serializers.FileInfo.Raw[];
  }
}
",
                    "name": "WorkspaceFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const WorkspaceRanResponse: core.schemas.ObjectSchema<
  serializers.WorkspaceRanResponse.Raw,
  TraceApi.WorkspaceRanResponse
> = core.schemas.object({
  submissionId: core.schemas.lazy(async () => (await import(\\"../..\\")).SubmissionId),
  runDetails: core.schemas.lazyObject(async () => (await import(\\"../..\\")).WorkspaceRunDetails),
});

export declare namespace WorkspaceRanResponse {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
    runDetails: serializers.WorkspaceRunDetails.Raw;
  }
}
",
                    "name": "WorkspaceRanResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const WorkspaceRunDetails: core.schemas.ObjectSchema<
  serializers.WorkspaceRunDetails.Raw,
  TraceApi.WorkspaceRunDetails
> = core.schemas.object({
  exceptionV2: core.schemas.lazy(async () => (await import(\\"../..\\")).ExceptionV2).optional(),
  exception: core.schemas.lazyObject(async () => (await import(\\"../..\\")).ExceptionInfo).optional(),
  stdout: core.schemas.string(),
});

export declare namespace WorkspaceRunDetails {
  interface Raw {
    exceptionV2?: serializers.ExceptionV2.Raw | null;
    exception?: serializers.ExceptionInfo.Raw | null;
    stdout: string;
  }
}
",
                    "name": "WorkspaceRunDetails.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const WorkspaceStarterFilesResponse: core.schemas.ObjectSchema<
  serializers.WorkspaceStarterFilesResponse.Raw,
  TraceApi.WorkspaceStarterFilesResponse
> = core.schemas.object({
  files: core.schemas.record(
    core.schemas.lazy(async () => (await import(\\"../..\\")).Language),
    core.schemas.lazyObject(async () => (await import(\\"../..\\")).WorkspaceFiles)
  ),
});

export declare namespace WorkspaceStarterFilesResponse {
  interface Raw {
    files: Record<serializers.Language.Raw, serializers.WorkspaceFiles.Raw>;
  }
}
",
                    "name": "WorkspaceStarterFilesResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const WorkspaceStarterFilesResponseV2: core.schemas.ObjectSchema<
  serializers.WorkspaceStarterFilesResponseV2.Raw,
  TraceApi.WorkspaceStarterFilesResponseV2
> = core.schemas.object({
  filesByLanguage: core.schemas.record(
    core.schemas.lazy(async () => (await import(\\"../..\\")).Language),
    core.schemas.lazyObject(async () => (await import(\\"../..\\")).v2.Files)
  ),
});

export declare namespace WorkspaceStarterFilesResponseV2 {
  interface Raw {
    filesByLanguage: Record<serializers.Language.Raw, serializers.v2.Files.Raw>;
  }
}
",
                    "name": "WorkspaceStarterFilesResponseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const WorkspaceSubmissionState: core.schemas.ObjectSchema<
  serializers.WorkspaceSubmissionState.Raw,
  TraceApi.WorkspaceSubmissionState
> = core.schemas.object({
  status: core.schemas.lazy(async () => (await import(\\"../..\\")).WorkspaceSubmissionStatus),
});

export declare namespace WorkspaceSubmissionState {
  interface Raw {
    status: serializers.WorkspaceSubmissionStatus.Raw;
  }
}
",
                    "name": "WorkspaceSubmissionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const WorkspaceSubmissionStatus: core.schemas.Schema<
  serializers.WorkspaceSubmissionStatus.Raw,
  TraceApi.WorkspaceSubmissionStatus
> = core.schemas
  .union(\\"type\\", {
    stopped: core.schemas.object({}),
    errored: core.schemas.object({
      value: core.schemas.lazy(async () => (await import(\\"../..\\")).ErrorInfo),
    }),
    running: core.schemas.object({
      value: core.schemas.lazy(async () => (await import(\\"../..\\")).RunningSubmissionState),
    }),
    ran: core.schemas.lazyObject(async () => (await import(\\"../..\\")).WorkspaceRunDetails),
    traced: core.schemas.lazyObject(async () => (await import(\\"../..\\")).WorkspaceRunDetails),
  })
  .transform<TraceApi.WorkspaceSubmissionStatus>({
    parse: (value) => {
      switch (value.type) {
        case \\"stopped\\":
          return TraceApi.WorkspaceSubmissionStatus.stopped();
        case \\"errored\\":
          return TraceApi.WorkspaceSubmissionStatus.errored(value.value);
        case \\"running\\":
          return TraceApi.WorkspaceSubmissionStatus.running(value.value);
        case \\"ran\\":
          return TraceApi.WorkspaceSubmissionStatus.ran(value);
        case \\"traced\\":
          return TraceApi.WorkspaceSubmissionStatus.traced(value);
        default:
          return TraceApi.WorkspaceSubmissionStatus._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace WorkspaceSubmissionStatus {
  type Raw =
    | WorkspaceSubmissionStatus.Stopped
    | WorkspaceSubmissionStatus.Errored
    | WorkspaceSubmissionStatus.Running
    | WorkspaceSubmissionStatus.Ran
    | WorkspaceSubmissionStatus.Traced;

  interface Stopped {
    type: \\"stopped\\";
  }

  interface Errored {
    type: \\"errored\\";
    value: serializers.ErrorInfo.Raw;
  }

  interface Running {
    type: \\"running\\";
    value: serializers.RunningSubmissionState.Raw;
  }

  interface Ran extends serializers.WorkspaceRunDetails.Raw {
    type: \\"ran\\";
  }

  interface Traced extends serializers.WorkspaceRunDetails.Raw {
    type: \\"traced\\";
  }
}
",
                    "name": "WorkspaceSubmissionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const WorkspaceSubmissionStatusV2: core.schemas.ObjectSchema<
  serializers.WorkspaceSubmissionStatusV2.Raw,
  TraceApi.WorkspaceSubmissionStatusV2
> = core.schemas.object({
  updates: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).WorkspaceSubmissionUpdate)),
});

export declare namespace WorkspaceSubmissionStatusV2 {
  interface Raw {
    updates: serializers.WorkspaceSubmissionUpdate.Raw[];
  }
}
",
                    "name": "WorkspaceSubmissionStatusV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const WorkspaceSubmissionUpdate: core.schemas.ObjectSchema<
  serializers.WorkspaceSubmissionUpdate.Raw,
  TraceApi.WorkspaceSubmissionUpdate
> = core.schemas.object({
  updateTime: core.schemas.date(),
  updateInfo: core.schemas.lazy(async () => (await import(\\"../..\\")).WorkspaceSubmissionUpdateInfo),
});

export declare namespace WorkspaceSubmissionUpdate {
  interface Raw {
    updateTime: string;
    updateInfo: serializers.WorkspaceSubmissionUpdateInfo.Raw;
  }
}
",
                    "name": "WorkspaceSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const WorkspaceSubmissionUpdateInfo: core.schemas.Schema<
  serializers.WorkspaceSubmissionUpdateInfo.Raw,
  TraceApi.WorkspaceSubmissionUpdateInfo
> = core.schemas
  .union(\\"type\\", {
    running: core.schemas.object({
      value: core.schemas.lazy(async () => (await import(\\"../..\\")).RunningSubmissionState),
    }),
    ran: core.schemas.lazyObject(async () => (await import(\\"../..\\")).WorkspaceRunDetails),
    stopped: core.schemas.object({}),
    traced: core.schemas.object({}),
    tracedV2: core.schemas.lazyObject(async () => (await import(\\"../..\\")).WorkspaceTracedUpdate),
    errored: core.schemas.object({
      value: core.schemas.lazy(async () => (await import(\\"../..\\")).ErrorInfo),
    }),
    finished: core.schemas.object({}),
  })
  .transform<TraceApi.WorkspaceSubmissionUpdateInfo>({
    parse: (value) => {
      switch (value.type) {
        case \\"running\\":
          return TraceApi.WorkspaceSubmissionUpdateInfo.running(value.value);
        case \\"ran\\":
          return TraceApi.WorkspaceSubmissionUpdateInfo.ran(value);
        case \\"stopped\\":
          return TraceApi.WorkspaceSubmissionUpdateInfo.stopped();
        case \\"traced\\":
          return TraceApi.WorkspaceSubmissionUpdateInfo.traced();
        case \\"tracedV2\\":
          return TraceApi.WorkspaceSubmissionUpdateInfo.tracedV2(value);
        case \\"errored\\":
          return TraceApi.WorkspaceSubmissionUpdateInfo.errored(value.value);
        case \\"finished\\":
          return TraceApi.WorkspaceSubmissionUpdateInfo.finished();
        default:
          return TraceApi.WorkspaceSubmissionUpdateInfo._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace WorkspaceSubmissionUpdateInfo {
  type Raw =
    | WorkspaceSubmissionUpdateInfo.Running
    | WorkspaceSubmissionUpdateInfo.Ran
    | WorkspaceSubmissionUpdateInfo.Stopped
    | WorkspaceSubmissionUpdateInfo.Traced
    | WorkspaceSubmissionUpdateInfo.TracedV2
    | WorkspaceSubmissionUpdateInfo.Errored
    | WorkspaceSubmissionUpdateInfo.Finished;

  interface Running {
    type: \\"running\\";
    value: serializers.RunningSubmissionState.Raw;
  }

  interface Ran extends serializers.WorkspaceRunDetails.Raw {
    type: \\"ran\\";
  }

  interface Stopped {
    type: \\"stopped\\";
  }

  interface Traced {
    type: \\"traced\\";
  }

  interface TracedV2 extends serializers.WorkspaceTracedUpdate.Raw {
    type: \\"tracedV2\\";
  }

  interface Errored {
    type: \\"errored\\";
    value: serializers.ErrorInfo.Raw;
  }

  interface Finished {
    type: \\"finished\\";
  }
}
",
                    "name": "WorkspaceSubmissionUpdateInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const WorkspaceSubmitRequest: core.schemas.ObjectSchema<
  serializers.WorkspaceSubmitRequest.Raw,
  TraceApi.WorkspaceSubmitRequest
> = core.schemas.object({
  submissionId: core.schemas.lazy(async () => (await import(\\"../..\\")).SubmissionId),
  language: core.schemas.lazy(async () => (await import(\\"../..\\")).Language),
  submissionFiles: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../..\\")).SubmissionFileInfo)),
  userId: core.schemas.string().optional(),
});

export declare namespace WorkspaceSubmitRequest {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
    language: serializers.Language.Raw;
    submissionFiles: serializers.SubmissionFileInfo.Raw[];
    userId?: string | null;
  }
}
",
                    "name": "WorkspaceSubmitRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const WorkspaceTracedUpdate: core.schemas.ObjectSchema<
  serializers.WorkspaceTracedUpdate.Raw,
  TraceApi.WorkspaceTracedUpdate
> = core.schemas.object({
  traceResponsesSize: core.schemas.number(),
});

export declare namespace WorkspaceTracedUpdate {
  interface Raw {
    traceResponsesSize: number;
  }
}
",
                    "name": "WorkspaceTracedUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./SubmissionId\\";
export * from \\"./ShareId\\";
export * from \\"./SubmissionRequest\\";
export * from \\"./InitializeProblemRequest\\";
export * from \\"./SubmitRequestV2\\";
export * from \\"./WorkspaceSubmitRequest\\";
export * from \\"./SubmissionFileInfo\\";
export * from \\"./SubmissionTypeEnum\\";
export * from \\"./StopRequest\\";
export * from \\"./SubmissionResponse\\";
export * from \\"./CodeExecutionUpdate\\";
export * from \\"./BuildingExecutorResponse\\";
export * from \\"./RunningResponse\\";
export * from \\"./RunningSubmissionState\\";
export * from \\"./ErroredResponse\\";
export * from \\"./ErrorInfo\\";
export * from \\"./CompileError\\";
export * from \\"./RuntimeError\\";
export * from \\"./InternalError\\";
export * from \\"./StoppedResponse\\";
export * from \\"./WorkspaceRanResponse\\";
export * from \\"./WorkspaceRunDetails\\";
export * from \\"./GradedResponse\\";
export * from \\"./GradedResponseV2\\";
export * from \\"./TestCaseGrade\\";
export * from \\"./TestCaseHiddenGrade\\";
export * from \\"./TestCaseNonHiddenGrade\\";
export * from \\"./RecordedResponseNotification\\";
export * from \\"./RecordingResponseNotification\\";
export * from \\"./LightweightStackframeInformation\\";
export * from \\"./TestCaseResultWithStdout\\";
export * from \\"./TestCaseResult\\";
export * from \\"./ActualResult\\";
export * from \\"./ExceptionV2\\";
export * from \\"./ExceptionInfo\\";
export * from \\"./InvalidRequestResponse\\";
export * from \\"./InvalidRequestCause\\";
export * from \\"./ExistingSubmissionExecuting\\";
export * from \\"./SubmissionIdNotFound\\";
export * from \\"./CustomTestCasesUnsupported\\";
export * from \\"./UnexpectedLanguageError\\";
export * from \\"./TerminatedResponse\\";
export * from \\"./FinishedResponse\\";
export * from \\"./StdoutResponse\\";
export * from \\"./StderrResponse\\";
export * from \\"./TraceResponse\\";
export * from \\"./TraceResponseV2\\";
export * from \\"./TracedFile\\";
export * from \\"./ExpressionLocation\\";
export * from \\"./StackInformation\\";
export * from \\"./StackFrame\\";
export * from \\"./Scope\\";
export * from \\"./ExecutionSessionResponse\\";
export * from \\"./ExecutionSessionStatus\\";
export * from \\"./SubmissionStatusV2\\";
export * from \\"./TestSubmissionStatusV2\\";
export * from \\"./WorkspaceSubmissionStatusV2\\";
export * from \\"./TestSubmissionUpdate\\";
export * from \\"./TestSubmissionUpdateInfo\\";
export * from \\"./WorkspaceSubmissionUpdate\\";
export * from \\"./WorkspaceSubmissionUpdateInfo\\";
export * from \\"./GradedTestCaseUpdate\\";
export * from \\"./RecordedTestCaseUpdate\\";
export * from \\"./WorkspaceTracedUpdate\\";
export * from \\"./SubmissionTypeState\\";
export * from \\"./WorkspaceSubmissionState\\";
export * from \\"./WorkspaceSubmissionStatus\\";
export * from \\"./TestSubmissionState\\";
export * from \\"./TestSubmissionStatus\\";
export * from \\"./SubmissionStatusForTestCase\\";
export * from \\"./TracedTestCase\\";
export * from \\"./TraceResponsesPage\\";
export * from \\"./TraceResponsesPageV2\\";
export * from \\"./GetTraceResponsesPageRequest\\";
export * from \\"./WorkspaceStarterFilesResponse\\";
export * from \\"./WorkspaceStarterFilesResponseV2\\";
export * from \\"./WorkspaceFiles\\";
export * from \\"./ExecutionSessionState\\";
export * from \\"./GetExecutionSessionStateResponse\\";
export * from \\"./GetSubmissionStateResponse\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "submission",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  serializers.sysprop.getNumWarmInstances.Response.Raw,
  Record<TraceApi.Language, number>
> = core.schemas.record(
  core.schemas.lazy(async () => (await import(\\"../..\\")).Language),
  core.schemas.number()
);

export declare namespace Response {
  type Raw = Record<serializers.Language.Raw, number>;
}
",
                    "name": "getNumWarmInstances.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getNumWarmInstances from \\"./getNumWarmInstances\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "sysprop",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./resources\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as v3 from \\"./v3\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const Response: core.schemas.Schema<
  serializers.v2.problem.getLatestProblem.Response.Raw,
  TraceApi.v2.ProblemInfoV2
> = core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.ProblemInfoV2);

export declare namespace Response {
  type Raw = serializers.v2.ProblemInfoV2.Raw;
}
",
                            "name": "getLatestProblem.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const Response: core.schemas.Schema<
  serializers.v2.problem.getLightweightProblems.Response.Raw,
  TraceApi.v2.LightweightProblemInfoV2[]
> = core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.LightweightProblemInfoV2));

export declare namespace Response {
  type Raw = serializers.v2.LightweightProblemInfoV2.Raw[];
}
",
                            "name": "getLightweightProblems.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const Response: core.schemas.Schema<
  serializers.v2.problem.getProblemVersion.Response.Raw,
  TraceApi.v2.ProblemInfoV2
> = core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.ProblemInfoV2);

export declare namespace Response {
  type Raw = serializers.v2.ProblemInfoV2.Raw;
}
",
                            "name": "getProblemVersion.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const Response: core.schemas.Schema<
  serializers.v2.problem.getProblems.Response.Raw,
  TraceApi.v2.ProblemInfoV2[]
> = core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.ProblemInfoV2));

export declare namespace Response {
  type Raw = serializers.v2.ProblemInfoV2.Raw[];
}
",
                            "name": "getProblems.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
export * as getLatestProblem from \\"./getLatestProblem\\";
export * as getProblemVersion from \\"./getProblemVersion\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "client",
                        "type": "directory",
                      },
                      Object {
                        "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const AssertCorrectnessCheck: core.schemas.Schema<
  serializers.v2.AssertCorrectnessCheck.Raw,
  TraceApi.v2.AssertCorrectnessCheck
> = core.schemas
  .union(\\"type\\", {
    deepEquality: core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.DeepEqualityCorrectnessCheck),
    custom: core.schemas.lazyObject(
      async () => (await import(\\"../../../..\\")).v2.VoidFunctionDefinitionThatTakesActualResult
    ),
  })
  .transform<TraceApi.v2.AssertCorrectnessCheck>({
    parse: (value) => {
      switch (value.type) {
        case \\"deepEquality\\":
          return TraceApi.v2.AssertCorrectnessCheck.deepEquality(value);
        case \\"custom\\":
          return TraceApi.v2.AssertCorrectnessCheck.custom(value);
        default:
          return TraceApi.v2.AssertCorrectnessCheck._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace AssertCorrectnessCheck {
  type Raw = AssertCorrectnessCheck.DeepEquality | AssertCorrectnessCheck.Custom;

  interface DeepEquality extends serializers.v2.DeepEqualityCorrectnessCheck.Raw {
    type: \\"deepEquality\\";
  }

  interface Custom extends serializers.v2.VoidFunctionDefinitionThatTakesActualResult.Raw {
    type: \\"custom\\";
  }
}
",
                            "name": "AssertCorrectnessCheck.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const BasicCustomFiles: core.schemas.ObjectSchema<
  serializers.v2.BasicCustomFiles.Raw,
  TraceApi.v2.BasicCustomFiles
> = core.schemas.object({
  methodName: core.schemas.string(),
  signature: core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.NonVoidFunctionSignature),
  additionalFiles: core.schemas.record(
    core.schemas.lazy(async () => (await import(\\"../../../..\\")).Language),
    core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.Files)
  ),
  basicTestCaseTemplate: core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.BasicTestCaseTemplate),
});

export declare namespace BasicCustomFiles {
  interface Raw {
    methodName: string;
    signature: serializers.v2.NonVoidFunctionSignature.Raw;
    additionalFiles: Record<serializers.Language.Raw, serializers.v2.Files.Raw>;
    basicTestCaseTemplate: serializers.v2.BasicTestCaseTemplate.Raw;
  }
}
",
                            "name": "BasicCustomFiles.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const BasicTestCaseTemplate: core.schemas.ObjectSchema<
  serializers.v2.BasicTestCaseTemplate.Raw,
  TraceApi.v2.BasicTestCaseTemplate
> = core.schemas.object({
  templateId: core.schemas.lazy(async () => (await import(\\"../../../..\\")).v2.TestCaseTemplateId),
  name: core.schemas.string(),
  description: core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.TestCaseImplementationDescription),
  expectedValueParameterId: core.schemas.lazy(async () => (await import(\\"../../../..\\")).v2.ParameterId),
});

export declare namespace BasicTestCaseTemplate {
  interface Raw {
    templateId: serializers.v2.TestCaseTemplateId.Raw;
    name: string;
    description: serializers.v2.TestCaseImplementationDescription.Raw;
    expectedValueParameterId: serializers.v2.ParameterId.Raw;
  }
}
",
                            "name": "BasicTestCaseTemplate.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const CreateProblemRequestV2: core.schemas.ObjectSchema<
  serializers.v2.CreateProblemRequestV2.Raw,
  TraceApi.v2.CreateProblemRequestV2
> = core.schemas.object({
  problemName: core.schemas.string(),
  problemDescription: core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).ProblemDescription),
  customFiles: core.schemas.lazy(async () => (await import(\\"../../../..\\")).v2.CustomFiles),
  customTestCaseTemplates: core.schemas.list(
    core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.TestCaseTemplate)
  ),
  testcases: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.TestCaseV2)),
  supportedLanguages: core.schemas.list(core.schemas.lazy(async () => (await import(\\"../../../..\\")).Language)),
  isPublic: core.schemas.boolean(),
});

export declare namespace CreateProblemRequestV2 {
  interface Raw {
    problemName: string;
    problemDescription: serializers.ProblemDescription.Raw;
    customFiles: serializers.v2.CustomFiles.Raw;
    customTestCaseTemplates: serializers.v2.TestCaseTemplate.Raw[];
    testcases: serializers.v2.TestCaseV2.Raw[];
    supportedLanguages: serializers.Language.Raw[];
    isPublic: boolean;
  }
}
",
                            "name": "CreateProblemRequestV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const CustomFiles: core.schemas.Schema<serializers.v2.CustomFiles.Raw, TraceApi.v2.CustomFiles> = core.schemas
  .union(\\"type\\", {
    basic: core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.BasicCustomFiles),
    custom: core.schemas.object({
      value: core.schemas.record(
        core.schemas.lazy(async () => (await import(\\"../../../..\\")).Language),
        core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.Files)
      ),
    }),
  })
  .transform<TraceApi.v2.CustomFiles>({
    parse: (value) => {
      switch (value.type) {
        case \\"basic\\":
          return TraceApi.v2.CustomFiles.basic(value);
        case \\"custom\\":
          return TraceApi.v2.CustomFiles.custom(value.value);
        default:
          return TraceApi.v2.CustomFiles._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace CustomFiles {
  type Raw = CustomFiles.Basic | CustomFiles.Custom;

  interface Basic extends serializers.v2.BasicCustomFiles.Raw {
    type: \\"basic\\";
  }

  interface Custom {
    type: \\"custom\\";
    value: Record<serializers.Language.Raw, serializers.v2.Files.Raw>;
  }
}
",
                            "name": "CustomFiles.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const DeepEqualityCorrectnessCheck: core.schemas.ObjectSchema<
  serializers.v2.DeepEqualityCorrectnessCheck.Raw,
  TraceApi.v2.DeepEqualityCorrectnessCheck
> = core.schemas.object({
  expectedValueParameterId: core.schemas.lazy(async () => (await import(\\"../../../..\\")).v2.ParameterId),
});

export declare namespace DeepEqualityCorrectnessCheck {
  interface Raw {
    expectedValueParameterId: serializers.v2.ParameterId.Raw;
  }
}
",
                            "name": "DeepEqualityCorrectnessCheck.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const DefaultProvidedFile: core.schemas.ObjectSchema<
  serializers.v2.DefaultProvidedFile.Raw,
  TraceApi.v2.DefaultProvidedFile
> = core.schemas.object({
  file: core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.FileInfoV2),
  relatedTypes: core.schemas.list(core.schemas.lazy(async () => (await import(\\"../../../..\\")).VariableType)),
});

export declare namespace DefaultProvidedFile {
  interface Raw {
    file: serializers.v2.FileInfoV2.Raw;
    relatedTypes: serializers.VariableType.Raw[];
  }
}
",
                            "name": "DefaultProvidedFile.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const FileInfoV2: core.schemas.ObjectSchema<serializers.v2.FileInfoV2.Raw, TraceApi.v2.FileInfoV2> =
  core.schemas.object({
    filename: core.schemas.string(),
    directory: core.schemas.string(),
    contents: core.schemas.string(),
    editable: core.schemas.boolean(),
  });

export declare namespace FileInfoV2 {
  interface Raw {
    filename: string;
    directory: string;
    contents: string;
    editable: boolean;
  }
}
",
                            "name": "FileInfoV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const Files: core.schemas.ObjectSchema<serializers.v2.Files.Raw, TraceApi.v2.Files> = core.schemas.object({
  files: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.FileInfoV2)),
});

export declare namespace Files {
  interface Raw {
    files: serializers.v2.FileInfoV2.Raw[];
  }
}
",
                            "name": "Files.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const FunctionImplementation: core.schemas.ObjectSchema<
  serializers.v2.FunctionImplementation.Raw,
  TraceApi.v2.FunctionImplementation
> = core.schemas.object({
  impl: core.schemas.string(),
  imports: core.schemas.string().optional(),
});

export declare namespace FunctionImplementation {
  interface Raw {
    impl: string;
    imports?: string | null;
  }
}
",
                            "name": "FunctionImplementation.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const FunctionImplementationForMultipleLanguages: core.schemas.ObjectSchema<
  serializers.v2.FunctionImplementationForMultipleLanguages.Raw,
  TraceApi.v2.FunctionImplementationForMultipleLanguages
> = core.schemas.object({
  codeByLanguage: core.schemas.record(
    core.schemas.lazy(async () => (await import(\\"../../../..\\")).Language),
    core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.FunctionImplementation)
  ),
});

export declare namespace FunctionImplementationForMultipleLanguages {
  interface Raw {
    codeByLanguage: Record<serializers.Language.Raw, serializers.v2.FunctionImplementation.Raw>;
  }
}
",
                            "name": "FunctionImplementationForMultipleLanguages.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const FunctionSignature: core.schemas.Schema<
  serializers.v2.FunctionSignature.Raw,
  TraceApi.v2.FunctionSignature
> = core.schemas
  .union(\\"type\\", {
    void: core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.VoidFunctionSignature),
    nonVoid: core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.NonVoidFunctionSignature),
    voidThatTakesActualResult: core.schemas.lazyObject(
      async () => (await import(\\"../../../..\\")).v2.VoidFunctionSignatureThatTakesActualResult
    ),
  })
  .transform<TraceApi.v2.FunctionSignature>({
    parse: (value) => {
      switch (value.type) {
        case \\"void\\":
          return TraceApi.v2.FunctionSignature.void(value);
        case \\"nonVoid\\":
          return TraceApi.v2.FunctionSignature.nonVoid(value);
        case \\"voidThatTakesActualResult\\":
          return TraceApi.v2.FunctionSignature.voidThatTakesActualResult(value);
        default:
          return TraceApi.v2.FunctionSignature._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace FunctionSignature {
  type Raw = FunctionSignature.Void | FunctionSignature.NonVoid | FunctionSignature.VoidThatTakesActualResult;

  interface Void extends serializers.v2.VoidFunctionSignature.Raw {
    type: \\"void\\";
  }

  interface NonVoid extends serializers.v2.NonVoidFunctionSignature.Raw {
    type: \\"nonVoid\\";
  }

  interface VoidThatTakesActualResult extends serializers.v2.VoidFunctionSignatureThatTakesActualResult.Raw {
    type: \\"voidThatTakesActualResult\\";
  }
}
",
                            "name": "FunctionSignature.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const GeneratedFiles: core.schemas.ObjectSchema<serializers.v2.GeneratedFiles.Raw, TraceApi.v2.GeneratedFiles> =
  core.schemas.object({
    generatedTestCaseFiles: core.schemas.record(
      core.schemas.lazy(async () => (await import(\\"../../../..\\")).Language),
      core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.Files)
    ),
    generatedTemplateFiles: core.schemas.record(
      core.schemas.lazy(async () => (await import(\\"../../../..\\")).Language),
      core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.Files)
    ),
    other: core.schemas.record(
      core.schemas.lazy(async () => (await import(\\"../../../..\\")).Language),
      core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.Files)
    ),
  });

export declare namespace GeneratedFiles {
  interface Raw {
    generatedTestCaseFiles: Record<serializers.Language.Raw, serializers.v2.Files.Raw>;
    generatedTemplateFiles: Record<serializers.Language.Raw, serializers.v2.Files.Raw>;
    other: Record<serializers.Language.Raw, serializers.v2.Files.Raw>;
  }
}
",
                            "name": "GeneratedFiles.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const GetBasicSolutionFileRequest: core.schemas.ObjectSchema<
  serializers.v2.GetBasicSolutionFileRequest.Raw,
  TraceApi.v2.GetBasicSolutionFileRequest
> = core.schemas.object({
  methodName: core.schemas.string(),
  signature: core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.NonVoidFunctionSignature),
});

export declare namespace GetBasicSolutionFileRequest {
  interface Raw {
    methodName: string;
    signature: serializers.v2.NonVoidFunctionSignature.Raw;
  }
}
",
                            "name": "GetBasicSolutionFileRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const GetBasicSolutionFileResponse: core.schemas.ObjectSchema<
  serializers.v2.GetBasicSolutionFileResponse.Raw,
  TraceApi.v2.GetBasicSolutionFileResponse
> = core.schemas.object({
  solutionFileByLanguage: core.schemas.record(
    core.schemas.lazy(async () => (await import(\\"../../../..\\")).Language),
    core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.FileInfoV2)
  ),
});

export declare namespace GetBasicSolutionFileResponse {
  interface Raw {
    solutionFileByLanguage: Record<serializers.Language.Raw, serializers.v2.FileInfoV2.Raw>;
  }
}
",
                            "name": "GetBasicSolutionFileResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const GetFunctionSignatureRequest: core.schemas.ObjectSchema<
  serializers.v2.GetFunctionSignatureRequest.Raw,
  TraceApi.v2.GetFunctionSignatureRequest
> = core.schemas.object({
  functionSignature: core.schemas.lazy(async () => (await import(\\"../../../..\\")).v2.FunctionSignature),
});

export declare namespace GetFunctionSignatureRequest {
  interface Raw {
    functionSignature: serializers.v2.FunctionSignature.Raw;
  }
}
",
                            "name": "GetFunctionSignatureRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const GetFunctionSignatureResponse: core.schemas.ObjectSchema<
  serializers.v2.GetFunctionSignatureResponse.Raw,
  TraceApi.v2.GetFunctionSignatureResponse
> = core.schemas.object({
  functionByLanguage: core.schemas.record(
    core.schemas.lazy(async () => (await import(\\"../../../..\\")).Language),
    core.schemas.string()
  ),
});

export declare namespace GetFunctionSignatureResponse {
  interface Raw {
    functionByLanguage: Record<serializers.Language.Raw, string>;
  }
}
",
                            "name": "GetFunctionSignatureResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const GetGeneratedTestCaseFileRequest: core.schemas.ObjectSchema<
  serializers.v2.GetGeneratedTestCaseFileRequest.Raw,
  TraceApi.v2.GetGeneratedTestCaseFileRequest
> = core.schemas.object({
  template: core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.TestCaseTemplate).optional(),
  testCase: core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.TestCaseV2),
});

export declare namespace GetGeneratedTestCaseFileRequest {
  interface Raw {
    template?: serializers.v2.TestCaseTemplate.Raw | null;
    testCase: serializers.v2.TestCaseV2.Raw;
  }
}
",
                            "name": "GetGeneratedTestCaseFileRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const GetGeneratedTestCaseTemplateFileRequest: core.schemas.ObjectSchema<
  serializers.v2.GetGeneratedTestCaseTemplateFileRequest.Raw,
  TraceApi.v2.GetGeneratedTestCaseTemplateFileRequest
> = core.schemas.object({
  template: core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.TestCaseTemplate),
});

export declare namespace GetGeneratedTestCaseTemplateFileRequest {
  interface Raw {
    template: serializers.v2.TestCaseTemplate.Raw;
  }
}
",
                            "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const LightweightProblemInfoV2: core.schemas.ObjectSchema<
  serializers.v2.LightweightProblemInfoV2.Raw,
  TraceApi.v2.LightweightProblemInfoV2
> = core.schemas.object({
  problemId: core.schemas.lazy(async () => (await import(\\"../../../..\\")).ProblemId),
  problemName: core.schemas.string(),
  problemVersion: core.schemas.number(),
  variableTypes: core.schemas.list(core.schemas.lazy(async () => (await import(\\"../../../..\\")).VariableType)),
});

export declare namespace LightweightProblemInfoV2 {
  interface Raw {
    problemId: serializers.ProblemId.Raw;
    problemName: string;
    problemVersion: number;
    variableTypes: serializers.VariableType.Raw[];
  }
}
",
                            "name": "LightweightProblemInfoV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const NonVoidFunctionDefinition: core.schemas.ObjectSchema<
  serializers.v2.NonVoidFunctionDefinition.Raw,
  TraceApi.v2.NonVoidFunctionDefinition
> = core.schemas.object({
  signature: core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.NonVoidFunctionSignature),
  code: core.schemas.lazyObject(
    async () => (await import(\\"../../../..\\")).v2.FunctionImplementationForMultipleLanguages
  ),
});

export declare namespace NonVoidFunctionDefinition {
  interface Raw {
    signature: serializers.v2.NonVoidFunctionSignature.Raw;
    code: serializers.v2.FunctionImplementationForMultipleLanguages.Raw;
  }
}
",
                            "name": "NonVoidFunctionDefinition.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const NonVoidFunctionSignature: core.schemas.ObjectSchema<
  serializers.v2.NonVoidFunctionSignature.Raw,
  TraceApi.v2.NonVoidFunctionSignature
> = core.schemas.object({
  parameters: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.Parameter)),
  returnType: core.schemas.lazy(async () => (await import(\\"../../../..\\")).VariableType),
});

export declare namespace NonVoidFunctionSignature {
  interface Raw {
    parameters: serializers.v2.Parameter.Raw[];
    returnType: serializers.VariableType.Raw;
  }
}
",
                            "name": "NonVoidFunctionSignature.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const Parameter: core.schemas.ObjectSchema<serializers.v2.Parameter.Raw, TraceApi.v2.Parameter> =
  core.schemas.object({
    parameterId: core.schemas.lazy(async () => (await import(\\"../../../..\\")).v2.ParameterId),
    name: core.schemas.string(),
    variableType: core.schemas.lazy(async () => (await import(\\"../../../..\\")).VariableType),
  });

export declare namespace Parameter {
  interface Raw {
    parameterId: serializers.v2.ParameterId.Raw;
    name: string;
    variableType: serializers.VariableType.Raw;
  }
}
",
                            "name": "Parameter.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const ParameterId: core.schemas.Schema<serializers.v2.ParameterId.Raw, TraceApi.v2.ParameterId> = core.schemas
  .string()
  .transform({
    parse: TraceApi.v2.ParameterId,
    json: (value) => value,
  });

export declare namespace ParameterId {
  type Raw = string;
}
",
                            "name": "ParameterId.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const ProblemInfoV2: core.schemas.ObjectSchema<serializers.v2.ProblemInfoV2.Raw, TraceApi.v2.ProblemInfoV2> =
  core.schemas.object({
    problemId: core.schemas.lazy(async () => (await import(\\"../../../..\\")).ProblemId),
    problemDescription: core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).ProblemDescription),
    problemName: core.schemas.string(),
    problemVersion: core.schemas.number(),
    supportedLanguages: core.schemas.list(core.schemas.lazy(async () => (await import(\\"../../../..\\")).Language)),
    customFiles: core.schemas.lazy(async () => (await import(\\"../../../..\\")).v2.CustomFiles),
    generatedFiles: core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.GeneratedFiles),
    customTestCaseTemplates: core.schemas.list(
      core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.TestCaseTemplate)
    ),
    testcases: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.TestCaseV2)),
    isPublic: core.schemas.boolean(),
  });

export declare namespace ProblemInfoV2 {
  interface Raw {
    problemId: serializers.ProblemId.Raw;
    problemDescription: serializers.ProblemDescription.Raw;
    problemName: string;
    problemVersion: number;
    supportedLanguages: serializers.Language.Raw[];
    customFiles: serializers.v2.CustomFiles.Raw;
    generatedFiles: serializers.v2.GeneratedFiles.Raw;
    customTestCaseTemplates: serializers.v2.TestCaseTemplate.Raw[];
    testcases: serializers.v2.TestCaseV2.Raw[];
    isPublic: boolean;
  }
}
",
                            "name": "ProblemInfoV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const TestCaseExpects: core.schemas.ObjectSchema<
  serializers.v2.TestCaseExpects.Raw,
  TraceApi.v2.TestCaseExpects
> = core.schemas.object({
  expectedStdout: core.schemas.string().optional(),
});

export declare namespace TestCaseExpects {
  interface Raw {
    expectedStdout?: string | null;
  }
}
",
                            "name": "TestCaseExpects.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const TestCaseFunction: core.schemas.Schema<serializers.v2.TestCaseFunction.Raw, TraceApi.v2.TestCaseFunction> =
  core.schemas
    .union(\\"type\\", {
      withActualResult: core.schemas.lazyObject(
        async () => (await import(\\"../../../..\\")).v2.TestCaseWithActualResultImplementation
      ),
      custom: core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.VoidFunctionDefinition),
    })
    .transform<TraceApi.v2.TestCaseFunction>({
      parse: (value) => {
        switch (value.type) {
          case \\"withActualResult\\":
            return TraceApi.v2.TestCaseFunction.withActualResult(value);
          case \\"custom\\":
            return TraceApi.v2.TestCaseFunction.custom(value);
          default:
            return TraceApi.v2.TestCaseFunction._unknown(value);
        }
      },
      json: (value) => value as any,
    });

export declare namespace TestCaseFunction {
  type Raw = TestCaseFunction.WithActualResult | TestCaseFunction.Custom;

  interface WithActualResult extends serializers.v2.TestCaseWithActualResultImplementation.Raw {
    type: \\"withActualResult\\";
  }

  interface Custom extends serializers.v2.VoidFunctionDefinition.Raw {
    type: \\"custom\\";
  }
}
",
                            "name": "TestCaseFunction.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const TestCaseId: core.schemas.Schema<serializers.v2.TestCaseId.Raw, TraceApi.v2.TestCaseId> = core.schemas
  .string()
  .transform({
    parse: TraceApi.v2.TestCaseId,
    json: (value) => value,
  });

export declare namespace TestCaseId {
  type Raw = string;
}
",
                            "name": "TestCaseId.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const TestCaseImplementation: core.schemas.ObjectSchema<
  serializers.v2.TestCaseImplementation.Raw,
  TraceApi.v2.TestCaseImplementation
> = core.schemas.object({
  description: core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.TestCaseImplementationDescription),
  function: core.schemas.lazy(async () => (await import(\\"../../../..\\")).v2.TestCaseFunction),
});

export declare namespace TestCaseImplementation {
  interface Raw {
    description: serializers.v2.TestCaseImplementationDescription.Raw;
    function: serializers.v2.TestCaseFunction.Raw;
  }
}
",
                            "name": "TestCaseImplementation.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const TestCaseImplementationDescription: core.schemas.ObjectSchema<
  serializers.v2.TestCaseImplementationDescription.Raw,
  TraceApi.v2.TestCaseImplementationDescription
> = core.schemas.object({
  boards: core.schemas.list(
    core.schemas.lazy(async () => (await import(\\"../../../..\\")).v2.TestCaseImplementationDescriptionBoard)
  ),
});

export declare namespace TestCaseImplementationDescription {
  interface Raw {
    boards: serializers.v2.TestCaseImplementationDescriptionBoard.Raw[];
  }
}
",
                            "name": "TestCaseImplementationDescription.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const TestCaseImplementationDescriptionBoard: core.schemas.Schema<
  serializers.v2.TestCaseImplementationDescriptionBoard.Raw,
  TraceApi.v2.TestCaseImplementationDescriptionBoard
> = core.schemas
  .union(\\"type\\", {
    html: core.schemas.object({
      value: core.schemas.string(),
    }),
    paramId: core.schemas.object({
      value: core.schemas.lazy(async () => (await import(\\"../../../..\\")).v2.ParameterId),
    }),
  })
  .transform<TraceApi.v2.TestCaseImplementationDescriptionBoard>({
    parse: (value) => {
      switch (value.type) {
        case \\"html\\":
          return TraceApi.v2.TestCaseImplementationDescriptionBoard.html(value.value);
        case \\"paramId\\":
          return TraceApi.v2.TestCaseImplementationDescriptionBoard.paramId(value.value);
        default:
          return TraceApi.v2.TestCaseImplementationDescriptionBoard._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestCaseImplementationDescriptionBoard {
  type Raw = TestCaseImplementationDescriptionBoard.Html | TestCaseImplementationDescriptionBoard.ParamId;

  interface Html {
    type: \\"html\\";
    value: string;
  }

  interface ParamId {
    type: \\"paramId\\";
    value: serializers.v2.ParameterId.Raw;
  }
}
",
                            "name": "TestCaseImplementationDescriptionBoard.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const TestCaseImplementationReference: core.schemas.Schema<
  serializers.v2.TestCaseImplementationReference.Raw,
  TraceApi.v2.TestCaseImplementationReference
> = core.schemas
  .union(\\"type\\", {
    templateId: core.schemas.object({
      value: core.schemas.lazy(async () => (await import(\\"../../../..\\")).v2.TestCaseTemplateId),
    }),
    implementation: core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.TestCaseImplementation),
  })
  .transform<TraceApi.v2.TestCaseImplementationReference>({
    parse: (value) => {
      switch (value.type) {
        case \\"templateId\\":
          return TraceApi.v2.TestCaseImplementationReference.templateId(value.value);
        case \\"implementation\\":
          return TraceApi.v2.TestCaseImplementationReference.implementation(value);
        default:
          return TraceApi.v2.TestCaseImplementationReference._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestCaseImplementationReference {
  type Raw = TestCaseImplementationReference.TemplateId | TestCaseImplementationReference.Implementation;

  interface TemplateId {
    type: \\"templateId\\";
    value: serializers.v2.TestCaseTemplateId.Raw;
  }

  interface Implementation extends serializers.v2.TestCaseImplementation.Raw {
    type: \\"implementation\\";
  }
}
",
                            "name": "TestCaseImplementationReference.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const TestCaseMetadata: core.schemas.ObjectSchema<
  serializers.v2.TestCaseMetadata.Raw,
  TraceApi.v2.TestCaseMetadata
> = core.schemas.object({
  id: core.schemas.lazy(async () => (await import(\\"../../../..\\")).v2.TestCaseId),
  name: core.schemas.string(),
  hidden: core.schemas.boolean(),
});

export declare namespace TestCaseMetadata {
  interface Raw {
    id: serializers.v2.TestCaseId.Raw;
    name: string;
    hidden: boolean;
  }
}
",
                            "name": "TestCaseMetadata.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const TestCaseTemplate: core.schemas.ObjectSchema<
  serializers.v2.TestCaseTemplate.Raw,
  TraceApi.v2.TestCaseTemplate
> = core.schemas.object({
  templateId: core.schemas.lazy(async () => (await import(\\"../../../..\\")).v2.TestCaseTemplateId),
  name: core.schemas.string(),
  implementation: core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.TestCaseImplementation),
});

export declare namespace TestCaseTemplate {
  interface Raw {
    templateId: serializers.v2.TestCaseTemplateId.Raw;
    name: string;
    implementation: serializers.v2.TestCaseImplementation.Raw;
  }
}
",
                            "name": "TestCaseTemplate.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const TestCaseTemplateId: core.schemas.Schema<
  serializers.v2.TestCaseTemplateId.Raw,
  TraceApi.v2.TestCaseTemplateId
> = core.schemas.string().transform({
  parse: TraceApi.v2.TestCaseTemplateId,
  json: (value) => value,
});

export declare namespace TestCaseTemplateId {
  type Raw = string;
}
",
                            "name": "TestCaseTemplateId.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const TestCaseV2: core.schemas.ObjectSchema<serializers.v2.TestCaseV2.Raw, TraceApi.v2.TestCaseV2> =
  core.schemas.object({
    metadata: core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.TestCaseMetadata),
    implementation: core.schemas.lazy(async () => (await import(\\"../../../..\\")).v2.TestCaseImplementationReference),
    arguments: core.schemas.record(
      core.schemas.lazy(async () => (await import(\\"../../../..\\")).v2.ParameterId),
      core.schemas.lazy(async () => (await import(\\"../../../..\\")).VariableValue)
    ),
    expects: core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.TestCaseExpects).optional(),
  });

export declare namespace TestCaseV2 {
  interface Raw {
    metadata: serializers.v2.TestCaseMetadata.Raw;
    implementation: serializers.v2.TestCaseImplementationReference.Raw;
    arguments: Record<serializers.v2.ParameterId.Raw, serializers.VariableValue.Raw>;
    expects?: serializers.v2.TestCaseExpects.Raw | null;
  }
}
",
                            "name": "TestCaseV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const TestCaseWithActualResultImplementation: core.schemas.ObjectSchema<
  serializers.v2.TestCaseWithActualResultImplementation.Raw,
  TraceApi.v2.TestCaseWithActualResultImplementation
> = core.schemas.object({
  getActualResult: core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.NonVoidFunctionDefinition),
  assertCorrectnessCheck: core.schemas.lazy(async () => (await import(\\"../../../..\\")).v2.AssertCorrectnessCheck),
});

export declare namespace TestCaseWithActualResultImplementation {
  interface Raw {
    getActualResult: serializers.v2.NonVoidFunctionDefinition.Raw;
    assertCorrectnessCheck: serializers.v2.AssertCorrectnessCheck.Raw;
  }
}
",
                            "name": "TestCaseWithActualResultImplementation.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const VoidFunctionDefinition: core.schemas.ObjectSchema<
  serializers.v2.VoidFunctionDefinition.Raw,
  TraceApi.v2.VoidFunctionDefinition
> = core.schemas.object({
  parameters: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.Parameter)),
  code: core.schemas.lazyObject(
    async () => (await import(\\"../../../..\\")).v2.FunctionImplementationForMultipleLanguages
  ),
});

export declare namespace VoidFunctionDefinition {
  interface Raw {
    parameters: serializers.v2.Parameter.Raw[];
    code: serializers.v2.FunctionImplementationForMultipleLanguages.Raw;
  }
}
",
                            "name": "VoidFunctionDefinition.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const VoidFunctionDefinitionThatTakesActualResult: core.schemas.ObjectSchema<
  serializers.v2.VoidFunctionDefinitionThatTakesActualResult.Raw,
  TraceApi.v2.VoidFunctionDefinitionThatTakesActualResult
> = core.schemas.object({
  additionalParameters: core.schemas.list(
    core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.Parameter)
  ),
  code: core.schemas.lazyObject(
    async () => (await import(\\"../../../..\\")).v2.FunctionImplementationForMultipleLanguages
  ),
});

export declare namespace VoidFunctionDefinitionThatTakesActualResult {
  interface Raw {
    additionalParameters: serializers.v2.Parameter.Raw[];
    code: serializers.v2.FunctionImplementationForMultipleLanguages.Raw;
  }
}
",
                            "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const VoidFunctionSignature: core.schemas.ObjectSchema<
  serializers.v2.VoidFunctionSignature.Raw,
  TraceApi.v2.VoidFunctionSignature
> = core.schemas.object({
  parameters: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.Parameter)),
});

export declare namespace VoidFunctionSignature {
  interface Raw {
    parameters: serializers.v2.Parameter.Raw[];
  }
}
",
                            "name": "VoidFunctionSignature.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../core\\";

export const VoidFunctionSignatureThatTakesActualResult: core.schemas.ObjectSchema<
  serializers.v2.VoidFunctionSignatureThatTakesActualResult.Raw,
  TraceApi.v2.VoidFunctionSignatureThatTakesActualResult
> = core.schemas.object({
  parameters: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../../../..\\")).v2.Parameter)),
  actualResultType: core.schemas.lazy(async () => (await import(\\"../../../..\\")).VariableType),
});

export declare namespace VoidFunctionSignatureThatTakesActualResult {
  interface Raw {
    parameters: serializers.v2.Parameter.Raw[];
    actualResultType: serializers.VariableType.Raw;
  }
}
",
                            "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "types",
                        "type": "directory",
                      },
                    ],
                    "name": "problem",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export * from \\"./resources\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": Array [
                              Object {
                                "contents": Array [
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const Response: core.schemas.Schema<
  serializers.v2.v3.problem.getLatestProblem.Response.Raw,
  TraceApi.v2.v3.ProblemInfoV2
> = core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.ProblemInfoV2);

export declare namespace Response {
  type Raw = serializers.v2.v3.ProblemInfoV2.Raw;
}
",
                                    "name": "getLatestProblem.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const Response: core.schemas.Schema<
  serializers.v2.v3.problem.getLightweightProblems.Response.Raw,
  TraceApi.v2.v3.LightweightProblemInfoV2[]
> = core.schemas.list(
  core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.LightweightProblemInfoV2)
);

export declare namespace Response {
  type Raw = serializers.v2.v3.LightweightProblemInfoV2.Raw[];
}
",
                                    "name": "getLightweightProblems.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const Response: core.schemas.Schema<
  serializers.v2.v3.problem.getProblemVersion.Response.Raw,
  TraceApi.v2.v3.ProblemInfoV2
> = core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.ProblemInfoV2);

export declare namespace Response {
  type Raw = serializers.v2.v3.ProblemInfoV2.Raw;
}
",
                                    "name": "getProblemVersion.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const Response: core.schemas.Schema<
  serializers.v2.v3.problem.getProblems.Response.Raw,
  TraceApi.v2.v3.ProblemInfoV2[]
> = core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.ProblemInfoV2));

export declare namespace Response {
  type Raw = serializers.v2.v3.ProblemInfoV2.Raw[];
}
",
                                    "name": "getProblems.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
export * as getLatestProblem from \\"./getLatestProblem\\";
export * as getProblemVersion from \\"./getProblemVersion\\";
",
                                    "name": "index.ts",
                                    "type": "file",
                                  },
                                ],
                                "name": "client",
                                "type": "directory",
                              },
                              Object {
                                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                                "name": "index.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": Array [
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const AssertCorrectnessCheck: core.schemas.Schema<
  serializers.v2.v3.AssertCorrectnessCheck.Raw,
  TraceApi.v2.v3.AssertCorrectnessCheck
> = core.schemas
  .union(\\"type\\", {
    deepEquality: core.schemas.lazyObject(
      async () => (await import(\\"../../../../../..\\")).v2.v3.DeepEqualityCorrectnessCheck
    ),
    custom: core.schemas.lazyObject(
      async () => (await import(\\"../../../../../..\\")).v2.v3.VoidFunctionDefinitionThatTakesActualResult
    ),
  })
  .transform<TraceApi.v2.v3.AssertCorrectnessCheck>({
    parse: (value) => {
      switch (value.type) {
        case \\"deepEquality\\":
          return TraceApi.v2.v3.AssertCorrectnessCheck.deepEquality(value);
        case \\"custom\\":
          return TraceApi.v2.v3.AssertCorrectnessCheck.custom(value);
        default:
          return TraceApi.v2.v3.AssertCorrectnessCheck._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace AssertCorrectnessCheck {
  type Raw = AssertCorrectnessCheck.DeepEquality | AssertCorrectnessCheck.Custom;

  interface DeepEquality extends serializers.v2.v3.DeepEqualityCorrectnessCheck.Raw {
    type: \\"deepEquality\\";
  }

  interface Custom extends serializers.v2.v3.VoidFunctionDefinitionThatTakesActualResult.Raw {
    type: \\"custom\\";
  }
}
",
                                    "name": "AssertCorrectnessCheck.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const BasicCustomFiles: core.schemas.ObjectSchema<
  serializers.v2.v3.BasicCustomFiles.Raw,
  TraceApi.v2.v3.BasicCustomFiles
> = core.schemas.object({
  methodName: core.schemas.string(),
  signature: core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.NonVoidFunctionSignature),
  additionalFiles: core.schemas.record(
    core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).Language),
    core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.Files)
  ),
  basicTestCaseTemplate: core.schemas.lazyObject(
    async () => (await import(\\"../../../../../..\\")).v2.v3.BasicTestCaseTemplate
  ),
});

export declare namespace BasicCustomFiles {
  interface Raw {
    methodName: string;
    signature: serializers.v2.v3.NonVoidFunctionSignature.Raw;
    additionalFiles: Record<serializers.Language.Raw, serializers.v2.v3.Files.Raw>;
    basicTestCaseTemplate: serializers.v2.v3.BasicTestCaseTemplate.Raw;
  }
}
",
                                    "name": "BasicCustomFiles.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const BasicTestCaseTemplate: core.schemas.ObjectSchema<
  serializers.v2.v3.BasicTestCaseTemplate.Raw,
  TraceApi.v2.v3.BasicTestCaseTemplate
> = core.schemas.object({
  templateId: core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).v2.v3.TestCaseTemplateId),
  name: core.schemas.string(),
  description: core.schemas.lazyObject(
    async () => (await import(\\"../../../../../..\\")).v2.v3.TestCaseImplementationDescription
  ),
  expectedValueParameterId: core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).v2.v3.ParameterId),
});

export declare namespace BasicTestCaseTemplate {
  interface Raw {
    templateId: serializers.v2.v3.TestCaseTemplateId.Raw;
    name: string;
    description: serializers.v2.v3.TestCaseImplementationDescription.Raw;
    expectedValueParameterId: serializers.v2.v3.ParameterId.Raw;
  }
}
",
                                    "name": "BasicTestCaseTemplate.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const CreateProblemRequestV2: core.schemas.ObjectSchema<
  serializers.v2.v3.CreateProblemRequestV2.Raw,
  TraceApi.v2.v3.CreateProblemRequestV2
> = core.schemas.object({
  problemName: core.schemas.string(),
  problemDescription: core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).ProblemDescription),
  customFiles: core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).v2.v3.CustomFiles),
  customTestCaseTemplates: core.schemas.list(
    core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.TestCaseTemplate)
  ),
  testcases: core.schemas.list(
    core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.TestCaseV2)
  ),
  supportedLanguages: core.schemas.list(core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).Language)),
  isPublic: core.schemas.boolean(),
});

export declare namespace CreateProblemRequestV2 {
  interface Raw {
    problemName: string;
    problemDescription: serializers.ProblemDescription.Raw;
    customFiles: serializers.v2.v3.CustomFiles.Raw;
    customTestCaseTemplates: serializers.v2.v3.TestCaseTemplate.Raw[];
    testcases: serializers.v2.v3.TestCaseV2.Raw[];
    supportedLanguages: serializers.Language.Raw[];
    isPublic: boolean;
  }
}
",
                                    "name": "CreateProblemRequestV2.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const CustomFiles: core.schemas.Schema<serializers.v2.v3.CustomFiles.Raw, TraceApi.v2.v3.CustomFiles> =
  core.schemas
    .union(\\"type\\", {
      basic: core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.BasicCustomFiles),
      custom: core.schemas.object({
        value: core.schemas.record(
          core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).Language),
          core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.Files)
        ),
      }),
    })
    .transform<TraceApi.v2.v3.CustomFiles>({
      parse: (value) => {
        switch (value.type) {
          case \\"basic\\":
            return TraceApi.v2.v3.CustomFiles.basic(value);
          case \\"custom\\":
            return TraceApi.v2.v3.CustomFiles.custom(value.value);
          default:
            return TraceApi.v2.v3.CustomFiles._unknown(value);
        }
      },
      json: (value) => value as any,
    });

export declare namespace CustomFiles {
  type Raw = CustomFiles.Basic | CustomFiles.Custom;

  interface Basic extends serializers.v2.v3.BasicCustomFiles.Raw {
    type: \\"basic\\";
  }

  interface Custom {
    type: \\"custom\\";
    value: Record<serializers.Language.Raw, serializers.v2.v3.Files.Raw>;
  }
}
",
                                    "name": "CustomFiles.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const DeepEqualityCorrectnessCheck: core.schemas.ObjectSchema<
  serializers.v2.v3.DeepEqualityCorrectnessCheck.Raw,
  TraceApi.v2.v3.DeepEqualityCorrectnessCheck
> = core.schemas.object({
  expectedValueParameterId: core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).v2.v3.ParameterId),
});

export declare namespace DeepEqualityCorrectnessCheck {
  interface Raw {
    expectedValueParameterId: serializers.v2.v3.ParameterId.Raw;
  }
}
",
                                    "name": "DeepEqualityCorrectnessCheck.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const DefaultProvidedFile: core.schemas.ObjectSchema<
  serializers.v2.v3.DefaultProvidedFile.Raw,
  TraceApi.v2.v3.DefaultProvidedFile
> = core.schemas.object({
  file: core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.FileInfoV2),
  relatedTypes: core.schemas.list(core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).VariableType)),
});

export declare namespace DefaultProvidedFile {
  interface Raw {
    file: serializers.v2.v3.FileInfoV2.Raw;
    relatedTypes: serializers.VariableType.Raw[];
  }
}
",
                                    "name": "DefaultProvidedFile.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const FileInfoV2: core.schemas.ObjectSchema<serializers.v2.v3.FileInfoV2.Raw, TraceApi.v2.v3.FileInfoV2> =
  core.schemas.object({
    filename: core.schemas.string(),
    directory: core.schemas.string(),
    contents: core.schemas.string(),
    editable: core.schemas.boolean(),
  });

export declare namespace FileInfoV2 {
  interface Raw {
    filename: string;
    directory: string;
    contents: string;
    editable: boolean;
  }
}
",
                                    "name": "FileInfoV2.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const Files: core.schemas.ObjectSchema<serializers.v2.v3.Files.Raw, TraceApi.v2.v3.Files> = core.schemas.object({
  files: core.schemas.list(core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.FileInfoV2)),
});

export declare namespace Files {
  interface Raw {
    files: serializers.v2.v3.FileInfoV2.Raw[];
  }
}
",
                                    "name": "Files.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const FunctionImplementation: core.schemas.ObjectSchema<
  serializers.v2.v3.FunctionImplementation.Raw,
  TraceApi.v2.v3.FunctionImplementation
> = core.schemas.object({
  impl: core.schemas.string(),
  imports: core.schemas.string().optional(),
});

export declare namespace FunctionImplementation {
  interface Raw {
    impl: string;
    imports?: string | null;
  }
}
",
                                    "name": "FunctionImplementation.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const FunctionImplementationForMultipleLanguages: core.schemas.ObjectSchema<
  serializers.v2.v3.FunctionImplementationForMultipleLanguages.Raw,
  TraceApi.v2.v3.FunctionImplementationForMultipleLanguages
> = core.schemas.object({
  codeByLanguage: core.schemas.record(
    core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).Language),
    core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.FunctionImplementation)
  ),
});

export declare namespace FunctionImplementationForMultipleLanguages {
  interface Raw {
    codeByLanguage: Record<serializers.Language.Raw, serializers.v2.v3.FunctionImplementation.Raw>;
  }
}
",
                                    "name": "FunctionImplementationForMultipleLanguages.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const FunctionSignature: core.schemas.Schema<
  serializers.v2.v3.FunctionSignature.Raw,
  TraceApi.v2.v3.FunctionSignature
> = core.schemas
  .union(\\"type\\", {
    void: core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.VoidFunctionSignature),
    nonVoid: core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.NonVoidFunctionSignature),
    voidThatTakesActualResult: core.schemas.lazyObject(
      async () => (await import(\\"../../../../../..\\")).v2.v3.VoidFunctionSignatureThatTakesActualResult
    ),
  })
  .transform<TraceApi.v2.v3.FunctionSignature>({
    parse: (value) => {
      switch (value.type) {
        case \\"void\\":
          return TraceApi.v2.v3.FunctionSignature.void(value);
        case \\"nonVoid\\":
          return TraceApi.v2.v3.FunctionSignature.nonVoid(value);
        case \\"voidThatTakesActualResult\\":
          return TraceApi.v2.v3.FunctionSignature.voidThatTakesActualResult(value);
        default:
          return TraceApi.v2.v3.FunctionSignature._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace FunctionSignature {
  type Raw = FunctionSignature.Void | FunctionSignature.NonVoid | FunctionSignature.VoidThatTakesActualResult;

  interface Void extends serializers.v2.v3.VoidFunctionSignature.Raw {
    type: \\"void\\";
  }

  interface NonVoid extends serializers.v2.v3.NonVoidFunctionSignature.Raw {
    type: \\"nonVoid\\";
  }

  interface VoidThatTakesActualResult extends serializers.v2.v3.VoidFunctionSignatureThatTakesActualResult.Raw {
    type: \\"voidThatTakesActualResult\\";
  }
}
",
                                    "name": "FunctionSignature.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const GeneratedFiles: core.schemas.ObjectSchema<
  serializers.v2.v3.GeneratedFiles.Raw,
  TraceApi.v2.v3.GeneratedFiles
> = core.schemas.object({
  generatedTestCaseFiles: core.schemas.record(
    core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).Language),
    core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.Files)
  ),
  generatedTemplateFiles: core.schemas.record(
    core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).Language),
    core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.Files)
  ),
  other: core.schemas.record(
    core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).Language),
    core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.Files)
  ),
});

export declare namespace GeneratedFiles {
  interface Raw {
    generatedTestCaseFiles: Record<serializers.Language.Raw, serializers.v2.v3.Files.Raw>;
    generatedTemplateFiles: Record<serializers.Language.Raw, serializers.v2.v3.Files.Raw>;
    other: Record<serializers.Language.Raw, serializers.v2.v3.Files.Raw>;
  }
}
",
                                    "name": "GeneratedFiles.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const GetBasicSolutionFileRequest: core.schemas.ObjectSchema<
  serializers.v2.v3.GetBasicSolutionFileRequest.Raw,
  TraceApi.v2.v3.GetBasicSolutionFileRequest
> = core.schemas.object({
  methodName: core.schemas.string(),
  signature: core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.NonVoidFunctionSignature),
});

export declare namespace GetBasicSolutionFileRequest {
  interface Raw {
    methodName: string;
    signature: serializers.v2.v3.NonVoidFunctionSignature.Raw;
  }
}
",
                                    "name": "GetBasicSolutionFileRequest.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const GetBasicSolutionFileResponse: core.schemas.ObjectSchema<
  serializers.v2.v3.GetBasicSolutionFileResponse.Raw,
  TraceApi.v2.v3.GetBasicSolutionFileResponse
> = core.schemas.object({
  solutionFileByLanguage: core.schemas.record(
    core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).Language),
    core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.FileInfoV2)
  ),
});

export declare namespace GetBasicSolutionFileResponse {
  interface Raw {
    solutionFileByLanguage: Record<serializers.Language.Raw, serializers.v2.v3.FileInfoV2.Raw>;
  }
}
",
                                    "name": "GetBasicSolutionFileResponse.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const GetFunctionSignatureRequest: core.schemas.ObjectSchema<
  serializers.v2.v3.GetFunctionSignatureRequest.Raw,
  TraceApi.v2.v3.GetFunctionSignatureRequest
> = core.schemas.object({
  functionSignature: core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).v2.v3.FunctionSignature),
});

export declare namespace GetFunctionSignatureRequest {
  interface Raw {
    functionSignature: serializers.v2.v3.FunctionSignature.Raw;
  }
}
",
                                    "name": "GetFunctionSignatureRequest.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const GetFunctionSignatureResponse: core.schemas.ObjectSchema<
  serializers.v2.v3.GetFunctionSignatureResponse.Raw,
  TraceApi.v2.v3.GetFunctionSignatureResponse
> = core.schemas.object({
  functionByLanguage: core.schemas.record(
    core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).Language),
    core.schemas.string()
  ),
});

export declare namespace GetFunctionSignatureResponse {
  interface Raw {
    functionByLanguage: Record<serializers.Language.Raw, string>;
  }
}
",
                                    "name": "GetFunctionSignatureResponse.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const GetGeneratedTestCaseFileRequest: core.schemas.ObjectSchema<
  serializers.v2.v3.GetGeneratedTestCaseFileRequest.Raw,
  TraceApi.v2.v3.GetGeneratedTestCaseFileRequest
> = core.schemas.object({
  template: core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.TestCaseTemplate).optional(),
  testCase: core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.TestCaseV2),
});

export declare namespace GetGeneratedTestCaseFileRequest {
  interface Raw {
    template?: serializers.v2.v3.TestCaseTemplate.Raw | null;
    testCase: serializers.v2.v3.TestCaseV2.Raw;
  }
}
",
                                    "name": "GetGeneratedTestCaseFileRequest.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const GetGeneratedTestCaseTemplateFileRequest: core.schemas.ObjectSchema<
  serializers.v2.v3.GetGeneratedTestCaseTemplateFileRequest.Raw,
  TraceApi.v2.v3.GetGeneratedTestCaseTemplateFileRequest
> = core.schemas.object({
  template: core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.TestCaseTemplate),
});

export declare namespace GetGeneratedTestCaseTemplateFileRequest {
  interface Raw {
    template: serializers.v2.v3.TestCaseTemplate.Raw;
  }
}
",
                                    "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const LightweightProblemInfoV2: core.schemas.ObjectSchema<
  serializers.v2.v3.LightweightProblemInfoV2.Raw,
  TraceApi.v2.v3.LightweightProblemInfoV2
> = core.schemas.object({
  problemId: core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).ProblemId),
  problemName: core.schemas.string(),
  problemVersion: core.schemas.number(),
  variableTypes: core.schemas.list(core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).VariableType)),
});

export declare namespace LightweightProblemInfoV2 {
  interface Raw {
    problemId: serializers.ProblemId.Raw;
    problemName: string;
    problemVersion: number;
    variableTypes: serializers.VariableType.Raw[];
  }
}
",
                                    "name": "LightweightProblemInfoV2.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const NonVoidFunctionDefinition: core.schemas.ObjectSchema<
  serializers.v2.v3.NonVoidFunctionDefinition.Raw,
  TraceApi.v2.v3.NonVoidFunctionDefinition
> = core.schemas.object({
  signature: core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.NonVoidFunctionSignature),
  code: core.schemas.lazyObject(
    async () => (await import(\\"../../../../../..\\")).v2.v3.FunctionImplementationForMultipleLanguages
  ),
});

export declare namespace NonVoidFunctionDefinition {
  interface Raw {
    signature: serializers.v2.v3.NonVoidFunctionSignature.Raw;
    code: serializers.v2.v3.FunctionImplementationForMultipleLanguages.Raw;
  }
}
",
                                    "name": "NonVoidFunctionDefinition.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const NonVoidFunctionSignature: core.schemas.ObjectSchema<
  serializers.v2.v3.NonVoidFunctionSignature.Raw,
  TraceApi.v2.v3.NonVoidFunctionSignature
> = core.schemas.object({
  parameters: core.schemas.list(
    core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.Parameter)
  ),
  returnType: core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).VariableType),
});

export declare namespace NonVoidFunctionSignature {
  interface Raw {
    parameters: serializers.v2.v3.Parameter.Raw[];
    returnType: serializers.VariableType.Raw;
  }
}
",
                                    "name": "NonVoidFunctionSignature.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const Parameter: core.schemas.ObjectSchema<serializers.v2.v3.Parameter.Raw, TraceApi.v2.v3.Parameter> =
  core.schemas.object({
    parameterId: core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).v2.v3.ParameterId),
    name: core.schemas.string(),
    variableType: core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).VariableType),
  });

export declare namespace Parameter {
  interface Raw {
    parameterId: serializers.v2.v3.ParameterId.Raw;
    name: string;
    variableType: serializers.VariableType.Raw;
  }
}
",
                                    "name": "Parameter.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const ParameterId: core.schemas.Schema<serializers.v2.v3.ParameterId.Raw, TraceApi.v2.v3.ParameterId> =
  core.schemas.string().transform({
    parse: TraceApi.v2.v3.ParameterId,
    json: (value) => value,
  });

export declare namespace ParameterId {
  type Raw = string;
}
",
                                    "name": "ParameterId.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const ProblemInfoV2: core.schemas.ObjectSchema<
  serializers.v2.v3.ProblemInfoV2.Raw,
  TraceApi.v2.v3.ProblemInfoV2
> = core.schemas.object({
  problemId: core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).ProblemId),
  problemDescription: core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).ProblemDescription),
  problemName: core.schemas.string(),
  problemVersion: core.schemas.number(),
  supportedLanguages: core.schemas.list(core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).Language)),
  customFiles: core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).v2.v3.CustomFiles),
  generatedFiles: core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.GeneratedFiles),
  customTestCaseTemplates: core.schemas.list(
    core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.TestCaseTemplate)
  ),
  testcases: core.schemas.list(
    core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.TestCaseV2)
  ),
  isPublic: core.schemas.boolean(),
});

export declare namespace ProblemInfoV2 {
  interface Raw {
    problemId: serializers.ProblemId.Raw;
    problemDescription: serializers.ProblemDescription.Raw;
    problemName: string;
    problemVersion: number;
    supportedLanguages: serializers.Language.Raw[];
    customFiles: serializers.v2.v3.CustomFiles.Raw;
    generatedFiles: serializers.v2.v3.GeneratedFiles.Raw;
    customTestCaseTemplates: serializers.v2.v3.TestCaseTemplate.Raw[];
    testcases: serializers.v2.v3.TestCaseV2.Raw[];
    isPublic: boolean;
  }
}
",
                                    "name": "ProblemInfoV2.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const TestCaseExpects: core.schemas.ObjectSchema<
  serializers.v2.v3.TestCaseExpects.Raw,
  TraceApi.v2.v3.TestCaseExpects
> = core.schemas.object({
  expectedStdout: core.schemas.string().optional(),
});

export declare namespace TestCaseExpects {
  interface Raw {
    expectedStdout?: string | null;
  }
}
",
                                    "name": "TestCaseExpects.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const TestCaseFunction: core.schemas.Schema<
  serializers.v2.v3.TestCaseFunction.Raw,
  TraceApi.v2.v3.TestCaseFunction
> = core.schemas
  .union(\\"type\\", {
    withActualResult: core.schemas.lazyObject(
      async () => (await import(\\"../../../../../..\\")).v2.v3.TestCaseWithActualResultImplementation
    ),
    custom: core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.VoidFunctionDefinition),
  })
  .transform<TraceApi.v2.v3.TestCaseFunction>({
    parse: (value) => {
      switch (value.type) {
        case \\"withActualResult\\":
          return TraceApi.v2.v3.TestCaseFunction.withActualResult(value);
        case \\"custom\\":
          return TraceApi.v2.v3.TestCaseFunction.custom(value);
        default:
          return TraceApi.v2.v3.TestCaseFunction._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestCaseFunction {
  type Raw = TestCaseFunction.WithActualResult | TestCaseFunction.Custom;

  interface WithActualResult extends serializers.v2.v3.TestCaseWithActualResultImplementation.Raw {
    type: \\"withActualResult\\";
  }

  interface Custom extends serializers.v2.v3.VoidFunctionDefinition.Raw {
    type: \\"custom\\";
  }
}
",
                                    "name": "TestCaseFunction.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const TestCaseId: core.schemas.Schema<serializers.v2.v3.TestCaseId.Raw, TraceApi.v2.v3.TestCaseId> = core.schemas
  .string()
  .transform({
    parse: TraceApi.v2.v3.TestCaseId,
    json: (value) => value,
  });

export declare namespace TestCaseId {
  type Raw = string;
}
",
                                    "name": "TestCaseId.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const TestCaseImplementation: core.schemas.ObjectSchema<
  serializers.v2.v3.TestCaseImplementation.Raw,
  TraceApi.v2.v3.TestCaseImplementation
> = core.schemas.object({
  description: core.schemas.lazyObject(
    async () => (await import(\\"../../../../../..\\")).v2.v3.TestCaseImplementationDescription
  ),
  function: core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).v2.v3.TestCaseFunction),
});

export declare namespace TestCaseImplementation {
  interface Raw {
    description: serializers.v2.v3.TestCaseImplementationDescription.Raw;
    function: serializers.v2.v3.TestCaseFunction.Raw;
  }
}
",
                                    "name": "TestCaseImplementation.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const TestCaseImplementationDescription: core.schemas.ObjectSchema<
  serializers.v2.v3.TestCaseImplementationDescription.Raw,
  TraceApi.v2.v3.TestCaseImplementationDescription
> = core.schemas.object({
  boards: core.schemas.list(
    core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).v2.v3.TestCaseImplementationDescriptionBoard)
  ),
});

export declare namespace TestCaseImplementationDescription {
  interface Raw {
    boards: serializers.v2.v3.TestCaseImplementationDescriptionBoard.Raw[];
  }
}
",
                                    "name": "TestCaseImplementationDescription.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const TestCaseImplementationDescriptionBoard: core.schemas.Schema<
  serializers.v2.v3.TestCaseImplementationDescriptionBoard.Raw,
  TraceApi.v2.v3.TestCaseImplementationDescriptionBoard
> = core.schemas
  .union(\\"type\\", {
    html: core.schemas.object({
      value: core.schemas.string(),
    }),
    paramId: core.schemas.object({
      value: core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).v2.v3.ParameterId),
    }),
  })
  .transform<TraceApi.v2.v3.TestCaseImplementationDescriptionBoard>({
    parse: (value) => {
      switch (value.type) {
        case \\"html\\":
          return TraceApi.v2.v3.TestCaseImplementationDescriptionBoard.html(value.value);
        case \\"paramId\\":
          return TraceApi.v2.v3.TestCaseImplementationDescriptionBoard.paramId(value.value);
        default:
          return TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestCaseImplementationDescriptionBoard {
  type Raw = TestCaseImplementationDescriptionBoard.Html | TestCaseImplementationDescriptionBoard.ParamId;

  interface Html {
    type: \\"html\\";
    value: string;
  }

  interface ParamId {
    type: \\"paramId\\";
    value: serializers.v2.v3.ParameterId.Raw;
  }
}
",
                                    "name": "TestCaseImplementationDescriptionBoard.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const TestCaseImplementationReference: core.schemas.Schema<
  serializers.v2.v3.TestCaseImplementationReference.Raw,
  TraceApi.v2.v3.TestCaseImplementationReference
> = core.schemas
  .union(\\"type\\", {
    templateId: core.schemas.object({
      value: core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).v2.v3.TestCaseTemplateId),
    }),
    implementation: core.schemas.lazyObject(
      async () => (await import(\\"../../../../../..\\")).v2.v3.TestCaseImplementation
    ),
  })
  .transform<TraceApi.v2.v3.TestCaseImplementationReference>({
    parse: (value) => {
      switch (value.type) {
        case \\"templateId\\":
          return TraceApi.v2.v3.TestCaseImplementationReference.templateId(value.value);
        case \\"implementation\\":
          return TraceApi.v2.v3.TestCaseImplementationReference.implementation(value);
        default:
          return TraceApi.v2.v3.TestCaseImplementationReference._unknown(value);
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestCaseImplementationReference {
  type Raw = TestCaseImplementationReference.TemplateId | TestCaseImplementationReference.Implementation;

  interface TemplateId {
    type: \\"templateId\\";
    value: serializers.v2.v3.TestCaseTemplateId.Raw;
  }

  interface Implementation extends serializers.v2.v3.TestCaseImplementation.Raw {
    type: \\"implementation\\";
  }
}
",
                                    "name": "TestCaseImplementationReference.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const TestCaseMetadata: core.schemas.ObjectSchema<
  serializers.v2.v3.TestCaseMetadata.Raw,
  TraceApi.v2.v3.TestCaseMetadata
> = core.schemas.object({
  id: core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).v2.v3.TestCaseId),
  name: core.schemas.string(),
  hidden: core.schemas.boolean(),
});

export declare namespace TestCaseMetadata {
  interface Raw {
    id: serializers.v2.v3.TestCaseId.Raw;
    name: string;
    hidden: boolean;
  }
}
",
                                    "name": "TestCaseMetadata.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const TestCaseTemplate: core.schemas.ObjectSchema<
  serializers.v2.v3.TestCaseTemplate.Raw,
  TraceApi.v2.v3.TestCaseTemplate
> = core.schemas.object({
  templateId: core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).v2.v3.TestCaseTemplateId),
  name: core.schemas.string(),
  implementation: core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.TestCaseImplementation),
});

export declare namespace TestCaseTemplate {
  interface Raw {
    templateId: serializers.v2.v3.TestCaseTemplateId.Raw;
    name: string;
    implementation: serializers.v2.v3.TestCaseImplementation.Raw;
  }
}
",
                                    "name": "TestCaseTemplate.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const TestCaseTemplateId: core.schemas.Schema<
  serializers.v2.v3.TestCaseTemplateId.Raw,
  TraceApi.v2.v3.TestCaseTemplateId
> = core.schemas.string().transform({
  parse: TraceApi.v2.v3.TestCaseTemplateId,
  json: (value) => value,
});

export declare namespace TestCaseTemplateId {
  type Raw = string;
}
",
                                    "name": "TestCaseTemplateId.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const TestCaseV2: core.schemas.ObjectSchema<serializers.v2.v3.TestCaseV2.Raw, TraceApi.v2.v3.TestCaseV2> =
  core.schemas.object({
    metadata: core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.TestCaseMetadata),
    implementation: core.schemas.lazy(
      async () => (await import(\\"../../../../../..\\")).v2.v3.TestCaseImplementationReference
    ),
    arguments: core.schemas.record(
      core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).v2.v3.ParameterId),
      core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).VariableValue)
    ),
    expects: core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.TestCaseExpects).optional(),
  });

export declare namespace TestCaseV2 {
  interface Raw {
    metadata: serializers.v2.v3.TestCaseMetadata.Raw;
    implementation: serializers.v2.v3.TestCaseImplementationReference.Raw;
    arguments: Record<serializers.v2.v3.ParameterId.Raw, serializers.VariableValue.Raw>;
    expects?: serializers.v2.v3.TestCaseExpects.Raw | null;
  }
}
",
                                    "name": "TestCaseV2.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const TestCaseWithActualResultImplementation: core.schemas.ObjectSchema<
  serializers.v2.v3.TestCaseWithActualResultImplementation.Raw,
  TraceApi.v2.v3.TestCaseWithActualResultImplementation
> = core.schemas.object({
  getActualResult: core.schemas.lazyObject(
    async () => (await import(\\"../../../../../..\\")).v2.v3.NonVoidFunctionDefinition
  ),
  assertCorrectnessCheck: core.schemas.lazy(
    async () => (await import(\\"../../../../../..\\")).v2.v3.AssertCorrectnessCheck
  ),
});

export declare namespace TestCaseWithActualResultImplementation {
  interface Raw {
    getActualResult: serializers.v2.v3.NonVoidFunctionDefinition.Raw;
    assertCorrectnessCheck: serializers.v2.v3.AssertCorrectnessCheck.Raw;
  }
}
",
                                    "name": "TestCaseWithActualResultImplementation.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const VoidFunctionDefinition: core.schemas.ObjectSchema<
  serializers.v2.v3.VoidFunctionDefinition.Raw,
  TraceApi.v2.v3.VoidFunctionDefinition
> = core.schemas.object({
  parameters: core.schemas.list(
    core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.Parameter)
  ),
  code: core.schemas.lazyObject(
    async () => (await import(\\"../../../../../..\\")).v2.v3.FunctionImplementationForMultipleLanguages
  ),
});

export declare namespace VoidFunctionDefinition {
  interface Raw {
    parameters: serializers.v2.v3.Parameter.Raw[];
    code: serializers.v2.v3.FunctionImplementationForMultipleLanguages.Raw;
  }
}
",
                                    "name": "VoidFunctionDefinition.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const VoidFunctionDefinitionThatTakesActualResult: core.schemas.ObjectSchema<
  serializers.v2.v3.VoidFunctionDefinitionThatTakesActualResult.Raw,
  TraceApi.v2.v3.VoidFunctionDefinitionThatTakesActualResult
> = core.schemas.object({
  additionalParameters: core.schemas.list(
    core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.Parameter)
  ),
  code: core.schemas.lazyObject(
    async () => (await import(\\"../../../../../..\\")).v2.v3.FunctionImplementationForMultipleLanguages
  ),
});

export declare namespace VoidFunctionDefinitionThatTakesActualResult {
  interface Raw {
    additionalParameters: serializers.v2.v3.Parameter.Raw[];
    code: serializers.v2.v3.FunctionImplementationForMultipleLanguages.Raw;
  }
}
",
                                    "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const VoidFunctionSignature: core.schemas.ObjectSchema<
  serializers.v2.v3.VoidFunctionSignature.Raw,
  TraceApi.v2.v3.VoidFunctionSignature
> = core.schemas.object({
  parameters: core.schemas.list(
    core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.Parameter)
  ),
});

export declare namespace VoidFunctionSignature {
  interface Raw {
    parameters: serializers.v2.v3.Parameter.Raw[];
  }
}
",
                                    "name": "VoidFunctionSignature.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"@fern-trace/api-sdk\\";
import * as core from \\"../../../../../../../core\\";

export const VoidFunctionSignatureThatTakesActualResult: core.schemas.ObjectSchema<
  serializers.v2.v3.VoidFunctionSignatureThatTakesActualResult.Raw,
  TraceApi.v2.v3.VoidFunctionSignatureThatTakesActualResult
> = core.schemas.object({
  parameters: core.schemas.list(
    core.schemas.lazyObject(async () => (await import(\\"../../../../../..\\")).v2.v3.Parameter)
  ),
  actualResultType: core.schemas.lazy(async () => (await import(\\"../../../../../..\\")).VariableType),
});

export declare namespace VoidFunctionSignatureThatTakesActualResult {
  interface Raw {
    parameters: serializers.v2.v3.Parameter.Raw[];
    actualResultType: serializers.VariableType.Raw;
  }
}
",
                                    "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                                    "name": "index.ts",
                                    "type": "file",
                                  },
                                ],
                                "name": "types",
                                "type": "directory",
                              },
                            ],
                            "name": "problem",
                            "type": "directory",
                          },
                        ],
                        "name": "resources",
                        "type": "directory",
                      },
                    ],
                    "name": "v3",
                    "type": "directory",
                  },
                ],
                "name": "resources",
                "type": "directory",
              },
            ],
            "name": "v2",
            "type": "directory",
          },
        ],
        "name": "serialization",
        "type": "directory",
      },
    ],
    "name": "src",
    "type": "directory",
  },
  Object {
    "contents": "{
    \\"compilerOptions\\": {
        \\"strict\\": true,
        \\"target\\": \\"esnext\\",
        \\"module\\": \\"esnext\\",
        \\"moduleResolution\\": \\"node\\",
        \\"esModuleInterop\\": true,
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"emitDeclarationOnly\\": true,
        \\"sourceMap\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true,
        \\"outDir\\": \\".\\",
        \\"rootDir\\": \\"src\\",
        \\"baseUrl\\": \\"src\\",
        \\"paths\\": {
            \\"@fern-trace/api-sdk\\": [
                \\".\\"
            ]
        }
    },
    \\"include\\": [
        \\"src\\"
    ],
    \\"exclude\\": []
}",
    "name": "tsconfig.json",
    "type": "file",
  },
]
`;
