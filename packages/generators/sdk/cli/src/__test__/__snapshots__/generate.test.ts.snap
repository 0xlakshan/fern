// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`runGenerator nursery 1`] = `
Array [
  Object {
    "contents": Array [
      Object {
        "contents": Array [
          Object {
            "contents": "name: ci

on: [push]

jobs:
  compile:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Set up node
        uses: actions/setup-node@v3

      - name: Compile
        run: yarn && yarn build
  
  publish:
    needs: [ compile ]
    if: github.event_name == 'push' && contains(github.ref, 'refs/tags/')
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Set up node
        uses: actions/setup-node@v3

      - name: Install dependencies
        run: yarn install

      - name: Build
        run: yarn build

      - name: Publish to npm
        run: |
          npm config set //registry.npmjs.org/:_authToken \${NPM_TOKEN}
          npm publish --ignore-scripts --access restricted
        env:
          NPM_TOKEN: \${{ secrets.NPM_TOKEN }}",
            "name": "ci.yml",
            "type": "file",
          },
        ],
        "name": "workflows",
        "type": "directory",
      },
    ],
    "name": ".github",
    "type": "directory",
  },
  Object {
    "contents": "node_modules
.DS_Store
*.d.ts
*.js
*.js.map

# yarn berry
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions

# these are needed to override '*.js' above
!.yarn/patches/**
!.yarn/plugins/**
!.yarn/releases/**
!.yarn/sdks/**
!.yarn/versions/**",
    "name": ".gitignore",
    "type": "file",
  },
  Object {
    "contents": ".yarn
node_modules
.npmignore
.pnp.cjs
*.js
*.d.ts",
    "name": ".prettierignore",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "{
  \\"recommendations\\": [
    \\"arcanis.vscode-zipfs\\",
    \\"esbenp.prettier-vscode\\"
  ]
}
",
        "name": "extensions.json",
        "type": "file",
      },
      Object {
        "contents": "{
  \\"search.exclude\\": {
    \\"**/.yarn\\": true,
    \\"**/.pnp.*\\": true
  },
  \\"prettier.prettierPath\\": \\".yarn/sdks/prettier/index.js\\",
  \\"typescript.tsdk\\": \\".yarn/sdks/typescript/lib\\",
  \\"typescript.enablePromptUseWorkspaceTsdk\\": true
}
",
        "name": "settings.json",
        "type": "file",
      },
    ],
    "name": ".vscode",
    "type": "directory",
  },
  Object {
    "contents": "nodeLinker: pnp

yarnPath: .yarn/releases/yarn-3.2.4.cjs
",
    "name": ".yarnrc.yml",
    "type": "file",
  },
  Object {
    "contents": "{
    \\"name\\": \\"@fern/api\\",
    \\"version\\": \\"0.0.1\\",
    \\"private\\": true,
    \\"repository\\": \\"https://github.com/fern/api}\\",
    \\"files\\": [
        \\"core\\",
        \\"resources\\",
        \\"serialization\\",
        \\"client\\",
        \\"*.{js,js.map,d.ts}\\"
    ],
    \\"main\\": \\"./index.js\\",
    \\"types\\": \\"./index.d.ts\\",
    \\"scripts\\": {
        \\"format\\": \\"prettier --write --print-width 120 'src/**/*.ts'\\",
        \\"build\\": \\"esbuild $(find src -name '*.ts') --format=cjs --sourcemap --outdir=. && tsc\\"
    },
    \\"dependencies\\": {
        \\"@types/url-join\\": \\"4.0.1\\",
        \\"axios\\": \\"^0.27.2\\",
        \\"url-join\\": \\"4.0.1\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"esbuild\\": \\"0.14.47\\",
        \\"prettier\\": \\"2.7.1\\",
        \\"typescript\\": \\"4.6.4\\"
    },
    \\"packageManager\\": \\"yarn@3.2.4\\"
}
",
    "name": "package.json",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { Client as OwnerClient } from \\"./resources/owner/client/Client\\";
import { Client as TokenClient } from \\"./resources/token/client/Client\\";

export declare namespace FernApiClient {
  interface Options {
    environment: string;
    apiVersion: string;
  }
}

export class FernApiClient {
  constructor(private readonly options: FernApiClient.Options) {}

  #owner: OwnerClient | undefined;

  public get owner(): OwnerClient {
    return (this.#owner ??= new OwnerClient(this.options));
  }

  #token: TokenClient | undefined;

  public get token(): TokenClient {
    return (this.#token ??= new TokenClient(this.options));
  }
}
",
        "name": "Client.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "export type APIResponse<Success, Failure> = SuccessfulResponse<Success> | FailedResponse<Failure>;

export interface SuccessfulResponse<T> {
  ok: true;
  body: T;
}

export interface FailedResponse<T> {
  ok: false;
  error: T;
}
",
                "name": "APIResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import axios, { AxiosError } from \\"axios\\";
import { APIResponse } from \\"./APIResponse\\";

export interface Fetcher {
  fetch: FetchFunction;
}

export type FetchFunction = (args: Fetcher.Args) => Promise<APIResponse<unknown, Fetcher.Error>>;

export declare namespace Fetcher {
  export interface Args {
    url: string;
    method: string;
    headers?: Record<string, string | undefined>;
    queryParameters?: URLSearchParams;
    body?: unknown;
    timeoutMs?: number;
  }

  export type Error = FailedStatusCodeError | NonJsonError | TimeoutError | UnknownError;

  export interface FailedStatusCodeError {
    reason: \\"status-code\\";
    statusCode: number;
    body: unknown;
  }

  export interface NonJsonError {
    reason: \\"non-json\\";
    statusCode: number;
    rawBody: string;
  }

  export interface TimeoutError {
    reason: \\"timeout\\";
  }

  export interface UnknownError {
    reason: \\"unknown\\";
    errorMessage: string;
  }
}

export const fetcher: FetchFunction = async (args) => {
  const headers: Record<string, string> = {
    \\"Content-Type\\": \\"application/json\\",
  };

  if (args.headers != null) {
    for (const [key, value] of Object.entries(args.headers)) {
      if (value != null) {
        headers[key] = value;
      }
    }
  }

  try {
    const response = await axios({
      url: args.url,
      params: args.queryParameters,
      method: args.method,
      headers,
      data: args.body,
      validateStatus: () => true,
      transformResponse: (response) => response,
      timeout: args.timeoutMs ?? 60_000,
      transitional: {
        clarifyTimeoutError: true,
      },
    });

    let body: unknown;
    if (response.data != null) {
      try {
        body = JSON.parse(response.data) ?? undefined;
      } catch {
        return {
          ok: false,
          error: {
            reason: \\"non-json\\",
            statusCode: response.status,
            rawBody: response.data,
          },
        };
      }
    }

    if (response.status >= 200 && response.status < 300) {
      return {
        ok: true,
        body,
      };
    } else {
      return {
        ok: false,
        error: {
          reason: \\"status-code\\",
          statusCode: response.status,
          body,
        },
      };
    }
  } catch (error) {
    if ((error as AxiosError).code === \\"ETIMEDOUT\\") {
      return {
        ok: false,
        error: {
          reason: \\"timeout\\",
        },
      };
    }

    return {
      ok: false,
      error: {
        reason: \\"unknown\\",
        errorMessage: (error as AxiosError).message,
      },
    };
  }
};
",
                "name": "Fetcher.ts",
                "type": "file",
              },
              Object {
                "contents": "export type Supplier<T> = T | Promise<T> | (() => T | Promise<T>);

export const Supplier = {
  get: async <T>(supplier: Supplier<T>): Promise<T> => {
    if (typeof supplier === \\"function\\") {
      return (supplier as () => T)();
    } else {
      return supplier;
    }
  },
};
",
                "name": "Supplier.ts",
                "type": "file",
              },
              Object {
                "contents": "export { type APIResponse } from \\"./APIResponse\\";
export { fetcher, type Fetcher, type FetchFunction } from \\"./Fetcher\\";
export { Supplier } from \\"./Supplier\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "fetcher",
            "type": "directory",
          },
          Object {
            "contents": "export * as schemas from \\"./schemas\\";
export * from \\"./utils\\";
export * from \\"./fetcher\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { SchemaUtils } from \\"./builders\\";

export type Schema<Raw = unknown, Parsed = unknown> = BaseSchema<Raw, Parsed> & SchemaUtils<Raw, Parsed>;

export type inferRaw<S extends Schema> = S extends Schema<infer Raw, any> ? Raw : never;
export type inferParsed<S extends Schema> = S extends Schema<any, infer Parsed> ? Parsed : never;

export interface BaseSchema<Raw, Parsed> {
  parse: (raw: Raw, opts?: SchemaOptions) => Parsed;
  json: (parsed: Parsed, opts?: SchemaOptions) => Raw;
}

export interface SchemaOptions {
  /**
   * @default false
   */
  skipUnknownKeysOnParse?: boolean;

  /**
   * @default false
   */
  includeUnknownKeysOnJson?: boolean;
}
",
                "name": "Schema.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function date(): Schema<string, Date> {
  const baseSchema: BaseSchema<string, Date> = {
    parse: (raw) => new Date(raw),
    json: (date) => date.toISOString(),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "date.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { date } from \\"./date\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "date",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function enum_<U extends string, E extends Readonly<[U, ...U[]]>>(_values: E): Schema<E[number], E[number]> {
  return createIdentitySchemaCreator<E[number]>()();
}
",
                        "name": "enum.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { enum_ } from \\"./enum\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "enum",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { identity } from \\"./identity\\";

export function createIdentitySchemaCreator<T>(): () => Schema<T, T> {
  return <T>() => identity<T>();
}
",
                        "name": "createIdentitySchemaCreator.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function identity<T>(): Schema<T, T> {
  const baseSchema: BaseSchema<T, T> = {
    parse: (raw) => raw,
    json: (parsed) => parsed,
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "identity.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { createIdentitySchemaCreator } from \\"./createIdentitySchemaCreator\\";
export { identity } from \\"./identity\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "identity",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./date\\";
export * from \\"./enum\\";
export * from \\"./identity\\";
export * from \\"./lazy\\";
export * from \\"./list\\";
export * from \\"./literals\\";
export * from \\"./object\\";
export * from \\"./object-like\\";
export * from \\"./primitives\\";
export * from \\"./record\\";
export * from \\"./schema-utils\\";
export * from \\"./set\\";
export * from \\"./union\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { lazy } from \\"./lazy\\";
export { lazyObject } from \\"./lazyObject\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

type Getter<Raw, Parsed> = () => Schema<Raw, Parsed>;
type MemoizedGetter<Raw, Parsed> = Getter<Raw, Parsed> & { __zurg_memoized?: Schema<Raw, Parsed> };

export function lazy<Raw, Parsed>(getter: Getter<Raw, Parsed>): Schema<Raw, Parsed> {
  const baseSchema = constructLazyBaseSchema(getter);
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function constructLazyBaseSchema<Raw, Parsed>(getter: Getter<Raw, Parsed>): BaseSchema<Raw, Parsed> {
  const getSchema = () => {
    const castedGetter = getter as MemoizedGetter<Raw, Parsed>;
    if (castedGetter.__zurg_memoized == null) {
      castedGetter.__zurg_memoized = getter();
    }
    return castedGetter.__zurg_memoized;
  };

  return {
    parse: (raw) => getSchema().parse(raw),
    json: (parsed) => getSchema().json(parsed),
  };
}
",
                        "name": "lazy.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { getObjectUtils } from \\"../object\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { ObjectSchema } from \\"../object/types\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { constructLazyBaseSchema } from \\"./lazy\\";

export function lazyObject<Raw, Parsed>(getter: () => ObjectSchema<Raw, Parsed>): ObjectSchema<Raw, Parsed> {
  const baseSchema = {
    ...OBJECT_LIKE_BRAND,
    ...constructLazyBaseSchema(getter),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}
",
                        "name": "lazyObject.ts",
                        "type": "file",
                      },
                    ],
                    "name": "lazy",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { list } from \\"./list\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function list<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Parsed[]> {
  const baseSchema: BaseSchema<Raw[], Parsed[]> = {
    parse: (raw, opts) => raw.map((item) => schema.parse(item, opts)),
    json: (parsed, opts) => parsed.map((item) => schema.json(item, opts)),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "list.ts",
                        "type": "file",
                      },
                    ],
                    "name": "list",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { stringLiteral } from \\"./stringLiteral\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function stringLiteral<V extends string>(_value: V): Schema<V, V> {
  return createIdentitySchemaCreator<V>()();
}
",
                        "name": "stringLiteral.ts",
                        "type": "file",
                      },
                    ],
                    "name": "literals",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { getObjectUtils, object } from \\"./object\\";
export { isProperty, property, type Property } from \\"./property\\";
export {
  type BaseObjectSchema,
  type inferObjectSchemaFromPropertySchemas,
  type inferParsedObject,
  type inferParsedObjectFromPropertySchemas,
  type inferParsedPropertySchema,
  type inferRawKey,
  type inferRawObject,
  type inferRawObjectFromPropertySchemas,
  type inferRawPropertySchema,
  type ObjectSchema,
  type ObjectUtils,
  type PropertySchemas,
} from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { isProperty } from \\"./property\\";
import {
  BaseObjectSchema,
  inferObjectSchemaFromPropertySchemas,
  inferParsedObjectFromPropertySchemas,
  inferRawObjectFromPropertySchemas,
  ObjectSchema,
  ObjectUtils,
  PropertySchemas,
} from \\"./types\\";

interface ObjectPropertyWithRawKey {
  rawKey: string;
  parsedKey: string | number | symbol;
  valueSchema: Schema<any, any>;
}

export function object<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(
  schemas: T
): inferObjectSchemaFromPropertySchemas<T> {
  const baseSchema: BaseObjectSchema<inferRawObjectFromPropertySchemas<T>, inferParsedObjectFromPropertySchemas<T>> = {
    ...OBJECT_LIKE_BRAND,

    parse: (raw, { skipUnknownKeysOnParse = false } = {}) => {
      const rawKeyToProperty: Record<string, ObjectPropertyWithRawKey> = {};

      for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
        const rawKey = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;

        const property: ObjectPropertyWithRawKey = {
          rawKey,
          parsedKey,
          valueSchema: isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.valueSchema : schemaOrObjectProperty,
        };

        rawKeyToProperty[rawKey] = property;
      }

      const parsed: Record<string | number | symbol, any> = {};

      for (const [rawKey, rawPropertyValue] of Object.entries(raw)) {
        const property = rawKeyToProperty[rawKey];

        if (property != null) {
          const value = property.valueSchema.parse(rawPropertyValue);
          parsed[property.parsedKey] = value;
        } else if (!skipUnknownKeysOnParse && rawPropertyValue != null) {
          parsed[rawKey] = rawPropertyValue;
        }
      }

      return parsed as inferParsedObjectFromPropertySchemas<T>;
    },

    json: (parsed, { includeUnknownKeysOnJson = false } = {}) => {
      const raw: Record<string | number | symbol, any> = {};

      for (const [parsedKey, parsedPropertyValue] of entries(parsed)) {
        const schemaOrObjectProperty = schemas[parsedKey as keyof T];
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (schemaOrObjectProperty != null) {
          if (isProperty(schemaOrObjectProperty)) {
            const value = schemaOrObjectProperty.valueSchema.json(parsedPropertyValue);
            raw[schemaOrObjectProperty.rawKey] = value;
          } else {
            const value = schemaOrObjectProperty.json(parsedPropertyValue);
            raw[parsedKey] = value;
          }
        } else if (includeUnknownKeysOnJson && parsedPropertyValue != null) {
          raw[parsedKey] = parsedPropertyValue;
        }
      }

      return raw as inferRawObjectFromPropertySchemas<T>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}

export function getObjectUtils<Raw, Parsed>(schema: BaseObjectSchema<Raw, Parsed>): ObjectUtils<Raw, Parsed> {
  return {
    extend: <RawExtension, ParsedExtension>(extension: ObjectSchema<RawExtension, ParsedExtension>) => {
      const baseSchema: BaseObjectSchema<Raw & RawExtension, Parsed & ParsedExtension> = {
        ...OBJECT_LIKE_BRAND,
        parse: (raw, opts) => ({
          ...schema.parse(raw, opts),
          ...extension.parse(raw, opts),
        }),
        json: (parsed, opts) => ({
          ...schema.json(parsed, opts),
          ...extension.json(parsed, opts),
        }),
      };

      return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
      };
    },
  };
}
",
                        "name": "object.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export function property<RawKey extends string, RawValue, ParsedValue>(
  rawKey: RawKey,
  valueSchema: Schema<RawValue, ParsedValue>
): Property<RawKey, RawValue, ParsedValue> {
  return {
    rawKey,
    valueSchema,
    isProperty: true,
  };
}

export interface Property<RawKey extends string, RawValue, ParsedValue> {
  rawKey: RawKey;
  valueSchema: Schema<RawValue, ParsedValue>;
  isProperty: true;
}

export function isProperty<O extends Property<any, any, any>>(maybeProperty: unknown): maybeProperty is O {
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return (maybeProperty as O).isProperty;
}
",
                        "name": "property.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsed, inferRaw, Schema } from \\"../../Schema\\";
import { addQuestionMarksToNullableProperties } from \\"../../utils/addQuestionMarksToNullableProperties\\";
import { BaseObjectLikeSchema, ObjectLikeSchema } from \\"../object-like\\";
import { Property } from \\"./property\\";

export type ObjectSchema<Raw, Parsed> = BaseObjectSchema<Raw, Parsed> &
  ObjectLikeSchema<Raw, Parsed> &
  ObjectUtils<Raw, Parsed>;

export type BaseObjectSchema<Raw, Parsed> = BaseObjectLikeSchema<Raw, Parsed>;

export interface ObjectUtils<Raw, Parsed> {
  extend: <RawExtension, ParsedExtension>(
    schemas: ObjectSchema<RawExtension, ParsedExtension>
  ) => ObjectSchema<Raw & RawExtension, Parsed & ParsedExtension>;
}

export type inferRawObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<infer Raw, any> ? Raw : never;

export type inferParsedObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<any, infer Parsed>
  ? Parsed
  : never;

export type inferObjectSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> = ObjectSchema<
  inferRawObjectFromPropertySchemas<T>,
  inferParsedObjectFromPropertySchemas<T>
>;

export type inferRawObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
  addQuestionMarksToNullableProperties<{
    [ParsedKey in keyof T as inferRawKey<ParsedKey, T[ParsedKey]>]: inferRawPropertySchema<T[ParsedKey]>;
  }>;

export type inferParsedObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
  addQuestionMarksToNullableProperties<{
    [K in keyof T]: inferParsedPropertySchema<T[K]>;
  }>;

export type PropertySchemas<ParsedKeys extends string | number | symbol> = Record<
  ParsedKeys,
  Property<any, any, any> | Schema<any, any>
>;

export type inferRawPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
  any,
  infer Raw,
  any
>
  ? Raw
  : P extends Schema<any, any>
  ? inferRaw<P>
  : never;

export type inferParsedPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
  any,
  any,
  infer Parsed
>
  ? Parsed
  : P extends Schema<any, any>
  ? inferParsed<P>
  : never;

export type inferRawKey<
  ParsedKey extends string | number | symbol,
  P extends Property<any, any, any> | Schema<any, any>
> = P extends Property<infer Raw, any, any> ? Raw : ParsedKey;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseObjectLikeSchema, ObjectLikeUtils } from \\"./types\\";
import { withProperties } from \\"./withProperties\\";

export function getObjectLikeUtils<Raw, Parsed>(
  schema: BaseObjectLikeSchema<Raw, Parsed>
): ObjectLikeUtils<Raw, Parsed> {
  return {
    withProperties: (properties) => withProperties(schema, properties),
  };
}
",
                        "name": "getObjectLikeUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getObjectLikeUtils } from \\"./getObjectLikeUtils\\";
export { OBJECT_LIKE_BRAND, type BaseObjectLikeSchema, type ObjectLikeSchema, type ObjectLikeUtils } from \\"./types\\";
export { withProperties } from \\"./withProperties\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";

export type ObjectLikeSchema<Raw, Parsed> = Schema<Raw, Parsed> &
  BaseObjectLikeSchema<Raw, Parsed> &
  ObjectLikeUtils<Raw, Parsed>;

export type BaseObjectLikeSchema<Raw, Parsed> = BaseSchema<Raw, Parsed> & {
  _objectLike: void;
};

export interface ObjectLikeUtils<Raw, Parsed> {
  withProperties: <T extends Record<string, any>>(properties: {
    [K in keyof T]: T[K] | ((parsed: Parsed) => T[K]);
  }) => ObjectLikeSchema<Raw, Parsed & T>;
}

export const OBJECT_LIKE_BRAND = undefined as unknown as { _objectLike: void };
",
                        "name": "types.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { getSchemaUtils } from \\"../schema-utils\\";
import { getObjectLikeUtils } from \\"./getObjectLikeUtils\\";
import { BaseObjectLikeSchema, ObjectLikeSchema, OBJECT_LIKE_BRAND } from \\"./types\\";

export function withProperties<RawObjectShape, ParsedObjectShape, Properties>(
  objectLike: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape>,
  properties: { [K in keyof Properties]: Properties[K] | ((parsed: ParsedObjectShape) => Properties[K]) }
): ObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> {
  const objectSchema: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> = {
    ...OBJECT_LIKE_BRAND,
    parse: (raw, opts) => {
      const parsedObject = objectLike.parse(raw, opts);
      const additionalProperties = Object.entries(properties).reduce<Record<string, any>>((processed, [key, value]) => {
        return {
          ...processed,
          [key]: typeof value === \\"function\\" ? value(parsedObject) : value,
        };
      }, {});

      return {
        ...parsedObject,
        ...(additionalProperties as Properties),
      };
    },
    json: (parsed, opts) => {
      // strip out added properties
      const addedPropertyKeys = new Set(Object.keys(properties));
      const parsedWithoutAddedProperties = Object.entries(parsed).reduce<Record<string, any>>(
        (filtered, [key, value]) => {
          if (!addedPropertyKeys.has(key)) {
            filtered[key] = value;
          }
          return filtered;
        },
        {}
      );

      return objectLike.json(parsedWithoutAddedProperties as ParsedObjectShape, opts);
    },
  };

  return {
    ...objectSchema,
    ...getSchemaUtils(objectSchema),
    ...getObjectLikeUtils(objectSchema),
  };
}
",
                        "name": "withProperties.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object-like",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const any = createIdentitySchemaCreator<any>();
",
                        "name": "any.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const boolean = createIdentitySchemaCreator<boolean>();
",
                        "name": "boolean.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { any } from \\"./any\\";
export { boolean } from \\"./boolean\\";
export { number } from \\"./number\\";
export { string } from \\"./string\\";
export { unknown } from \\"./unknown\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const number = createIdentitySchemaCreator<number>();
",
                        "name": "number.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const string = createIdentitySchemaCreator<string>();
",
                        "name": "string.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const unknown = createIdentitySchemaCreator<unknown>();
",
                        "name": "unknown.ts",
                        "type": "file",
                      },
                    ],
                    "name": "primitives",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { record } from \\"./record\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function record<RawKey extends string | number, ParsedKey extends string | number, RawValue, ParsedValue>(
  keySchema: Schema<RawKey, ParsedKey>,
  valueSchema: Schema<RawValue, ParsedValue>
): Schema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> {
  const baseSchema: BaseSchema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> = {
    parse: (raw, opts) => {
      return entries(raw).reduce(
        (parsed, [key, value]) => {
          parsed[keySchema.parse(key, opts)] = valueSchema.parse(value, opts);
          return parsed;
        },
        // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
        {} as Record<ParsedKey, ParsedValue>
      );
    },
    json: (parsed, opts) => {
      return entries(parsed).reduce(
        (raw, [key, value]) => {
          raw[keySchema.json(key, opts)] = valueSchema.json(value, opts);
          return raw;
        },
        // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
        {} as Record<RawKey, RawValue>
      );
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "record.ts",
                        "type": "file",
                      },
                    ],
                    "name": "record",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { OptionalSchema, OPTIONAL_BRAND } from \\"./types\\";

export interface SchemaUtils<Raw, Parsed> {
  optional: () => OptionalSchema<Raw, Parsed>;
  transform: <PostTransform>(transformer: BaseSchema<Parsed, PostTransform>) => Schema<Raw, PostTransform>;
}

export function getSchemaUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): SchemaUtils<Raw, Parsed> {
  return {
    optional: () => optional(schema),
    transform: (transformer) => transform(schema, transformer),
  };
}

/**
 * schema utils are defined in one file to resolve issues with circular imports
 */

export function optional<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): OptionalSchema<Raw, Parsed> {
  const baseSchema: BaseSchema<Raw | null | undefined, Parsed | undefined> = {
    parse: (raw, opts) => (raw != null ? schema.parse(raw, opts) : undefined),
    json: (parsed, opts) => (parsed != null ? schema.json(parsed, opts) : undefined),
  };

  return {
    ...OPTIONAL_BRAND,
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function transform<PreTransformRaw, PreTransformParsed, PostTransform>(
  schema: BaseSchema<PreTransformRaw, PreTransformParsed>,
  transformer: BaseSchema<PreTransformParsed, PostTransform>
): Schema<PreTransformRaw, PostTransform> {
  const baseSchema: BaseSchema<PreTransformRaw, PostTransform> = {
    parse: (raw, opts) => {
      const postTransformParsed = schema.parse(raw, opts);
      return transformer.parse(postTransformParsed, opts);
    },
    json: (parsed, opts) => {
      const preTransformParsed = transformer.json(parsed, opts);
      return schema.json(preTransformParsed, opts);
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "getSchemaUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getSchemaUtils, optional, transform, type SchemaUtils } from \\"./getSchemaUtils\\";
export { OPTIONAL_BRAND, type OptionalSchema } from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export const OPTIONAL_BRAND = undefined as unknown as { _isOptional: void };

export type OptionalSchema<Raw, Parsed> = Schema<Raw | null | undefined, Parsed | undefined> & {
  _isOptional: void;
};
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "schema-utils",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { set } from \\"./set\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function set<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Set<Parsed>> {
  const baseSchema: BaseSchema<Raw[], Set<Parsed>> = {
    parse: (raw, opts) => new Set(raw.map((item) => schema.parse(item, opts))),
    json: (parsed, opts) => [...parsed].map((item) => schema.json(item, opts)),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "set.ts",
                        "type": "file",
                      },
                    ],
                    "name": "set",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export function discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string>(
  parsedDiscriminant: ParsedDiscriminant,
  rawDiscriminant: RawDiscriminant
): Discriminant<RawDiscriminant, ParsedDiscriminant> {
  return {
    parsedDiscriminant,
    rawDiscriminant,
  };
}

export interface Discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string> {
  parsedDiscriminant: ParsedDiscriminant;
  rawDiscriminant: RawDiscriminant;
}
",
                        "name": "discriminant.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { discriminant, type Discriminant } from \\"./discriminant\\";
export {
  type inferParsedDiscriminant,
  type inferParsedUnion,
  type inferRawDiscriminant,
  type inferRawUnion,
  type UnionSubtypes,
} from \\"./types\\";
export { union } from \\"./union\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsedObject, inferRawObject, ObjectSchema } from \\"../object\\";
import { Discriminant } from \\"./discriminant\\";

export type UnionSubtypes<DiscriminantValues extends string | number | symbol> = {
  [K in DiscriminantValues]: ObjectSchema<any, any>;
};

export type inferRawUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
  [K in keyof U]: Record<inferRawDiscriminant<D>, K> & inferRawObject<U[K]>;
}[keyof U];

export type inferParsedUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
  [K in keyof U]: Record<inferParsedDiscriminant<D>, K> & inferParsedObject<U[K]>;
}[keyof U];

export type inferRawDiscriminant<D extends string | Discriminant<any, any>> = D extends string
  ? D
  : D extends Discriminant<infer Raw, any>
  ? Raw
  : never;

export type inferParsedDiscriminant<D extends string | Discriminant<any, any>> = D extends string
  ? D
  : D extends Discriminant<any, infer Parsed>
  ? Parsed
  : never;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseObjectLikeSchema, getObjectLikeUtils, ObjectLikeSchema, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { Discriminant } from \\"./discriminant\\";
import { inferParsedDiscriminant, inferParsedUnion, inferRawDiscriminant, inferRawUnion, UnionSubtypes } from \\"./types\\";

export function union<D extends string | Discriminant<any, any>, U extends UnionSubtypes<any>>(
  discriminant: D,
  union: U
): ObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> {
  const rawDiscriminant =
    typeof discriminant === \\"string\\" ? discriminant : (discriminant.rawDiscriminant as inferRawDiscriminant<D>);
  const parsedDiscriminant =
    typeof discriminant === \\"string\\" ? discriminant : (discriminant.parsedDiscriminant as inferParsedDiscriminant<D>);

  const baseSchema: BaseObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> = {
    ...OBJECT_LIKE_BRAND,

    parse: (raw, opts) => {
      const { [rawDiscriminant]: discriminantValue, ...additionalProperties } = raw;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [parsedDiscriminant]: discriminantValue,
        } as inferParsedUnion<D, U>;
      }

      return {
        ...additionalPropertySchemas.parse(additionalProperties, opts),
        [parsedDiscriminant]: discriminantValue,
      } as inferParsedUnion<D, U>;
    },

    json: (parsed, opts) => {
      const { [parsedDiscriminant]: discriminantValue, ...additionalProperties } = parsed;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [rawDiscriminant]: discriminantValue,
        } as unknown as inferRawUnion<D, U>;
      }

      return {
        ...additionalPropertySchemas.json(additionalProperties, opts),
        [rawDiscriminant]: discriminantValue,
      } as inferRawUnion<D, U>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
  };
}
",
                        "name": "union.ts",
                        "type": "file",
                      },
                    ],
                    "name": "union",
                    "type": "directory",
                  },
                ],
                "name": "builders",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./builders\\";
export { type inferParsed, type inferRaw, type Schema, type SchemaOptions } from \\"./Schema\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export type addQuestionMarksToNullableProperties<T> = {
  [K in OptionalKeys<T>]?: undefined extends T[K] ? T[K] : never;
} & Pick<T, RequiredKeys<T>>;

export type OptionalKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? K : never;
}[keyof T];

export type RequiredKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? never : K;
}[keyof T];
",
                    "name": "addQuestionMarksToNullableProperties.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function entries<T>(object: T): [keyof T, T[keyof T]][] {
  return Object.entries(object) as [keyof T, T[keyof T]][];
}
",
                    "name": "entries.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function keys<T>(object: T): (keyof T)[] {
  return Object.keys(object) as (keyof T)[];
}
",
                    "name": "keys.ts",
                    "type": "file",
                  },
                ],
                "name": "utils",
                "type": "directory",
              },
            ],
            "name": "schemas",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export function addNonEnumerableProperty<T, K extends string, V>(object: T, key: K, value: V): T & Record<K, V> {
  const copy = { ...object };
  Object.defineProperty(copy, key, {
    enumerable: false,
    writable: true,
  });
  (copy as any)[key] = value;
  return copy as T & Record<K, V>;
}
",
                "name": "addNonEnumerableProperty.ts",
                "type": "file",
              },
              Object {
                "contents": "export { addNonEnumerableProperty } from \\"./addNonEnumerableProperty\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "utils",
            "type": "directory",
          },
        ],
        "name": "core",
        "type": "directory",
      },
      Object {
        "contents": "export * as FernApi from \\"./resources\\";
export { FernApiClient } from \\"./Client\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * as owner from \\"./owner\\";
export * from \\"./owner/types\\";
export * as token from \\"./token\\";
export * from \\"./token/types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";
import * as core from \\"../../../core\\";

export declare namespace Client {
  interface Options {
    environment: string;
    apiVersion: string;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async create(request: FernApi.CreateOwnerRequest): Promise<FernApi.owner.create.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment, \\"/owner/\\"),
      method: \\"POST\\",
      headers: {
        \\"X-API-Version\\": this.options?.apiVersion,
      },
      body: serializers.CreateOwnerRequest.json(request),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    if (response.error.reason === \\"status-code\\") {
      switch ((response.error.body as serializers.owner.create.Error.Raw)?.errorName) {
        case \\"OwnerAlreadyExistsError\\":
          return {
            ok: false,
            error: serializers.owner.create.Error.parse(response.error.body as serializers.owner.create.Error.Raw),
          };
      }
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async get(request: FernApi.owner.get.Request): Promise<FernApi.owner.get.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment, \`/owner/\${request.ownerId}\`),
      method: \\"GET\\",
      headers: {
        \\"X-API-Version\\": this.options?.apiVersion,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.Owner.parse(response.body as serializers.Owner.Raw),
      };
    }

    if (response.error.reason === \\"status-code\\") {
      switch ((response.error.body as serializers.owner.get.Error.Raw)?.errorName) {
        case \\"OwnerNotFoundError\\":
          return {
            ok: false,
            error: serializers.owner.get.Error.parse(response.error.body as serializers.owner.get.Error.Raw),
          };
      }
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async update(request: FernApi.owner.update.Request): Promise<FernApi.owner.update.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment, \`/owner/\${request.ownerId}\`),
      method: \\"PUT\\",
      headers: {
        \\"X-API-Version\\": this.options?.apiVersion,
      },
      body: serializers.UpdateOwnerRequest.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.Owner.parse(response.body as serializers.Owner.Raw),
      };
    }

    if (response.error.reason === \\"status-code\\") {
      switch ((response.error.body as serializers.owner.update.Error.Raw)?.errorName) {
        case \\"OwnerNotFoundError\\":
          return {
            ok: false,
            error: serializers.owner.update.Error.parse(response.error.body as serializers.owner.update.Error.Raw),
          };
      }
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, FernApi.owner.create.Error>;
export type Error = FernApi.owner.create.Error.OwnerAlreadyExistsError | FernApi.owner.create.Error._Unknown;

export declare namespace Error {
  interface OwnerAlreadyExistsError extends _Utils {
    errorName: \\"OwnerAlreadyExistsError\\";
  }

  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernApi.owner.create.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    ownerAlreadyExistsError: () => _Result;
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  ownerAlreadyExistsError: (): FernApi.owner.create.Error.OwnerAlreadyExistsError => {
    const valueWithoutVisit: Omit<FernApi.owner.create.Error.OwnerAlreadyExistsError, \\"_visit\\"> = {
      errorName: \\"OwnerAlreadyExistsError\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.owner.create.Error.OwnerAlreadyExistsError, visitor: FernApi.owner.create.Error._Visitor<_Result>) {
      return FernApi.owner.create.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: FernApi.owner.create.Error,
    visitor: FernApi.owner.create.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      case \\"OwnerAlreadyExistsError\\":
        return visitor.ownerAlreadyExistsError();
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "create.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  ownerId: FernApi.OwnerId;
}

export type Response = core.APIResponse<FernApi.Owner, FernApi.owner.get.Error>;
export type Error = FernApi.owner.get.Error.OwnerNotFoundError | FernApi.owner.get.Error._Unknown;

export declare namespace Error {
  interface OwnerNotFoundError extends _Utils {
    errorName: \\"OwnerNotFoundError\\";
  }

  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernApi.owner.get.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    ownerNotFoundError: () => _Result;
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  ownerNotFoundError: (): FernApi.owner.get.Error.OwnerNotFoundError => {
    const valueWithoutVisit: Omit<FernApi.owner.get.Error.OwnerNotFoundError, \\"_visit\\"> = {
      errorName: \\"OwnerNotFoundError\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.owner.get.Error.OwnerNotFoundError, visitor: FernApi.owner.get.Error._Visitor<_Result>) {
      return FernApi.owner.get.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(value: FernApi.owner.get.Error, visitor: FernApi.owner.get.Error._Visitor<_Result>): _Result => {
    switch (value.errorName) {
      case \\"OwnerNotFoundError\\":
        return visitor.ownerNotFoundError();
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "get.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as create from \\"./create\\";
export * as get from \\"./get\\";
export * as update from \\"./update\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  ownerId: FernApi.OwnerId;
  _body: FernApi.UpdateOwnerRequest;
}

export type Response = core.APIResponse<FernApi.Owner, FernApi.owner.update.Error>;
export type Error = FernApi.owner.update.Error.OwnerNotFoundError | FernApi.owner.update.Error._Unknown;

export declare namespace Error {
  interface OwnerNotFoundError extends _Utils {
    errorName: \\"OwnerNotFoundError\\";
  }

  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernApi.owner.update.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    ownerNotFoundError: () => _Result;
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  ownerNotFoundError: (): FernApi.owner.update.Error.OwnerNotFoundError => {
    const valueWithoutVisit: Omit<FernApi.owner.update.Error.OwnerNotFoundError, \\"_visit\\"> = {
      errorName: \\"OwnerNotFoundError\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.owner.update.Error.OwnerNotFoundError, visitor: FernApi.owner.update.Error._Visitor<_Result>) {
      return FernApi.owner.update.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: FernApi.owner.update.Error,
    visitor: FernApi.owner.update.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      case \\"OwnerNotFoundError\\":
        return visitor.ownerNotFoundError();
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "update.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";

export interface CreateOwnerRequest {
  ownerId: FernApi.OwnerId;
  data?: unknown;
}
",
                    "name": "CreateOwnerRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";

export interface Owner {
  ownerId: FernApi.OwnerId;
  data?: unknown;
}
",
                    "name": "Owner.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";

/**
 * Unique id for an owner.
 */
export type OwnerId = string;

export const OwnerId = {
  create: (value: string) => value as unknown as FernApi.OwnerId,
} as const;
",
                    "name": "OwnerId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface UpdateOwnerRequest {
  data?: unknown;
}
",
                    "name": "UpdateOwnerRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./OwnerId\\";
export * from \\"./CreateOwnerRequest\\";
export * from \\"./UpdateOwnerRequest\\";
export * from \\"./Owner\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "owner",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";
import * as core from \\"../../../core\\";

export declare namespace Client {
  interface Options {
    environment: string;
    apiVersion: string;
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async create(request: FernApi.CreateTokenRequest): Promise<FernApi.token.create.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment, \\"/tokens/create\\"),
      method: \\"POST\\",
      headers: {
        \\"X-API-Version\\": this.options?.apiVersion,
      },
      body: serializers.CreateTokenRequest.json(request),
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.CreateTokenResponse.parse(response.body as serializers.CreateTokenResponse.Raw),
      };
    }

    if (response.error.reason === \\"status-code\\") {
      switch ((response.error.body as serializers.token.create.Error.Raw)?.errorName) {
        case \\"OwnerNotFoundError\\":
          return {
            ok: false,
            error: serializers.token.create.Error.parse(response.error.body as serializers.token.create.Error.Raw),
          };
      }
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getTokenMetadata(
    request: FernApi.GetTokenMetadataRequest
  ): Promise<FernApi.token.getTokenMetadata.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment, \\"/tokens/metadata\\"),
      method: \\"POST\\",
      headers: {
        \\"X-API-Version\\": this.options?.apiVersion,
      },
      body: serializers.GetTokenMetadataRequest.json(request),
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.TokenMetadata.parse(response.body as serializers.TokenMetadata.Raw),
      };
    }

    if (response.error.reason === \\"status-code\\") {
      switch ((response.error.body as serializers.token.getTokenMetadata.Error.Raw)?.errorName) {
        case \\"TokenNotFoundError\\":
          return {
            ok: false,
            error: serializers.token.getTokenMetadata.Error.parse(
              response.error.body as serializers.token.getTokenMetadata.Error.Raw
            ),
          };
      }
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getTokensForOwner(
    request: FernApi.token.getTokensForOwner.Request
  ): Promise<FernApi.token.getTokensForOwner.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment, \`/tokens/owner/\${request.ownerId}\`),
      method: \\"GET\\",
      headers: {
        \\"X-API-Version\\": this.options?.apiVersion,
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.token.getTokensForOwner.Response.parse(response.body as serializers.TokenMetadata.Raw[]),
      };
    }

    if (response.error.reason === \\"status-code\\") {
      switch ((response.error.body as serializers.token.getTokensForOwner.Error.Raw)?.errorName) {
        case \\"OwnerNotFoundError\\":
          return {
            ok: false,
            error: serializers.token.getTokensForOwner.Error.parse(
              response.error.body as serializers.token.getTokensForOwner.Error.Raw
            ),
          };
      }
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<FernApi.CreateTokenResponse, FernApi.token.create.Error>;
export type Error = FernApi.token.create.Error.OwnerNotFoundError | FernApi.token.create.Error._Unknown;

export declare namespace Error {
  interface OwnerNotFoundError extends _Utils {
    errorName: \\"OwnerNotFoundError\\";
  }

  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernApi.token.create.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    ownerNotFoundError: () => _Result;
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  ownerNotFoundError: (): FernApi.token.create.Error.OwnerNotFoundError => {
    const valueWithoutVisit: Omit<FernApi.token.create.Error.OwnerNotFoundError, \\"_visit\\"> = {
      errorName: \\"OwnerNotFoundError\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.token.create.Error.OwnerNotFoundError, visitor: FernApi.token.create.Error._Visitor<_Result>) {
      return FernApi.token.create.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: FernApi.token.create.Error,
    visitor: FernApi.token.create.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      case \\"OwnerNotFoundError\\":
        return visitor.ownerNotFoundError();
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "create.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<FernApi.TokenMetadata, FernApi.token.getTokenMetadata.Error>;
export type Error =
  | FernApi.token.getTokenMetadata.Error.TokenNotFoundError
  | FernApi.token.getTokenMetadata.Error._Unknown;

export declare namespace Error {
  interface TokenNotFoundError extends _Utils {
    errorName: \\"TokenNotFoundError\\";
  }

  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernApi.token.getTokenMetadata.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    tokenNotFoundError: () => _Result;
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  tokenNotFoundError: (): FernApi.token.getTokenMetadata.Error.TokenNotFoundError => {
    const valueWithoutVisit: Omit<FernApi.token.getTokenMetadata.Error.TokenNotFoundError, \\"_visit\\"> = {
      errorName: \\"TokenNotFoundError\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.token.getTokenMetadata.Error.TokenNotFoundError, visitor: FernApi.token.getTokenMetadata.Error._Visitor<_Result>) {
      return FernApi.token.getTokenMetadata.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: FernApi.token.getTokenMetadata.Error,
    visitor: FernApi.token.getTokenMetadata.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      case \\"TokenNotFoundError\\":
        return visitor.tokenNotFoundError();
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "getTokenMetadata.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  ownerId: FernApi.OwnerId;
}

export type Response = core.APIResponse<FernApi.TokenMetadata[], FernApi.token.getTokensForOwner.Error>;
export type Error =
  | FernApi.token.getTokensForOwner.Error.OwnerNotFoundError
  | FernApi.token.getTokensForOwner.Error._Unknown;

export declare namespace Error {
  interface OwnerNotFoundError extends _Utils {
    errorName: \\"OwnerNotFoundError\\";
  }

  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernApi.token.getTokensForOwner.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    ownerNotFoundError: () => _Result;
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  ownerNotFoundError: (): FernApi.token.getTokensForOwner.Error.OwnerNotFoundError => {
    const valueWithoutVisit: Omit<FernApi.token.getTokensForOwner.Error.OwnerNotFoundError, \\"_visit\\"> = {
      errorName: \\"OwnerNotFoundError\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.token.getTokensForOwner.Error.OwnerNotFoundError, visitor: FernApi.token.getTokensForOwner.Error._Visitor<_Result>) {
      return FernApi.token.getTokensForOwner.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: FernApi.token.getTokensForOwner.Error,
    visitor: FernApi.token.getTokensForOwner.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      case \\"OwnerNotFoundError\\":
        return visitor.ownerNotFoundError();
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "getTokensForOwner.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as create from \\"./create\\";
export * as getTokenMetadata from \\"./getTokenMetadata\\";
export * as getTokensForOwner from \\"./getTokensForOwner\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";

export interface CreateTokenRequest {
  ownerId: FernApi.OwnerId;
  description?: string;
}
",
                    "name": "CreateTokenRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";

export interface CreateTokenResponse {
  token: string;
  tokenId: FernApi.TokenId;
}
",
                    "name": "CreateTokenResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface GetTokenMetadataRequest {
  token: string;
}
",
                    "name": "GetTokenMetadataRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";

export type TokenId = string;

export const TokenId = {
  create: (value: string) => value as unknown as FernApi.TokenId,
} as const;
",
                    "name": "TokenId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";

export interface TokenMetadata {
  tokenId: FernApi.TokenId;
  ownerId: FernApi.OwnerId;
  description?: string;
  createdTime: Date;
  status: FernApi.TokenStatus;
}
",
                    "name": "TokenMetadata.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type TokenStatus =
  | FernApi.TokenStatus.Active
  | FernApi.TokenStatus.Expired
  | FernApi.TokenStatus.Revoked
  | FernApi.TokenStatus._Unknown;

export declare namespace TokenStatus {
  interface Active extends _Utils {
    type: \\"active\\";
  }

  interface Expired extends _Utils {
    type: \\"expired\\";
  }

  interface Revoked extends _Utils {
    type: \\"revoked\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: FernApi.TokenStatus._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    active: () => _Result;
    expired: () => _Result;
    revoked: () => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const TokenStatus = {
  active: (): FernApi.TokenStatus.Active => {
    const valueWithoutVisit: Omit<FernApi.TokenStatus.Active, \\"_visit\\"> = {
      type: \\"active\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.TokenStatus.Active, visitor: FernApi.TokenStatus._Visitor<_Result>) {
      return FernApi.TokenStatus._visit(this, visitor);
    });
  },

  expired: (): FernApi.TokenStatus.Expired => {
    const valueWithoutVisit: Omit<FernApi.TokenStatus.Expired, \\"_visit\\"> = {
      type: \\"expired\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.TokenStatus.Expired, visitor: FernApi.TokenStatus._Visitor<_Result>) {
      return FernApi.TokenStatus._visit(this, visitor);
    });
  },

  revoked: (): FernApi.TokenStatus.Revoked => {
    const valueWithoutVisit: Omit<FernApi.TokenStatus.Revoked, \\"_visit\\"> = {
      type: \\"revoked\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: FernApi.TokenStatus.Revoked, visitor: FernApi.TokenStatus._Visitor<_Result>) {
      return FernApi.TokenStatus._visit(this, visitor);
    });
  },

  _visit: <_Result>(value: FernApi.TokenStatus, visitor: FernApi.TokenStatus._Visitor<_Result>): _Result => {
    switch (value.type) {
      case \\"active\\":
        return visitor.active();
      case \\"expired\\":
        return visitor.expired();
      case \\"revoked\\":
        return visitor.revoked();
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "TokenStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./TokenId\\";
export * from \\"./CreateTokenRequest\\";
export * from \\"./CreateTokenResponse\\";
export * from \\"./GetTokenMetadataRequest\\";
export * from \\"./TokenMetadata\\";
export * from \\"./TokenStatus\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "token",
            "type": "directory",
          },
        ],
        "name": "resources",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * as owner from \\"./owner\\";
export * from \\"./owner/types\\";
export * as token from \\"./token\\";
export * from \\"./token/types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Error: core.schemas.Schema<Error.Raw, FernApi.owner.create.Error> = core.schemas
  .union(\\"errorName\\", {
    OwnerAlreadyExistsError: core.schemas.object({}),
  })
  .transform<FernApi.owner.create.Error>({
    parse: (value) => {
      switch (value.errorName) {
        case \\"OwnerAlreadyExistsError\\":
          return FernApi.owner.create.Error.ownerAlreadyExistsError();
      }
    },
    json: (value) => value as any,
  });

export declare namespace Error {
  type Raw = Error.OwnerAlreadyExistsError;

  interface OwnerAlreadyExistsError {
    errorName: \\"OwnerAlreadyExistsError\\";
  }
}
",
                    "name": "create.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Error: core.schemas.Schema<Error.Raw, FernApi.owner.get.Error> = core.schemas
  .union(\\"errorName\\", {
    OwnerNotFoundError: core.schemas.object({}),
  })
  .transform<FernApi.owner.get.Error>({
    parse: (value) => {
      switch (value.errorName) {
        case \\"OwnerNotFoundError\\":
          return FernApi.owner.get.Error.ownerNotFoundError();
      }
    },
    json: (value) => value as any,
  });

export declare namespace Error {
  type Raw = Error.OwnerNotFoundError;

  interface OwnerNotFoundError {
    errorName: \\"OwnerNotFoundError\\";
  }
}
",
                    "name": "get.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as create from \\"./create\\";
export * as get from \\"./get\\";
export * as update from \\"./update\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Error: core.schemas.Schema<Error.Raw, FernApi.owner.update.Error> = core.schemas
  .union(\\"errorName\\", {
    OwnerNotFoundError: core.schemas.object({}),
  })
  .transform<FernApi.owner.update.Error>({
    parse: (value) => {
      switch (value.errorName) {
        case \\"OwnerNotFoundError\\":
          return FernApi.owner.update.Error.ownerNotFoundError();
      }
    },
    json: (value) => value as any,
  });

export declare namespace Error {
  type Raw = Error.OwnerNotFoundError;

  interface OwnerNotFoundError {
    errorName: \\"OwnerNotFoundError\\";
  }
}
",
                    "name": "update.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const CreateOwnerRequest: core.schemas.ObjectSchema<CreateOwnerRequest.Raw, FernApi.CreateOwnerRequest> =
  core.schemas.object({
    ownerId: core.schemas.lazy(() => serializers.OwnerId),
    data: core.schemas.unknown(),
  });

export declare namespace CreateOwnerRequest {
  interface Raw {
    ownerId: serializers.OwnerId.Raw;
    data?: unknown;
  }
}
",
                    "name": "CreateOwnerRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const Owner: core.schemas.ObjectSchema<Owner.Raw, FernApi.Owner> = core.schemas.object({
  ownerId: core.schemas.lazy(() => serializers.OwnerId),
  data: core.schemas.unknown(),
});

export declare namespace Owner {
  interface Raw {
    ownerId: serializers.OwnerId.Raw;
    data?: unknown;
  }
}
",
                    "name": "Owner.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const OwnerId: core.schemas.Schema<OwnerId.Raw, FernApi.OwnerId> = core.schemas.string();

export declare namespace OwnerId {
  type Raw = string;
}
",
                    "name": "OwnerId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const UpdateOwnerRequest: core.schemas.ObjectSchema<UpdateOwnerRequest.Raw, FernApi.UpdateOwnerRequest> =
  core.schemas.object({
    data: core.schemas.unknown(),
  });

export declare namespace UpdateOwnerRequest {
  interface Raw {
    data?: unknown;
  }
}
",
                    "name": "UpdateOwnerRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./OwnerId\\";
export * from \\"./CreateOwnerRequest\\";
export * from \\"./UpdateOwnerRequest\\";
export * from \\"./Owner\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "owner",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Error: core.schemas.Schema<Error.Raw, FernApi.token.create.Error> = core.schemas
  .union(\\"errorName\\", {
    OwnerNotFoundError: core.schemas.object({}),
  })
  .transform<FernApi.token.create.Error>({
    parse: (value) => {
      switch (value.errorName) {
        case \\"OwnerNotFoundError\\":
          return FernApi.token.create.Error.ownerNotFoundError();
      }
    },
    json: (value) => value as any,
  });

export declare namespace Error {
  type Raw = Error.OwnerNotFoundError;

  interface OwnerNotFoundError {
    errorName: \\"OwnerNotFoundError\\";
  }
}
",
                    "name": "create.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Error: core.schemas.Schema<Error.Raw, FernApi.token.getTokenMetadata.Error> = core.schemas
  .union(\\"errorName\\", {
    TokenNotFoundError: core.schemas.object({}),
  })
  .transform<FernApi.token.getTokenMetadata.Error>({
    parse: (value) => {
      switch (value.errorName) {
        case \\"TokenNotFoundError\\":
          return FernApi.token.getTokenMetadata.Error.tokenNotFoundError();
      }
    },
    json: (value) => value as any,
  });

export declare namespace Error {
  type Raw = Error.TokenNotFoundError;

  interface TokenNotFoundError {
    errorName: \\"TokenNotFoundError\\";
  }
}
",
                    "name": "getTokenMetadata.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { FernApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<serializers.TokenMetadata.Raw[], FernApi.TokenMetadata[]> =
  core.schemas.list(core.schemas.lazyObject(() => serializers.TokenMetadata));
export const Error: core.schemas.Schema<Error.Raw, FernApi.token.getTokensForOwner.Error> = core.schemas
  .union(\\"errorName\\", {
    OwnerNotFoundError: core.schemas.object({}),
  })
  .transform<FernApi.token.getTokensForOwner.Error>({
    parse: (value) => {
      switch (value.errorName) {
        case \\"OwnerNotFoundError\\":
          return FernApi.token.getTokensForOwner.Error.ownerNotFoundError();
      }
    },
    json: (value) => value as any,
  });

export declare namespace Error {
  type Raw = Error.OwnerNotFoundError;

  interface OwnerNotFoundError {
    errorName: \\"OwnerNotFoundError\\";
  }
}
",
                    "name": "getTokensForOwner.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as create from \\"./create\\";
export * as getTokenMetadata from \\"./getTokenMetadata\\";
export * as getTokensForOwner from \\"./getTokensForOwner\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const CreateTokenRequest: core.schemas.ObjectSchema<CreateTokenRequest.Raw, FernApi.CreateTokenRequest> =
  core.schemas.object({
    ownerId: core.schemas.lazy(() => serializers.OwnerId),
    description: core.schemas.string().optional(),
  });

export declare namespace CreateTokenRequest {
  interface Raw {
    ownerId: serializers.OwnerId.Raw;
    description?: string | null;
  }
}
",
                    "name": "CreateTokenRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const CreateTokenResponse: core.schemas.ObjectSchema<CreateTokenResponse.Raw, FernApi.CreateTokenResponse> =
  core.schemas.object({
    token: core.schemas.string(),
    tokenId: core.schemas.lazy(() => serializers.TokenId),
  });

export declare namespace CreateTokenResponse {
  interface Raw {
    token: string;
    tokenId: serializers.TokenId.Raw;
  }
}
",
                    "name": "CreateTokenResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const GetTokenMetadataRequest: core.schemas.ObjectSchema<
  GetTokenMetadataRequest.Raw,
  FernApi.GetTokenMetadataRequest
> = core.schemas.object({
  token: core.schemas.string(),
});

export declare namespace GetTokenMetadataRequest {
  interface Raw {
    token: string;
  }
}
",
                    "name": "GetTokenMetadataRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const TokenId: core.schemas.Schema<TokenId.Raw, FernApi.TokenId> = core.schemas.string();

export declare namespace TokenId {
  type Raw = string;
}
",
                    "name": "TokenId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TokenMetadata: core.schemas.ObjectSchema<TokenMetadata.Raw, FernApi.TokenMetadata> = core.schemas.object({
  tokenId: core.schemas.lazy(() => serializers.TokenId),
  ownerId: core.schemas.lazy(() => serializers.OwnerId),
  description: core.schemas.string().optional(),
  createdTime: core.schemas.date(),
  status: core.schemas.lazy(() => serializers.TokenStatus),
});

export declare namespace TokenMetadata {
  interface Raw {
    tokenId: serializers.TokenId.Raw;
    ownerId: serializers.OwnerId.Raw;
    description?: string | null;
    createdTime: string;
    status: serializers.TokenStatus.Raw;
  }
}
",
                    "name": "TokenMetadata.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const TokenStatus: core.schemas.Schema<TokenStatus.Raw, FernApi.TokenStatus> = core.schemas
  .union(\\"type\\", {
    active: core.schemas.object({}),
    expired: core.schemas.object({}),
    revoked: core.schemas.object({}),
  })
  .transform<FernApi.TokenStatus>({
    parse: (value) => {
      switch (value.type) {
        case \\"active\\":
          return FernApi.TokenStatus.active();
        case \\"expired\\":
          return FernApi.TokenStatus.expired();
        case \\"revoked\\":
          return FernApi.TokenStatus.revoked();
        default:
          return core.addNonEnumerableProperty(value, \\"_visit\\", function <
            _Result
          >(this: FernApi.TokenStatus, visitor: FernApi.TokenStatus._Visitor<_Result>) {
            return visitor._other(value);
          });
      }
    },
    json: (value) => value as any,
  });

export declare namespace TokenStatus {
  type Raw = TokenStatus.Active | TokenStatus.Expired | TokenStatus.Revoked;

  interface Active {
    type: \\"active\\";
  }

  interface Expired {
    type: \\"expired\\";
  }

  interface Revoked {
    type: \\"revoked\\";
  }
}
",
                    "name": "TokenStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./TokenId\\";
export * from \\"./CreateTokenRequest\\";
export * from \\"./CreateTokenResponse\\";
export * from \\"./GetTokenMetadataRequest\\";
export * from \\"./TokenMetadata\\";
export * from \\"./TokenStatus\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "token",
            "type": "directory",
          },
        ],
        "name": "serialization",
        "type": "directory",
      },
    ],
    "name": "src",
    "type": "directory",
  },
  Object {
    "contents": "{
    \\"compilerOptions\\": {
        \\"strict\\": true,
        \\"target\\": \\"esnext\\",
        \\"moduleResolution\\": \\"node\\",
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"sourceMap\\": true,
        \\"emitDeclarationOnly\\": true,
        \\"esModuleInterop\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true,
        \\"declarationDir\\": \\".\\",
        \\"rootDir\\": \\"src\\"
    },
    \\"include\\": [
        \\"src\\"
    ],
    \\"exclude\\": []
}",
    "name": "tsconfig.json",
    "type": "file",
  },
]
`;

exports[`runGenerator reserved-keywords 1`] = `
Array [
  Object {
    "contents": "node_modules
.DS_Store
*.d.ts
*.js
*.js.map

# yarn berry
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions

# these are needed to override '*.js' above
!.yarn/patches/**
!.yarn/plugins/**
!.yarn/releases/**
!.yarn/sdks/**
!.yarn/versions/**",
    "name": ".gitignore",
    "type": "file",
  },
  Object {
    "contents": "registry=https://registry.npmjs.org/
",
    "name": ".npmrc",
    "type": "file",
  },
  Object {
    "contents": ".yarn
node_modules
.npmignore
.pnp.cjs
*.js
*.d.ts",
    "name": ".prettierignore",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "{
  \\"recommendations\\": [
    \\"arcanis.vscode-zipfs\\",
    \\"esbenp.prettier-vscode\\"
  ]
}
",
        "name": "extensions.json",
        "type": "file",
      },
      Object {
        "contents": "{
  \\"search.exclude\\": {
    \\"**/.yarn\\": true,
    \\"**/.pnp.*\\": true
  },
  \\"prettier.prettierPath\\": \\".yarn/sdks/prettier/index.js\\",
  \\"typescript.tsdk\\": \\".yarn/sdks/typescript/lib\\",
  \\"typescript.enablePromptUseWorkspaceTsdk\\": true
}
",
        "name": "settings.json",
        "type": "file",
      },
    ],
    "name": ".vscode",
    "type": "directory",
  },
  Object {
    "contents": "nodeLinker: pnp

yarnPath: .yarn/releases/yarn-3.2.4.cjs
",
    "name": ".yarnrc.yml",
    "type": "file",
  },
  Object {
    "contents": "{
    \\"name\\": \\"@fern-fern/api-sdk\\",
    \\"version\\": \\"\\",
    \\"files\\": [
        \\"core\\",
        \\"resources\\",
        \\"serialization\\",
        \\"client\\",
        \\"*.{js,js.map,d.ts}\\"
    ],
    \\"main\\": \\"./index.js\\",
    \\"types\\": \\"./index.d.ts\\",
    \\"scripts\\": {
        \\"format\\": \\"prettier --write --print-width 120 'src/**/*.ts'\\",
        \\"build\\": \\"esbuild $(find src -name '*.ts') --format=cjs --sourcemap --outdir=. && tsc\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"esbuild\\": \\"0.14.47\\",
        \\"prettier\\": \\"2.7.1\\",
        \\"typescript\\": \\"4.6.4\\"
    },
    \\"packageManager\\": \\"yarn@3.2.4\\"
}
",
    "name": "package.json",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": Array [
          Object {
            "contents": "export * as schemas from \\"./schemas\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { SchemaUtils } from \\"./builders\\";

export type Schema<Raw = unknown, Parsed = unknown> = BaseSchema<Raw, Parsed> & SchemaUtils<Raw, Parsed>;

export type inferRaw<S extends Schema> = S extends Schema<infer Raw, any> ? Raw : never;
export type inferParsed<S extends Schema> = S extends Schema<any, infer Parsed> ? Parsed : never;

export interface BaseSchema<Raw, Parsed> {
  parse: (raw: Raw, opts?: SchemaOptions) => Parsed;
  json: (parsed: Parsed, opts?: SchemaOptions) => Raw;
}

export interface SchemaOptions {
  /**
   * @default false
   */
  skipUnknownKeysOnParse?: boolean;

  /**
   * @default false
   */
  includeUnknownKeysOnJson?: boolean;
}
",
                "name": "Schema.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function date(): Schema<string, Date> {
  const baseSchema: BaseSchema<string, Date> = {
    parse: (raw) => new Date(raw),
    json: (date) => date.toISOString(),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "date.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { date } from \\"./date\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "date",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function enum_<U extends string, E extends Readonly<[U, ...U[]]>>(_values: E): Schema<E[number], E[number]> {
  return createIdentitySchemaCreator<E[number]>()();
}
",
                        "name": "enum.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { enum_ } from \\"./enum\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "enum",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { identity } from \\"./identity\\";

export function createIdentitySchemaCreator<T>(): () => Schema<T, T> {
  return <T>() => identity<T>();
}
",
                        "name": "createIdentitySchemaCreator.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function identity<T>(): Schema<T, T> {
  const baseSchema: BaseSchema<T, T> = {
    parse: (raw) => raw,
    json: (parsed) => parsed,
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "identity.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { createIdentitySchemaCreator } from \\"./createIdentitySchemaCreator\\";
export { identity } from \\"./identity\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "identity",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./date\\";
export * from \\"./enum\\";
export * from \\"./identity\\";
export * from \\"./lazy\\";
export * from \\"./list\\";
export * from \\"./literals\\";
export * from \\"./object\\";
export * from \\"./object-like\\";
export * from \\"./primitives\\";
export * from \\"./record\\";
export * from \\"./schema-utils\\";
export * from \\"./set\\";
export * from \\"./union\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { lazy } from \\"./lazy\\";
export { lazyObject } from \\"./lazyObject\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

type Getter<Raw, Parsed> = () => Schema<Raw, Parsed>;
type MemoizedGetter<Raw, Parsed> = Getter<Raw, Parsed> & { __zurg_memoized?: Schema<Raw, Parsed> };

export function lazy<Raw, Parsed>(getter: Getter<Raw, Parsed>): Schema<Raw, Parsed> {
  const baseSchema = constructLazyBaseSchema(getter);
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function constructLazyBaseSchema<Raw, Parsed>(getter: Getter<Raw, Parsed>): BaseSchema<Raw, Parsed> {
  const getSchema = () => {
    const castedGetter = getter as MemoizedGetter<Raw, Parsed>;
    if (castedGetter.__zurg_memoized == null) {
      castedGetter.__zurg_memoized = getter();
    }
    return castedGetter.__zurg_memoized;
  };

  return {
    parse: (raw) => getSchema().parse(raw),
    json: (parsed) => getSchema().json(parsed),
  };
}
",
                        "name": "lazy.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { getObjectUtils } from \\"../object\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { ObjectSchema } from \\"../object/types\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { constructLazyBaseSchema } from \\"./lazy\\";

export function lazyObject<Raw, Parsed>(getter: () => ObjectSchema<Raw, Parsed>): ObjectSchema<Raw, Parsed> {
  const baseSchema = {
    ...OBJECT_LIKE_BRAND,
    ...constructLazyBaseSchema(getter),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}
",
                        "name": "lazyObject.ts",
                        "type": "file",
                      },
                    ],
                    "name": "lazy",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { list } from \\"./list\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function list<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Parsed[]> {
  const baseSchema: BaseSchema<Raw[], Parsed[]> = {
    parse: (raw, opts) => raw.map((item) => schema.parse(item, opts)),
    json: (parsed, opts) => parsed.map((item) => schema.json(item, opts)),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "list.ts",
                        "type": "file",
                      },
                    ],
                    "name": "list",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { stringLiteral } from \\"./stringLiteral\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function stringLiteral<V extends string>(_value: V): Schema<V, V> {
  return createIdentitySchemaCreator<V>()();
}
",
                        "name": "stringLiteral.ts",
                        "type": "file",
                      },
                    ],
                    "name": "literals",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { getObjectUtils, object } from \\"./object\\";
export { isProperty, property, type Property } from \\"./property\\";
export {
  type BaseObjectSchema,
  type inferObjectSchemaFromPropertySchemas,
  type inferParsedObject,
  type inferParsedObjectFromPropertySchemas,
  type inferParsedPropertySchema,
  type inferRawKey,
  type inferRawObject,
  type inferRawObjectFromPropertySchemas,
  type inferRawPropertySchema,
  type ObjectSchema,
  type ObjectUtils,
  type PropertySchemas,
} from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { isProperty } from \\"./property\\";
import {
  BaseObjectSchema,
  inferObjectSchemaFromPropertySchemas,
  inferParsedObjectFromPropertySchemas,
  inferRawObjectFromPropertySchemas,
  ObjectSchema,
  ObjectUtils,
  PropertySchemas,
} from \\"./types\\";

interface ObjectPropertyWithRawKey {
  rawKey: string;
  parsedKey: string | number | symbol;
  valueSchema: Schema<any, any>;
}

export function object<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(
  schemas: T
): inferObjectSchemaFromPropertySchemas<T> {
  const baseSchema: BaseObjectSchema<inferRawObjectFromPropertySchemas<T>, inferParsedObjectFromPropertySchemas<T>> = {
    ...OBJECT_LIKE_BRAND,

    parse: (raw, { skipUnknownKeysOnParse = false } = {}) => {
      const rawKeyToProperty: Record<string, ObjectPropertyWithRawKey> = {};

      for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
        const rawKey = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;

        const property: ObjectPropertyWithRawKey = {
          rawKey,
          parsedKey,
          valueSchema: isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.valueSchema : schemaOrObjectProperty,
        };

        rawKeyToProperty[rawKey] = property;
      }

      const parsed: Record<string | number | symbol, any> = {};

      for (const [rawKey, rawPropertyValue] of Object.entries(raw)) {
        const property = rawKeyToProperty[rawKey];

        if (property != null) {
          const value = property.valueSchema.parse(rawPropertyValue);
          parsed[property.parsedKey] = value;
        } else if (!skipUnknownKeysOnParse && rawPropertyValue != null) {
          parsed[rawKey] = rawPropertyValue;
        }
      }

      return parsed as inferParsedObjectFromPropertySchemas<T>;
    },

    json: (parsed, { includeUnknownKeysOnJson = false } = {}) => {
      const raw: Record<string | number | symbol, any> = {};

      for (const [parsedKey, parsedPropertyValue] of entries(parsed)) {
        const schemaOrObjectProperty = schemas[parsedKey as keyof T];
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (schemaOrObjectProperty != null) {
          if (isProperty(schemaOrObjectProperty)) {
            const value = schemaOrObjectProperty.valueSchema.json(parsedPropertyValue);
            raw[schemaOrObjectProperty.rawKey] = value;
          } else {
            const value = schemaOrObjectProperty.json(parsedPropertyValue);
            raw[parsedKey] = value;
          }
        } else if (includeUnknownKeysOnJson && parsedPropertyValue != null) {
          raw[parsedKey] = parsedPropertyValue;
        }
      }

      return raw as inferRawObjectFromPropertySchemas<T>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}

export function getObjectUtils<Raw, Parsed>(schema: BaseObjectSchema<Raw, Parsed>): ObjectUtils<Raw, Parsed> {
  return {
    extend: <RawExtension, ParsedExtension>(extension: ObjectSchema<RawExtension, ParsedExtension>) => {
      const baseSchema: BaseObjectSchema<Raw & RawExtension, Parsed & ParsedExtension> = {
        ...OBJECT_LIKE_BRAND,
        parse: (raw, opts) => ({
          ...schema.parse(raw, opts),
          ...extension.parse(raw, opts),
        }),
        json: (parsed, opts) => ({
          ...schema.json(parsed, opts),
          ...extension.json(parsed, opts),
        }),
      };

      return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
      };
    },
  };
}
",
                        "name": "object.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export function property<RawKey extends string, RawValue, ParsedValue>(
  rawKey: RawKey,
  valueSchema: Schema<RawValue, ParsedValue>
): Property<RawKey, RawValue, ParsedValue> {
  return {
    rawKey,
    valueSchema,
    isProperty: true,
  };
}

export interface Property<RawKey extends string, RawValue, ParsedValue> {
  rawKey: RawKey;
  valueSchema: Schema<RawValue, ParsedValue>;
  isProperty: true;
}

export function isProperty<O extends Property<any, any, any>>(maybeProperty: unknown): maybeProperty is O {
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return (maybeProperty as O).isProperty;
}
",
                        "name": "property.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsed, inferRaw, Schema } from \\"../../Schema\\";
import { addQuestionMarksToNullableProperties } from \\"../../utils/addQuestionMarksToNullableProperties\\";
import { BaseObjectLikeSchema, ObjectLikeSchema } from \\"../object-like\\";
import { Property } from \\"./property\\";

export type ObjectSchema<Raw, Parsed> = BaseObjectSchema<Raw, Parsed> &
  ObjectLikeSchema<Raw, Parsed> &
  ObjectUtils<Raw, Parsed>;

export type BaseObjectSchema<Raw, Parsed> = BaseObjectLikeSchema<Raw, Parsed>;

export interface ObjectUtils<Raw, Parsed> {
  extend: <RawExtension, ParsedExtension>(
    schemas: ObjectSchema<RawExtension, ParsedExtension>
  ) => ObjectSchema<Raw & RawExtension, Parsed & ParsedExtension>;
}

export type inferRawObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<infer Raw, any> ? Raw : never;

export type inferParsedObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<any, infer Parsed>
  ? Parsed
  : never;

export type inferObjectSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> = ObjectSchema<
  inferRawObjectFromPropertySchemas<T>,
  inferParsedObjectFromPropertySchemas<T>
>;

export type inferRawObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
  addQuestionMarksToNullableProperties<{
    [ParsedKey in keyof T as inferRawKey<ParsedKey, T[ParsedKey]>]: inferRawPropertySchema<T[ParsedKey]>;
  }>;

export type inferParsedObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
  addQuestionMarksToNullableProperties<{
    [K in keyof T]: inferParsedPropertySchema<T[K]>;
  }>;

export type PropertySchemas<ParsedKeys extends string | number | symbol> = Record<
  ParsedKeys,
  Property<any, any, any> | Schema<any, any>
>;

export type inferRawPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
  any,
  infer Raw,
  any
>
  ? Raw
  : P extends Schema<any, any>
  ? inferRaw<P>
  : never;

export type inferParsedPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
  any,
  any,
  infer Parsed
>
  ? Parsed
  : P extends Schema<any, any>
  ? inferParsed<P>
  : never;

export type inferRawKey<
  ParsedKey extends string | number | symbol,
  P extends Property<any, any, any> | Schema<any, any>
> = P extends Property<infer Raw, any, any> ? Raw : ParsedKey;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseObjectLikeSchema, ObjectLikeUtils } from \\"./types\\";
import { withProperties } from \\"./withProperties\\";

export function getObjectLikeUtils<Raw, Parsed>(
  schema: BaseObjectLikeSchema<Raw, Parsed>
): ObjectLikeUtils<Raw, Parsed> {
  return {
    withProperties: (properties) => withProperties(schema, properties),
  };
}
",
                        "name": "getObjectLikeUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getObjectLikeUtils } from \\"./getObjectLikeUtils\\";
export { OBJECT_LIKE_BRAND, type BaseObjectLikeSchema, type ObjectLikeSchema, type ObjectLikeUtils } from \\"./types\\";
export { withProperties } from \\"./withProperties\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";

export type ObjectLikeSchema<Raw, Parsed> = Schema<Raw, Parsed> &
  BaseObjectLikeSchema<Raw, Parsed> &
  ObjectLikeUtils<Raw, Parsed>;

export type BaseObjectLikeSchema<Raw, Parsed> = BaseSchema<Raw, Parsed> & {
  _objectLike: void;
};

export interface ObjectLikeUtils<Raw, Parsed> {
  withProperties: <T extends Record<string, any>>(properties: {
    [K in keyof T]: T[K] | ((parsed: Parsed) => T[K]);
  }) => ObjectLikeSchema<Raw, Parsed & T>;
}

export const OBJECT_LIKE_BRAND = undefined as unknown as { _objectLike: void };
",
                        "name": "types.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { getSchemaUtils } from \\"../schema-utils\\";
import { getObjectLikeUtils } from \\"./getObjectLikeUtils\\";
import { BaseObjectLikeSchema, ObjectLikeSchema, OBJECT_LIKE_BRAND } from \\"./types\\";

export function withProperties<RawObjectShape, ParsedObjectShape, Properties>(
  objectLike: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape>,
  properties: { [K in keyof Properties]: Properties[K] | ((parsed: ParsedObjectShape) => Properties[K]) }
): ObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> {
  const objectSchema: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> = {
    ...OBJECT_LIKE_BRAND,
    parse: (raw, opts) => {
      const parsedObject = objectLike.parse(raw, opts);
      const additionalProperties = Object.entries(properties).reduce<Record<string, any>>((processed, [key, value]) => {
        return {
          ...processed,
          [key]: typeof value === \\"function\\" ? value(parsedObject) : value,
        };
      }, {});

      return {
        ...parsedObject,
        ...(additionalProperties as Properties),
      };
    },
    json: (parsed, opts) => {
      // strip out added properties
      const addedPropertyKeys = new Set(Object.keys(properties));
      const parsedWithoutAddedProperties = Object.entries(parsed).reduce<Record<string, any>>(
        (filtered, [key, value]) => {
          if (!addedPropertyKeys.has(key)) {
            filtered[key] = value;
          }
          return filtered;
        },
        {}
      );

      return objectLike.json(parsedWithoutAddedProperties as ParsedObjectShape, opts);
    },
  };

  return {
    ...objectSchema,
    ...getSchemaUtils(objectSchema),
    ...getObjectLikeUtils(objectSchema),
  };
}
",
                        "name": "withProperties.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object-like",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const any = createIdentitySchemaCreator<any>();
",
                        "name": "any.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const boolean = createIdentitySchemaCreator<boolean>();
",
                        "name": "boolean.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { any } from \\"./any\\";
export { boolean } from \\"./boolean\\";
export { number } from \\"./number\\";
export { string } from \\"./string\\";
export { unknown } from \\"./unknown\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const number = createIdentitySchemaCreator<number>();
",
                        "name": "number.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const string = createIdentitySchemaCreator<string>();
",
                        "name": "string.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const unknown = createIdentitySchemaCreator<unknown>();
",
                        "name": "unknown.ts",
                        "type": "file",
                      },
                    ],
                    "name": "primitives",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { record } from \\"./record\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function record<RawKey extends string | number, ParsedKey extends string | number, RawValue, ParsedValue>(
  keySchema: Schema<RawKey, ParsedKey>,
  valueSchema: Schema<RawValue, ParsedValue>
): Schema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> {
  const baseSchema: BaseSchema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> = {
    parse: (raw, opts) => {
      return entries(raw).reduce(
        (parsed, [key, value]) => {
          parsed[keySchema.parse(key, opts)] = valueSchema.parse(value, opts);
          return parsed;
        },
        // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
        {} as Record<ParsedKey, ParsedValue>
      );
    },
    json: (parsed, opts) => {
      return entries(parsed).reduce(
        (raw, [key, value]) => {
          raw[keySchema.json(key, opts)] = valueSchema.json(value, opts);
          return raw;
        },
        // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
        {} as Record<RawKey, RawValue>
      );
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "record.ts",
                        "type": "file",
                      },
                    ],
                    "name": "record",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { OptionalSchema, OPTIONAL_BRAND } from \\"./types\\";

export interface SchemaUtils<Raw, Parsed> {
  optional: () => OptionalSchema<Raw, Parsed>;
  transform: <PostTransform>(transformer: BaseSchema<Parsed, PostTransform>) => Schema<Raw, PostTransform>;
}

export function getSchemaUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): SchemaUtils<Raw, Parsed> {
  return {
    optional: () => optional(schema),
    transform: (transformer) => transform(schema, transformer),
  };
}

/**
 * schema utils are defined in one file to resolve issues with circular imports
 */

export function optional<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): OptionalSchema<Raw, Parsed> {
  const baseSchema: BaseSchema<Raw | null | undefined, Parsed | undefined> = {
    parse: (raw, opts) => (raw != null ? schema.parse(raw, opts) : undefined),
    json: (parsed, opts) => (parsed != null ? schema.json(parsed, opts) : undefined),
  };

  return {
    ...OPTIONAL_BRAND,
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function transform<PreTransformRaw, PreTransformParsed, PostTransform>(
  schema: BaseSchema<PreTransformRaw, PreTransformParsed>,
  transformer: BaseSchema<PreTransformParsed, PostTransform>
): Schema<PreTransformRaw, PostTransform> {
  const baseSchema: BaseSchema<PreTransformRaw, PostTransform> = {
    parse: (raw, opts) => {
      const postTransformParsed = schema.parse(raw, opts);
      return transformer.parse(postTransformParsed, opts);
    },
    json: (parsed, opts) => {
      const preTransformParsed = transformer.json(parsed, opts);
      return schema.json(preTransformParsed, opts);
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "getSchemaUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getSchemaUtils, optional, transform, type SchemaUtils } from \\"./getSchemaUtils\\";
export { OPTIONAL_BRAND, type OptionalSchema } from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export const OPTIONAL_BRAND = undefined as unknown as { _isOptional: void };

export type OptionalSchema<Raw, Parsed> = Schema<Raw | null | undefined, Parsed | undefined> & {
  _isOptional: void;
};
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "schema-utils",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { set } from \\"./set\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function set<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Set<Parsed>> {
  const baseSchema: BaseSchema<Raw[], Set<Parsed>> = {
    parse: (raw, opts) => new Set(raw.map((item) => schema.parse(item, opts))),
    json: (parsed, opts) => [...parsed].map((item) => schema.json(item, opts)),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "set.ts",
                        "type": "file",
                      },
                    ],
                    "name": "set",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export function discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string>(
  parsedDiscriminant: ParsedDiscriminant,
  rawDiscriminant: RawDiscriminant
): Discriminant<RawDiscriminant, ParsedDiscriminant> {
  return {
    parsedDiscriminant,
    rawDiscriminant,
  };
}

export interface Discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string> {
  parsedDiscriminant: ParsedDiscriminant;
  rawDiscriminant: RawDiscriminant;
}
",
                        "name": "discriminant.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { discriminant, type Discriminant } from \\"./discriminant\\";
export {
  type inferParsedDiscriminant,
  type inferParsedUnion,
  type inferRawDiscriminant,
  type inferRawUnion,
  type UnionSubtypes,
} from \\"./types\\";
export { union } from \\"./union\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsedObject, inferRawObject, ObjectSchema } from \\"../object\\";
import { Discriminant } from \\"./discriminant\\";

export type UnionSubtypes<DiscriminantValues extends string | number | symbol> = {
  [K in DiscriminantValues]: ObjectSchema<any, any>;
};

export type inferRawUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
  [K in keyof U]: Record<inferRawDiscriminant<D>, K> & inferRawObject<U[K]>;
}[keyof U];

export type inferParsedUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
  [K in keyof U]: Record<inferParsedDiscriminant<D>, K> & inferParsedObject<U[K]>;
}[keyof U];

export type inferRawDiscriminant<D extends string | Discriminant<any, any>> = D extends string
  ? D
  : D extends Discriminant<infer Raw, any>
  ? Raw
  : never;

export type inferParsedDiscriminant<D extends string | Discriminant<any, any>> = D extends string
  ? D
  : D extends Discriminant<any, infer Parsed>
  ? Parsed
  : never;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseObjectLikeSchema, getObjectLikeUtils, ObjectLikeSchema, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { Discriminant } from \\"./discriminant\\";
import { inferParsedDiscriminant, inferParsedUnion, inferRawDiscriminant, inferRawUnion, UnionSubtypes } from \\"./types\\";

export function union<D extends string | Discriminant<any, any>, U extends UnionSubtypes<any>>(
  discriminant: D,
  union: U
): ObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> {
  const rawDiscriminant =
    typeof discriminant === \\"string\\" ? discriminant : (discriminant.rawDiscriminant as inferRawDiscriminant<D>);
  const parsedDiscriminant =
    typeof discriminant === \\"string\\" ? discriminant : (discriminant.parsedDiscriminant as inferParsedDiscriminant<D>);

  const baseSchema: BaseObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> = {
    ...OBJECT_LIKE_BRAND,

    parse: (raw, opts) => {
      const { [rawDiscriminant]: discriminantValue, ...additionalProperties } = raw;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [parsedDiscriminant]: discriminantValue,
        } as inferParsedUnion<D, U>;
      }

      return {
        ...additionalPropertySchemas.parse(additionalProperties, opts),
        [parsedDiscriminant]: discriminantValue,
      } as inferParsedUnion<D, U>;
    },

    json: (parsed, opts) => {
      const { [parsedDiscriminant]: discriminantValue, ...additionalProperties } = parsed;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [rawDiscriminant]: discriminantValue,
        } as unknown as inferRawUnion<D, U>;
      }

      return {
        ...additionalPropertySchemas.json(additionalProperties, opts),
        [rawDiscriminant]: discriminantValue,
      } as inferRawUnion<D, U>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
  };
}
",
                        "name": "union.ts",
                        "type": "file",
                      },
                    ],
                    "name": "union",
                    "type": "directory",
                  },
                ],
                "name": "builders",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./builders\\";
export { type inferParsed, type inferRaw, type Schema, type SchemaOptions } from \\"./Schema\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export type addQuestionMarksToNullableProperties<T> = {
  [K in OptionalKeys<T>]?: undefined extends T[K] ? T[K] : never;
} & Pick<T, RequiredKeys<T>>;

export type OptionalKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? K : never;
}[keyof T];

export type RequiredKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? never : K;
}[keyof T];
",
                    "name": "addQuestionMarksToNullableProperties.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function entries<T>(object: T): [keyof T, T[keyof T]][] {
  return Object.entries(object) as [keyof T, T[keyof T]][];
}
",
                    "name": "entries.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function keys<T>(object: T): (keyof T)[] {
  return Object.keys(object) as (keyof T)[];
}
",
                    "name": "keys.ts",
                    "type": "file",
                  },
                ],
                "name": "utils",
                "type": "directory",
              },
            ],
            "name": "schemas",
            "type": "directory",
          },
        ],
        "name": "core",
        "type": "directory",
      },
      Object {
        "contents": "export * as FernApi from \\"./resources\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * as package_ from \\"./package\\";
export * from \\"./package/types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface Package {
  name: string;
}
",
                    "name": "Package.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./Package\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "package",
            "type": "directory",
          },
        ],
        "name": "resources",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": "export * as package_ from \\"./package\\";
export * from \\"./package/types\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { FernApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Package: core.schemas.ObjectSchema<Package.Raw, FernApi.Package> = core.schemas.object({
  name: core.schemas.string(),
});

export declare namespace Package {
  interface Raw {
    name: string;
  }
}
",
                    "name": "Package.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./Package\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "package",
            "type": "directory",
          },
        ],
        "name": "serialization",
        "type": "directory",
      },
    ],
    "name": "src",
    "type": "directory",
  },
  Object {
    "contents": "{
    \\"compilerOptions\\": {
        \\"strict\\": true,
        \\"target\\": \\"esnext\\",
        \\"moduleResolution\\": \\"node\\",
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"sourceMap\\": true,
        \\"emitDeclarationOnly\\": true,
        \\"esModuleInterop\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true,
        \\"declarationDir\\": \\".\\",
        \\"rootDir\\": \\"src\\"
    },
    \\"include\\": [
        \\"src\\"
    ],
    \\"exclude\\": []
}",
    "name": "tsconfig.json",
    "type": "file",
  },
]
`;

exports[`runGenerator trace 1`] = `
Array [
  Object {
    "contents": "node_modules
.DS_Store
*.d.ts
*.js
*.js.map

# yarn berry
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions

# these are needed to override '*.js' above
!.yarn/patches/**
!.yarn/plugins/**
!.yarn/releases/**
!.yarn/sdks/**
!.yarn/versions/**",
    "name": ".gitignore",
    "type": "file",
  },
  Object {
    "contents": "registry=https://registry.npmjs.org/
",
    "name": ".npmrc",
    "type": "file",
  },
  Object {
    "contents": ".yarn
node_modules
.npmignore
.pnp.cjs
*.js
*.d.ts",
    "name": ".prettierignore",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "{
  \\"recommendations\\": [
    \\"arcanis.vscode-zipfs\\",
    \\"esbenp.prettier-vscode\\"
  ]
}
",
        "name": "extensions.json",
        "type": "file",
      },
      Object {
        "contents": "{
  \\"search.exclude\\": {
    \\"**/.yarn\\": true,
    \\"**/.pnp.*\\": true
  },
  \\"prettier.prettierPath\\": \\".yarn/sdks/prettier/index.js\\",
  \\"typescript.tsdk\\": \\".yarn/sdks/typescript/lib\\",
  \\"typescript.enablePromptUseWorkspaceTsdk\\": true
}
",
        "name": "settings.json",
        "type": "file",
      },
    ],
    "name": ".vscode",
    "type": "directory",
  },
  Object {
    "contents": "nodeLinker: pnp

yarnPath: .yarn/releases/yarn-3.2.4.cjs
",
    "name": ".yarnrc.yml",
    "type": "file",
  },
  Object {
    "contents": "{
    \\"name\\": \\"@fern-trace/api-sdk\\",
    \\"version\\": \\"\\",
    \\"files\\": [
        \\"core\\",
        \\"resources\\",
        \\"serialization\\",
        \\"client\\",
        \\"*.{js,js.map,d.ts}\\"
    ],
    \\"main\\": \\"./index.js\\",
    \\"types\\": \\"./index.d.ts\\",
    \\"scripts\\": {
        \\"format\\": \\"prettier --write --print-width 120 'src/**/*.ts'\\",
        \\"build\\": \\"esbuild $(find src -name '*.ts') --format=cjs --sourcemap --outdir=. && tsc\\"
    },
    \\"dependencies\\": {
        \\"@types/basic-auth\\": \\"^1.1.3\\",
        \\"@types/url-join\\": \\"4.0.1\\",
        \\"axios\\": \\"^0.27.2\\",
        \\"basic-auth\\": \\"^2.0.1\\",
        \\"js-base64\\": \\"^3.7.2\\",
        \\"url-join\\": \\"4.0.1\\"
    },
    \\"devDependencies\\": {
        \\"@types/node\\": \\"17.0.33\\",
        \\"esbuild\\": \\"0.14.47\\",
        \\"prettier\\": \\"2.7.1\\",
        \\"typescript\\": \\"4.6.4\\"
    },
    \\"packageManager\\": \\"yarn@3.2.4\\"
}
",
    "name": "package.json",
    "type": "file",
  },
  Object {
    "contents": Array [
      Object {
        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as environments from \\"./environments\\";
import * as core from \\"./core\\";
import { Client as AdminClient } from \\"./resources/admin/client/Client\\";
import { Client as HomepageClient } from \\"./resources/homepage/client/Client\\";
import { Client as MigrationClient } from \\"./resources/migration/client/Client\\";
import { Client as PlaylistClient } from \\"./resources/playlist/client/Client\\";
import { Client as ProblemClient } from \\"./resources/problem/client/Client\\";
import { Client as SubmissionClient } from \\"./resources/submission/client/Client\\";
import { Client as SyspropClient } from \\"./resources/sysprop/client/Client\\";
import { Client as V2Client } from \\"./resources/v2/client/Client\\";

export declare namespace TraceApiClient {
  interface Options {
    environment?: environments.Environment | string;
    auth?: {
      token?: core.Supplier<core.BearerToken>;
    };
  }
}

export class TraceApiClient {
  constructor(private readonly options: TraceApiClient.Options) {}

  #admin: AdminClient | undefined;

  public get admin(): AdminClient {
    return (this.#admin ??= new AdminClient(this.options));
  }

  #homepage: HomepageClient | undefined;

  public get homepage(): HomepageClient {
    return (this.#homepage ??= new HomepageClient(this.options));
  }

  #migration: MigrationClient | undefined;

  public get migration(): MigrationClient {
    return (this.#migration ??= new MigrationClient(this.options));
  }

  #playlist: PlaylistClient | undefined;

  public get playlist(): PlaylistClient {
    return (this.#playlist ??= new PlaylistClient(this.options));
  }

  #problem: ProblemClient | undefined;

  public get problem(): ProblemClient {
    return (this.#problem ??= new ProblemClient(this.options));
  }

  #submission: SubmissionClient | undefined;

  public get submission(): SubmissionClient {
    return (this.#submission ??= new SubmissionClient(this.options));
  }

  #sysprop: SyspropClient | undefined;

  public get sysprop(): SyspropClient {
    return (this.#sysprop ??= new SyspropClient(this.options));
  }

  #v2: V2Client | undefined;

  public get v2(): V2Client {
    return (this.#v2 ??= new V2Client(this.options));
  }
}
",
        "name": "Client.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": "import { parse } from \\"basic-auth\\";
import { Base64 } from \\"js-base64\\";

export interface BasicAuth {
  username: string;
  password: string;
}

export const BasicAuth = {
  toAuthorizationHeader: (basicAuth: BasicAuth | undefined): string | undefined => {
    if (basicAuth == null) {
      return undefined;
    }
    const token = Base64.encode(\`\${basicAuth.username}:\${basicAuth.password}\`);
    return \`Basic \${token}\`;
  },
  fromAuthorizationHeader: (header: string): BasicAuth => {
    const parsed = parse(header);
    if (parsed == null) {
      throw new Error(\\"Invalid basic auth\\");
    }
    return {
      username: parsed.name,
      password: parsed.pass,
    };
  },
};
",
                "name": "BasicAuth.ts",
                "type": "file",
              },
              Object {
                "contents": "export type BearerToken = string;

const BEARER_AUTH_HEADER_PREFIX = /^Bearer /i;

export const BearerToken = {
  toAuthorizationHeader: (token: BearerToken | undefined): string | undefined => {
    if (token == null) {
      return undefined;
    }
    return \`Bearer \${token}\`;
  },
  fromAuthorizationHeader: (header: string): BearerToken => {
    return header.replace(BEARER_AUTH_HEADER_PREFIX, \\"\\").trim() as BearerToken;
  },
};
",
                "name": "BearerToken.ts",
                "type": "file",
              },
              Object {
                "contents": "export { BasicAuth } from \\"./BasicAuth\\";
export { BearerToken } from \\"./BearerToken\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "auth",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export type APIResponse<Success, Failure> = SuccessfulResponse<Success> | FailedResponse<Failure>;

export interface SuccessfulResponse<T> {
  ok: true;
  body: T;
}

export interface FailedResponse<T> {
  ok: false;
  error: T;
}
",
                "name": "APIResponse.ts",
                "type": "file",
              },
              Object {
                "contents": "import axios, { AxiosError } from \\"axios\\";
import { APIResponse } from \\"./APIResponse\\";

export interface Fetcher {
  fetch: FetchFunction;
}

export type FetchFunction = (args: Fetcher.Args) => Promise<APIResponse<unknown, Fetcher.Error>>;

export declare namespace Fetcher {
  export interface Args {
    url: string;
    method: string;
    headers?: Record<string, string | undefined>;
    queryParameters?: URLSearchParams;
    body?: unknown;
    timeoutMs?: number;
  }

  export type Error = FailedStatusCodeError | NonJsonError | TimeoutError | UnknownError;

  export interface FailedStatusCodeError {
    reason: \\"status-code\\";
    statusCode: number;
    body: unknown;
  }

  export interface NonJsonError {
    reason: \\"non-json\\";
    statusCode: number;
    rawBody: string;
  }

  export interface TimeoutError {
    reason: \\"timeout\\";
  }

  export interface UnknownError {
    reason: \\"unknown\\";
    errorMessage: string;
  }
}

export const fetcher: FetchFunction = async (args) => {
  const headers: Record<string, string> = {
    \\"Content-Type\\": \\"application/json\\",
  };

  if (args.headers != null) {
    for (const [key, value] of Object.entries(args.headers)) {
      if (value != null) {
        headers[key] = value;
      }
    }
  }

  try {
    const response = await axios({
      url: args.url,
      params: args.queryParameters,
      method: args.method,
      headers,
      data: args.body,
      validateStatus: () => true,
      transformResponse: (response) => response,
      timeout: args.timeoutMs ?? 60_000,
      transitional: {
        clarifyTimeoutError: true,
      },
    });

    let body: unknown;
    if (response.data != null) {
      try {
        body = JSON.parse(response.data) ?? undefined;
      } catch {
        return {
          ok: false,
          error: {
            reason: \\"non-json\\",
            statusCode: response.status,
            rawBody: response.data,
          },
        };
      }
    }

    if (response.status >= 200 && response.status < 300) {
      return {
        ok: true,
        body,
      };
    } else {
      return {
        ok: false,
        error: {
          reason: \\"status-code\\",
          statusCode: response.status,
          body,
        },
      };
    }
  } catch (error) {
    if ((error as AxiosError).code === \\"ETIMEDOUT\\") {
      return {
        ok: false,
        error: {
          reason: \\"timeout\\",
        },
      };
    }

    return {
      ok: false,
      error: {
        reason: \\"unknown\\",
        errorMessage: (error as AxiosError).message,
      },
    };
  }
};
",
                "name": "Fetcher.ts",
                "type": "file",
              },
              Object {
                "contents": "export type Supplier<T> = T | Promise<T> | (() => T | Promise<T>);

export const Supplier = {
  get: async <T>(supplier: Supplier<T>): Promise<T> => {
    if (typeof supplier === \\"function\\") {
      return (supplier as () => T)();
    } else {
      return supplier;
    }
  },
};
",
                "name": "Supplier.ts",
                "type": "file",
              },
              Object {
                "contents": "export { type APIResponse } from \\"./APIResponse\\";
export { fetcher, type Fetcher, type FetchFunction } from \\"./Fetcher\\";
export { Supplier } from \\"./Supplier\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "fetcher",
            "type": "directory",
          },
          Object {
            "contents": "export * as schemas from \\"./schemas\\";
export * from \\"./utils\\";
export * from \\"./fetcher\\";
export * from \\"./auth\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "import { SchemaUtils } from \\"./builders\\";

export type Schema<Raw = unknown, Parsed = unknown> = BaseSchema<Raw, Parsed> & SchemaUtils<Raw, Parsed>;

export type inferRaw<S extends Schema> = S extends Schema<infer Raw, any> ? Raw : never;
export type inferParsed<S extends Schema> = S extends Schema<any, infer Parsed> ? Parsed : never;

export interface BaseSchema<Raw, Parsed> {
  parse: (raw: Raw, opts?: SchemaOptions) => Parsed;
  json: (parsed: Parsed, opts?: SchemaOptions) => Raw;
}

export interface SchemaOptions {
  /**
   * @default false
   */
  skipUnknownKeysOnParse?: boolean;

  /**
   * @default false
   */
  includeUnknownKeysOnJson?: boolean;
}
",
                "name": "Schema.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function date(): Schema<string, Date> {
  const baseSchema: BaseSchema<string, Date> = {
    parse: (raw) => new Date(raw),
    json: (date) => date.toISOString(),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "date.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { date } from \\"./date\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "date",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function enum_<U extends string, E extends Readonly<[U, ...U[]]>>(_values: E): Schema<E[number], E[number]> {
  return createIdentitySchemaCreator<E[number]>()();
}
",
                        "name": "enum.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { enum_ } from \\"./enum\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "enum",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { identity } from \\"./identity\\";

export function createIdentitySchemaCreator<T>(): () => Schema<T, T> {
  return <T>() => identity<T>();
}
",
                        "name": "createIdentitySchemaCreator.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function identity<T>(): Schema<T, T> {
  const baseSchema: BaseSchema<T, T> = {
    parse: (raw) => raw,
    json: (parsed) => parsed,
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "identity.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { createIdentitySchemaCreator } from \\"./createIdentitySchemaCreator\\";
export { identity } from \\"./identity\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                    ],
                    "name": "identity",
                    "type": "directory",
                  },
                  Object {
                    "contents": "export * from \\"./date\\";
export * from \\"./enum\\";
export * from \\"./identity\\";
export * from \\"./lazy\\";
export * from \\"./list\\";
export * from \\"./literals\\";
export * from \\"./object\\";
export * from \\"./object-like\\";
export * from \\"./primitives\\";
export * from \\"./record\\";
export * from \\"./schema-utils\\";
export * from \\"./set\\";
export * from \\"./union\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { lazy } from \\"./lazy\\";
export { lazyObject } from \\"./lazyObject\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

type Getter<Raw, Parsed> = () => Schema<Raw, Parsed>;
type MemoizedGetter<Raw, Parsed> = Getter<Raw, Parsed> & { __zurg_memoized?: Schema<Raw, Parsed> };

export function lazy<Raw, Parsed>(getter: Getter<Raw, Parsed>): Schema<Raw, Parsed> {
  const baseSchema = constructLazyBaseSchema(getter);
  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function constructLazyBaseSchema<Raw, Parsed>(getter: Getter<Raw, Parsed>): BaseSchema<Raw, Parsed> {
  const getSchema = () => {
    const castedGetter = getter as MemoizedGetter<Raw, Parsed>;
    if (castedGetter.__zurg_memoized == null) {
      castedGetter.__zurg_memoized = getter();
    }
    return castedGetter.__zurg_memoized;
  };

  return {
    parse: (raw) => getSchema().parse(raw),
    json: (parsed) => getSchema().json(parsed),
  };
}
",
                        "name": "lazy.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { getObjectUtils } from \\"../object\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { ObjectSchema } from \\"../object/types\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { constructLazyBaseSchema } from \\"./lazy\\";

export function lazyObject<Raw, Parsed>(getter: () => ObjectSchema<Raw, Parsed>): ObjectSchema<Raw, Parsed> {
  const baseSchema = {
    ...OBJECT_LIKE_BRAND,
    ...constructLazyBaseSchema(getter),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}
",
                        "name": "lazyObject.ts",
                        "type": "file",
                      },
                    ],
                    "name": "lazy",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { list } from \\"./list\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function list<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Parsed[]> {
  const baseSchema: BaseSchema<Raw[], Parsed[]> = {
    parse: (raw, opts) => raw.map((item) => schema.parse(item, opts)),
    json: (parsed, opts) => parsed.map((item) => schema.json(item, opts)),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "list.ts",
                        "type": "file",
                      },
                    ],
                    "name": "list",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { stringLiteral } from \\"./stringLiteral\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { createIdentitySchemaCreator } from \\"../identity\\";

export function stringLiteral<V extends string>(_value: V): Schema<V, V> {
  return createIdentitySchemaCreator<V>()();
}
",
                        "name": "stringLiteral.ts",
                        "type": "file",
                      },
                    ],
                    "name": "literals",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { getObjectUtils, object } from \\"./object\\";
export { isProperty, property, type Property } from \\"./property\\";
export {
  type BaseObjectSchema,
  type inferObjectSchemaFromPropertySchemas,
  type inferParsedObject,
  type inferParsedObjectFromPropertySchemas,
  type inferParsedPropertySchema,
  type inferRawKey,
  type inferRawObject,
  type inferRawObjectFromPropertySchemas,
  type inferRawPropertySchema,
  type ObjectSchema,
  type ObjectUtils,
  type PropertySchemas,
} from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { isProperty } from \\"./property\\";
import {
  BaseObjectSchema,
  inferObjectSchemaFromPropertySchemas,
  inferParsedObjectFromPropertySchemas,
  inferRawObjectFromPropertySchemas,
  ObjectSchema,
  ObjectUtils,
  PropertySchemas,
} from \\"./types\\";

interface ObjectPropertyWithRawKey {
  rawKey: string;
  parsedKey: string | number | symbol;
  valueSchema: Schema<any, any>;
}

export function object<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(
  schemas: T
): inferObjectSchemaFromPropertySchemas<T> {
  const baseSchema: BaseObjectSchema<inferRawObjectFromPropertySchemas<T>, inferParsedObjectFromPropertySchemas<T>> = {
    ...OBJECT_LIKE_BRAND,

    parse: (raw, { skipUnknownKeysOnParse = false } = {}) => {
      const rawKeyToProperty: Record<string, ObjectPropertyWithRawKey> = {};

      for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {
        const rawKey = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;

        const property: ObjectPropertyWithRawKey = {
          rawKey,
          parsedKey,
          valueSchema: isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.valueSchema : schemaOrObjectProperty,
        };

        rawKeyToProperty[rawKey] = property;
      }

      const parsed: Record<string | number | symbol, any> = {};

      for (const [rawKey, rawPropertyValue] of Object.entries(raw)) {
        const property = rawKeyToProperty[rawKey];

        if (property != null) {
          const value = property.valueSchema.parse(rawPropertyValue);
          parsed[property.parsedKey] = value;
        } else if (!skipUnknownKeysOnParse && rawPropertyValue != null) {
          parsed[rawKey] = rawPropertyValue;
        }
      }

      return parsed as inferParsedObjectFromPropertySchemas<T>;
    },

    json: (parsed, { includeUnknownKeysOnJson = false } = {}) => {
      const raw: Record<string | number | symbol, any> = {};

      for (const [parsedKey, parsedPropertyValue] of entries(parsed)) {
        const schemaOrObjectProperty = schemas[parsedKey as keyof T];
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (schemaOrObjectProperty != null) {
          if (isProperty(schemaOrObjectProperty)) {
            const value = schemaOrObjectProperty.valueSchema.json(parsedPropertyValue);
            raw[schemaOrObjectProperty.rawKey] = value;
          } else {
            const value = schemaOrObjectProperty.json(parsedPropertyValue);
            raw[parsedKey] = value;
          }
        } else if (includeUnknownKeysOnJson && parsedPropertyValue != null) {
          raw[parsedKey] = parsedPropertyValue;
        }
      }

      return raw as inferRawObjectFromPropertySchemas<T>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
    ...getObjectUtils(baseSchema),
  };
}

export function getObjectUtils<Raw, Parsed>(schema: BaseObjectSchema<Raw, Parsed>): ObjectUtils<Raw, Parsed> {
  return {
    extend: <RawExtension, ParsedExtension>(extension: ObjectSchema<RawExtension, ParsedExtension>) => {
      const baseSchema: BaseObjectSchema<Raw & RawExtension, Parsed & ParsedExtension> = {
        ...OBJECT_LIKE_BRAND,
        parse: (raw, opts) => ({
          ...schema.parse(raw, opts),
          ...extension.parse(raw, opts),
        }),
        json: (parsed, opts) => ({
          ...schema.json(parsed, opts),
          ...extension.json(parsed, opts),
        }),
      };

      return {
        ...baseSchema,
        ...getSchemaUtils(baseSchema),
        ...getObjectLikeUtils(baseSchema),
        ...getObjectUtils(baseSchema),
      };
    },
  };
}
",
                        "name": "object.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export function property<RawKey extends string, RawValue, ParsedValue>(
  rawKey: RawKey,
  valueSchema: Schema<RawValue, ParsedValue>
): Property<RawKey, RawValue, ParsedValue> {
  return {
    rawKey,
    valueSchema,
    isProperty: true,
  };
}

export interface Property<RawKey extends string, RawValue, ParsedValue> {
  rawKey: RawKey;
  valueSchema: Schema<RawValue, ParsedValue>;
  isProperty: true;
}

export function isProperty<O extends Property<any, any, any>>(maybeProperty: unknown): maybeProperty is O {
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return (maybeProperty as O).isProperty;
}
",
                        "name": "property.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsed, inferRaw, Schema } from \\"../../Schema\\";
import { addQuestionMarksToNullableProperties } from \\"../../utils/addQuestionMarksToNullableProperties\\";
import { BaseObjectLikeSchema, ObjectLikeSchema } from \\"../object-like\\";
import { Property } from \\"./property\\";

export type ObjectSchema<Raw, Parsed> = BaseObjectSchema<Raw, Parsed> &
  ObjectLikeSchema<Raw, Parsed> &
  ObjectUtils<Raw, Parsed>;

export type BaseObjectSchema<Raw, Parsed> = BaseObjectLikeSchema<Raw, Parsed>;

export interface ObjectUtils<Raw, Parsed> {
  extend: <RawExtension, ParsedExtension>(
    schemas: ObjectSchema<RawExtension, ParsedExtension>
  ) => ObjectSchema<Raw & RawExtension, Parsed & ParsedExtension>;
}

export type inferRawObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<infer Raw, any> ? Raw : never;

export type inferParsedObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<any, infer Parsed>
  ? Parsed
  : never;

export type inferObjectSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> = ObjectSchema<
  inferRawObjectFromPropertySchemas<T>,
  inferParsedObjectFromPropertySchemas<T>
>;

export type inferRawObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
  addQuestionMarksToNullableProperties<{
    [ParsedKey in keyof T as inferRawKey<ParsedKey, T[ParsedKey]>]: inferRawPropertySchema<T[ParsedKey]>;
  }>;

export type inferParsedObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =
  addQuestionMarksToNullableProperties<{
    [K in keyof T]: inferParsedPropertySchema<T[K]>;
  }>;

export type PropertySchemas<ParsedKeys extends string | number | symbol> = Record<
  ParsedKeys,
  Property<any, any, any> | Schema<any, any>
>;

export type inferRawPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
  any,
  infer Raw,
  any
>
  ? Raw
  : P extends Schema<any, any>
  ? inferRaw<P>
  : never;

export type inferParsedPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<
  any,
  any,
  infer Parsed
>
  ? Parsed
  : P extends Schema<any, any>
  ? inferParsed<P>
  : never;

export type inferRawKey<
  ParsedKey extends string | number | symbol,
  P extends Property<any, any, any> | Schema<any, any>
> = P extends Property<infer Raw, any, any> ? Raw : ParsedKey;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseObjectLikeSchema, ObjectLikeUtils } from \\"./types\\";
import { withProperties } from \\"./withProperties\\";

export function getObjectLikeUtils<Raw, Parsed>(
  schema: BaseObjectLikeSchema<Raw, Parsed>
): ObjectLikeUtils<Raw, Parsed> {
  return {
    withProperties: (properties) => withProperties(schema, properties),
  };
}
",
                        "name": "getObjectLikeUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getObjectLikeUtils } from \\"./getObjectLikeUtils\\";
export { OBJECT_LIKE_BRAND, type BaseObjectLikeSchema, type ObjectLikeSchema, type ObjectLikeUtils } from \\"./types\\";
export { withProperties } from \\"./withProperties\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";

export type ObjectLikeSchema<Raw, Parsed> = Schema<Raw, Parsed> &
  BaseObjectLikeSchema<Raw, Parsed> &
  ObjectLikeUtils<Raw, Parsed>;

export type BaseObjectLikeSchema<Raw, Parsed> = BaseSchema<Raw, Parsed> & {
  _objectLike: void;
};

export interface ObjectLikeUtils<Raw, Parsed> {
  withProperties: <T extends Record<string, any>>(properties: {
    [K in keyof T]: T[K] | ((parsed: Parsed) => T[K]);
  }) => ObjectLikeSchema<Raw, Parsed & T>;
}

export const OBJECT_LIKE_BRAND = undefined as unknown as { _objectLike: void };
",
                        "name": "types.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { getSchemaUtils } from \\"../schema-utils\\";
import { getObjectLikeUtils } from \\"./getObjectLikeUtils\\";
import { BaseObjectLikeSchema, ObjectLikeSchema, OBJECT_LIKE_BRAND } from \\"./types\\";

export function withProperties<RawObjectShape, ParsedObjectShape, Properties>(
  objectLike: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape>,
  properties: { [K in keyof Properties]: Properties[K] | ((parsed: ParsedObjectShape) => Properties[K]) }
): ObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> {
  const objectSchema: BaseObjectLikeSchema<RawObjectShape, ParsedObjectShape & Properties> = {
    ...OBJECT_LIKE_BRAND,
    parse: (raw, opts) => {
      const parsedObject = objectLike.parse(raw, opts);
      const additionalProperties = Object.entries(properties).reduce<Record<string, any>>((processed, [key, value]) => {
        return {
          ...processed,
          [key]: typeof value === \\"function\\" ? value(parsedObject) : value,
        };
      }, {});

      return {
        ...parsedObject,
        ...(additionalProperties as Properties),
      };
    },
    json: (parsed, opts) => {
      // strip out added properties
      const addedPropertyKeys = new Set(Object.keys(properties));
      const parsedWithoutAddedProperties = Object.entries(parsed).reduce<Record<string, any>>(
        (filtered, [key, value]) => {
          if (!addedPropertyKeys.has(key)) {
            filtered[key] = value;
          }
          return filtered;
        },
        {}
      );

      return objectLike.json(parsedWithoutAddedProperties as ParsedObjectShape, opts);
    },
  };

  return {
    ...objectSchema,
    ...getSchemaUtils(objectSchema),
    ...getObjectLikeUtils(objectSchema),
  };
}
",
                        "name": "withProperties.ts",
                        "type": "file",
                      },
                    ],
                    "name": "object-like",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const any = createIdentitySchemaCreator<any>();
",
                        "name": "any.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const boolean = createIdentitySchemaCreator<boolean>();
",
                        "name": "boolean.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { any } from \\"./any\\";
export { boolean } from \\"./boolean\\";
export { number } from \\"./number\\";
export { string } from \\"./string\\";
export { unknown } from \\"./unknown\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const number = createIdentitySchemaCreator<number>();
",
                        "name": "number.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const string = createIdentitySchemaCreator<string>();
",
                        "name": "string.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { createIdentitySchemaCreator } from \\"../identity\\";

export const unknown = createIdentitySchemaCreator<unknown>();
",
                        "name": "unknown.ts",
                        "type": "file",
                      },
                    ],
                    "name": "primitives",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { record } from \\"./record\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { entries } from \\"../../utils/entries\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function record<RawKey extends string | number, ParsedKey extends string | number, RawValue, ParsedValue>(
  keySchema: Schema<RawKey, ParsedKey>,
  valueSchema: Schema<RawValue, ParsedValue>
): Schema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> {
  const baseSchema: BaseSchema<Record<RawKey, RawValue>, Record<ParsedKey, ParsedValue>> = {
    parse: (raw, opts) => {
      return entries(raw).reduce(
        (parsed, [key, value]) => {
          parsed[keySchema.parse(key, opts)] = valueSchema.parse(value, opts);
          return parsed;
        },
        // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
        {} as Record<ParsedKey, ParsedValue>
      );
    },
    json: (parsed, opts) => {
      return entries(parsed).reduce(
        (raw, [key, value]) => {
          raw[keySchema.json(key, opts)] = valueSchema.json(value, opts);
          return raw;
        },
        // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
        {} as Record<RawKey, RawValue>
      );
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "record.ts",
                        "type": "file",
                      },
                    ],
                    "name": "record",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { OptionalSchema, OPTIONAL_BRAND } from \\"./types\\";

export interface SchemaUtils<Raw, Parsed> {
  optional: () => OptionalSchema<Raw, Parsed>;
  transform: <PostTransform>(transformer: BaseSchema<Parsed, PostTransform>) => Schema<Raw, PostTransform>;
}

export function getSchemaUtils<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): SchemaUtils<Raw, Parsed> {
  return {
    optional: () => optional(schema),
    transform: (transformer) => transform(schema, transformer),
  };
}

/**
 * schema utils are defined in one file to resolve issues with circular imports
 */

export function optional<Raw, Parsed>(schema: BaseSchema<Raw, Parsed>): OptionalSchema<Raw, Parsed> {
  const baseSchema: BaseSchema<Raw | null | undefined, Parsed | undefined> = {
    parse: (raw, opts) => (raw != null ? schema.parse(raw, opts) : undefined),
    json: (parsed, opts) => (parsed != null ? schema.json(parsed, opts) : undefined),
  };

  return {
    ...OPTIONAL_BRAND,
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}

export function transform<PreTransformRaw, PreTransformParsed, PostTransform>(
  schema: BaseSchema<PreTransformRaw, PreTransformParsed>,
  transformer: BaseSchema<PreTransformParsed, PostTransform>
): Schema<PreTransformRaw, PostTransform> {
  const baseSchema: BaseSchema<PreTransformRaw, PostTransform> = {
    parse: (raw, opts) => {
      const postTransformParsed = schema.parse(raw, opts);
      return transformer.parse(postTransformParsed, opts);
    },
    json: (parsed, opts) => {
      const preTransformParsed = transformer.json(parsed, opts);
      return schema.json(preTransformParsed, opts);
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "getSchemaUtils.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { getSchemaUtils, optional, transform, type SchemaUtils } from \\"./getSchemaUtils\\";
export { OPTIONAL_BRAND, type OptionalSchema } from \\"./types\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { Schema } from \\"../../Schema\\";

export const OPTIONAL_BRAND = undefined as unknown as { _isOptional: void };

export type OptionalSchema<Raw, Parsed> = Schema<Raw | null | undefined, Parsed | undefined> & {
  _isOptional: void;
};
",
                        "name": "types.ts",
                        "type": "file",
                      },
                    ],
                    "name": "schema-utils",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export { set } from \\"./set\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseSchema, Schema } from \\"../../Schema\\";
import { getSchemaUtils } from \\"../schema-utils\\";

export function set<Raw, Parsed>(schema: Schema<Raw, Parsed>): Schema<Raw[], Set<Parsed>> {
  const baseSchema: BaseSchema<Raw[], Set<Parsed>> = {
    parse: (raw, opts) => new Set(raw.map((item) => schema.parse(item, opts))),
    json: (parsed, opts) => [...parsed].map((item) => schema.json(item, opts)),
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
  };
}
",
                        "name": "set.ts",
                        "type": "file",
                      },
                    ],
                    "name": "set",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export function discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string>(
  parsedDiscriminant: ParsedDiscriminant,
  rawDiscriminant: RawDiscriminant
): Discriminant<RawDiscriminant, ParsedDiscriminant> {
  return {
    parsedDiscriminant,
    rawDiscriminant,
  };
}

export interface Discriminant<RawDiscriminant extends string, ParsedDiscriminant extends string> {
  parsedDiscriminant: ParsedDiscriminant;
  rawDiscriminant: RawDiscriminant;
}
",
                        "name": "discriminant.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "export { discriminant, type Discriminant } from \\"./discriminant\\";
export {
  type inferParsedDiscriminant,
  type inferParsedUnion,
  type inferRawDiscriminant,
  type inferRawUnion,
  type UnionSubtypes,
} from \\"./types\\";
export { union } from \\"./union\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { inferParsedObject, inferRawObject, ObjectSchema } from \\"../object\\";
import { Discriminant } from \\"./discriminant\\";

export type UnionSubtypes<DiscriminantValues extends string | number | symbol> = {
  [K in DiscriminantValues]: ObjectSchema<any, any>;
};

export type inferRawUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
  [K in keyof U]: Record<inferRawDiscriminant<D>, K> & inferRawObject<U[K]>;
}[keyof U];

export type inferParsedUnion<D extends string | Discriminant<any, any>, U extends UnionSubtypes<keyof U>> = {
  [K in keyof U]: Record<inferParsedDiscriminant<D>, K> & inferParsedObject<U[K]>;
}[keyof U];

export type inferRawDiscriminant<D extends string | Discriminant<any, any>> = D extends string
  ? D
  : D extends Discriminant<infer Raw, any>
  ? Raw
  : never;

export type inferParsedDiscriminant<D extends string | Discriminant<any, any>> = D extends string
  ? D
  : D extends Discriminant<any, infer Parsed>
  ? Parsed
  : never;
",
                        "name": "types.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": "import { BaseObjectLikeSchema, getObjectLikeUtils, ObjectLikeSchema, OBJECT_LIKE_BRAND } from \\"../object-like\\";
import { getSchemaUtils } from \\"../schema-utils\\";
import { Discriminant } from \\"./discriminant\\";
import { inferParsedDiscriminant, inferParsedUnion, inferRawDiscriminant, inferRawUnion, UnionSubtypes } from \\"./types\\";

export function union<D extends string | Discriminant<any, any>, U extends UnionSubtypes<any>>(
  discriminant: D,
  union: U
): ObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> {
  const rawDiscriminant =
    typeof discriminant === \\"string\\" ? discriminant : (discriminant.rawDiscriminant as inferRawDiscriminant<D>);
  const parsedDiscriminant =
    typeof discriminant === \\"string\\" ? discriminant : (discriminant.parsedDiscriminant as inferParsedDiscriminant<D>);

  const baseSchema: BaseObjectLikeSchema<inferRawUnion<D, U>, inferParsedUnion<D, U>> = {
    ...OBJECT_LIKE_BRAND,

    parse: (raw, opts) => {
      const { [rawDiscriminant]: discriminantValue, ...additionalProperties } = raw;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [parsedDiscriminant]: discriminantValue,
        } as inferParsedUnion<D, U>;
      }

      return {
        ...additionalPropertySchemas.parse(additionalProperties, opts),
        [parsedDiscriminant]: discriminantValue,
      } as inferParsedUnion<D, U>;
    },

    json: (parsed, opts) => {
      const { [parsedDiscriminant]: discriminantValue, ...additionalProperties } = parsed;
      const additionalPropertySchemas = union[discriminantValue];

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (additionalPropertySchemas == null) {
        return {
          ...additionalProperties,
          [rawDiscriminant]: discriminantValue,
        } as unknown as inferRawUnion<D, U>;
      }

      return {
        ...additionalPropertySchemas.json(additionalProperties, opts),
        [rawDiscriminant]: discriminantValue,
      } as inferRawUnion<D, U>;
    },
  };

  return {
    ...baseSchema,
    ...getSchemaUtils(baseSchema),
    ...getObjectLikeUtils(baseSchema),
  };
}
",
                        "name": "union.ts",
                        "type": "file",
                      },
                    ],
                    "name": "union",
                    "type": "directory",
                  },
                ],
                "name": "builders",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./builders\\";
export { type inferParsed, type inferRaw, type Schema, type SchemaOptions } from \\"./Schema\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export type addQuestionMarksToNullableProperties<T> = {
  [K in OptionalKeys<T>]?: undefined extends T[K] ? T[K] : never;
} & Pick<T, RequiredKeys<T>>;

export type OptionalKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? K : never;
}[keyof T];

export type RequiredKeys<T> = {
  [K in keyof T]: undefined extends T[K] ? never : K;
}[keyof T];
",
                    "name": "addQuestionMarksToNullableProperties.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function entries<T>(object: T): [keyof T, T[keyof T]][] {
  return Object.entries(object) as [keyof T, T[keyof T]][];
}
",
                    "name": "entries.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export function keys<T>(object: T): (keyof T)[] {
  return Object.keys(object) as (keyof T)[];
}
",
                    "name": "keys.ts",
                    "type": "file",
                  },
                ],
                "name": "utils",
                "type": "directory",
              },
            ],
            "name": "schemas",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export function addNonEnumerableProperty<T, K extends string, V>(object: T, key: K, value: V): T & Record<K, V> {
  const copy = { ...object };
  Object.defineProperty(copy, key, {
    enumerable: false,
    writable: true,
  });
  (copy as any)[key] = value;
  return copy as T & Record<K, V>;
}
",
                "name": "addNonEnumerableProperty.ts",
                "type": "file",
              },
              Object {
                "contents": "export { addNonEnumerableProperty } from \\"./addNonEnumerableProperty\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "utils",
            "type": "directory",
          },
        ],
        "name": "core",
        "type": "directory",
      },
      Object {
        "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export const Environment = {
  Prod: \\"prod.trace.com\\",
  /**
   * i'm staging
   */
  Staging: \\"staging.trace.com\\",
} as const;

export type Environment = typeof Environment.Prod | typeof Environment.Staging;
",
        "name": "environments.ts",
        "type": "file",
      },
      Object {
        "contents": "export * as TraceApi from \\"./resources\\";
export { TraceApiClient } from \\"./Client\\";
",
        "name": "index.ts",
        "type": "file",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    auth?: {
      token?: core.Supplier<core.BearerToken>;
    };
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async updateTestSubmissionStatus(
    request: TraceApi.admin.updateTestSubmissionStatus.Request
  ): Promise<TraceApi.admin.updateTestSubmissionStatus.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-test-submission-status/\${request.submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
      body: serializers.TestSubmissionStatus.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async sendTestSubmissionUpdate(
    request: TraceApi.admin.sendTestSubmissionUpdate.Request
  ): Promise<TraceApi.admin.sendTestSubmissionUpdate.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-test-submission-status-v2/\${request.submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
      body: serializers.TestSubmissionUpdate.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async updateWorkspaceSubmissionStatus(
    request: TraceApi.admin.updateWorkspaceSubmissionStatus.Request
  ): Promise<TraceApi.admin.updateWorkspaceSubmissionStatus.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-workspace-submission-status/\${request.submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
      body: serializers.WorkspaceSubmissionStatus.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async sendWorkspaceSubmissionUpdate(
    request: TraceApi.admin.sendWorkspaceSubmissionUpdate.Request
  ): Promise<TraceApi.admin.sendWorkspaceSubmissionUpdate.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-workspace-submission-status-v2/\${request.submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
      body: serializers.WorkspaceSubmissionUpdate.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async storeTracedTestCase(
    request: TraceApi.admin.storeTracedTestCase.Request
  ): Promise<TraceApi.admin.storeTracedTestCase.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-test-trace/submission/\${request.submissionId}/testCase/\${request.testCaseId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
      body: serializers.StoreTracedTestCaseRequest.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async storeTracedTestCaseV2(
    request: TraceApi.admin.storeTracedTestCaseV2.Request
  ): Promise<TraceApi.admin.storeTracedTestCaseV2.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-test-trace-v2/submission/\${request.submissionId}/testCase/\${request.testCaseId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
      body: serializers.admin.storeTracedTestCaseV2.Request.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async storeTracedWorkspace(
    request: TraceApi.admin.storeTracedWorkspace.Request
  ): Promise<TraceApi.admin.storeTracedWorkspace.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-workspace-trace/submission/\${request.submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
      body: serializers.StoreTracedWorkspaceRequest.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async storeTracedWorkspaceV2(
    request: TraceApi.admin.storeTracedWorkspaceV2.Request
  ): Promise<TraceApi.admin.storeTracedWorkspaceV2.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/admin/store-workspace-trace-v2/submission/\${request.submissionId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
      body: serializers.admin.storeTracedWorkspaceV2.Request.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as updateTestSubmissionStatus from \\"./updateTestSubmissionStatus\\";
export * as sendTestSubmissionUpdate from \\"./sendTestSubmissionUpdate\\";
export * as updateWorkspaceSubmissionStatus from \\"./updateWorkspaceSubmissionStatus\\";
export * as sendWorkspaceSubmissionUpdate from \\"./sendWorkspaceSubmissionUpdate\\";
export * as storeTracedTestCase from \\"./storeTracedTestCase\\";
export * as storeTracedTestCaseV2 from \\"./storeTracedTestCaseV2\\";
export * as storeTracedWorkspace from \\"./storeTracedWorkspace\\";
export * as storeTracedWorkspaceV2 from \\"./storeTracedWorkspaceV2\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  submissionId: TraceApi.SubmissionId;
  _body: TraceApi.TestSubmissionUpdate;
}

export type Response = core.APIResponse<void, TraceApi.admin.sendTestSubmissionUpdate.Error>;
export type Error = TraceApi.admin.sendTestSubmissionUpdate.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.admin.sendTestSubmissionUpdate.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                    "name": "sendTestSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  submissionId: TraceApi.SubmissionId;
  _body: TraceApi.WorkspaceSubmissionUpdate;
}

export type Response = core.APIResponse<void, TraceApi.admin.sendWorkspaceSubmissionUpdate.Error>;
export type Error = TraceApi.admin.sendWorkspaceSubmissionUpdate.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.admin.sendWorkspaceSubmissionUpdate.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                    "name": "sendWorkspaceSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  submissionId: TraceApi.SubmissionId;
  testCaseId: string;
  _body: TraceApi.StoreTracedTestCaseRequest;
}

export type Response = core.APIResponse<void, TraceApi.admin.storeTracedTestCase.Error>;
export type Error = TraceApi.admin.storeTracedTestCase.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.admin.storeTracedTestCase.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                    "name": "storeTracedTestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  submissionId: TraceApi.SubmissionId;
  testCaseId: TraceApi.v2.TestCaseId;
  _body: TraceApi.TraceResponseV2[];
}

export type Response = core.APIResponse<void, TraceApi.admin.storeTracedTestCaseV2.Error>;
export type Error = TraceApi.admin.storeTracedTestCaseV2.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.admin.storeTracedTestCaseV2.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                    "name": "storeTracedTestCaseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  submissionId: TraceApi.SubmissionId;
  _body: TraceApi.StoreTracedWorkspaceRequest;
}

export type Response = core.APIResponse<void, TraceApi.admin.storeTracedWorkspace.Error>;
export type Error = TraceApi.admin.storeTracedWorkspace.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.admin.storeTracedWorkspace.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                    "name": "storeTracedWorkspace.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  submissionId: TraceApi.SubmissionId;
  _body: TraceApi.TraceResponseV2[];
}

export type Response = core.APIResponse<void, TraceApi.admin.storeTracedWorkspaceV2.Error>;
export type Error = TraceApi.admin.storeTracedWorkspaceV2.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.admin.storeTracedWorkspaceV2.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                    "name": "storeTracedWorkspaceV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  submissionId: TraceApi.SubmissionId;
  _body: TraceApi.TestSubmissionStatus;
}

export type Response = core.APIResponse<void, TraceApi.admin.updateTestSubmissionStatus.Error>;
export type Error = TraceApi.admin.updateTestSubmissionStatus.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.admin.updateTestSubmissionStatus.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                    "name": "updateTestSubmissionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  submissionId: TraceApi.SubmissionId;
  _body: TraceApi.WorkspaceSubmissionStatus;
}

export type Response = core.APIResponse<void, TraceApi.admin.updateWorkspaceSubmissionStatus.Error>;
export type Error = TraceApi.admin.updateWorkspaceSubmissionStatus.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.admin.updateWorkspaceSubmissionStatus.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                    "name": "updateWorkspaceSubmissionStatus.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface StoreTracedTestCaseRequest {
  result: TraceApi.TestCaseResultWithStdout;
  traceResponses: TraceApi.TraceResponse[];
}
",
                    "name": "StoreTracedTestCaseRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface StoreTracedWorkspaceRequest {
  workspaceRunDetails: TraceApi.WorkspaceRunDetails;
  traceResponses: TraceApi.TraceResponse[];
}
",
                    "name": "StoreTracedWorkspaceRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./StoreTracedTestCaseRequest\\";
export * from \\"./StoreTracedWorkspaceRequest\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "admin",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface BinaryTreeNodeAndTreeValue {
  nodeId: TraceApi.NodeId;
  fullTree: TraceApi.BinaryTreeValue;
}
",
                    "name": "BinaryTreeNodeAndTreeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface BinaryTreeNodeValue {
  nodeId: TraceApi.NodeId;
  val: number;
  right?: TraceApi.NodeId;
  left?: TraceApi.NodeId;
}
",
                    "name": "BinaryTreeNodeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface BinaryTreeValue {
  root?: TraceApi.NodeId;
  nodes: Record<TraceApi.NodeId, TraceApi.BinaryTreeNodeValue>;
}
",
                    "name": "BinaryTreeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface DebugKeyValuePairs {
  key: TraceApi.DebugVariableValue;
  value: TraceApi.DebugVariableValue;
}
",
                    "name": "DebugKeyValuePairs.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface DebugMapValue {
  keyValuePairs: TraceApi.DebugKeyValuePairs[];
}
",
                    "name": "DebugMapValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type DebugVariableValue =
  | TraceApi.DebugVariableValue.IntegerValue
  | TraceApi.DebugVariableValue.BooleanValue
  | TraceApi.DebugVariableValue.DoubleValue
  | TraceApi.DebugVariableValue.StringValue
  | TraceApi.DebugVariableValue.CharValue
  | TraceApi.DebugVariableValue.MapValue
  | TraceApi.DebugVariableValue.ListValue
  | TraceApi.DebugVariableValue.BinaryTreeNodeValue
  | TraceApi.DebugVariableValue.SinglyLinkedListNodeValue
  | TraceApi.DebugVariableValue.DoublyLinkedListNodeValue
  | TraceApi.DebugVariableValue.UndefinedValue
  | TraceApi.DebugVariableValue.NullValue
  | TraceApi.DebugVariableValue.GenericValue
  | TraceApi.DebugVariableValue._Unknown;

export declare namespace DebugVariableValue {
  interface IntegerValue extends _Utils {
    type: \\"integerValue\\";
    value: number;
  }

  interface BooleanValue extends _Utils {
    type: \\"booleanValue\\";
    value: boolean;
  }

  interface DoubleValue extends _Utils {
    type: \\"doubleValue\\";
    value: number;
  }

  interface StringValue extends _Utils {
    type: \\"stringValue\\";
    value: string;
  }

  interface CharValue extends _Utils {
    type: \\"charValue\\";
    value: string;
  }

  interface MapValue extends TraceApi.DebugMapValue, _Utils {
    type: \\"mapValue\\";
  }

  interface ListValue extends _Utils {
    type: \\"listValue\\";
    value: TraceApi.DebugVariableValue[];
  }

  interface BinaryTreeNodeValue extends TraceApi.BinaryTreeNodeAndTreeValue, _Utils {
    type: \\"binaryTreeNodeValue\\";
  }

  interface SinglyLinkedListNodeValue extends TraceApi.SinglyLinkedListNodeAndListValue, _Utils {
    type: \\"singlyLinkedListNodeValue\\";
  }

  interface DoublyLinkedListNodeValue extends TraceApi.DoublyLinkedListNodeAndListValue, _Utils {
    type: \\"doublyLinkedListNodeValue\\";
  }

  interface UndefinedValue extends _Utils {
    type: \\"undefinedValue\\";
  }

  interface NullValue extends _Utils {
    type: \\"nullValue\\";
  }

  interface GenericValue extends TraceApi.GenericValue, _Utils {
    type: \\"genericValue\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.DebugVariableValue._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    integerValue: (value: number) => _Result;
    booleanValue: (value: boolean) => _Result;
    doubleValue: (value: number) => _Result;
    stringValue: (value: string) => _Result;
    charValue: (value: string) => _Result;
    mapValue: (value: TraceApi.DebugMapValue) => _Result;
    listValue: (value: TraceApi.DebugVariableValue[]) => _Result;
    binaryTreeNodeValue: (value: TraceApi.BinaryTreeNodeAndTreeValue) => _Result;
    singlyLinkedListNodeValue: (value: TraceApi.SinglyLinkedListNodeAndListValue) => _Result;
    doublyLinkedListNodeValue: (value: TraceApi.DoublyLinkedListNodeAndListValue) => _Result;
    undefinedValue: () => _Result;
    nullValue: () => _Result;
    genericValue: (value: TraceApi.GenericValue) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const DebugVariableValue = {
  integerValue: (value: number): TraceApi.DebugVariableValue.IntegerValue => {
    const valueWithoutVisit: Omit<TraceApi.DebugVariableValue.IntegerValue, \\"_visit\\"> = {
      value: value,
      type: \\"integerValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.DebugVariableValue.IntegerValue, visitor: TraceApi.DebugVariableValue._Visitor<_Result>) {
      return TraceApi.DebugVariableValue._visit(this, visitor);
    });
  },

  booleanValue: (value: boolean): TraceApi.DebugVariableValue.BooleanValue => {
    const valueWithoutVisit: Omit<TraceApi.DebugVariableValue.BooleanValue, \\"_visit\\"> = {
      value: value,
      type: \\"booleanValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.DebugVariableValue.BooleanValue, visitor: TraceApi.DebugVariableValue._Visitor<_Result>) {
      return TraceApi.DebugVariableValue._visit(this, visitor);
    });
  },

  doubleValue: (value: number): TraceApi.DebugVariableValue.DoubleValue => {
    const valueWithoutVisit: Omit<TraceApi.DebugVariableValue.DoubleValue, \\"_visit\\"> = {
      value: value,
      type: \\"doubleValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.DebugVariableValue.DoubleValue, visitor: TraceApi.DebugVariableValue._Visitor<_Result>) {
      return TraceApi.DebugVariableValue._visit(this, visitor);
    });
  },

  stringValue: (value: string): TraceApi.DebugVariableValue.StringValue => {
    const valueWithoutVisit: Omit<TraceApi.DebugVariableValue.StringValue, \\"_visit\\"> = {
      value: value,
      type: \\"stringValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.DebugVariableValue.StringValue, visitor: TraceApi.DebugVariableValue._Visitor<_Result>) {
      return TraceApi.DebugVariableValue._visit(this, visitor);
    });
  },

  charValue: (value: string): TraceApi.DebugVariableValue.CharValue => {
    const valueWithoutVisit: Omit<TraceApi.DebugVariableValue.CharValue, \\"_visit\\"> = {
      value: value,
      type: \\"charValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.DebugVariableValue.CharValue, visitor: TraceApi.DebugVariableValue._Visitor<_Result>) {
      return TraceApi.DebugVariableValue._visit(this, visitor);
    });
  },

  mapValue: (value: TraceApi.DebugMapValue): TraceApi.DebugVariableValue.MapValue => {
    const valueWithoutVisit: Omit<TraceApi.DebugVariableValue.MapValue, \\"_visit\\"> = {
      ...value,
      type: \\"mapValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.DebugVariableValue.MapValue, visitor: TraceApi.DebugVariableValue._Visitor<_Result>) {
      return TraceApi.DebugVariableValue._visit(this, visitor);
    });
  },

  listValue: (value: TraceApi.DebugVariableValue[]): TraceApi.DebugVariableValue.ListValue => {
    const valueWithoutVisit: Omit<TraceApi.DebugVariableValue.ListValue, \\"_visit\\"> = {
      value: value,
      type: \\"listValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.DebugVariableValue.ListValue, visitor: TraceApi.DebugVariableValue._Visitor<_Result>) {
      return TraceApi.DebugVariableValue._visit(this, visitor);
    });
  },

  binaryTreeNodeValue: (
    value: TraceApi.BinaryTreeNodeAndTreeValue
  ): TraceApi.DebugVariableValue.BinaryTreeNodeValue => {
    const valueWithoutVisit: Omit<TraceApi.DebugVariableValue.BinaryTreeNodeValue, \\"_visit\\"> = {
      ...value,
      type: \\"binaryTreeNodeValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.DebugVariableValue.BinaryTreeNodeValue, visitor: TraceApi.DebugVariableValue._Visitor<_Result>) {
      return TraceApi.DebugVariableValue._visit(this, visitor);
    });
  },

  singlyLinkedListNodeValue: (
    value: TraceApi.SinglyLinkedListNodeAndListValue
  ): TraceApi.DebugVariableValue.SinglyLinkedListNodeValue => {
    const valueWithoutVisit: Omit<TraceApi.DebugVariableValue.SinglyLinkedListNodeValue, \\"_visit\\"> = {
      ...value,
      type: \\"singlyLinkedListNodeValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.DebugVariableValue.SinglyLinkedListNodeValue, visitor: TraceApi.DebugVariableValue._Visitor<_Result>) {
      return TraceApi.DebugVariableValue._visit(this, visitor);
    });
  },

  doublyLinkedListNodeValue: (
    value: TraceApi.DoublyLinkedListNodeAndListValue
  ): TraceApi.DebugVariableValue.DoublyLinkedListNodeValue => {
    const valueWithoutVisit: Omit<TraceApi.DebugVariableValue.DoublyLinkedListNodeValue, \\"_visit\\"> = {
      ...value,
      type: \\"doublyLinkedListNodeValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.DebugVariableValue.DoublyLinkedListNodeValue, visitor: TraceApi.DebugVariableValue._Visitor<_Result>) {
      return TraceApi.DebugVariableValue._visit(this, visitor);
    });
  },

  undefinedValue: (): TraceApi.DebugVariableValue.UndefinedValue => {
    const valueWithoutVisit: Omit<TraceApi.DebugVariableValue.UndefinedValue, \\"_visit\\"> = {
      type: \\"undefinedValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.DebugVariableValue.UndefinedValue, visitor: TraceApi.DebugVariableValue._Visitor<_Result>) {
      return TraceApi.DebugVariableValue._visit(this, visitor);
    });
  },

  nullValue: (): TraceApi.DebugVariableValue.NullValue => {
    const valueWithoutVisit: Omit<TraceApi.DebugVariableValue.NullValue, \\"_visit\\"> = {
      type: \\"nullValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.DebugVariableValue.NullValue, visitor: TraceApi.DebugVariableValue._Visitor<_Result>) {
      return TraceApi.DebugVariableValue._visit(this, visitor);
    });
  },

  genericValue: (value: TraceApi.GenericValue): TraceApi.DebugVariableValue.GenericValue => {
    const valueWithoutVisit: Omit<TraceApi.DebugVariableValue.GenericValue, \\"_visit\\"> = {
      ...value,
      type: \\"genericValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.DebugVariableValue.GenericValue, visitor: TraceApi.DebugVariableValue._Visitor<_Result>) {
      return TraceApi.DebugVariableValue._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.DebugVariableValue,
    visitor: TraceApi.DebugVariableValue._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"integerValue\\":
        return visitor.integerValue(value.value);
      case \\"booleanValue\\":
        return visitor.booleanValue(value.value);
      case \\"doubleValue\\":
        return visitor.doubleValue(value.value);
      case \\"stringValue\\":
        return visitor.stringValue(value.value);
      case \\"charValue\\":
        return visitor.charValue(value.value);
      case \\"mapValue\\":
        return visitor.mapValue(value);
      case \\"listValue\\":
        return visitor.listValue(value.value);
      case \\"binaryTreeNodeValue\\":
        return visitor.binaryTreeNodeValue(value);
      case \\"singlyLinkedListNodeValue\\":
        return visitor.singlyLinkedListNodeValue(value);
      case \\"doublyLinkedListNodeValue\\":
        return visitor.doublyLinkedListNodeValue(value);
      case \\"undefinedValue\\":
        return visitor.undefinedValue();
      case \\"nullValue\\":
        return visitor.nullValue();
      case \\"genericValue\\":
        return visitor.genericValue(value);
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "DebugVariableValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface DoublyLinkedListNodeAndListValue {
  nodeId: TraceApi.NodeId;
  fullList: TraceApi.DoublyLinkedListValue;
}
",
                    "name": "DoublyLinkedListNodeAndListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface DoublyLinkedListNodeValue {
  nodeId: TraceApi.NodeId;
  val: number;
  next?: TraceApi.NodeId;
  prev?: TraceApi.NodeId;
}
",
                    "name": "DoublyLinkedListNodeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface DoublyLinkedListValue {
  head?: TraceApi.NodeId;
  nodes: Record<TraceApi.NodeId, TraceApi.DoublyLinkedListNodeValue>;
}
",
                    "name": "DoublyLinkedListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface FileInfo {
  filename: string;
  contents: string;
}
",
                    "name": "FileInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface GenericValue {
  stringifiedType?: string;
  stringifiedValue: string;
}
",
                    "name": "GenericValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface KeyValuePair {
  key: TraceApi.VariableValue;
  value: TraceApi.VariableValue;
}
",
                    "name": "KeyValuePair.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface Language<RawValue extends Language.RawValue = Language.RawValue> {
  value: RawValue;
  visit: <_Result>(visitor: TraceApi.Language._Visitor<_Result>) => _Result;
}

const _Java: Language<\\"JAVA\\"> = {
  value: \\"JAVA\\",
  visit: (visitor) => visitor.java(),
};
const _Javascript: Language<\\"JAVASCRIPT\\"> = {
  value: \\"JAVASCRIPT\\",
  visit: (visitor) => visitor.javascript(),
};
const _Python: Language<\\"PYTHON\\"> = {
  value: \\"PYTHON\\",
  visit: (visitor) => visitor.python(),
};
export const Language = {
  Java: _Java,
  Javascript: _Javascript,
  Python: _Python,
  _parse: (value: string): Language => {
    switch (value) {
      case \\"JAVA\\": {
        return _Java;
      }
      case \\"JAVASCRIPT\\": {
        return _Javascript;
      }
      case \\"PYTHON\\": {
        return _Python;
      }
      default: {
        return {
          value: value as Language.RawValue,
          visit: (visitor) => visitor._other(value),
        };
      }
    }
  },
} as const;

export declare namespace Language {
  type RawValue = \\"JAVA\\" | \\"JAVASCRIPT\\" | \\"PYTHON\\";

  interface _Visitor<_Result> {
    java: () => _Result;
    javascript: () => _Result;
    python: () => _Result;
    _other: (value: string) => _Result;
  }
}
",
                    "name": "Language.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface ListType {
  valueType: TraceApi.VariableType;
  /** Whether this list is fixed-size (for languages that supports fixed-size lists). Defaults to false. */
  isFixedLength?: boolean;
}
",
                    "name": "ListType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface MapType {
  keyType: TraceApi.VariableType;
  valueType: TraceApi.VariableType;
}
",
                    "name": "MapType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface MapValue {
  keyValuePairs: TraceApi.KeyValuePair[];
}
",
                    "name": "MapValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export type NodeId = string & {
  NodeId: void;
};

export const NodeId = {
  create: (value: string) => value as unknown as TraceApi.NodeId,
} as const;
",
                    "name": "NodeId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export type ProblemId = string & {
  ProblemId: void;
};

export const ProblemId = {
  create: (value: string) => value as unknown as TraceApi.ProblemId,
} as const;
",
                    "name": "ProblemId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface SinglyLinkedListNodeAndListValue {
  nodeId: TraceApi.NodeId;
  fullList: TraceApi.SinglyLinkedListValue;
}
",
                    "name": "SinglyLinkedListNodeAndListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface SinglyLinkedListNodeValue {
  nodeId: TraceApi.NodeId;
  val: number;
  next?: TraceApi.NodeId;
}
",
                    "name": "SinglyLinkedListNodeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface SinglyLinkedListValue {
  head?: TraceApi.NodeId;
  nodes: Record<TraceApi.NodeId, TraceApi.SinglyLinkedListNodeValue>;
}
",
                    "name": "SinglyLinkedListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface TestCase {
  id: string;
  params: TraceApi.VariableValue[];
}
",
                    "name": "TestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface TestCaseWithExpectedResult {
  testCase: TraceApi.TestCase;
  expectedResult: TraceApi.VariableValue;
}
",
                    "name": "TestCaseWithExpectedResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export type UserId = string & {
  UserId: void;
};

export const UserId = {
  create: (value: string) => value as unknown as TraceApi.UserId,
} as const;
",
                    "name": "UserId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type VariableType =
  | TraceApi.VariableType.IntegerType
  | TraceApi.VariableType.DoubleType
  | TraceApi.VariableType.BooleanType
  | TraceApi.VariableType.StringType
  | TraceApi.VariableType.CharType
  | TraceApi.VariableType.ListType
  | TraceApi.VariableType.MapType
  | TraceApi.VariableType.BinaryTreeType
  | TraceApi.VariableType.SinglyLinkedListType
  | TraceApi.VariableType.DoublyLinkedListType
  | TraceApi.VariableType._Unknown;

export declare namespace VariableType {
  interface IntegerType extends _Utils {
    type: \\"integerType\\";
  }

  interface DoubleType extends _Utils {
    type: \\"doubleType\\";
  }

  interface BooleanType extends _Utils {
    type: \\"booleanType\\";
  }

  interface StringType extends _Utils {
    type: \\"stringType\\";
  }

  interface CharType extends _Utils {
    type: \\"charType\\";
  }

  interface ListType extends TraceApi.ListType, _Utils {
    type: \\"listType\\";
  }

  interface MapType extends TraceApi.MapType, _Utils {
    type: \\"mapType\\";
  }

  interface BinaryTreeType extends _Utils {
    type: \\"binaryTreeType\\";
  }

  interface SinglyLinkedListType extends _Utils {
    type: \\"singlyLinkedListType\\";
  }

  interface DoublyLinkedListType extends _Utils {
    type: \\"doublyLinkedListType\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.VariableType._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    integerType: () => _Result;
    doubleType: () => _Result;
    booleanType: () => _Result;
    stringType: () => _Result;
    charType: () => _Result;
    listType: (value: TraceApi.ListType) => _Result;
    mapType: (value: TraceApi.MapType) => _Result;
    binaryTreeType: () => _Result;
    singlyLinkedListType: () => _Result;
    doublyLinkedListType: () => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const VariableType = {
  integerType: (): TraceApi.VariableType.IntegerType => {
    const valueWithoutVisit: Omit<TraceApi.VariableType.IntegerType, \\"_visit\\"> = {
      type: \\"integerType\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableType.IntegerType, visitor: TraceApi.VariableType._Visitor<_Result>) {
      return TraceApi.VariableType._visit(this, visitor);
    });
  },

  doubleType: (): TraceApi.VariableType.DoubleType => {
    const valueWithoutVisit: Omit<TraceApi.VariableType.DoubleType, \\"_visit\\"> = {
      type: \\"doubleType\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableType.DoubleType, visitor: TraceApi.VariableType._Visitor<_Result>) {
      return TraceApi.VariableType._visit(this, visitor);
    });
  },

  booleanType: (): TraceApi.VariableType.BooleanType => {
    const valueWithoutVisit: Omit<TraceApi.VariableType.BooleanType, \\"_visit\\"> = {
      type: \\"booleanType\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableType.BooleanType, visitor: TraceApi.VariableType._Visitor<_Result>) {
      return TraceApi.VariableType._visit(this, visitor);
    });
  },

  stringType: (): TraceApi.VariableType.StringType => {
    const valueWithoutVisit: Omit<TraceApi.VariableType.StringType, \\"_visit\\"> = {
      type: \\"stringType\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableType.StringType, visitor: TraceApi.VariableType._Visitor<_Result>) {
      return TraceApi.VariableType._visit(this, visitor);
    });
  },

  charType: (): TraceApi.VariableType.CharType => {
    const valueWithoutVisit: Omit<TraceApi.VariableType.CharType, \\"_visit\\"> = {
      type: \\"charType\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableType.CharType, visitor: TraceApi.VariableType._Visitor<_Result>) {
      return TraceApi.VariableType._visit(this, visitor);
    });
  },

  listType: (value: TraceApi.ListType): TraceApi.VariableType.ListType => {
    const valueWithoutVisit: Omit<TraceApi.VariableType.ListType, \\"_visit\\"> = {
      ...value,
      type: \\"listType\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableType.ListType, visitor: TraceApi.VariableType._Visitor<_Result>) {
      return TraceApi.VariableType._visit(this, visitor);
    });
  },

  mapType: (value: TraceApi.MapType): TraceApi.VariableType.MapType => {
    const valueWithoutVisit: Omit<TraceApi.VariableType.MapType, \\"_visit\\"> = {
      ...value,
      type: \\"mapType\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableType.MapType, visitor: TraceApi.VariableType._Visitor<_Result>) {
      return TraceApi.VariableType._visit(this, visitor);
    });
  },

  binaryTreeType: (): TraceApi.VariableType.BinaryTreeType => {
    const valueWithoutVisit: Omit<TraceApi.VariableType.BinaryTreeType, \\"_visit\\"> = {
      type: \\"binaryTreeType\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableType.BinaryTreeType, visitor: TraceApi.VariableType._Visitor<_Result>) {
      return TraceApi.VariableType._visit(this, visitor);
    });
  },

  singlyLinkedListType: (): TraceApi.VariableType.SinglyLinkedListType => {
    const valueWithoutVisit: Omit<TraceApi.VariableType.SinglyLinkedListType, \\"_visit\\"> = {
      type: \\"singlyLinkedListType\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableType.SinglyLinkedListType, visitor: TraceApi.VariableType._Visitor<_Result>) {
      return TraceApi.VariableType._visit(this, visitor);
    });
  },

  doublyLinkedListType: (): TraceApi.VariableType.DoublyLinkedListType => {
    const valueWithoutVisit: Omit<TraceApi.VariableType.DoublyLinkedListType, \\"_visit\\"> = {
      type: \\"doublyLinkedListType\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableType.DoublyLinkedListType, visitor: TraceApi.VariableType._Visitor<_Result>) {
      return TraceApi.VariableType._visit(this, visitor);
    });
  },

  _visit: <_Result>(value: TraceApi.VariableType, visitor: TraceApi.VariableType._Visitor<_Result>): _Result => {
    switch (value.type) {
      case \\"integerType\\":
        return visitor.integerType();
      case \\"doubleType\\":
        return visitor.doubleType();
      case \\"booleanType\\":
        return visitor.booleanType();
      case \\"stringType\\":
        return visitor.stringType();
      case \\"charType\\":
        return visitor.charType();
      case \\"listType\\":
        return visitor.listType(value);
      case \\"mapType\\":
        return visitor.mapType(value);
      case \\"binaryTreeType\\":
        return visitor.binaryTreeType();
      case \\"singlyLinkedListType\\":
        return visitor.singlyLinkedListType();
      case \\"doublyLinkedListType\\":
        return visitor.doublyLinkedListType();
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "VariableType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type VariableValue =
  | TraceApi.VariableValue.IntegerValue
  | TraceApi.VariableValue.BooleanValue
  | TraceApi.VariableValue.DoubleValue
  | TraceApi.VariableValue.StringValue
  | TraceApi.VariableValue.CharValue
  | TraceApi.VariableValue.MapValue
  | TraceApi.VariableValue.ListValue
  | TraceApi.VariableValue.BinaryTreeValue
  | TraceApi.VariableValue.SinglyLinkedListValue
  | TraceApi.VariableValue.DoublyLinkedListValue
  | TraceApi.VariableValue.NullValue
  | TraceApi.VariableValue._Unknown;

export declare namespace VariableValue {
  interface IntegerValue extends _Utils {
    type: \\"integerValue\\";
    value: number;
  }

  interface BooleanValue extends _Utils {
    type: \\"booleanValue\\";
    value: boolean;
  }

  interface DoubleValue extends _Utils {
    type: \\"doubleValue\\";
    value: number;
  }

  interface StringValue extends _Utils {
    type: \\"stringValue\\";
    value: string;
  }

  interface CharValue extends _Utils {
    type: \\"charValue\\";
    value: string;
  }

  interface MapValue extends TraceApi.MapValue, _Utils {
    type: \\"mapValue\\";
  }

  interface ListValue extends _Utils {
    type: \\"listValue\\";
    value: TraceApi.VariableValue[];
  }

  interface BinaryTreeValue extends TraceApi.BinaryTreeValue, _Utils {
    type: \\"binaryTreeValue\\";
  }

  interface SinglyLinkedListValue extends TraceApi.SinglyLinkedListValue, _Utils {
    type: \\"singlyLinkedListValue\\";
  }

  interface DoublyLinkedListValue extends TraceApi.DoublyLinkedListValue, _Utils {
    type: \\"doublyLinkedListValue\\";
  }

  interface NullValue extends _Utils {
    type: \\"nullValue\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.VariableValue._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    integerValue: (value: number) => _Result;
    booleanValue: (value: boolean) => _Result;
    doubleValue: (value: number) => _Result;
    stringValue: (value: string) => _Result;
    charValue: (value: string) => _Result;
    mapValue: (value: TraceApi.MapValue) => _Result;
    listValue: (value: TraceApi.VariableValue[]) => _Result;
    binaryTreeValue: (value: TraceApi.BinaryTreeValue) => _Result;
    singlyLinkedListValue: (value: TraceApi.SinglyLinkedListValue) => _Result;
    doublyLinkedListValue: (value: TraceApi.DoublyLinkedListValue) => _Result;
    nullValue: () => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const VariableValue = {
  integerValue: (value: number): TraceApi.VariableValue.IntegerValue => {
    const valueWithoutVisit: Omit<TraceApi.VariableValue.IntegerValue, \\"_visit\\"> = {
      value: value,
      type: \\"integerValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableValue.IntegerValue, visitor: TraceApi.VariableValue._Visitor<_Result>) {
      return TraceApi.VariableValue._visit(this, visitor);
    });
  },

  booleanValue: (value: boolean): TraceApi.VariableValue.BooleanValue => {
    const valueWithoutVisit: Omit<TraceApi.VariableValue.BooleanValue, \\"_visit\\"> = {
      value: value,
      type: \\"booleanValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableValue.BooleanValue, visitor: TraceApi.VariableValue._Visitor<_Result>) {
      return TraceApi.VariableValue._visit(this, visitor);
    });
  },

  doubleValue: (value: number): TraceApi.VariableValue.DoubleValue => {
    const valueWithoutVisit: Omit<TraceApi.VariableValue.DoubleValue, \\"_visit\\"> = {
      value: value,
      type: \\"doubleValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableValue.DoubleValue, visitor: TraceApi.VariableValue._Visitor<_Result>) {
      return TraceApi.VariableValue._visit(this, visitor);
    });
  },

  stringValue: (value: string): TraceApi.VariableValue.StringValue => {
    const valueWithoutVisit: Omit<TraceApi.VariableValue.StringValue, \\"_visit\\"> = {
      value: value,
      type: \\"stringValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableValue.StringValue, visitor: TraceApi.VariableValue._Visitor<_Result>) {
      return TraceApi.VariableValue._visit(this, visitor);
    });
  },

  charValue: (value: string): TraceApi.VariableValue.CharValue => {
    const valueWithoutVisit: Omit<TraceApi.VariableValue.CharValue, \\"_visit\\"> = {
      value: value,
      type: \\"charValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableValue.CharValue, visitor: TraceApi.VariableValue._Visitor<_Result>) {
      return TraceApi.VariableValue._visit(this, visitor);
    });
  },

  mapValue: (value: TraceApi.MapValue): TraceApi.VariableValue.MapValue => {
    const valueWithoutVisit: Omit<TraceApi.VariableValue.MapValue, \\"_visit\\"> = {
      ...value,
      type: \\"mapValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableValue.MapValue, visitor: TraceApi.VariableValue._Visitor<_Result>) {
      return TraceApi.VariableValue._visit(this, visitor);
    });
  },

  listValue: (value: TraceApi.VariableValue[]): TraceApi.VariableValue.ListValue => {
    const valueWithoutVisit: Omit<TraceApi.VariableValue.ListValue, \\"_visit\\"> = {
      value: value,
      type: \\"listValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableValue.ListValue, visitor: TraceApi.VariableValue._Visitor<_Result>) {
      return TraceApi.VariableValue._visit(this, visitor);
    });
  },

  binaryTreeValue: (value: TraceApi.BinaryTreeValue): TraceApi.VariableValue.BinaryTreeValue => {
    const valueWithoutVisit: Omit<TraceApi.VariableValue.BinaryTreeValue, \\"_visit\\"> = {
      ...value,
      type: \\"binaryTreeValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableValue.BinaryTreeValue, visitor: TraceApi.VariableValue._Visitor<_Result>) {
      return TraceApi.VariableValue._visit(this, visitor);
    });
  },

  singlyLinkedListValue: (value: TraceApi.SinglyLinkedListValue): TraceApi.VariableValue.SinglyLinkedListValue => {
    const valueWithoutVisit: Omit<TraceApi.VariableValue.SinglyLinkedListValue, \\"_visit\\"> = {
      ...value,
      type: \\"singlyLinkedListValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableValue.SinglyLinkedListValue, visitor: TraceApi.VariableValue._Visitor<_Result>) {
      return TraceApi.VariableValue._visit(this, visitor);
    });
  },

  doublyLinkedListValue: (value: TraceApi.DoublyLinkedListValue): TraceApi.VariableValue.DoublyLinkedListValue => {
    const valueWithoutVisit: Omit<TraceApi.VariableValue.DoublyLinkedListValue, \\"_visit\\"> = {
      ...value,
      type: \\"doublyLinkedListValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableValue.DoublyLinkedListValue, visitor: TraceApi.VariableValue._Visitor<_Result>) {
      return TraceApi.VariableValue._visit(this, visitor);
    });
  },

  nullValue: (): TraceApi.VariableValue.NullValue => {
    const valueWithoutVisit: Omit<TraceApi.VariableValue.NullValue, \\"_visit\\"> = {
      type: \\"nullValue\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.VariableValue.NullValue, visitor: TraceApi.VariableValue._Visitor<_Result>) {
      return TraceApi.VariableValue._visit(this, visitor);
    });
  },

  _visit: <_Result>(value: TraceApi.VariableValue, visitor: TraceApi.VariableValue._Visitor<_Result>): _Result => {
    switch (value.type) {
      case \\"integerValue\\":
        return visitor.integerValue(value.value);
      case \\"booleanValue\\":
        return visitor.booleanValue(value.value);
      case \\"doubleValue\\":
        return visitor.doubleValue(value.value);
      case \\"stringValue\\":
        return visitor.stringValue(value.value);
      case \\"charValue\\":
        return visitor.charValue(value.value);
      case \\"mapValue\\":
        return visitor.mapValue(value);
      case \\"listValue\\":
        return visitor.listValue(value.value);
      case \\"binaryTreeValue\\":
        return visitor.binaryTreeValue(value);
      case \\"singlyLinkedListValue\\":
        return visitor.singlyLinkedListValue(value);
      case \\"doublyLinkedListValue\\":
        return visitor.doublyLinkedListValue(value);
      case \\"nullValue\\":
        return visitor.nullValue();
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "VariableValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./UserId\\";
export * from \\"./ProblemId\\";
export * from \\"./NodeId\\";
export * from \\"./VariableType\\";
export * from \\"./ListType\\";
export * from \\"./MapType\\";
export * from \\"./VariableValue\\";
export * from \\"./DebugVariableValue\\";
export * from \\"./GenericValue\\";
export * from \\"./MapValue\\";
export * from \\"./KeyValuePair\\";
export * from \\"./BinaryTreeValue\\";
export * from \\"./BinaryTreeNodeValue\\";
export * from \\"./BinaryTreeNodeAndTreeValue\\";
export * from \\"./SinglyLinkedListValue\\";
export * from \\"./SinglyLinkedListNodeValue\\";
export * from \\"./SinglyLinkedListNodeAndListValue\\";
export * from \\"./DoublyLinkedListValue\\";
export * from \\"./DoublyLinkedListNodeValue\\";
export * from \\"./DoublyLinkedListNodeAndListValue\\";
export * from \\"./DebugMapValue\\";
export * from \\"./DebugKeyValuePairs\\";
export * from \\"./TestCase\\";
export * from \\"./TestCaseWithExpectedResult\\";
export * from \\"./FileInfo\\";
export * from \\"./Language\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "commons",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    auth?: {
      token?: core.Supplier<core.BearerToken>;
    };
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async getHomepageProblems(): Promise<TraceApi.homepage.getHomepageProblems.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/homepage-problems/\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.homepage.getHomepageProblems.Response.parse(response.body as serializers.ProblemId.Raw[]),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async setHomepageProblems(
    request: TraceApi.ProblemId[]
  ): Promise<TraceApi.homepage.setHomepageProblems.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/homepage-problems/\\"),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
      body: serializers.homepage.setHomepageProblems.Request.json(request),
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<TraceApi.ProblemId[], TraceApi.homepage.getHomepageProblems.Error>;
export type Error = TraceApi.homepage.getHomepageProblems.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.homepage.getHomepageProblems.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                    "name": "getHomepageProblems.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getHomepageProblems from \\"./getHomepageProblems\\";
export * as setHomepageProblems from \\"./setHomepageProblems\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<void, TraceApi.homepage.setHomepageProblems.Error>;
export type Error = TraceApi.homepage.setHomepageProblems.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.homepage.setHomepageProblems.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                    "name": "setHomepageProblems.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "homepage",
            "type": "directory",
          },
          Object {
            "contents": "export * as admin from \\"./admin\\";
export * from \\"./admin/types\\";
export * as commons from \\"./commons\\";
export * from \\"./commons/types\\";
export * as langServer from \\"./langServer\\";
export * from \\"./langServer/types\\";
export * as migration from \\"./migration\\";
export * from \\"./migration/types\\";
export * as playlist from \\"./playlist\\";
export * from \\"./playlist/types\\";
export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as submission from \\"./submission\\";
export * from \\"./submission/types\\";
export * as v2 from \\"./v2\\";
export * from \\"./playlist/errors\\";
export * as homepage from \\"./homepage\\";
export * as sysprop from \\"./sysprop\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface LangServerRequest {
  request?: unknown;
}
",
                    "name": "LangServerRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface LangServerResponse {
  response?: unknown;
}
",
                    "name": "LangServerResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./LangServerRequest\\";
export * from \\"./LangServerResponse\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "langServer",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    auth?: {
      token?: core.Supplier<core.BearerToken>;
    };
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async getAttemptedMigrations(): Promise<TraceApi.migration.getAttemptedMigrations.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/migration-info/all\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.migration.getAttemptedMigrations.Response.parse(response.body as serializers.Migration.Raw[]),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<TraceApi.Migration[], TraceApi.migration.getAttemptedMigrations.Error>;
export type Error = TraceApi.migration.getAttemptedMigrations.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.migration.getAttemptedMigrations.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                    "name": "getAttemptedMigrations.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getAttemptedMigrations from \\"./getAttemptedMigrations\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface Migration {
  name: string;
  status: TraceApi.MigrationStatus;
}
",
                    "name": "Migration.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface MigrationStatus<RawValue extends MigrationStatus.RawValue = MigrationStatus.RawValue> {
  value: RawValue;
  visit: <_Result>(visitor: TraceApi.MigrationStatus._Visitor<_Result>) => _Result;
}

const _Running: MigrationStatus<\\"RUNNING\\"> = {
  value: \\"RUNNING\\",
  visit: (visitor) => visitor.running(),
};
const _Failed: MigrationStatus<\\"FAILED\\"> = {
  value: \\"FAILED\\",
  visit: (visitor) => visitor.failed(),
};
const _Finished: MigrationStatus<\\"FINISHED\\"> = {
  value: \\"FINISHED\\",
  visit: (visitor) => visitor.finished(),
};
export const MigrationStatus = {
  Running: _Running,
  Failed: _Failed,
  Finished: _Finished,
  _parse: (value: string): MigrationStatus => {
    switch (value) {
      case \\"RUNNING\\": {
        return _Running;
      }
      case \\"FAILED\\": {
        return _Failed;
      }
      case \\"FINISHED\\": {
        return _Finished;
      }
      default: {
        return {
          value: value as MigrationStatus.RawValue,
          visit: (visitor) => visitor._other(value),
        };
      }
    }
  },
} as const;

export declare namespace MigrationStatus {
  type RawValue = \\"RUNNING\\" | \\"FAILED\\" | \\"FINISHED\\";

  interface _Visitor<_Result> {
    running: () => _Result;
    failed: () => _Result;
    finished: () => _Result;
    _other: (value: string) => _Result;
  }
}
",
                    "name": "MigrationStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./MigrationStatus\\";
export * from \\"./Migration\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "migration",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    auth?: {
      token?: core.Supplier<core.BearerToken>;
    };
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async createPlaylist(
    request: TraceApi.playlist.createPlaylist.Request
  ): Promise<TraceApi.playlist.createPlaylist.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/v2/playlist/\${request.serviceParam}create\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
      body: serializers.PlaylistCreateRequest.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.Playlist.parse(response.body as serializers.Playlist.Raw),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getPlaylists(
    request: TraceApi.playlist.getPlaylists.Request
  ): Promise<TraceApi.playlist.getPlaylists.Response> {
    const queryParameters = new URLSearchParams();
    if (request.limit != null) {
      queryParameters.append(\\"limit\\", request.limit.toString());
    }

    queryParameters.append(\\"otherField\\", request.otherField);
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/v2/playlist/\${request.serviceParam}all\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
      queryParameters: queryParameters,
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.playlist.getPlaylists.Response.parse(response.body as serializers.Playlist.Raw[]),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getPlaylist(
    request: TraceApi.playlist.getPlaylist.Request
  ): Promise<TraceApi.playlist.getPlaylist.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/v2/playlist/\${request.serviceParam}\${request.playlistId}\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.Playlist.parse(response.body as serializers.Playlist.Raw),
      };
    }

    if (response.error.reason === \\"status-code\\") {
      switch ((response.error.body as serializers.playlist.getPlaylist.Error.Raw)?.errorName) {
        case \\"PlaylistIdNotFoundError\\":
        case \\"UnauthorizedError\\":
          return {
            ok: false,
            error: serializers.playlist.getPlaylist.Error.parse(
              response.error.body as serializers.playlist.getPlaylist.Error.Raw
            ),
          };
      }
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async updatePlaylist(
    request: TraceApi.playlist.updatePlaylist.Request
  ): Promise<TraceApi.playlist.updatePlaylist.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/v2/playlist/\${request.serviceParam}\${request.playlistId}\`
      ),
      method: \\"PUT\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
      body: serializers.playlist.updatePlaylist.Request.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.playlist.updatePlaylist.Response.parse(
          response.body as serializers.Playlist.Raw | null | undefined
        ),
      };
    }

    if (response.error.reason === \\"status-code\\") {
      switch ((response.error.body as serializers.playlist.updatePlaylist.Error.Raw)?.errorName) {
        case \\"PlaylistIdNotFoundError\\":
          return {
            ok: false,
            error: serializers.playlist.updatePlaylist.Error.parse(
              response.error.body as serializers.playlist.updatePlaylist.Error.Raw
            ),
          };
      }
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async deletePlaylist(
    request: TraceApi.playlist.deletePlaylist.Request
  ): Promise<TraceApi.playlist.deletePlaylist.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/v2/playlist/\${request.serviceParam}\${request.playlistId}\`
      ),
      method: \\"DELETE\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  serviceParam: number;
  _body: TraceApi.PlaylistCreateRequest;
}

export type Response = core.APIResponse<TraceApi.Playlist, TraceApi.playlist.createPlaylist.Error>;
export type Error = TraceApi.playlist.createPlaylist.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.playlist.createPlaylist.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                    "name": "createPlaylist.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  serviceParam: number;
  playlistId: TraceApi.PlaylistId;
}

export type Response = core.APIResponse<void, TraceApi.playlist.deletePlaylist.Error>;
export type Error = TraceApi.playlist.deletePlaylist.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.playlist.deletePlaylist.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                    "name": "deletePlaylist.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  serviceParam: number;
  playlistId: TraceApi.PlaylistId;
}

export type Response = core.APIResponse<TraceApi.Playlist, TraceApi.playlist.getPlaylist.Error>;
export type Error =
  | TraceApi.playlist.getPlaylist.Error.PlaylistIdNotFoundError
  | TraceApi.playlist.getPlaylist.Error.UnauthorizedError
  | TraceApi.playlist.getPlaylist.Error._Unknown;

export declare namespace Error {
  interface PlaylistIdNotFoundError extends _Utils {
    errorName: \\"PlaylistIdNotFoundError\\";
    content: TraceApi.PlaylistIdNotFoundError;
  }

  interface UnauthorizedError extends _Utils {
    errorName: \\"UnauthorizedError\\";
  }

  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.playlist.getPlaylist.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    playlistIdNotFoundError: (value: TraceApi.PlaylistIdNotFoundError) => _Result;
    unauthorizedError: () => _Result;
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  playlistIdNotFoundError: (
    value: TraceApi.PlaylistIdNotFoundError
  ): TraceApi.playlist.getPlaylist.Error.PlaylistIdNotFoundError => {
    const valueWithoutVisit: Omit<TraceApi.playlist.getPlaylist.Error.PlaylistIdNotFoundError, \\"_visit\\"> = {
      content: value,
      errorName: \\"PlaylistIdNotFoundError\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.playlist.getPlaylist.Error.PlaylistIdNotFoundError, visitor: TraceApi.playlist.getPlaylist.Error._Visitor<_Result>) {
      return TraceApi.playlist.getPlaylist.Error._visit(this, visitor);
    });
  },

  unauthorizedError: (): TraceApi.playlist.getPlaylist.Error.UnauthorizedError => {
    const valueWithoutVisit: Omit<TraceApi.playlist.getPlaylist.Error.UnauthorizedError, \\"_visit\\"> = {
      errorName: \\"UnauthorizedError\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.playlist.getPlaylist.Error.UnauthorizedError, visitor: TraceApi.playlist.getPlaylist.Error._Visitor<_Result>) {
      return TraceApi.playlist.getPlaylist.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.playlist.getPlaylist.Error,
    visitor: TraceApi.playlist.getPlaylist.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      case \\"PlaylistIdNotFoundError\\":
        return visitor.playlistIdNotFoundError(value.content);
      case \\"UnauthorizedError\\":
        return visitor.unauthorizedError();
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "getPlaylist.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  limit?: number;
  otherField: string;
  serviceParam: number;
}

export type Response = core.APIResponse<TraceApi.Playlist[], TraceApi.playlist.getPlaylists.Error>;
export type Error = TraceApi.playlist.getPlaylists.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.playlist.getPlaylists.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                    "name": "getPlaylists.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as createPlaylist from \\"./createPlaylist\\";
export * as getPlaylists from \\"./getPlaylists\\";
export * as getPlaylist from \\"./getPlaylist\\";
export * as updatePlaylist from \\"./updatePlaylist\\";
export * as deletePlaylist from \\"./deletePlaylist\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  serviceParam: number;
  playlistId: TraceApi.PlaylistId;
  _body?: TraceApi.UpdatePlaylistRequest;
}

export type Response = core.APIResponse<TraceApi.Playlist | undefined, TraceApi.playlist.updatePlaylist.Error>;
export type Error =
  | TraceApi.playlist.updatePlaylist.Error.PlaylistIdNotFoundError
  | TraceApi.playlist.updatePlaylist.Error._Unknown;

export declare namespace Error {
  interface PlaylistIdNotFoundError extends _Utils {
    errorName: \\"PlaylistIdNotFoundError\\";
    content: TraceApi.PlaylistIdNotFoundError;
  }

  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.playlist.updatePlaylist.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    playlistIdNotFoundError: (value: TraceApi.PlaylistIdNotFoundError) => _Result;
    _other: (value: core.Fetcher.Error) => _Result;
  }
}

export const Error = {
  playlistIdNotFoundError: (
    value: TraceApi.PlaylistIdNotFoundError
  ): TraceApi.playlist.updatePlaylist.Error.PlaylistIdNotFoundError => {
    const valueWithoutVisit: Omit<TraceApi.playlist.updatePlaylist.Error.PlaylistIdNotFoundError, \\"_visit\\"> = {
      content: value,
      errorName: \\"PlaylistIdNotFoundError\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.playlist.updatePlaylist.Error.PlaylistIdNotFoundError, visitor: TraceApi.playlist.updatePlaylist.Error._Visitor<_Result>) {
      return TraceApi.playlist.updatePlaylist.Error._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.playlist.updatePlaylist.Error,
    visitor: TraceApi.playlist.updatePlaylist.Error._Visitor<_Result>
  ): _Result => {
    switch (value.errorName) {
      case \\"PlaylistIdNotFoundError\\":
        return visitor.playlistIdNotFoundError(value.content);
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "updatePlaylist.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export type PlaylistIdNotFoundError = TraceApi.PlaylistIdNotFoundErrorBody;

export const PlaylistIdNotFoundError = {
  create: (value: string) => value as unknown as TraceApi.PlaylistIdNotFoundError,
} as const;
",
                    "name": "PlaylistIdNotFoundError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./PlaylistIdNotFoundError\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "errors",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./errors\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface Playlist extends TraceApi.PlaylistCreateRequest {
  playlistId: TraceApi.PlaylistId;
  ownerId: TraceApi.UserId;
}
",
                    "name": "Playlist.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface PlaylistCreateRequest {
  name: string;
  problems: TraceApi.ProblemId[];
}
",
                    "name": "PlaylistCreateRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export type PlaylistId = string & {
  PlaylistId: void;
};

export const PlaylistId = {
  create: (value: string) => value as unknown as TraceApi.PlaylistId,
} as const;
",
                    "name": "PlaylistId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type PlaylistIdNotFoundErrorBody =
  | TraceApi.PlaylistIdNotFoundErrorBody.PlaylistId
  | TraceApi.PlaylistIdNotFoundErrorBody._Unknown;

export declare namespace PlaylistIdNotFoundErrorBody {
  interface PlaylistId extends _Utils {
    type: \\"playlistId\\";
    value: TraceApi.PlaylistId;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.PlaylistIdNotFoundErrorBody._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    playlistId: (value: TraceApi.PlaylistId) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const PlaylistIdNotFoundErrorBody = {
  playlistId: (value: TraceApi.PlaylistId): TraceApi.PlaylistIdNotFoundErrorBody.PlaylistId => {
    const valueWithoutVisit: Omit<TraceApi.PlaylistIdNotFoundErrorBody.PlaylistId, \\"_visit\\"> = {
      value: value,
      type: \\"playlistId\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.PlaylistIdNotFoundErrorBody.PlaylistId, visitor: TraceApi.PlaylistIdNotFoundErrorBody._Visitor<_Result>) {
      return TraceApi.PlaylistIdNotFoundErrorBody._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.PlaylistIdNotFoundErrorBody,
    visitor: TraceApi.PlaylistIdNotFoundErrorBody._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"playlistId\\":
        return visitor.playlistId(value.value);
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "PlaylistIdNotFoundErrorBody.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface ReservedKeywordEnum<RawValue extends ReservedKeywordEnum.RawValue = ReservedKeywordEnum.RawValue> {
  value: RawValue;
  visit: <_Result>(visitor: TraceApi.ReservedKeywordEnum._Visitor<_Result>) => _Result;
}

const _Is: ReservedKeywordEnum<\\"is\\"> = {
  value: \\"is\\",
  visit: (visitor) => visitor.is(),
};
const _As: ReservedKeywordEnum<\\"as\\"> = {
  value: \\"as\\",
  visit: (visitor) => visitor.as(),
};
export const ReservedKeywordEnum = {
  Is: _Is,
  As: _As,
  _parse: (value: string): ReservedKeywordEnum => {
    switch (value) {
      case \\"is\\": {
        return _Is;
      }
      case \\"as\\": {
        return _As;
      }
      default: {
        return {
          value: value as ReservedKeywordEnum.RawValue,
          visit: (visitor) => visitor._other(value),
        };
      }
    }
  },
} as const;

export declare namespace ReservedKeywordEnum {
  type RawValue = \\"is\\" | \\"as\\";

  interface _Visitor<_Result> {
    is: () => _Result;
    as: () => _Result;
    _other: (value: string) => _Result;
  }
}
",
                    "name": "ReservedKeywordEnum.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface UpdatePlaylistRequest {
  name: string;
  problems: TraceApi.ProblemId[];
}
",
                    "name": "UpdatePlaylistRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./PlaylistId\\";
export * from \\"./Playlist\\";
export * from \\"./PlaylistCreateRequest\\";
export * from \\"./UpdatePlaylistRequest\\";
export * from \\"./PlaylistIdNotFoundErrorBody\\";
export * from \\"./ReservedKeywordEnum\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "playlist",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    auth?: {
      token?: core.Supplier<core.BearerToken>;
    };
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async createProblem(request: TraceApi.CreateProblemRequest): Promise<TraceApi.problem.createProblem.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/problem-crud/create\\"),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
      body: serializers.CreateProblemRequest.json(request),
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.CreateProblemResponse.parse(response.body as serializers.CreateProblemResponse.Raw),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async updateProblem(
    request: TraceApi.problem.updateProblem.Request
  ): Promise<TraceApi.problem.updateProblem.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/problem-crud/update/\${request.problemId}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
      body: serializers.CreateProblemRequest.json(request._body),
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.UpdateProblemResponse.parse(response.body as serializers.UpdateProblemResponse.Raw),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async deleteProblem(
    request: TraceApi.problem.deleteProblem.Request
  ): Promise<TraceApi.problem.deleteProblem.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/problem-crud/delete/\${request.problemId}\`
      ),
      method: \\"DELETE\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getDefaultStarterFiles(
    request: TraceApi.GetDefaultStarterFilesRequest
  ): Promise<TraceApi.problem.getDefaultStarterFiles.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/problem-crud/default-starter-files\\"),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
      body: serializers.GetDefaultStarterFilesRequest.json(request),
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.GetDefaultStarterFilesResponse.parse(
          response.body as serializers.GetDefaultStarterFilesResponse.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<TraceApi.CreateProblemResponse, TraceApi.problem.createProblem.Error>;
export type Error = TraceApi.problem.createProblem.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.problem.createProblem.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                    "name": "createProblem.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  problemId: TraceApi.ProblemId;
}

export type Response = core.APIResponse<void, TraceApi.problem.deleteProblem.Error>;
export type Error = TraceApi.problem.deleteProblem.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.problem.deleteProblem.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                    "name": "deleteProblem.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  TraceApi.GetDefaultStarterFilesResponse,
  TraceApi.problem.getDefaultStarterFiles.Error
>;
export type Error = TraceApi.problem.getDefaultStarterFiles.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.problem.getDefaultStarterFiles.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                    "name": "getDefaultStarterFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as createProblem from \\"./createProblem\\";
export * as updateProblem from \\"./updateProblem\\";
export * as deleteProblem from \\"./deleteProblem\\";
export * as getDefaultStarterFiles from \\"./getDefaultStarterFiles\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  problemId: TraceApi.ProblemId;
  _body: TraceApi.CreateProblemRequest;
}

export type Response = core.APIResponse<TraceApi.UpdateProblemResponse, TraceApi.problem.updateProblem.Error>;
export type Error = TraceApi.problem.updateProblem.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.problem.updateProblem.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                    "name": "updateProblem.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type CreateProblemError = TraceApi.CreateProblemError.Generic | TraceApi.CreateProblemError._Unknown;

export declare namespace CreateProblemError {
  interface Generic extends TraceApi.GenericCreateProblemError, _Utils {
    errorType: \\"generic\\";
  }

  interface _Unknown extends _Utils {
    errorType: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.CreateProblemError._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    generic: (value: TraceApi.GenericCreateProblemError) => _Result;
    _other: (value: { errorType: string }) => _Result;
  }
}

export const CreateProblemError = {
  generic: (value: TraceApi.GenericCreateProblemError): TraceApi.CreateProblemError.Generic => {
    const valueWithoutVisit: Omit<TraceApi.CreateProblemError.Generic, \\"_visit\\"> = {
      ...value,
      errorType: \\"generic\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CreateProblemError.Generic, visitor: TraceApi.CreateProblemError._Visitor<_Result>) {
      return TraceApi.CreateProblemError._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.CreateProblemError,
    visitor: TraceApi.CreateProblemError._Visitor<_Result>
  ): _Result => {
    switch (value.errorType) {
      case \\"generic\\":
        return visitor.generic(value);
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "CreateProblemError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface CreateProblemRequest {
  problemName: string;
  problemDescription: TraceApi.ProblemDescription;
  files: Record<TraceApi.Language.RawValue, TraceApi.ProblemFiles>;
  inputParams: TraceApi.VariableTypeAndName[];
  outputType: TraceApi.VariableType;
  testcases: TraceApi.TestCaseWithExpectedResult[];
  methodName: string;
}
",
                    "name": "CreateProblemRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type CreateProblemResponse =
  | TraceApi.CreateProblemResponse.Success
  | TraceApi.CreateProblemResponse.Error
  | TraceApi.CreateProblemResponse._Unknown;

export declare namespace CreateProblemResponse {
  interface Success extends _Utils {
    type: \\"success\\";
    value: TraceApi.ProblemId;
  }

  interface Error extends _Utils {
    type: \\"error\\";
    value: TraceApi.CreateProblemError;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.CreateProblemResponse._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    success: (value: TraceApi.ProblemId) => _Result;
    error: (value: TraceApi.CreateProblemError) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const CreateProblemResponse = {
  success: (value: TraceApi.ProblemId): TraceApi.CreateProblemResponse.Success => {
    const valueWithoutVisit: Omit<TraceApi.CreateProblemResponse.Success, \\"_visit\\"> = {
      value: value,
      type: \\"success\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CreateProblemResponse.Success, visitor: TraceApi.CreateProblemResponse._Visitor<_Result>) {
      return TraceApi.CreateProblemResponse._visit(this, visitor);
    });
  },

  error: (value: TraceApi.CreateProblemError): TraceApi.CreateProblemResponse.Error => {
    const valueWithoutVisit: Omit<TraceApi.CreateProblemResponse.Error, \\"_visit\\"> = {
      value: value,
      type: \\"error\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CreateProblemResponse.Error, visitor: TraceApi.CreateProblemResponse._Visitor<_Result>) {
      return TraceApi.CreateProblemResponse._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.CreateProblemResponse,
    visitor: TraceApi.CreateProblemResponse._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"success\\":
        return visitor.success(value.value);
      case \\"error\\":
        return visitor.error(value.value);
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "CreateProblemResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface GenericCreateProblemError {
  message: string;
  type: string;
  stacktrace: string;
}
",
                    "name": "GenericCreateProblemError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface GetDefaultStarterFilesRequest {
  inputParams: TraceApi.VariableTypeAndName[];
  outputType: TraceApi.VariableType;
  methodName: string;
}
",
                    "name": "GetDefaultStarterFilesRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface GetDefaultStarterFilesResponse {
  files: Record<TraceApi.Language.RawValue, TraceApi.ProblemFiles>;
}
",
                    "name": "GetDefaultStarterFilesResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface ProblemDescription {
  boards: TraceApi.ProblemDescriptionBoard[];
}
",
                    "name": "ProblemDescription.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type ProblemDescriptionBoard =
  | TraceApi.ProblemDescriptionBoard.Html
  | TraceApi.ProblemDescriptionBoard.Variable
  | TraceApi.ProblemDescriptionBoard.TestCaseId
  | TraceApi.ProblemDescriptionBoard._Unknown;

export declare namespace ProblemDescriptionBoard {
  interface Html extends _Utils {
    type: \\"html\\";
    value: string;
  }

  interface Variable extends _Utils {
    type: \\"variable\\";
    value: TraceApi.VariableValue;
  }

  interface TestCaseId extends _Utils {
    type: \\"testCaseId\\";
    value: string;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.ProblemDescriptionBoard._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    html: (value: string) => _Result;
    variable: (value: TraceApi.VariableValue) => _Result;
    testCaseId: (value: string) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const ProblemDescriptionBoard = {
  html: (value: string): TraceApi.ProblemDescriptionBoard.Html => {
    const valueWithoutVisit: Omit<TraceApi.ProblemDescriptionBoard.Html, \\"_visit\\"> = {
      value: value,
      type: \\"html\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.ProblemDescriptionBoard.Html, visitor: TraceApi.ProblemDescriptionBoard._Visitor<_Result>) {
      return TraceApi.ProblemDescriptionBoard._visit(this, visitor);
    });
  },

  variable: (value: TraceApi.VariableValue): TraceApi.ProblemDescriptionBoard.Variable => {
    const valueWithoutVisit: Omit<TraceApi.ProblemDescriptionBoard.Variable, \\"_visit\\"> = {
      value: value,
      type: \\"variable\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.ProblemDescriptionBoard.Variable, visitor: TraceApi.ProblemDescriptionBoard._Visitor<_Result>) {
      return TraceApi.ProblemDescriptionBoard._visit(this, visitor);
    });
  },

  testCaseId: (value: string): TraceApi.ProblemDescriptionBoard.TestCaseId => {
    const valueWithoutVisit: Omit<TraceApi.ProblemDescriptionBoard.TestCaseId, \\"_visit\\"> = {
      value: value,
      type: \\"testCaseId\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.ProblemDescriptionBoard.TestCaseId, visitor: TraceApi.ProblemDescriptionBoard._Visitor<_Result>) {
      return TraceApi.ProblemDescriptionBoard._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.ProblemDescriptionBoard,
    visitor: TraceApi.ProblemDescriptionBoard._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"html\\":
        return visitor.html(value.value);
      case \\"variable\\":
        return visitor.variable(value.value);
      case \\"testCaseId\\":
        return visitor.testCaseId(value.value);
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "ProblemDescriptionBoard.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface ProblemFiles {
  solutionFile: TraceApi.FileInfo;
  readOnlyFiles: TraceApi.FileInfo[];
}
",
                    "name": "ProblemFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface ProblemInfo {
  problemId: TraceApi.ProblemId;
  problemDescription: TraceApi.ProblemDescription;
  problemName: string;
  problemVersion: number;
  files: Record<TraceApi.Language.RawValue, TraceApi.ProblemFiles>;
  inputParams: TraceApi.VariableTypeAndName[];
  outputType: TraceApi.VariableType;
  testcases: TraceApi.TestCaseWithExpectedResult[];
  methodName: string;
  supportsCustomTestCases: boolean;
}
",
                    "name": "ProblemInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface ProblemsMap {
  problemsById: Record<TraceApi.ProblemId, TraceApi.ProblemInfo>;
}
",
                    "name": "ProblemsMap.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface UpdateProblemResponse {
  problemVersion: number;
}
",
                    "name": "UpdateProblemResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface VariableTypeAndName {
  variableType: TraceApi.VariableType;
  name: string;
}
",
                    "name": "VariableTypeAndName.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./ProblemInfo\\";
export * from \\"./ProblemsMap\\";
export * from \\"./ProblemDescription\\";
export * from \\"./ProblemDescriptionBoard\\";
export * from \\"./ProblemFiles\\";
export * from \\"./VariableTypeAndName\\";
export * from \\"./CreateProblemRequest\\";
export * from \\"./CreateProblemResponse\\";
export * from \\"./UpdateProblemResponse\\";
export * from \\"./CreateProblemError\\";
export * from \\"./GenericCreateProblemError\\";
export * from \\"./GetDefaultStarterFilesRequest\\";
export * from \\"./GetDefaultStarterFilesResponse\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "problem",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    auth?: {
      token?: core.Supplier<core.BearerToken>;
    };
  }
}

/**
 * Responsible for spinning up and spinning down execution.
 */
export class Client {
  constructor(private readonly options: Client.Options) {}

  public async createExecutionSession(
    request: TraceApi.submission.createExecutionSession.Request
  ): Promise<TraceApi.submission.createExecutionSession.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/sessions/create-session/\${request.language}\`
      ),
      method: \\"POST\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.ExecutionSessionResponse.parse(response.body as serializers.ExecutionSessionResponse.Raw),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getExecutionSession(
    request: TraceApi.submission.getExecutionSession.Request
  ): Promise<TraceApi.submission.getExecutionSession.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \`/sessions/\${request.sessionId}\`),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.submission.getExecutionSession.Response.parse(
          response.body as serializers.ExecutionSessionResponse.Raw | null | undefined
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async stopExecutionSession(
    request: TraceApi.submission.stopExecutionSession.Request
  ): Promise<TraceApi.submission.stopExecutionSession.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \`/sessions/stop/\${request.sessionId}\`),
      method: \\"DELETE\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getExecutionSessionsState(): Promise<TraceApi.submission.getExecutionSessionsState.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/sessions/execution-sessions-state\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.GetExecutionSessionStateResponse.parse(
          response.body as serializers.GetExecutionSessionStateResponse.Raw
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  language: TraceApi.Language;
}

export type Response = core.APIResponse<
  TraceApi.ExecutionSessionResponse,
  TraceApi.submission.createExecutionSession.Error
>;
export type Error = TraceApi.submission.createExecutionSession.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.submission.createExecutionSession.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                    "name": "createExecutionSession.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  sessionId: string;
}

export type Response = core.APIResponse<
  TraceApi.ExecutionSessionResponse | undefined,
  TraceApi.submission.getExecutionSession.Error
>;
export type Error = TraceApi.submission.getExecutionSession.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.submission.getExecutionSession.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                    "name": "getExecutionSession.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  TraceApi.GetExecutionSessionStateResponse,
  TraceApi.submission.getExecutionSessionsState.Error
>;
export type Error = TraceApi.submission.getExecutionSessionsState.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.submission.getExecutionSessionsState.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                    "name": "getExecutionSessionsState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as createExecutionSession from \\"./createExecutionSession\\";
export * as getExecutionSession from \\"./getExecutionSession\\";
export * as stopExecutionSession from \\"./stopExecutionSession\\";
export * as getExecutionSessionsState from \\"./getExecutionSessionsState\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  sessionId: string;
}

export type Response = core.APIResponse<void, TraceApi.submission.stopExecutionSession.Error>;
export type Error = TraceApi.submission.stopExecutionSession.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.submission.stopExecutionSession.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                    "name": "stopExecutionSession.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type ActualResult =
  | TraceApi.ActualResult.Value
  | TraceApi.ActualResult.Exception
  | TraceApi.ActualResult.ExceptionV2
  | TraceApi.ActualResult._Unknown;

export declare namespace ActualResult {
  interface Value extends _Utils {
    type: \\"value\\";
    value: TraceApi.VariableValue;
  }

  interface Exception extends TraceApi.ExceptionInfo, _Utils {
    type: \\"exception\\";
  }

  interface ExceptionV2 extends _Utils {
    type: \\"exceptionV2\\";
    value: TraceApi.ExceptionV2;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.ActualResult._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    value: (value: TraceApi.VariableValue) => _Result;
    exception: (value: TraceApi.ExceptionInfo) => _Result;
    exceptionV2: (value: TraceApi.ExceptionV2) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const ActualResult = {
  value: (value: TraceApi.VariableValue): TraceApi.ActualResult.Value => {
    const valueWithoutVisit: Omit<TraceApi.ActualResult.Value, \\"_visit\\"> = {
      value: value,
      type: \\"value\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.ActualResult.Value, visitor: TraceApi.ActualResult._Visitor<_Result>) {
      return TraceApi.ActualResult._visit(this, visitor);
    });
  },

  exception: (value: TraceApi.ExceptionInfo): TraceApi.ActualResult.Exception => {
    const valueWithoutVisit: Omit<TraceApi.ActualResult.Exception, \\"_visit\\"> = {
      ...value,
      type: \\"exception\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.ActualResult.Exception, visitor: TraceApi.ActualResult._Visitor<_Result>) {
      return TraceApi.ActualResult._visit(this, visitor);
    });
  },

  exceptionV2: (value: TraceApi.ExceptionV2): TraceApi.ActualResult.ExceptionV2 => {
    const valueWithoutVisit: Omit<TraceApi.ActualResult.ExceptionV2, \\"_visit\\"> = {
      value: value,
      type: \\"exceptionV2\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.ActualResult.ExceptionV2, visitor: TraceApi.ActualResult._Visitor<_Result>) {
      return TraceApi.ActualResult._visit(this, visitor);
    });
  },

  _visit: <_Result>(value: TraceApi.ActualResult, visitor: TraceApi.ActualResult._Visitor<_Result>): _Result => {
    switch (value.type) {
      case \\"value\\":
        return visitor.value(value.value);
      case \\"exception\\":
        return visitor.exception(value);
      case \\"exceptionV2\\":
        return visitor.exceptionV2(value.value);
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "ActualResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface BuildingExecutorResponse {
  submissionId: TraceApi.SubmissionId;
  status: TraceApi.ExecutionSessionStatus;
}
",
                    "name": "BuildingExecutorResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type CodeExecutionUpdate =
  /**
   * Statuses if an executor for the session isn't ready (Before RunningResponse). */
  | TraceApi.CodeExecutionUpdate.BuildingExecutor
  /**
   * Sent once a test submission is executing. */
  | TraceApi.CodeExecutionUpdate.Running
  /**
   * Sent if a submission cannot be run (i.e. Compile Error). */
  | TraceApi.CodeExecutionUpdate.Errored
  /**
   * Sent if a submission is stopped. */
  | TraceApi.CodeExecutionUpdate.Stopped
  /**
   * Graded testcases without trace information. */
  | TraceApi.CodeExecutionUpdate.Graded
  /**
   * Graded submission for v2 problems. */
  | TraceApi.CodeExecutionUpdate.GradedV2
  /**
   * Workspace run without trace information. */
  | TraceApi.CodeExecutionUpdate.WorkspaceRan
  /**
   * Gives progress about what is being recorded. */
  | TraceApi.CodeExecutionUpdate.Recording
  /**
   * Graded testcases with trace information. */
  | TraceApi.CodeExecutionUpdate.Recorded
  /**
   * Sent if an invalid request is sent for a submission. */
  | TraceApi.CodeExecutionUpdate.InvalidRequest
  /**
   * Sent once a submission is graded and fully recorded. */
  | TraceApi.CodeExecutionUpdate.Finished
  | TraceApi.CodeExecutionUpdate._Unknown;

export declare namespace CodeExecutionUpdate {
  interface BuildingExecutor extends TraceApi.BuildingExecutorResponse, _Utils {
    type: \\"buildingExecutor\\";
  }

  interface Running extends TraceApi.RunningResponse, _Utils {
    type: \\"running\\";
  }

  interface Errored extends TraceApi.ErroredResponse, _Utils {
    type: \\"errored\\";
  }

  interface Stopped extends TraceApi.StoppedResponse, _Utils {
    type: \\"stopped\\";
  }

  interface Graded extends TraceApi.GradedResponse, _Utils {
    type: \\"graded\\";
  }

  interface GradedV2 extends TraceApi.GradedResponseV2, _Utils {
    type: \\"gradedV2\\";
  }

  interface WorkspaceRan extends TraceApi.WorkspaceRanResponse, _Utils {
    type: \\"workspaceRan\\";
  }

  interface Recording extends TraceApi.RecordingResponseNotification, _Utils {
    type: \\"recording\\";
  }

  interface Recorded extends TraceApi.RecordedResponseNotification, _Utils {
    type: \\"recorded\\";
  }

  interface InvalidRequest extends TraceApi.InvalidRequestResponse, _Utils {
    type: \\"invalidRequest\\";
  }

  interface Finished extends TraceApi.FinishedResponse, _Utils {
    type: \\"finished\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    buildingExecutor: (value: TraceApi.BuildingExecutorResponse) => _Result;
    running: (value: TraceApi.RunningResponse) => _Result;
    errored: (value: TraceApi.ErroredResponse) => _Result;
    stopped: (value: TraceApi.StoppedResponse) => _Result;
    graded: (value: TraceApi.GradedResponse) => _Result;
    gradedV2: (value: TraceApi.GradedResponseV2) => _Result;
    workspaceRan: (value: TraceApi.WorkspaceRanResponse) => _Result;
    recording: (value: TraceApi.RecordingResponseNotification) => _Result;
    recorded: (value: TraceApi.RecordedResponseNotification) => _Result;
    invalidRequest: (value: TraceApi.InvalidRequestResponse) => _Result;
    finished: (value: TraceApi.FinishedResponse) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const CodeExecutionUpdate = {
  buildingExecutor: (value: TraceApi.BuildingExecutorResponse): TraceApi.CodeExecutionUpdate.BuildingExecutor => {
    const valueWithoutVisit: Omit<TraceApi.CodeExecutionUpdate.BuildingExecutor, \\"_visit\\"> = {
      ...value,
      type: \\"buildingExecutor\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CodeExecutionUpdate.BuildingExecutor, visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>) {
      return TraceApi.CodeExecutionUpdate._visit(this, visitor);
    });
  },

  running: (value: TraceApi.RunningResponse): TraceApi.CodeExecutionUpdate.Running => {
    const valueWithoutVisit: Omit<TraceApi.CodeExecutionUpdate.Running, \\"_visit\\"> = {
      ...value,
      type: \\"running\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CodeExecutionUpdate.Running, visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>) {
      return TraceApi.CodeExecutionUpdate._visit(this, visitor);
    });
  },

  errored: (value: TraceApi.ErroredResponse): TraceApi.CodeExecutionUpdate.Errored => {
    const valueWithoutVisit: Omit<TraceApi.CodeExecutionUpdate.Errored, \\"_visit\\"> = {
      ...value,
      type: \\"errored\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CodeExecutionUpdate.Errored, visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>) {
      return TraceApi.CodeExecutionUpdate._visit(this, visitor);
    });
  },

  stopped: (value: TraceApi.StoppedResponse): TraceApi.CodeExecutionUpdate.Stopped => {
    const valueWithoutVisit: Omit<TraceApi.CodeExecutionUpdate.Stopped, \\"_visit\\"> = {
      ...value,
      type: \\"stopped\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CodeExecutionUpdate.Stopped, visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>) {
      return TraceApi.CodeExecutionUpdate._visit(this, visitor);
    });
  },

  graded: (value: TraceApi.GradedResponse): TraceApi.CodeExecutionUpdate.Graded => {
    const valueWithoutVisit: Omit<TraceApi.CodeExecutionUpdate.Graded, \\"_visit\\"> = {
      ...value,
      type: \\"graded\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CodeExecutionUpdate.Graded, visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>) {
      return TraceApi.CodeExecutionUpdate._visit(this, visitor);
    });
  },

  gradedV2: (value: TraceApi.GradedResponseV2): TraceApi.CodeExecutionUpdate.GradedV2 => {
    const valueWithoutVisit: Omit<TraceApi.CodeExecutionUpdate.GradedV2, \\"_visit\\"> = {
      ...value,
      type: \\"gradedV2\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CodeExecutionUpdate.GradedV2, visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>) {
      return TraceApi.CodeExecutionUpdate._visit(this, visitor);
    });
  },

  workspaceRan: (value: TraceApi.WorkspaceRanResponse): TraceApi.CodeExecutionUpdate.WorkspaceRan => {
    const valueWithoutVisit: Omit<TraceApi.CodeExecutionUpdate.WorkspaceRan, \\"_visit\\"> = {
      ...value,
      type: \\"workspaceRan\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CodeExecutionUpdate.WorkspaceRan, visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>) {
      return TraceApi.CodeExecutionUpdate._visit(this, visitor);
    });
  },

  recording: (value: TraceApi.RecordingResponseNotification): TraceApi.CodeExecutionUpdate.Recording => {
    const valueWithoutVisit: Omit<TraceApi.CodeExecutionUpdate.Recording, \\"_visit\\"> = {
      ...value,
      type: \\"recording\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CodeExecutionUpdate.Recording, visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>) {
      return TraceApi.CodeExecutionUpdate._visit(this, visitor);
    });
  },

  recorded: (value: TraceApi.RecordedResponseNotification): TraceApi.CodeExecutionUpdate.Recorded => {
    const valueWithoutVisit: Omit<TraceApi.CodeExecutionUpdate.Recorded, \\"_visit\\"> = {
      ...value,
      type: \\"recorded\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CodeExecutionUpdate.Recorded, visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>) {
      return TraceApi.CodeExecutionUpdate._visit(this, visitor);
    });
  },

  invalidRequest: (value: TraceApi.InvalidRequestResponse): TraceApi.CodeExecutionUpdate.InvalidRequest => {
    const valueWithoutVisit: Omit<TraceApi.CodeExecutionUpdate.InvalidRequest, \\"_visit\\"> = {
      ...value,
      type: \\"invalidRequest\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CodeExecutionUpdate.InvalidRequest, visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>) {
      return TraceApi.CodeExecutionUpdate._visit(this, visitor);
    });
  },

  finished: (value: TraceApi.FinishedResponse): TraceApi.CodeExecutionUpdate.Finished => {
    const valueWithoutVisit: Omit<TraceApi.CodeExecutionUpdate.Finished, \\"_visit\\"> = {
      ...value,
      type: \\"finished\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.CodeExecutionUpdate.Finished, visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>) {
      return TraceApi.CodeExecutionUpdate._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.CodeExecutionUpdate,
    visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"buildingExecutor\\":
        return visitor.buildingExecutor(value);
      case \\"running\\":
        return visitor.running(value);
      case \\"errored\\":
        return visitor.errored(value);
      case \\"stopped\\":
        return visitor.stopped(value);
      case \\"graded\\":
        return visitor.graded(value);
      case \\"gradedV2\\":
        return visitor.gradedV2(value);
      case \\"workspaceRan\\":
        return visitor.workspaceRan(value);
      case \\"recording\\":
        return visitor.recording(value);
      case \\"recorded\\":
        return visitor.recorded(value);
      case \\"invalidRequest\\":
        return visitor.invalidRequest(value);
      case \\"finished\\":
        return visitor.finished(value);
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "CodeExecutionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface CompileError {
  message: string;
}
",
                    "name": "CompileError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface CustomTestCasesUnsupported {
  problemId: TraceApi.ProblemId;
  submissionId: TraceApi.SubmissionId;
}
",
                    "name": "CustomTestCasesUnsupported.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type ErrorInfo =
  | TraceApi.ErrorInfo.CompileError
  /**
   * If the submission cannot be executed and throws a runtime error before getting to any of the testcases.
   *  */
  | TraceApi.ErrorInfo.RuntimeError
  /**
   * If the trace backend encounters an unexpected error.
   *  */
  | TraceApi.ErrorInfo.InternalError
  | TraceApi.ErrorInfo._Unknown;

export declare namespace ErrorInfo {
  interface CompileError extends TraceApi.CompileError, _Utils {
    type: \\"compileError\\";
  }

  interface RuntimeError extends TraceApi.RuntimeError, _Utils {
    type: \\"runtimeError\\";
  }

  interface InternalError extends TraceApi.InternalError, _Utils {
    type: \\"internalError\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.ErrorInfo._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    compileError: (value: TraceApi.CompileError) => _Result;
    runtimeError: (value: TraceApi.RuntimeError) => _Result;
    internalError: (value: TraceApi.InternalError) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const ErrorInfo = {
  compileError: (value: TraceApi.CompileError): TraceApi.ErrorInfo.CompileError => {
    const valueWithoutVisit: Omit<TraceApi.ErrorInfo.CompileError, \\"_visit\\"> = {
      ...value,
      type: \\"compileError\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.ErrorInfo.CompileError, visitor: TraceApi.ErrorInfo._Visitor<_Result>) {
      return TraceApi.ErrorInfo._visit(this, visitor);
    });
  },

  runtimeError: (value: TraceApi.RuntimeError): TraceApi.ErrorInfo.RuntimeError => {
    const valueWithoutVisit: Omit<TraceApi.ErrorInfo.RuntimeError, \\"_visit\\"> = {
      ...value,
      type: \\"runtimeError\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.ErrorInfo.RuntimeError, visitor: TraceApi.ErrorInfo._Visitor<_Result>) {
      return TraceApi.ErrorInfo._visit(this, visitor);
    });
  },

  internalError: (value: TraceApi.InternalError): TraceApi.ErrorInfo.InternalError => {
    const valueWithoutVisit: Omit<TraceApi.ErrorInfo.InternalError, \\"_visit\\"> = {
      ...value,
      type: \\"internalError\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.ErrorInfo.InternalError, visitor: TraceApi.ErrorInfo._Visitor<_Result>) {
      return TraceApi.ErrorInfo._visit(this, visitor);
    });
  },

  _visit: <_Result>(value: TraceApi.ErrorInfo, visitor: TraceApi.ErrorInfo._Visitor<_Result>): _Result => {
    switch (value.type) {
      case \\"compileError\\":
        return visitor.compileError(value);
      case \\"runtimeError\\":
        return visitor.runtimeError(value);
      case \\"internalError\\":
        return visitor.internalError(value);
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "ErrorInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface ErroredResponse {
  submissionId: TraceApi.SubmissionId;
  errorInfo: TraceApi.ErrorInfo;
}
",
                    "name": "ErroredResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface ExceptionInfo {
  exceptionType: string;
  exceptionMessage: string;
  exceptionStacktrace: string;
}
",
                    "name": "ExceptionInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type ExceptionV2 = TraceApi.ExceptionV2.Generic | TraceApi.ExceptionV2.Timeout | TraceApi.ExceptionV2._Unknown;

export declare namespace ExceptionV2 {
  interface Generic extends TraceApi.ExceptionInfo, _Utils {
    type: \\"generic\\";
  }

  interface Timeout extends _Utils {
    type: \\"timeout\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.ExceptionV2._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    generic: (value: TraceApi.ExceptionInfo) => _Result;
    timeout: () => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const ExceptionV2 = {
  generic: (value: TraceApi.ExceptionInfo): TraceApi.ExceptionV2.Generic => {
    const valueWithoutVisit: Omit<TraceApi.ExceptionV2.Generic, \\"_visit\\"> = {
      ...value,
      type: \\"generic\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.ExceptionV2.Generic, visitor: TraceApi.ExceptionV2._Visitor<_Result>) {
      return TraceApi.ExceptionV2._visit(this, visitor);
    });
  },

  timeout: (): TraceApi.ExceptionV2.Timeout => {
    const valueWithoutVisit: Omit<TraceApi.ExceptionV2.Timeout, \\"_visit\\"> = {
      type: \\"timeout\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.ExceptionV2.Timeout, visitor: TraceApi.ExceptionV2._Visitor<_Result>) {
      return TraceApi.ExceptionV2._visit(this, visitor);
    });
  },

  _visit: <_Result>(value: TraceApi.ExceptionV2, visitor: TraceApi.ExceptionV2._Visitor<_Result>): _Result => {
    switch (value.type) {
      case \\"generic\\":
        return visitor.generic(value);
      case \\"timeout\\":
        return visitor.timeout();
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "ExceptionV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface ExecutionSessionResponse {
  sessionId: string;
  executionSessionUrl?: string;
  language: TraceApi.Language;
  status: TraceApi.ExecutionSessionStatus;
}
",
                    "name": "ExecutionSessionResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface ExecutionSessionState {
  lastTimeContacted?: string;
  sessionId: string;
  isWarmInstance: boolean;
  awsTaskId?: string;
  language: TraceApi.Language;
  status: TraceApi.ExecutionSessionStatus;
}
",
                    "name": "ExecutionSessionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface ExecutionSessionStatus<
  RawValue extends ExecutionSessionStatus.RawValue = ExecutionSessionStatus.RawValue
> {
  value: RawValue;
  visit: <_Result>(visitor: TraceApi.ExecutionSessionStatus._Visitor<_Result>) => _Result;
}

const _CreatingContainer: ExecutionSessionStatus<\\"CREATING_CONTAINER\\"> = {
  value: \\"CREATING_CONTAINER\\",
  visit: (visitor) => visitor.creatingContainer(),
};
const _ProvisioningContainer: ExecutionSessionStatus<\\"PROVISIONING_CONTAINER\\"> = {
  value: \\"PROVISIONING_CONTAINER\\",
  visit: (visitor) => visitor.provisioningContainer(),
};
const _PendingContainer: ExecutionSessionStatus<\\"PENDING_CONTAINER\\"> = {
  value: \\"PENDING_CONTAINER\\",
  visit: (visitor) => visitor.pendingContainer(),
};
const _RunningContainer: ExecutionSessionStatus<\\"RUNNING_CONTAINER\\"> = {
  value: \\"RUNNING_CONTAINER\\",
  visit: (visitor) => visitor.runningContainer(),
};
const _LiveContainer: ExecutionSessionStatus<\\"LIVE_CONTAINER\\"> = {
  value: \\"LIVE_CONTAINER\\",
  visit: (visitor) => visitor.liveContainer(),
};
const _FailedToLaunch: ExecutionSessionStatus<\\"FAILED_TO_LAUNCH\\"> = {
  value: \\"FAILED_TO_LAUNCH\\",
  visit: (visitor) => visitor.failedToLaunch(),
};
export const ExecutionSessionStatus = {
  CreatingContainer: _CreatingContainer,
  ProvisioningContainer: _ProvisioningContainer,
  PendingContainer: _PendingContainer,
  RunningContainer: _RunningContainer,
  LiveContainer: _LiveContainer,
  FailedToLaunch: _FailedToLaunch,
  _parse: (value: string): ExecutionSessionStatus => {
    switch (value) {
      case \\"CREATING_CONTAINER\\": {
        return _CreatingContainer;
      }
      case \\"PROVISIONING_CONTAINER\\": {
        return _ProvisioningContainer;
      }
      case \\"PENDING_CONTAINER\\": {
        return _PendingContainer;
      }
      case \\"RUNNING_CONTAINER\\": {
        return _RunningContainer;
      }
      case \\"LIVE_CONTAINER\\": {
        return _LiveContainer;
      }
      case \\"FAILED_TO_LAUNCH\\": {
        return _FailedToLaunch;
      }
      default: {
        return {
          value: value as ExecutionSessionStatus.RawValue,
          visit: (visitor) => visitor._other(value),
        };
      }
    }
  },
} as const;

export declare namespace ExecutionSessionStatus {
  type RawValue =
    | \\"CREATING_CONTAINER\\"
    | \\"PROVISIONING_CONTAINER\\"
    | \\"PENDING_CONTAINER\\"
    | \\"RUNNING_CONTAINER\\"
    | \\"LIVE_CONTAINER\\"
    | \\"FAILED_TO_LAUNCH\\";

  interface _Visitor<_Result> {
    creatingContainer: () => _Result;
    provisioningContainer: () => _Result;
    pendingContainer: () => _Result;
    runningContainer: () => _Result;
    liveContainer: () => _Result;
    failedToLaunch: () => _Result;
    _other: (value: string) => _Result;
  }
}
",
                    "name": "ExecutionSessionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface ExistingSubmissionExecuting {
  submissionId: TraceApi.SubmissionId;
}
",
                    "name": "ExistingSubmissionExecuting.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface ExpressionLocation {
  start: number;
  offset: number;
}
",
                    "name": "ExpressionLocation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface FinishedResponse {
  submissionId: TraceApi.SubmissionId;
}
",
                    "name": "FinishedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface GetExecutionSessionStateResponse {
  states: Record<string, TraceApi.ExecutionSessionState>;
  numWarmingInstances?: number;
  warmingSessionIds: string[];
}
",
                    "name": "GetExecutionSessionStateResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface GetSubmissionStateResponse {
  timeSubmitted?: Date;
  submission: string;
  language: TraceApi.Language;
  submissionTypeState: TraceApi.SubmissionTypeState;
}
",
                    "name": "GetSubmissionStateResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface GetTraceResponsesPageRequest {
  offset?: number;
}
",
                    "name": "GetTraceResponsesPageRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface GradedResponse {
  submissionId: TraceApi.SubmissionId;
  testCases: Record<string, TraceApi.TestCaseResultWithStdout>;
}
",
                    "name": "GradedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface GradedResponseV2 {
  submissionId: TraceApi.SubmissionId;
  testCases: Record<TraceApi.v2.TestCaseId, TraceApi.TestCaseGrade>;
}
",
                    "name": "GradedResponseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface GradedTestCaseUpdate {
  testCaseId: TraceApi.v2.TestCaseId;
  grade: TraceApi.TestCaseGrade;
}
",
                    "name": "GradedTestCaseUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface InitializeProblemRequest {
  problemId: TraceApi.ProblemId;
  problemVersion?: number;
}
",
                    "name": "InitializeProblemRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface InternalError {
  exceptionInfo: TraceApi.ExceptionInfo;
}
",
                    "name": "InternalError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type InvalidRequestCause =
  /**
   * The submission request references a submission id that doesn't exist. */
  | TraceApi.InvalidRequestCause.SubmissionIdNotFound
  | TraceApi.InvalidRequestCause.CustomTestCasesUnsupported
  /**
   * The submission request was routed to an incorrect language executor. */
  | TraceApi.InvalidRequestCause.UnexpectedLanguage
  | TraceApi.InvalidRequestCause._Unknown;

export declare namespace InvalidRequestCause {
  interface SubmissionIdNotFound extends TraceApi.SubmissionIdNotFound, _Utils {
    type: \\"submissionIdNotFound\\";
  }

  interface CustomTestCasesUnsupported extends TraceApi.CustomTestCasesUnsupported, _Utils {
    type: \\"customTestCasesUnsupported\\";
  }

  interface UnexpectedLanguage extends TraceApi.UnexpectedLanguageError, _Utils {
    type: \\"unexpectedLanguage\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.InvalidRequestCause._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    submissionIdNotFound: (value: TraceApi.SubmissionIdNotFound) => _Result;
    customTestCasesUnsupported: (value: TraceApi.CustomTestCasesUnsupported) => _Result;
    unexpectedLanguage: (value: TraceApi.UnexpectedLanguageError) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const InvalidRequestCause = {
  submissionIdNotFound: (value: TraceApi.SubmissionIdNotFound): TraceApi.InvalidRequestCause.SubmissionIdNotFound => {
    const valueWithoutVisit: Omit<TraceApi.InvalidRequestCause.SubmissionIdNotFound, \\"_visit\\"> = {
      ...value,
      type: \\"submissionIdNotFound\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.InvalidRequestCause.SubmissionIdNotFound, visitor: TraceApi.InvalidRequestCause._Visitor<_Result>) {
      return TraceApi.InvalidRequestCause._visit(this, visitor);
    });
  },

  customTestCasesUnsupported: (
    value: TraceApi.CustomTestCasesUnsupported
  ): TraceApi.InvalidRequestCause.CustomTestCasesUnsupported => {
    const valueWithoutVisit: Omit<TraceApi.InvalidRequestCause.CustomTestCasesUnsupported, \\"_visit\\"> = {
      ...value,
      type: \\"customTestCasesUnsupported\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.InvalidRequestCause.CustomTestCasesUnsupported, visitor: TraceApi.InvalidRequestCause._Visitor<_Result>) {
      return TraceApi.InvalidRequestCause._visit(this, visitor);
    });
  },

  unexpectedLanguage: (value: TraceApi.UnexpectedLanguageError): TraceApi.InvalidRequestCause.UnexpectedLanguage => {
    const valueWithoutVisit: Omit<TraceApi.InvalidRequestCause.UnexpectedLanguage, \\"_visit\\"> = {
      ...value,
      type: \\"unexpectedLanguage\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.InvalidRequestCause.UnexpectedLanguage, visitor: TraceApi.InvalidRequestCause._Visitor<_Result>) {
      return TraceApi.InvalidRequestCause._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.InvalidRequestCause,
    visitor: TraceApi.InvalidRequestCause._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"submissionIdNotFound\\":
        return visitor.submissionIdNotFound(value);
      case \\"customTestCasesUnsupported\\":
        return visitor.customTestCasesUnsupported(value);
      case \\"unexpectedLanguage\\":
        return visitor.unexpectedLanguage(value);
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "InvalidRequestCause.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface InvalidRequestResponse {
  request: TraceApi.SubmissionRequest;
  cause: TraceApi.InvalidRequestCause;
}
",
                    "name": "InvalidRequestResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface LightweightStackframeInformation {
  numStackFrames: number;
  topStackFrameMethodName: string;
}
",
                    "name": "LightweightStackframeInformation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface RecordedResponseNotification {
  submissionId: TraceApi.SubmissionId;
  traceResponsesSize: number;
  testCaseId?: string;
}
",
                    "name": "RecordedResponseNotification.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface RecordedTestCaseUpdate {
  testCaseId: TraceApi.v2.TestCaseId;
  traceResponsesSize: number;
}
",
                    "name": "RecordedTestCaseUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface RecordingResponseNotification {
  submissionId: TraceApi.SubmissionId;
  testCaseId?: string;
  lineNumber: number;
  lightweightStackInfo: TraceApi.LightweightStackframeInformation;
  tracedFile?: TraceApi.TracedFile;
}
",
                    "name": "RecordingResponseNotification.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface RunningResponse {
  submissionId: TraceApi.SubmissionId;
  state: TraceApi.RunningSubmissionState;
}
",
                    "name": "RunningResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface RunningSubmissionState<
  RawValue extends RunningSubmissionState.RawValue = RunningSubmissionState.RawValue
> {
  value: RawValue;
  visit: <_Result>(visitor: TraceApi.RunningSubmissionState._Visitor<_Result>) => _Result;
}

const _QueueingSubmission: RunningSubmissionState<\\"QUEUEING_SUBMISSION\\"> = {
  value: \\"QUEUEING_SUBMISSION\\",
  visit: (visitor) => visitor.queueingSubmission(),
};
const _KillingHistoricalSubmissions: RunningSubmissionState<\\"KILLING_HISTORICAL_SUBMISSIONS\\"> = {
  value: \\"KILLING_HISTORICAL_SUBMISSIONS\\",
  visit: (visitor) => visitor.killingHistoricalSubmissions(),
};
const _WritingSubmissionToFile: RunningSubmissionState<\\"WRITING_SUBMISSION_TO_FILE\\"> = {
  value: \\"WRITING_SUBMISSION_TO_FILE\\",
  visit: (visitor) => visitor.writingSubmissionToFile(),
};
const _CompilingSubmission: RunningSubmissionState<\\"COMPILING_SUBMISSION\\"> = {
  value: \\"COMPILING_SUBMISSION\\",
  visit: (visitor) => visitor.compilingSubmission(),
};
const _RunningSubmission: RunningSubmissionState<\\"RUNNING_SUBMISSION\\"> = {
  value: \\"RUNNING_SUBMISSION\\",
  visit: (visitor) => visitor.runningSubmission(),
};
export const RunningSubmissionState = {
  QueueingSubmission: _QueueingSubmission,
  KillingHistoricalSubmissions: _KillingHistoricalSubmissions,
  WritingSubmissionToFile: _WritingSubmissionToFile,
  CompilingSubmission: _CompilingSubmission,
  RunningSubmission: _RunningSubmission,
  _parse: (value: string): RunningSubmissionState => {
    switch (value) {
      case \\"QUEUEING_SUBMISSION\\": {
        return _QueueingSubmission;
      }
      case \\"KILLING_HISTORICAL_SUBMISSIONS\\": {
        return _KillingHistoricalSubmissions;
      }
      case \\"WRITING_SUBMISSION_TO_FILE\\": {
        return _WritingSubmissionToFile;
      }
      case \\"COMPILING_SUBMISSION\\": {
        return _CompilingSubmission;
      }
      case \\"RUNNING_SUBMISSION\\": {
        return _RunningSubmission;
      }
      default: {
        return {
          value: value as RunningSubmissionState.RawValue,
          visit: (visitor) => visitor._other(value),
        };
      }
    }
  },
} as const;

export declare namespace RunningSubmissionState {
  type RawValue =
    | \\"QUEUEING_SUBMISSION\\"
    | \\"KILLING_HISTORICAL_SUBMISSIONS\\"
    | \\"WRITING_SUBMISSION_TO_FILE\\"
    | \\"COMPILING_SUBMISSION\\"
    | \\"RUNNING_SUBMISSION\\";

  interface _Visitor<_Result> {
    queueingSubmission: () => _Result;
    killingHistoricalSubmissions: () => _Result;
    writingSubmissionToFile: () => _Result;
    compilingSubmission: () => _Result;
    runningSubmission: () => _Result;
    _other: (value: string) => _Result;
  }
}
",
                    "name": "RunningSubmissionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface RuntimeError {
  message: string;
}
",
                    "name": "RuntimeError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface Scope {
  variables: Record<string, TraceApi.DebugVariableValue>;
}
",
                    "name": "Scope.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export type ShareId = string & {
  ShareId: void;
};

export const ShareId = {
  create: (value: string) => value as unknown as TraceApi.ShareId,
} as const;
",
                    "name": "ShareId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface StackFrame {
  methodName: string;
  lineNumber: number;
  scopes: TraceApi.Scope[];
}
",
                    "name": "StackFrame.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface StackInformation {
  numStackFrames: number;
  topStackFrame?: TraceApi.StackFrame;
}
",
                    "name": "StackInformation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface StderrResponse {
  submissionId: TraceApi.SubmissionId;
  stderr: string;
}
",
                    "name": "StderrResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface StdoutResponse {
  submissionId: TraceApi.SubmissionId;
  stdout: string;
}
",
                    "name": "StdoutResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface StopRequest {
  submissionId: TraceApi.SubmissionId;
}
",
                    "name": "StopRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface StoppedResponse {
  submissionId: TraceApi.SubmissionId;
}
",
                    "name": "StoppedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface SubmissionFileInfo {
  directory: string;
  filename: string;
  contents: string;
}
",
                    "name": "SubmissionFileInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export type SubmissionId = string & {
  SubmissionId: void;
};

export const SubmissionId = {
  create: (value: string) => value as unknown as TraceApi.SubmissionId,
} as const;
",
                    "name": "SubmissionId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface SubmissionIdNotFound {
  missingSubmissionId: TraceApi.SubmissionId;
}
",
                    "name": "SubmissionIdNotFound.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type SubmissionRequest =
  | TraceApi.SubmissionRequest.InitializeProblemRequest
  | TraceApi.SubmissionRequest.InitializeWorkspaceRequest
  | TraceApi.SubmissionRequest.SubmitV2
  | TraceApi.SubmissionRequest.WorkspaceSubmit
  | TraceApi.SubmissionRequest.Stop
  | TraceApi.SubmissionRequest._Unknown;

export declare namespace SubmissionRequest {
  interface InitializeProblemRequest extends TraceApi.InitializeProblemRequest, _Utils {
    type: \\"initializeProblemRequest\\";
  }

  interface InitializeWorkspaceRequest extends _Utils {
    type: \\"initializeWorkspaceRequest\\";
  }

  interface SubmitV2 extends TraceApi.SubmitRequestV2, _Utils {
    type: \\"submitV2\\";
  }

  interface WorkspaceSubmit extends TraceApi.WorkspaceSubmitRequest, _Utils {
    type: \\"workspaceSubmit\\";
  }

  interface Stop extends TraceApi.StopRequest, _Utils {
    type: \\"stop\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.SubmissionRequest._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    initializeProblemRequest: (value: TraceApi.InitializeProblemRequest) => _Result;
    initializeWorkspaceRequest: () => _Result;
    submitV2: (value: TraceApi.SubmitRequestV2) => _Result;
    workspaceSubmit: (value: TraceApi.WorkspaceSubmitRequest) => _Result;
    stop: (value: TraceApi.StopRequest) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const SubmissionRequest = {
  initializeProblemRequest: (
    value: TraceApi.InitializeProblemRequest
  ): TraceApi.SubmissionRequest.InitializeProblemRequest => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionRequest.InitializeProblemRequest, \\"_visit\\"> = {
      ...value,
      type: \\"initializeProblemRequest\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionRequest.InitializeProblemRequest, visitor: TraceApi.SubmissionRequest._Visitor<_Result>) {
      return TraceApi.SubmissionRequest._visit(this, visitor);
    });
  },

  initializeWorkspaceRequest: (): TraceApi.SubmissionRequest.InitializeWorkspaceRequest => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionRequest.InitializeWorkspaceRequest, \\"_visit\\"> = {
      type: \\"initializeWorkspaceRequest\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionRequest.InitializeWorkspaceRequest, visitor: TraceApi.SubmissionRequest._Visitor<_Result>) {
      return TraceApi.SubmissionRequest._visit(this, visitor);
    });
  },

  submitV2: (value: TraceApi.SubmitRequestV2): TraceApi.SubmissionRequest.SubmitV2 => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionRequest.SubmitV2, \\"_visit\\"> = {
      ...value,
      type: \\"submitV2\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionRequest.SubmitV2, visitor: TraceApi.SubmissionRequest._Visitor<_Result>) {
      return TraceApi.SubmissionRequest._visit(this, visitor);
    });
  },

  workspaceSubmit: (value: TraceApi.WorkspaceSubmitRequest): TraceApi.SubmissionRequest.WorkspaceSubmit => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionRequest.WorkspaceSubmit, \\"_visit\\"> = {
      ...value,
      type: \\"workspaceSubmit\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionRequest.WorkspaceSubmit, visitor: TraceApi.SubmissionRequest._Visitor<_Result>) {
      return TraceApi.SubmissionRequest._visit(this, visitor);
    });
  },

  stop: (value: TraceApi.StopRequest): TraceApi.SubmissionRequest.Stop => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionRequest.Stop, \\"_visit\\"> = {
      ...value,
      type: \\"stop\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionRequest.Stop, visitor: TraceApi.SubmissionRequest._Visitor<_Result>) {
      return TraceApi.SubmissionRequest._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.SubmissionRequest,
    visitor: TraceApi.SubmissionRequest._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"initializeProblemRequest\\":
        return visitor.initializeProblemRequest(value);
      case \\"initializeWorkspaceRequest\\":
        return visitor.initializeWorkspaceRequest();
      case \\"submitV2\\":
        return visitor.submitV2(value);
      case \\"workspaceSubmit\\":
        return visitor.workspaceSubmit(value);
      case \\"stop\\":
        return visitor.stop(value);
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "SubmissionRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type SubmissionResponse =
  | TraceApi.SubmissionResponse.ServerInitialized
  | TraceApi.SubmissionResponse.ProblemInitialized
  | TraceApi.SubmissionResponse.WorkspaceInitialized
  | TraceApi.SubmissionResponse.ServerErrored
  | TraceApi.SubmissionResponse.CodeExecutionUpdate
  | TraceApi.SubmissionResponse.Terminated
  | TraceApi.SubmissionResponse._Unknown;

export declare namespace SubmissionResponse {
  interface ServerInitialized extends _Utils {
    type: \\"serverInitialized\\";
  }

  interface ProblemInitialized extends _Utils {
    type: \\"problemInitialized\\";
    value: TraceApi.ProblemId;
  }

  interface WorkspaceInitialized extends _Utils {
    type: \\"workspaceInitialized\\";
  }

  interface ServerErrored extends TraceApi.ExceptionInfo, _Utils {
    type: \\"serverErrored\\";
  }

  interface CodeExecutionUpdate extends _Utils {
    type: \\"codeExecutionUpdate\\";
    value: TraceApi.CodeExecutionUpdate;
  }

  interface Terminated extends TraceApi.TerminatedResponse, _Utils {
    type: \\"terminated\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.SubmissionResponse._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    serverInitialized: () => _Result;
    problemInitialized: (value: TraceApi.ProblemId) => _Result;
    workspaceInitialized: () => _Result;
    serverErrored: (value: TraceApi.ExceptionInfo) => _Result;
    codeExecutionUpdate: (value: TraceApi.CodeExecutionUpdate) => _Result;
    terminated: (value: TraceApi.TerminatedResponse) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const SubmissionResponse = {
  serverInitialized: (): TraceApi.SubmissionResponse.ServerInitialized => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionResponse.ServerInitialized, \\"_visit\\"> = {
      type: \\"serverInitialized\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionResponse.ServerInitialized, visitor: TraceApi.SubmissionResponse._Visitor<_Result>) {
      return TraceApi.SubmissionResponse._visit(this, visitor);
    });
  },

  problemInitialized: (value: TraceApi.ProblemId): TraceApi.SubmissionResponse.ProblemInitialized => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionResponse.ProblemInitialized, \\"_visit\\"> = {
      value: value,
      type: \\"problemInitialized\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionResponse.ProblemInitialized, visitor: TraceApi.SubmissionResponse._Visitor<_Result>) {
      return TraceApi.SubmissionResponse._visit(this, visitor);
    });
  },

  workspaceInitialized: (): TraceApi.SubmissionResponse.WorkspaceInitialized => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionResponse.WorkspaceInitialized, \\"_visit\\"> = {
      type: \\"workspaceInitialized\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionResponse.WorkspaceInitialized, visitor: TraceApi.SubmissionResponse._Visitor<_Result>) {
      return TraceApi.SubmissionResponse._visit(this, visitor);
    });
  },

  serverErrored: (value: TraceApi.ExceptionInfo): TraceApi.SubmissionResponse.ServerErrored => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionResponse.ServerErrored, \\"_visit\\"> = {
      ...value,
      type: \\"serverErrored\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionResponse.ServerErrored, visitor: TraceApi.SubmissionResponse._Visitor<_Result>) {
      return TraceApi.SubmissionResponse._visit(this, visitor);
    });
  },

  codeExecutionUpdate: (value: TraceApi.CodeExecutionUpdate): TraceApi.SubmissionResponse.CodeExecutionUpdate => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionResponse.CodeExecutionUpdate, \\"_visit\\"> = {
      value: value,
      type: \\"codeExecutionUpdate\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionResponse.CodeExecutionUpdate, visitor: TraceApi.SubmissionResponse._Visitor<_Result>) {
      return TraceApi.SubmissionResponse._visit(this, visitor);
    });
  },

  terminated: (value: TraceApi.TerminatedResponse): TraceApi.SubmissionResponse.Terminated => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionResponse.Terminated, \\"_visit\\"> = {
      ...value,
      type: \\"terminated\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionResponse.Terminated, visitor: TraceApi.SubmissionResponse._Visitor<_Result>) {
      return TraceApi.SubmissionResponse._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.SubmissionResponse,
    visitor: TraceApi.SubmissionResponse._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"serverInitialized\\":
        return visitor.serverInitialized();
      case \\"problemInitialized\\":
        return visitor.problemInitialized(value.value);
      case \\"workspaceInitialized\\":
        return visitor.workspaceInitialized();
      case \\"serverErrored\\":
        return visitor.serverErrored(value);
      case \\"codeExecutionUpdate\\":
        return visitor.codeExecutionUpdate(value.value);
      case \\"terminated\\":
        return visitor.terminated(value);
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "SubmissionResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type SubmissionStatusForTestCase =
  | TraceApi.SubmissionStatusForTestCase.Graded
  | TraceApi.SubmissionStatusForTestCase.GradedV2
  | TraceApi.SubmissionStatusForTestCase.Traced
  | TraceApi.SubmissionStatusForTestCase._Unknown;

export declare namespace SubmissionStatusForTestCase {
  interface Graded extends TraceApi.TestCaseResultWithStdout, _Utils {
    type: \\"graded\\";
  }

  interface GradedV2 extends _Utils {
    type: \\"gradedV2\\";
    value: TraceApi.TestCaseGrade;
  }

  interface Traced extends TraceApi.TracedTestCase, _Utils {
    type: \\"traced\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.SubmissionStatusForTestCase._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    graded: (value: TraceApi.TestCaseResultWithStdout) => _Result;
    gradedV2: (value: TraceApi.TestCaseGrade) => _Result;
    traced: (value: TraceApi.TracedTestCase) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const SubmissionStatusForTestCase = {
  graded: (value: TraceApi.TestCaseResultWithStdout): TraceApi.SubmissionStatusForTestCase.Graded => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionStatusForTestCase.Graded, \\"_visit\\"> = {
      ...value,
      type: \\"graded\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionStatusForTestCase.Graded, visitor: TraceApi.SubmissionStatusForTestCase._Visitor<_Result>) {
      return TraceApi.SubmissionStatusForTestCase._visit(this, visitor);
    });
  },

  gradedV2: (value: TraceApi.TestCaseGrade): TraceApi.SubmissionStatusForTestCase.GradedV2 => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionStatusForTestCase.GradedV2, \\"_visit\\"> = {
      value: value,
      type: \\"gradedV2\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionStatusForTestCase.GradedV2, visitor: TraceApi.SubmissionStatusForTestCase._Visitor<_Result>) {
      return TraceApi.SubmissionStatusForTestCase._visit(this, visitor);
    });
  },

  traced: (value: TraceApi.TracedTestCase): TraceApi.SubmissionStatusForTestCase.Traced => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionStatusForTestCase.Traced, \\"_visit\\"> = {
      ...value,
      type: \\"traced\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionStatusForTestCase.Traced, visitor: TraceApi.SubmissionStatusForTestCase._Visitor<_Result>) {
      return TraceApi.SubmissionStatusForTestCase._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.SubmissionStatusForTestCase,
    visitor: TraceApi.SubmissionStatusForTestCase._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"graded\\":
        return visitor.graded(value);
      case \\"gradedV2\\":
        return visitor.gradedV2(value.value);
      case \\"traced\\":
        return visitor.traced(value);
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "SubmissionStatusForTestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type SubmissionStatusV2 =
  | TraceApi.SubmissionStatusV2.Test
  | TraceApi.SubmissionStatusV2.Workspace
  | TraceApi.SubmissionStatusV2._Unknown;

export declare namespace SubmissionStatusV2 {
  interface Test extends TraceApi.TestSubmissionStatusV2, _Utils {
    type: \\"test\\";
  }

  interface Workspace extends TraceApi.WorkspaceSubmissionStatusV2, _Utils {
    type: \\"workspace\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.SubmissionStatusV2._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    test: (value: TraceApi.TestSubmissionStatusV2) => _Result;
    workspace: (value: TraceApi.WorkspaceSubmissionStatusV2) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const SubmissionStatusV2 = {
  test: (value: TraceApi.TestSubmissionStatusV2): TraceApi.SubmissionStatusV2.Test => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionStatusV2.Test, \\"_visit\\"> = {
      ...value,
      type: \\"test\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionStatusV2.Test, visitor: TraceApi.SubmissionStatusV2._Visitor<_Result>) {
      return TraceApi.SubmissionStatusV2._visit(this, visitor);
    });
  },

  workspace: (value: TraceApi.WorkspaceSubmissionStatusV2): TraceApi.SubmissionStatusV2.Workspace => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionStatusV2.Workspace, \\"_visit\\"> = {
      ...value,
      type: \\"workspace\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionStatusV2.Workspace, visitor: TraceApi.SubmissionStatusV2._Visitor<_Result>) {
      return TraceApi.SubmissionStatusV2._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.SubmissionStatusV2,
    visitor: TraceApi.SubmissionStatusV2._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"test\\":
        return visitor.test(value);
      case \\"workspace\\":
        return visitor.workspace(value);
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "SubmissionStatusV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

/**
 * Keep in sync with SubmissionType.
 */
export interface SubmissionTypeEnum<RawValue extends SubmissionTypeEnum.RawValue = SubmissionTypeEnum.RawValue> {
  value: RawValue;
  visit: <_Result>(visitor: TraceApi.SubmissionTypeEnum._Visitor<_Result>) => _Result;
}

const _Test: SubmissionTypeEnum<\\"TEST\\"> = {
  value: \\"TEST\\",
  visit: (visitor) => visitor.test(),
};
export const SubmissionTypeEnum = {
  Test: _Test,
  _parse: (value: string): SubmissionTypeEnum => {
    switch (value) {
      case \\"TEST\\": {
        return _Test;
      }
      default: {
        return {
          value: value as SubmissionTypeEnum.RawValue,
          visit: (visitor) => visitor._other(value),
        };
      }
    }
  },
} as const;

export declare namespace SubmissionTypeEnum {
  type RawValue = \\"TEST\\";

  interface _Visitor<_Result> {
    test: () => _Result;
    _other: (value: string) => _Result;
  }
}
",
                    "name": "SubmissionTypeEnum.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type SubmissionTypeState =
  | TraceApi.SubmissionTypeState.Test
  | TraceApi.SubmissionTypeState.Workspace
  | TraceApi.SubmissionTypeState._Unknown;

export declare namespace SubmissionTypeState {
  interface Test extends TraceApi.TestSubmissionState, _Utils {
    type: \\"test\\";
  }

  interface Workspace extends TraceApi.WorkspaceSubmissionState, _Utils {
    type: \\"workspace\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.SubmissionTypeState._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    test: (value: TraceApi.TestSubmissionState) => _Result;
    workspace: (value: TraceApi.WorkspaceSubmissionState) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const SubmissionTypeState = {
  test: (value: TraceApi.TestSubmissionState): TraceApi.SubmissionTypeState.Test => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionTypeState.Test, \\"_visit\\"> = {
      ...value,
      type: \\"test\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionTypeState.Test, visitor: TraceApi.SubmissionTypeState._Visitor<_Result>) {
      return TraceApi.SubmissionTypeState._visit(this, visitor);
    });
  },

  workspace: (value: TraceApi.WorkspaceSubmissionState): TraceApi.SubmissionTypeState.Workspace => {
    const valueWithoutVisit: Omit<TraceApi.SubmissionTypeState.Workspace, \\"_visit\\"> = {
      ...value,
      type: \\"workspace\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.SubmissionTypeState.Workspace, visitor: TraceApi.SubmissionTypeState._Visitor<_Result>) {
      return TraceApi.SubmissionTypeState._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.SubmissionTypeState,
    visitor: TraceApi.SubmissionTypeState._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"test\\":
        return visitor.test(value);
      case \\"workspace\\":
        return visitor.workspace(value);
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "SubmissionTypeState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface SubmitRequestV2 {
  submissionId: TraceApi.SubmissionId;
  language: TraceApi.Language;
  submissionFiles: TraceApi.SubmissionFileInfo[];
  problemId: TraceApi.ProblemId;
  problemVersion?: number;
  userId?: string;
}
",
                    "name": "SubmitRequestV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface TerminatedResponse {}
",
                    "name": "TerminatedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type TestCaseGrade =
  | TraceApi.TestCaseGrade.Hidden
  | TraceApi.TestCaseGrade.NonHidden
  | TraceApi.TestCaseGrade._Unknown;

export declare namespace TestCaseGrade {
  interface Hidden extends TraceApi.TestCaseHiddenGrade, _Utils {
    type: \\"hidden\\";
  }

  interface NonHidden extends TraceApi.TestCaseNonHiddenGrade, _Utils {
    type: \\"nonHidden\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.TestCaseGrade._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    hidden: (value: TraceApi.TestCaseHiddenGrade) => _Result;
    nonHidden: (value: TraceApi.TestCaseNonHiddenGrade) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const TestCaseGrade = {
  hidden: (value: TraceApi.TestCaseHiddenGrade): TraceApi.TestCaseGrade.Hidden => {
    const valueWithoutVisit: Omit<TraceApi.TestCaseGrade.Hidden, \\"_visit\\"> = {
      ...value,
      type: \\"hidden\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.TestCaseGrade.Hidden, visitor: TraceApi.TestCaseGrade._Visitor<_Result>) {
      return TraceApi.TestCaseGrade._visit(this, visitor);
    });
  },

  nonHidden: (value: TraceApi.TestCaseNonHiddenGrade): TraceApi.TestCaseGrade.NonHidden => {
    const valueWithoutVisit: Omit<TraceApi.TestCaseGrade.NonHidden, \\"_visit\\"> = {
      ...value,
      type: \\"nonHidden\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.TestCaseGrade.NonHidden, visitor: TraceApi.TestCaseGrade._Visitor<_Result>) {
      return TraceApi.TestCaseGrade._visit(this, visitor);
    });
  },

  _visit: <_Result>(value: TraceApi.TestCaseGrade, visitor: TraceApi.TestCaseGrade._Visitor<_Result>): _Result => {
    switch (value.type) {
      case \\"hidden\\":
        return visitor.hidden(value);
      case \\"nonHidden\\":
        return visitor.nonHidden(value);
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "TestCaseGrade.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface TestCaseHiddenGrade {
  passed: boolean;
}
",
                    "name": "TestCaseHiddenGrade.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface TestCaseNonHiddenGrade {
  passed: boolean;
  actualResult?: TraceApi.VariableValue;
  exception?: TraceApi.ExceptionV2;
  stdout: string;
}
",
                    "name": "TestCaseNonHiddenGrade.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface TestCaseResult {
  expectedResult: TraceApi.VariableValue;
  actualResult: TraceApi.ActualResult;
  passed: boolean;
}
",
                    "name": "TestCaseResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface TestCaseResultWithStdout {
  result: TraceApi.TestCaseResult;
  stdout: string;
}
",
                    "name": "TestCaseResultWithStdout.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface TestSubmissionState {
  problemId: TraceApi.ProblemId;
  defaultTestCases: TraceApi.TestCase[];
  customTestCases: TraceApi.TestCase[];
  status: TraceApi.TestSubmissionStatus;
}
",
                    "name": "TestSubmissionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type TestSubmissionStatus =
  | TraceApi.TestSubmissionStatus.Stopped
  | TraceApi.TestSubmissionStatus.Errored
  | TraceApi.TestSubmissionStatus.Running
  | TraceApi.TestSubmissionStatus.TestCaseIdToState
  | TraceApi.TestSubmissionStatus._Unknown;

export declare namespace TestSubmissionStatus {
  interface Stopped extends _Utils {
    type: \\"stopped\\";
  }

  interface Errored extends _Utils {
    type: \\"errored\\";
    value: TraceApi.ErrorInfo;
  }

  interface Running extends _Utils {
    type: \\"running\\";
    value: TraceApi.RunningSubmissionState;
  }

  interface TestCaseIdToState extends _Utils {
    type: \\"testCaseIdToState\\";
    value: Record<string, TraceApi.SubmissionStatusForTestCase>;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.TestSubmissionStatus._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    stopped: () => _Result;
    errored: (value: TraceApi.ErrorInfo) => _Result;
    running: (value: TraceApi.RunningSubmissionState) => _Result;
    testCaseIdToState: (value: Record<string, TraceApi.SubmissionStatusForTestCase>) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const TestSubmissionStatus = {
  stopped: (): TraceApi.TestSubmissionStatus.Stopped => {
    const valueWithoutVisit: Omit<TraceApi.TestSubmissionStatus.Stopped, \\"_visit\\"> = {
      type: \\"stopped\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.TestSubmissionStatus.Stopped, visitor: TraceApi.TestSubmissionStatus._Visitor<_Result>) {
      return TraceApi.TestSubmissionStatus._visit(this, visitor);
    });
  },

  errored: (value: TraceApi.ErrorInfo): TraceApi.TestSubmissionStatus.Errored => {
    const valueWithoutVisit: Omit<TraceApi.TestSubmissionStatus.Errored, \\"_visit\\"> = {
      value: value,
      type: \\"errored\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.TestSubmissionStatus.Errored, visitor: TraceApi.TestSubmissionStatus._Visitor<_Result>) {
      return TraceApi.TestSubmissionStatus._visit(this, visitor);
    });
  },

  running: (value: TraceApi.RunningSubmissionState): TraceApi.TestSubmissionStatus.Running => {
    const valueWithoutVisit: Omit<TraceApi.TestSubmissionStatus.Running, \\"_visit\\"> = {
      value: value,
      type: \\"running\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.TestSubmissionStatus.Running, visitor: TraceApi.TestSubmissionStatus._Visitor<_Result>) {
      return TraceApi.TestSubmissionStatus._visit(this, visitor);
    });
  },

  testCaseIdToState: (
    value: Record<string, TraceApi.SubmissionStatusForTestCase>
  ): TraceApi.TestSubmissionStatus.TestCaseIdToState => {
    const valueWithoutVisit: Omit<TraceApi.TestSubmissionStatus.TestCaseIdToState, \\"_visit\\"> = {
      value: value,
      type: \\"testCaseIdToState\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.TestSubmissionStatus.TestCaseIdToState, visitor: TraceApi.TestSubmissionStatus._Visitor<_Result>) {
      return TraceApi.TestSubmissionStatus._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.TestSubmissionStatus,
    visitor: TraceApi.TestSubmissionStatus._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"stopped\\":
        return visitor.stopped();
      case \\"errored\\":
        return visitor.errored(value.value);
      case \\"running\\":
        return visitor.running(value.value);
      case \\"testCaseIdToState\\":
        return visitor.testCaseIdToState(value.value);
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "TestSubmissionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface TestSubmissionStatusV2 {
  updates: TraceApi.TestSubmissionUpdate[];
  problemId: TraceApi.ProblemId;
  problemVersion: number;
  problemInfo: TraceApi.v2.ProblemInfoV2;
}
",
                    "name": "TestSubmissionStatusV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface TestSubmissionUpdate {
  updateTime: Date;
  updateInfo: TraceApi.TestSubmissionUpdateInfo;
}
",
                    "name": "TestSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type TestSubmissionUpdateInfo =
  | TraceApi.TestSubmissionUpdateInfo.Running
  | TraceApi.TestSubmissionUpdateInfo.Stopped
  | TraceApi.TestSubmissionUpdateInfo.Errored
  | TraceApi.TestSubmissionUpdateInfo.GradedTestCase
  | TraceApi.TestSubmissionUpdateInfo.RecordedTestCase
  | TraceApi.TestSubmissionUpdateInfo.Finished
  | TraceApi.TestSubmissionUpdateInfo._Unknown;

export declare namespace TestSubmissionUpdateInfo {
  interface Running extends _Utils {
    type: \\"running\\";
    value: TraceApi.RunningSubmissionState;
  }

  interface Stopped extends _Utils {
    type: \\"stopped\\";
  }

  interface Errored extends _Utils {
    type: \\"errored\\";
    value: TraceApi.ErrorInfo;
  }

  interface GradedTestCase extends TraceApi.GradedTestCaseUpdate, _Utils {
    type: \\"gradedTestCase\\";
  }

  interface RecordedTestCase extends TraceApi.RecordedTestCaseUpdate, _Utils {
    type: \\"recordedTestCase\\";
  }

  interface Finished extends _Utils {
    type: \\"finished\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.TestSubmissionUpdateInfo._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    running: (value: TraceApi.RunningSubmissionState) => _Result;
    stopped: () => _Result;
    errored: (value: TraceApi.ErrorInfo) => _Result;
    gradedTestCase: (value: TraceApi.GradedTestCaseUpdate) => _Result;
    recordedTestCase: (value: TraceApi.RecordedTestCaseUpdate) => _Result;
    finished: () => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const TestSubmissionUpdateInfo = {
  running: (value: TraceApi.RunningSubmissionState): TraceApi.TestSubmissionUpdateInfo.Running => {
    const valueWithoutVisit: Omit<TraceApi.TestSubmissionUpdateInfo.Running, \\"_visit\\"> = {
      value: value,
      type: \\"running\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.TestSubmissionUpdateInfo.Running, visitor: TraceApi.TestSubmissionUpdateInfo._Visitor<_Result>) {
      return TraceApi.TestSubmissionUpdateInfo._visit(this, visitor);
    });
  },

  stopped: (): TraceApi.TestSubmissionUpdateInfo.Stopped => {
    const valueWithoutVisit: Omit<TraceApi.TestSubmissionUpdateInfo.Stopped, \\"_visit\\"> = {
      type: \\"stopped\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.TestSubmissionUpdateInfo.Stopped, visitor: TraceApi.TestSubmissionUpdateInfo._Visitor<_Result>) {
      return TraceApi.TestSubmissionUpdateInfo._visit(this, visitor);
    });
  },

  errored: (value: TraceApi.ErrorInfo): TraceApi.TestSubmissionUpdateInfo.Errored => {
    const valueWithoutVisit: Omit<TraceApi.TestSubmissionUpdateInfo.Errored, \\"_visit\\"> = {
      value: value,
      type: \\"errored\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.TestSubmissionUpdateInfo.Errored, visitor: TraceApi.TestSubmissionUpdateInfo._Visitor<_Result>) {
      return TraceApi.TestSubmissionUpdateInfo._visit(this, visitor);
    });
  },

  gradedTestCase: (value: TraceApi.GradedTestCaseUpdate): TraceApi.TestSubmissionUpdateInfo.GradedTestCase => {
    const valueWithoutVisit: Omit<TraceApi.TestSubmissionUpdateInfo.GradedTestCase, \\"_visit\\"> = {
      ...value,
      type: \\"gradedTestCase\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.TestSubmissionUpdateInfo.GradedTestCase, visitor: TraceApi.TestSubmissionUpdateInfo._Visitor<_Result>) {
      return TraceApi.TestSubmissionUpdateInfo._visit(this, visitor);
    });
  },

  recordedTestCase: (value: TraceApi.RecordedTestCaseUpdate): TraceApi.TestSubmissionUpdateInfo.RecordedTestCase => {
    const valueWithoutVisit: Omit<TraceApi.TestSubmissionUpdateInfo.RecordedTestCase, \\"_visit\\"> = {
      ...value,
      type: \\"recordedTestCase\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.TestSubmissionUpdateInfo.RecordedTestCase, visitor: TraceApi.TestSubmissionUpdateInfo._Visitor<_Result>) {
      return TraceApi.TestSubmissionUpdateInfo._visit(this, visitor);
    });
  },

  finished: (): TraceApi.TestSubmissionUpdateInfo.Finished => {
    const valueWithoutVisit: Omit<TraceApi.TestSubmissionUpdateInfo.Finished, \\"_visit\\"> = {
      type: \\"finished\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.TestSubmissionUpdateInfo.Finished, visitor: TraceApi.TestSubmissionUpdateInfo._Visitor<_Result>) {
      return TraceApi.TestSubmissionUpdateInfo._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.TestSubmissionUpdateInfo,
    visitor: TraceApi.TestSubmissionUpdateInfo._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"running\\":
        return visitor.running(value.value);
      case \\"stopped\\":
        return visitor.stopped();
      case \\"errored\\":
        return visitor.errored(value.value);
      case \\"gradedTestCase\\":
        return visitor.gradedTestCase(value);
      case \\"recordedTestCase\\":
        return visitor.recordedTestCase(value);
      case \\"finished\\":
        return visitor.finished();
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "TestSubmissionUpdateInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface TraceResponse {
  submissionId: TraceApi.SubmissionId;
  lineNumber: number;
  returnValue?: TraceApi.DebugVariableValue;
  expressionLocation?: TraceApi.ExpressionLocation;
  stack: TraceApi.StackInformation;
  stdout?: string;
}
",
                    "name": "TraceResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface TraceResponseV2 {
  submissionId: TraceApi.SubmissionId;
  lineNumber: number;
  file: TraceApi.TracedFile;
  returnValue?: TraceApi.DebugVariableValue;
  expressionLocation?: TraceApi.ExpressionLocation;
  stack: TraceApi.StackInformation;
  stdout?: string;
}
",
                    "name": "TraceResponseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface TraceResponsesPage {
  /**
   * If present, use this to load subseqent pages.
   * The offset is the id of the next trace response to load.
   *
   */
  offset?: number;
  traceResponses: TraceApi.TraceResponse[];
}
",
                    "name": "TraceResponsesPage.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface TraceResponsesPageV2 {
  /**
   * If present, use this to load subseqent pages.
   * The offset is the id of the next trace response to load.
   *
   */
  offset?: number;
  traceResponses: TraceApi.TraceResponseV2[];
}
",
                    "name": "TraceResponsesPageV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface TracedFile {
  filename: string;
  directory: string;
}
",
                    "name": "TracedFile.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface TracedTestCase {
  result: TraceApi.TestCaseResultWithStdout;
  traceResponsesSize: number;
}
",
                    "name": "TracedTestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface UnexpectedLanguageError {
  expectedLanguage: TraceApi.Language;
  actualLanguage: TraceApi.Language;
}
",
                    "name": "UnexpectedLanguageError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface WorkspaceFiles {
  mainFile: TraceApi.FileInfo;
  readOnlyFiles: TraceApi.FileInfo[];
}
",
                    "name": "WorkspaceFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface WorkspaceRanResponse {
  submissionId: TraceApi.SubmissionId;
  runDetails: TraceApi.WorkspaceRunDetails;
}
",
                    "name": "WorkspaceRanResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface WorkspaceRunDetails {
  exceptionV2?: TraceApi.ExceptionV2;
  exception?: TraceApi.ExceptionInfo;
  stdout: string;
}
",
                    "name": "WorkspaceRunDetails.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface WorkspaceStarterFilesResponse {
  files: Record<TraceApi.Language.RawValue, TraceApi.WorkspaceFiles>;
}
",
                    "name": "WorkspaceStarterFilesResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface WorkspaceStarterFilesResponseV2 {
  filesByLanguage: Record<TraceApi.Language.RawValue, TraceApi.v2.Files>;
}
",
                    "name": "WorkspaceStarterFilesResponseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface WorkspaceSubmissionState {
  status: TraceApi.WorkspaceSubmissionStatus;
}
",
                    "name": "WorkspaceSubmissionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type WorkspaceSubmissionStatus =
  | TraceApi.WorkspaceSubmissionStatus.Stopped
  | TraceApi.WorkspaceSubmissionStatus.Errored
  | TraceApi.WorkspaceSubmissionStatus.Running
  | TraceApi.WorkspaceSubmissionStatus.Ran
  | TraceApi.WorkspaceSubmissionStatus.Traced
  | TraceApi.WorkspaceSubmissionStatus._Unknown;

export declare namespace WorkspaceSubmissionStatus {
  interface Stopped extends _Utils {
    type: \\"stopped\\";
  }

  interface Errored extends _Utils {
    type: \\"errored\\";
    value: TraceApi.ErrorInfo;
  }

  interface Running extends _Utils {
    type: \\"running\\";
    value: TraceApi.RunningSubmissionState;
  }

  interface Ran extends TraceApi.WorkspaceRunDetails, _Utils {
    type: \\"ran\\";
  }

  interface Traced extends TraceApi.WorkspaceRunDetails, _Utils {
    type: \\"traced\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.WorkspaceSubmissionStatus._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    stopped: () => _Result;
    errored: (value: TraceApi.ErrorInfo) => _Result;
    running: (value: TraceApi.RunningSubmissionState) => _Result;
    ran: (value: TraceApi.WorkspaceRunDetails) => _Result;
    traced: (value: TraceApi.WorkspaceRunDetails) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const WorkspaceSubmissionStatus = {
  stopped: (): TraceApi.WorkspaceSubmissionStatus.Stopped => {
    const valueWithoutVisit: Omit<TraceApi.WorkspaceSubmissionStatus.Stopped, \\"_visit\\"> = {
      type: \\"stopped\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.WorkspaceSubmissionStatus.Stopped, visitor: TraceApi.WorkspaceSubmissionStatus._Visitor<_Result>) {
      return TraceApi.WorkspaceSubmissionStatus._visit(this, visitor);
    });
  },

  errored: (value: TraceApi.ErrorInfo): TraceApi.WorkspaceSubmissionStatus.Errored => {
    const valueWithoutVisit: Omit<TraceApi.WorkspaceSubmissionStatus.Errored, \\"_visit\\"> = {
      value: value,
      type: \\"errored\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.WorkspaceSubmissionStatus.Errored, visitor: TraceApi.WorkspaceSubmissionStatus._Visitor<_Result>) {
      return TraceApi.WorkspaceSubmissionStatus._visit(this, visitor);
    });
  },

  running: (value: TraceApi.RunningSubmissionState): TraceApi.WorkspaceSubmissionStatus.Running => {
    const valueWithoutVisit: Omit<TraceApi.WorkspaceSubmissionStatus.Running, \\"_visit\\"> = {
      value: value,
      type: \\"running\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.WorkspaceSubmissionStatus.Running, visitor: TraceApi.WorkspaceSubmissionStatus._Visitor<_Result>) {
      return TraceApi.WorkspaceSubmissionStatus._visit(this, visitor);
    });
  },

  ran: (value: TraceApi.WorkspaceRunDetails): TraceApi.WorkspaceSubmissionStatus.Ran => {
    const valueWithoutVisit: Omit<TraceApi.WorkspaceSubmissionStatus.Ran, \\"_visit\\"> = {
      ...value,
      type: \\"ran\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.WorkspaceSubmissionStatus.Ran, visitor: TraceApi.WorkspaceSubmissionStatus._Visitor<_Result>) {
      return TraceApi.WorkspaceSubmissionStatus._visit(this, visitor);
    });
  },

  traced: (value: TraceApi.WorkspaceRunDetails): TraceApi.WorkspaceSubmissionStatus.Traced => {
    const valueWithoutVisit: Omit<TraceApi.WorkspaceSubmissionStatus.Traced, \\"_visit\\"> = {
      ...value,
      type: \\"traced\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.WorkspaceSubmissionStatus.Traced, visitor: TraceApi.WorkspaceSubmissionStatus._Visitor<_Result>) {
      return TraceApi.WorkspaceSubmissionStatus._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.WorkspaceSubmissionStatus,
    visitor: TraceApi.WorkspaceSubmissionStatus._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"stopped\\":
        return visitor.stopped();
      case \\"errored\\":
        return visitor.errored(value.value);
      case \\"running\\":
        return visitor.running(value.value);
      case \\"ran\\":
        return visitor.ran(value);
      case \\"traced\\":
        return visitor.traced(value);
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "WorkspaceSubmissionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface WorkspaceSubmissionStatusV2 {
  updates: TraceApi.WorkspaceSubmissionUpdate[];
}
",
                    "name": "WorkspaceSubmissionStatusV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface WorkspaceSubmissionUpdate {
  updateTime: Date;
  updateInfo: TraceApi.WorkspaceSubmissionUpdateInfo;
}
",
                    "name": "WorkspaceSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type WorkspaceSubmissionUpdateInfo =
  | TraceApi.WorkspaceSubmissionUpdateInfo.Running
  | TraceApi.WorkspaceSubmissionUpdateInfo.Ran
  | TraceApi.WorkspaceSubmissionUpdateInfo.Stopped
  | TraceApi.WorkspaceSubmissionUpdateInfo.Traced
  | TraceApi.WorkspaceSubmissionUpdateInfo.TracedV2
  | TraceApi.WorkspaceSubmissionUpdateInfo.Errored
  | TraceApi.WorkspaceSubmissionUpdateInfo.Finished
  | TraceApi.WorkspaceSubmissionUpdateInfo._Unknown;

export declare namespace WorkspaceSubmissionUpdateInfo {
  interface Running extends _Utils {
    type: \\"running\\";
    value: TraceApi.RunningSubmissionState;
  }

  interface Ran extends TraceApi.WorkspaceRunDetails, _Utils {
    type: \\"ran\\";
  }

  interface Stopped extends _Utils {
    type: \\"stopped\\";
  }

  interface Traced extends _Utils {
    type: \\"traced\\";
  }

  interface TracedV2 extends TraceApi.WorkspaceTracedUpdate, _Utils {
    type: \\"tracedV2\\";
  }

  interface Errored extends _Utils {
    type: \\"errored\\";
    value: TraceApi.ErrorInfo;
  }

  interface Finished extends _Utils {
    type: \\"finished\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.WorkspaceSubmissionUpdateInfo._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    running: (value: TraceApi.RunningSubmissionState) => _Result;
    ran: (value: TraceApi.WorkspaceRunDetails) => _Result;
    stopped: () => _Result;
    traced: () => _Result;
    tracedV2: (value: TraceApi.WorkspaceTracedUpdate) => _Result;
    errored: (value: TraceApi.ErrorInfo) => _Result;
    finished: () => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const WorkspaceSubmissionUpdateInfo = {
  running: (value: TraceApi.RunningSubmissionState): TraceApi.WorkspaceSubmissionUpdateInfo.Running => {
    const valueWithoutVisit: Omit<TraceApi.WorkspaceSubmissionUpdateInfo.Running, \\"_visit\\"> = {
      value: value,
      type: \\"running\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.WorkspaceSubmissionUpdateInfo.Running, visitor: TraceApi.WorkspaceSubmissionUpdateInfo._Visitor<_Result>) {
      return TraceApi.WorkspaceSubmissionUpdateInfo._visit(this, visitor);
    });
  },

  ran: (value: TraceApi.WorkspaceRunDetails): TraceApi.WorkspaceSubmissionUpdateInfo.Ran => {
    const valueWithoutVisit: Omit<TraceApi.WorkspaceSubmissionUpdateInfo.Ran, \\"_visit\\"> = {
      ...value,
      type: \\"ran\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.WorkspaceSubmissionUpdateInfo.Ran, visitor: TraceApi.WorkspaceSubmissionUpdateInfo._Visitor<_Result>) {
      return TraceApi.WorkspaceSubmissionUpdateInfo._visit(this, visitor);
    });
  },

  stopped: (): TraceApi.WorkspaceSubmissionUpdateInfo.Stopped => {
    const valueWithoutVisit: Omit<TraceApi.WorkspaceSubmissionUpdateInfo.Stopped, \\"_visit\\"> = {
      type: \\"stopped\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.WorkspaceSubmissionUpdateInfo.Stopped, visitor: TraceApi.WorkspaceSubmissionUpdateInfo._Visitor<_Result>) {
      return TraceApi.WorkspaceSubmissionUpdateInfo._visit(this, visitor);
    });
  },

  traced: (): TraceApi.WorkspaceSubmissionUpdateInfo.Traced => {
    const valueWithoutVisit: Omit<TraceApi.WorkspaceSubmissionUpdateInfo.Traced, \\"_visit\\"> = {
      type: \\"traced\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.WorkspaceSubmissionUpdateInfo.Traced, visitor: TraceApi.WorkspaceSubmissionUpdateInfo._Visitor<_Result>) {
      return TraceApi.WorkspaceSubmissionUpdateInfo._visit(this, visitor);
    });
  },

  tracedV2: (value: TraceApi.WorkspaceTracedUpdate): TraceApi.WorkspaceSubmissionUpdateInfo.TracedV2 => {
    const valueWithoutVisit: Omit<TraceApi.WorkspaceSubmissionUpdateInfo.TracedV2, \\"_visit\\"> = {
      ...value,
      type: \\"tracedV2\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.WorkspaceSubmissionUpdateInfo.TracedV2, visitor: TraceApi.WorkspaceSubmissionUpdateInfo._Visitor<_Result>) {
      return TraceApi.WorkspaceSubmissionUpdateInfo._visit(this, visitor);
    });
  },

  errored: (value: TraceApi.ErrorInfo): TraceApi.WorkspaceSubmissionUpdateInfo.Errored => {
    const valueWithoutVisit: Omit<TraceApi.WorkspaceSubmissionUpdateInfo.Errored, \\"_visit\\"> = {
      value: value,
      type: \\"errored\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.WorkspaceSubmissionUpdateInfo.Errored, visitor: TraceApi.WorkspaceSubmissionUpdateInfo._Visitor<_Result>) {
      return TraceApi.WorkspaceSubmissionUpdateInfo._visit(this, visitor);
    });
  },

  finished: (): TraceApi.WorkspaceSubmissionUpdateInfo.Finished => {
    const valueWithoutVisit: Omit<TraceApi.WorkspaceSubmissionUpdateInfo.Finished, \\"_visit\\"> = {
      type: \\"finished\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.WorkspaceSubmissionUpdateInfo.Finished, visitor: TraceApi.WorkspaceSubmissionUpdateInfo._Visitor<_Result>) {
      return TraceApi.WorkspaceSubmissionUpdateInfo._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.WorkspaceSubmissionUpdateInfo,
    visitor: TraceApi.WorkspaceSubmissionUpdateInfo._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"running\\":
        return visitor.running(value.value);
      case \\"ran\\":
        return visitor.ran(value);
      case \\"stopped\\":
        return visitor.stopped();
      case \\"traced\\":
        return visitor.traced();
      case \\"tracedV2\\":
        return visitor.tracedV2(value);
      case \\"errored\\":
        return visitor.errored(value.value);
      case \\"finished\\":
        return visitor.finished();
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                    "name": "WorkspaceSubmissionUpdateInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";

export interface WorkspaceSubmitRequest {
  submissionId: TraceApi.SubmissionId;
  language: TraceApi.Language;
  submissionFiles: TraceApi.SubmissionFileInfo[];
  userId?: string;
}
",
                    "name": "WorkspaceSubmitRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface WorkspaceTracedUpdate {
  traceResponsesSize: number;
}
",
                    "name": "WorkspaceTracedUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./SubmissionId\\";
export * from \\"./ShareId\\";
export * from \\"./SubmissionRequest\\";
export * from \\"./InitializeProblemRequest\\";
export * from \\"./SubmitRequestV2\\";
export * from \\"./WorkspaceSubmitRequest\\";
export * from \\"./SubmissionFileInfo\\";
export * from \\"./SubmissionTypeEnum\\";
export * from \\"./StopRequest\\";
export * from \\"./SubmissionResponse\\";
export * from \\"./CodeExecutionUpdate\\";
export * from \\"./BuildingExecutorResponse\\";
export * from \\"./RunningResponse\\";
export * from \\"./RunningSubmissionState\\";
export * from \\"./ErroredResponse\\";
export * from \\"./ErrorInfo\\";
export * from \\"./CompileError\\";
export * from \\"./RuntimeError\\";
export * from \\"./InternalError\\";
export * from \\"./StoppedResponse\\";
export * from \\"./WorkspaceRanResponse\\";
export * from \\"./WorkspaceRunDetails\\";
export * from \\"./GradedResponse\\";
export * from \\"./GradedResponseV2\\";
export * from \\"./TestCaseGrade\\";
export * from \\"./TestCaseHiddenGrade\\";
export * from \\"./TestCaseNonHiddenGrade\\";
export * from \\"./RecordedResponseNotification\\";
export * from \\"./RecordingResponseNotification\\";
export * from \\"./LightweightStackframeInformation\\";
export * from \\"./TestCaseResultWithStdout\\";
export * from \\"./TestCaseResult\\";
export * from \\"./ActualResult\\";
export * from \\"./ExceptionV2\\";
export * from \\"./ExceptionInfo\\";
export * from \\"./InvalidRequestResponse\\";
export * from \\"./InvalidRequestCause\\";
export * from \\"./ExistingSubmissionExecuting\\";
export * from \\"./SubmissionIdNotFound\\";
export * from \\"./CustomTestCasesUnsupported\\";
export * from \\"./UnexpectedLanguageError\\";
export * from \\"./TerminatedResponse\\";
export * from \\"./FinishedResponse\\";
export * from \\"./StdoutResponse\\";
export * from \\"./StderrResponse\\";
export * from \\"./TraceResponse\\";
export * from \\"./TraceResponseV2\\";
export * from \\"./TracedFile\\";
export * from \\"./ExpressionLocation\\";
export * from \\"./StackInformation\\";
export * from \\"./StackFrame\\";
export * from \\"./Scope\\";
export * from \\"./ExecutionSessionResponse\\";
export * from \\"./ExecutionSessionStatus\\";
export * from \\"./SubmissionStatusV2\\";
export * from \\"./TestSubmissionStatusV2\\";
export * from \\"./WorkspaceSubmissionStatusV2\\";
export * from \\"./TestSubmissionUpdate\\";
export * from \\"./TestSubmissionUpdateInfo\\";
export * from \\"./WorkspaceSubmissionUpdate\\";
export * from \\"./WorkspaceSubmissionUpdateInfo\\";
export * from \\"./GradedTestCaseUpdate\\";
export * from \\"./RecordedTestCaseUpdate\\";
export * from \\"./WorkspaceTracedUpdate\\";
export * from \\"./SubmissionTypeState\\";
export * from \\"./WorkspaceSubmissionState\\";
export * from \\"./WorkspaceSubmissionStatus\\";
export * from \\"./TestSubmissionState\\";
export * from \\"./TestSubmissionStatus\\";
export * from \\"./SubmissionStatusForTestCase\\";
export * from \\"./TracedTestCase\\";
export * from \\"./TraceResponsesPage\\";
export * from \\"./TraceResponsesPageV2\\";
export * from \\"./GetTraceResponsesPageRequest\\";
export * from \\"./WorkspaceStarterFilesResponse\\";
export * from \\"./WorkspaceStarterFilesResponseV2\\";
export * from \\"./WorkspaceFiles\\";
export * from \\"./ExecutionSessionState\\";
export * from \\"./GetExecutionSessionStateResponse\\";
export * from \\"./GetSubmissionStateResponse\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "submission",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { TraceApi } from \\"../../..\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    auth?: {
      token?: core.Supplier<core.BearerToken>;
    };
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async setNumWarmInstances(
    request: TraceApi.sysprop.setNumWarmInstances.Request
  ): Promise<TraceApi.sysprop.setNumWarmInstances.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/sysprop/num-warm-instances/\${request.language}/\${request.numWarmInstances}\`
      ),
      method: \\"PUT\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: undefined,
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getNumWarmInstances(): Promise<TraceApi.sysprop.getNumWarmInstances.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/sysprop/num-warm-instances\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.sysprop.getNumWarmInstances.Response.parse(
          response.body as Record<serializers.Language.Raw, number>
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export type Response = core.APIResponse<
  Record<TraceApi.Language.RawValue, number>,
  TraceApi.sysprop.getNumWarmInstances.Error
>;
export type Error = TraceApi.sysprop.getNumWarmInstances.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.sysprop.getNumWarmInstances.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                    "name": "getNumWarmInstances.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as setNumWarmInstances from \\"./setNumWarmInstances\\";
export * as getNumWarmInstances from \\"./getNumWarmInstances\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export interface Request {
  language: TraceApi.Language;
  numWarmInstances: number;
}

export type Response = core.APIResponse<void, TraceApi.sysprop.setNumWarmInstances.Error>;
export type Error = TraceApi.sysprop.setNumWarmInstances.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.sysprop.setNumWarmInstances.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                    "name": "setNumWarmInstances.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "sysprop",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../environments\\";
import * as core from \\"../../../core\\";
import { Client as ProblemClient } from \\"../resources/problem/client/Client\\";
import { Client as V3Client } from \\"../resources/v3/client/Client\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    auth?: {
      token?: core.Supplier<core.BearerToken>;
    };
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  #problem: ProblemClient | undefined;

  public get problem(): ProblemClient {
    return (this.#problem ??= new ProblemClient(this.options));
  }

  #v3: V3Client | undefined;

  public get v3(): V3Client {
    return (this.#v3 ??= new V3Client(this.options));
  }
}
",
                    "name": "Client.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export {};
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./resources\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as v3 from \\"./v3\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../../environments\\";
import * as core from \\"../../../../../core\\";
import { TraceApi } from \\"../../../../..\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    auth?: {
      token?: core.Supplier<core.BearerToken>;
    };
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async getLightweightProblems(): Promise<TraceApi.v2.problem.getLightweightProblems.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/problems-v2/lightweight-problem-info\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.v2.problem.getLightweightProblems.Response.parse(
          response.body as serializers.v2.LightweightProblemInfoV2.Raw[]
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getProblems(): Promise<TraceApi.v2.problem.getProblems.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/problems-v2/problem-info\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.v2.problem.getProblems.Response.parse(response.body as serializers.v2.ProblemInfoV2.Raw[]),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getLatestProblem(
    request: TraceApi.v2.problem.getLatestProblem.Request
  ): Promise<TraceApi.v2.problem.getLatestProblem.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/problems-v2/problem-info/\${request.problemId}\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.v2.ProblemInfoV2.parse(response.body as serializers.v2.ProblemInfoV2.Raw),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getProblemVersion(
    request: TraceApi.v2.problem.getProblemVersion.Request
  ): Promise<TraceApi.v2.problem.getProblemVersion.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/problems-v2/problem-info/\${request.problemId}/version/\${request.problemVersion}\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.v2.ProblemInfoV2.parse(response.body as serializers.v2.ProblemInfoV2.Raw),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                            "name": "Client.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export interface Request {
  problemId: TraceApi.ProblemId;
}

export type Response = core.APIResponse<TraceApi.v2.ProblemInfoV2, TraceApi.v2.problem.getLatestProblem.Error>;
export type Error = TraceApi.v2.problem.getLatestProblem.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.problem.getLatestProblem.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                            "name": "getLatestProblem.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export type Response = core.APIResponse<
  TraceApi.v2.LightweightProblemInfoV2[],
  TraceApi.v2.problem.getLightweightProblems.Error
>;
export type Error = TraceApi.v2.problem.getLightweightProblems.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.problem.getLightweightProblems.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                            "name": "getLightweightProblems.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export interface Request {
  problemId: TraceApi.ProblemId;
  problemVersion: number;
}

export type Response = core.APIResponse<TraceApi.v2.ProblemInfoV2, TraceApi.v2.problem.getProblemVersion.Error>;
export type Error = TraceApi.v2.problem.getProblemVersion.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.problem.getProblemVersion.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                            "name": "getProblemVersion.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export type Response = core.APIResponse<TraceApi.v2.ProblemInfoV2[], TraceApi.v2.problem.getProblems.Error>;
export type Error = TraceApi.v2.problem.getProblems.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.problem.getProblems.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                            "name": "getProblems.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
export * as getLatestProblem from \\"./getLatestProblem\\";
export * as getProblemVersion from \\"./getProblemVersion\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "client",
                        "type": "directory",
                      },
                      Object {
                        "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export type AssertCorrectnessCheck =
  | TraceApi.v2.AssertCorrectnessCheck.DeepEquality
  | TraceApi.v2.AssertCorrectnessCheck.Custom
  | TraceApi.v2.AssertCorrectnessCheck._Unknown;

export declare namespace AssertCorrectnessCheck {
  interface DeepEquality extends TraceApi.v2.DeepEqualityCorrectnessCheck, _Utils {
    type: \\"deepEquality\\";
  }

  interface Custom extends TraceApi.v2.VoidFunctionDefinitionThatTakesActualResult, _Utils {
    type: \\"custom\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.AssertCorrectnessCheck._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    deepEquality: (value: TraceApi.v2.DeepEqualityCorrectnessCheck) => _Result;
    custom: (value: TraceApi.v2.VoidFunctionDefinitionThatTakesActualResult) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const AssertCorrectnessCheck = {
  deepEquality: (value: TraceApi.v2.DeepEqualityCorrectnessCheck): TraceApi.v2.AssertCorrectnessCheck.DeepEquality => {
    const valueWithoutVisit: Omit<TraceApi.v2.AssertCorrectnessCheck.DeepEquality, \\"_visit\\"> = {
      ...value,
      type: \\"deepEquality\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.AssertCorrectnessCheck.DeepEquality, visitor: TraceApi.v2.AssertCorrectnessCheck._Visitor<_Result>) {
      return TraceApi.v2.AssertCorrectnessCheck._visit(this, visitor);
    });
  },

  custom: (
    value: TraceApi.v2.VoidFunctionDefinitionThatTakesActualResult
  ): TraceApi.v2.AssertCorrectnessCheck.Custom => {
    const valueWithoutVisit: Omit<TraceApi.v2.AssertCorrectnessCheck.Custom, \\"_visit\\"> = {
      ...value,
      type: \\"custom\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.AssertCorrectnessCheck.Custom, visitor: TraceApi.v2.AssertCorrectnessCheck._Visitor<_Result>) {
      return TraceApi.v2.AssertCorrectnessCheck._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.AssertCorrectnessCheck,
    visitor: TraceApi.v2.AssertCorrectnessCheck._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"deepEquality\\":
        return visitor.deepEquality(value);
      case \\"custom\\":
        return visitor.custom(value);
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                            "name": "AssertCorrectnessCheck.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface BasicCustomFiles {
  methodName: string;
  signature: TraceApi.v2.NonVoidFunctionSignature;
  additionalFiles: Record<TraceApi.Language.RawValue, TraceApi.v2.Files>;
  basicTestCaseTemplate: TraceApi.v2.BasicTestCaseTemplate;
}
",
                            "name": "BasicCustomFiles.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface BasicTestCaseTemplate {
  templateId: TraceApi.v2.TestCaseTemplateId;
  name: string;
  description: TraceApi.v2.TestCaseImplementationDescription;
  expectedValueParameterId: TraceApi.v2.ParameterId;
}
",
                            "name": "BasicTestCaseTemplate.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface CreateProblemRequestV2 {
  problemName: string;
  problemDescription: TraceApi.ProblemDescription;
  customFiles: TraceApi.v2.CustomFiles;
  customTestCaseTemplates: TraceApi.v2.TestCaseTemplate[];
  testcases: TraceApi.v2.TestCaseV2[];
  supportedLanguages: TraceApi.Language[];
  isPublic: boolean;
}
",
                            "name": "CreateProblemRequestV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export type CustomFiles =
  | TraceApi.v2.CustomFiles.Basic
  | TraceApi.v2.CustomFiles.Custom
  | TraceApi.v2.CustomFiles._Unknown;

export declare namespace CustomFiles {
  interface Basic extends TraceApi.v2.BasicCustomFiles, _Utils {
    type: \\"basic\\";
  }

  interface Custom extends _Utils {
    type: \\"custom\\";
    value: Record<TraceApi.Language.RawValue, TraceApi.v2.Files>;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.CustomFiles._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    basic: (value: TraceApi.v2.BasicCustomFiles) => _Result;
    custom: (value: Record<TraceApi.Language.RawValue, TraceApi.v2.Files>) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const CustomFiles = {
  basic: (value: TraceApi.v2.BasicCustomFiles): TraceApi.v2.CustomFiles.Basic => {
    const valueWithoutVisit: Omit<TraceApi.v2.CustomFiles.Basic, \\"_visit\\"> = {
      ...value,
      type: \\"basic\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.CustomFiles.Basic, visitor: TraceApi.v2.CustomFiles._Visitor<_Result>) {
      return TraceApi.v2.CustomFiles._visit(this, visitor);
    });
  },

  custom: (value: Record<TraceApi.Language.RawValue, TraceApi.v2.Files>): TraceApi.v2.CustomFiles.Custom => {
    const valueWithoutVisit: Omit<TraceApi.v2.CustomFiles.Custom, \\"_visit\\"> = {
      value: value,
      type: \\"custom\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.CustomFiles.Custom, visitor: TraceApi.v2.CustomFiles._Visitor<_Result>) {
      return TraceApi.v2.CustomFiles._visit(this, visitor);
    });
  },

  _visit: <_Result>(value: TraceApi.v2.CustomFiles, visitor: TraceApi.v2.CustomFiles._Visitor<_Result>): _Result => {
    switch (value.type) {
      case \\"basic\\":
        return visitor.basic(value);
      case \\"custom\\":
        return visitor.custom(value.value);
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                            "name": "CustomFiles.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface DeepEqualityCorrectnessCheck {
  expectedValueParameterId: TraceApi.v2.ParameterId;
}
",
                            "name": "DeepEqualityCorrectnessCheck.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface DefaultProvidedFile {
  file: TraceApi.v2.FileInfoV2;
  relatedTypes: TraceApi.VariableType[];
}
",
                            "name": "DefaultProvidedFile.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface FileInfoV2 {
  filename: string;
  directory: string;
  contents: string;
  editable: boolean;
}
",
                            "name": "FileInfoV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface Files {
  files: TraceApi.v2.FileInfoV2[];
}
",
                            "name": "Files.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface FunctionImplementation {
  impl: string;
  imports?: string;
}
",
                            "name": "FunctionImplementation.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface FunctionImplementationForMultipleLanguages {
  codeByLanguage: Record<TraceApi.Language.RawValue, TraceApi.v2.FunctionImplementation>;
}
",
                            "name": "FunctionImplementationForMultipleLanguages.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export type FunctionSignature =
  | TraceApi.v2.FunctionSignature.Void
  | TraceApi.v2.FunctionSignature.NonVoid
  /**
   * Useful when specifying custom grading for a testcase where actualResult is defined. */
  | TraceApi.v2.FunctionSignature.VoidThatTakesActualResult
  | TraceApi.v2.FunctionSignature._Unknown;

export declare namespace FunctionSignature {
  interface Void extends TraceApi.v2.VoidFunctionSignature, _Utils {
    type: \\"void\\";
  }

  interface NonVoid extends TraceApi.v2.NonVoidFunctionSignature, _Utils {
    type: \\"nonVoid\\";
  }

  interface VoidThatTakesActualResult extends TraceApi.v2.VoidFunctionSignatureThatTakesActualResult, _Utils {
    type: \\"voidThatTakesActualResult\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.FunctionSignature._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    void: (value: TraceApi.v2.VoidFunctionSignature) => _Result;
    nonVoid: (value: TraceApi.v2.NonVoidFunctionSignature) => _Result;
    voidThatTakesActualResult: (value: TraceApi.v2.VoidFunctionSignatureThatTakesActualResult) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const FunctionSignature = {
  void: (value: TraceApi.v2.VoidFunctionSignature): TraceApi.v2.FunctionSignature.Void => {
    const valueWithoutVisit: Omit<TraceApi.v2.FunctionSignature.Void, \\"_visit\\"> = {
      ...value,
      type: \\"void\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.FunctionSignature.Void, visitor: TraceApi.v2.FunctionSignature._Visitor<_Result>) {
      return TraceApi.v2.FunctionSignature._visit(this, visitor);
    });
  },

  nonVoid: (value: TraceApi.v2.NonVoidFunctionSignature): TraceApi.v2.FunctionSignature.NonVoid => {
    const valueWithoutVisit: Omit<TraceApi.v2.FunctionSignature.NonVoid, \\"_visit\\"> = {
      ...value,
      type: \\"nonVoid\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.FunctionSignature.NonVoid, visitor: TraceApi.v2.FunctionSignature._Visitor<_Result>) {
      return TraceApi.v2.FunctionSignature._visit(this, visitor);
    });
  },

  voidThatTakesActualResult: (
    value: TraceApi.v2.VoidFunctionSignatureThatTakesActualResult
  ): TraceApi.v2.FunctionSignature.VoidThatTakesActualResult => {
    const valueWithoutVisit: Omit<TraceApi.v2.FunctionSignature.VoidThatTakesActualResult, \\"_visit\\"> = {
      ...value,
      type: \\"voidThatTakesActualResult\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.FunctionSignature.VoidThatTakesActualResult, visitor: TraceApi.v2.FunctionSignature._Visitor<_Result>) {
      return TraceApi.v2.FunctionSignature._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.FunctionSignature,
    visitor: TraceApi.v2.FunctionSignature._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"void\\":
        return visitor.void(value);
      case \\"nonVoid\\":
        return visitor.nonVoid(value);
      case \\"voidThatTakesActualResult\\":
        return visitor.voidThatTakesActualResult(value);
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                            "name": "FunctionSignature.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface GeneratedFiles {
  generatedTestCaseFiles: Record<TraceApi.Language.RawValue, TraceApi.v2.Files>;
  generatedTemplateFiles: Record<TraceApi.Language.RawValue, TraceApi.v2.Files>;
  other: Record<TraceApi.Language.RawValue, TraceApi.v2.Files>;
}
",
                            "name": "GeneratedFiles.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface GetBasicSolutionFileRequest {
  methodName: string;
  signature: TraceApi.v2.NonVoidFunctionSignature;
}
",
                            "name": "GetBasicSolutionFileRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface GetBasicSolutionFileResponse {
  solutionFileByLanguage: Record<TraceApi.Language.RawValue, TraceApi.v2.FileInfoV2>;
}
",
                            "name": "GetBasicSolutionFileResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface GetFunctionSignatureRequest {
  functionSignature: TraceApi.v2.FunctionSignature;
}
",
                            "name": "GetFunctionSignatureRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface GetFunctionSignatureResponse {
  functionByLanguage: Record<TraceApi.Language.RawValue, string>;
}
",
                            "name": "GetFunctionSignatureResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface GetGeneratedTestCaseFileRequest {
  template?: TraceApi.v2.TestCaseTemplate;
  testCase: TraceApi.v2.TestCaseV2;
}
",
                            "name": "GetGeneratedTestCaseFileRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface GetGeneratedTestCaseTemplateFileRequest {
  template: TraceApi.v2.TestCaseTemplate;
}
",
                            "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface LightweightProblemInfoV2 {
  problemId: TraceApi.ProblemId;
  problemName: string;
  problemVersion: number;
  variableTypes: TraceApi.VariableType[];
}
",
                            "name": "LightweightProblemInfoV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface NonVoidFunctionDefinition {
  signature: TraceApi.v2.NonVoidFunctionSignature;
  code: TraceApi.v2.FunctionImplementationForMultipleLanguages;
}
",
                            "name": "NonVoidFunctionDefinition.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface NonVoidFunctionSignature {
  parameters: TraceApi.v2.Parameter[];
  returnType: TraceApi.VariableType;
}
",
                            "name": "NonVoidFunctionSignature.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface Parameter {
  parameterId: TraceApi.v2.ParameterId;
  name: string;
  variableType: TraceApi.VariableType;
}
",
                            "name": "Parameter.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export type ParameterId = string & {
  v2_ParameterId: void;
};

export const ParameterId = {
  create: (value: string) => value as unknown as TraceApi.v2.ParameterId,
} as const;
",
                            "name": "ParameterId.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface ProblemInfoV2 {
  problemId: TraceApi.ProblemId;
  problemDescription: TraceApi.ProblemDescription;
  problemName: string;
  problemVersion: number;
  supportedLanguages: TraceApi.Language[];
  customFiles: TraceApi.v2.CustomFiles;
  generatedFiles: TraceApi.v2.GeneratedFiles;
  customTestCaseTemplates: TraceApi.v2.TestCaseTemplate[];
  testcases: TraceApi.v2.TestCaseV2[];
  isPublic: boolean;
}
",
                            "name": "ProblemInfoV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface TestCaseExpects {
  expectedStdout?: string;
}
",
                            "name": "TestCaseExpects.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export type TestCaseFunction =
  | TraceApi.v2.TestCaseFunction.WithActualResult
  | TraceApi.v2.TestCaseFunction.Custom
  | TraceApi.v2.TestCaseFunction._Unknown;

export declare namespace TestCaseFunction {
  interface WithActualResult extends TraceApi.v2.TestCaseWithActualResultImplementation, _Utils {
    type: \\"withActualResult\\";
  }

  interface Custom extends TraceApi.v2.VoidFunctionDefinition, _Utils {
    type: \\"custom\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.TestCaseFunction._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    withActualResult: (value: TraceApi.v2.TestCaseWithActualResultImplementation) => _Result;
    custom: (value: TraceApi.v2.VoidFunctionDefinition) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const TestCaseFunction = {
  withActualResult: (
    value: TraceApi.v2.TestCaseWithActualResultImplementation
  ): TraceApi.v2.TestCaseFunction.WithActualResult => {
    const valueWithoutVisit: Omit<TraceApi.v2.TestCaseFunction.WithActualResult, \\"_visit\\"> = {
      ...value,
      type: \\"withActualResult\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.TestCaseFunction.WithActualResult, visitor: TraceApi.v2.TestCaseFunction._Visitor<_Result>) {
      return TraceApi.v2.TestCaseFunction._visit(this, visitor);
    });
  },

  custom: (value: TraceApi.v2.VoidFunctionDefinition): TraceApi.v2.TestCaseFunction.Custom => {
    const valueWithoutVisit: Omit<TraceApi.v2.TestCaseFunction.Custom, \\"_visit\\"> = {
      ...value,
      type: \\"custom\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.TestCaseFunction.Custom, visitor: TraceApi.v2.TestCaseFunction._Visitor<_Result>) {
      return TraceApi.v2.TestCaseFunction._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.TestCaseFunction,
    visitor: TraceApi.v2.TestCaseFunction._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"withActualResult\\":
        return visitor.withActualResult(value);
      case \\"custom\\":
        return visitor.custom(value);
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                            "name": "TestCaseFunction.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export type TestCaseId = string & {
  v2_TestCaseId: void;
};

export const TestCaseId = {
  create: (value: string) => value as unknown as TraceApi.v2.TestCaseId,
} as const;
",
                            "name": "TestCaseId.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface TestCaseImplementation {
  description: TraceApi.v2.TestCaseImplementationDescription;
  function: TraceApi.v2.TestCaseFunction;
}
",
                            "name": "TestCaseImplementation.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface TestCaseImplementationDescription {
  boards: TraceApi.v2.TestCaseImplementationDescriptionBoard[];
}
",
                            "name": "TestCaseImplementationDescription.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export type TestCaseImplementationDescriptionBoard =
  | TraceApi.v2.TestCaseImplementationDescriptionBoard.Html
  | TraceApi.v2.TestCaseImplementationDescriptionBoard.ParamId
  | TraceApi.v2.TestCaseImplementationDescriptionBoard._Unknown;

export declare namespace TestCaseImplementationDescriptionBoard {
  interface Html extends _Utils {
    type: \\"html\\";
    value: string;
  }

  interface ParamId extends _Utils {
    type: \\"paramId\\";
    value: TraceApi.v2.ParameterId;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.TestCaseImplementationDescriptionBoard._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    html: (value: string) => _Result;
    paramId: (value: TraceApi.v2.ParameterId) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const TestCaseImplementationDescriptionBoard = {
  html: (value: string): TraceApi.v2.TestCaseImplementationDescriptionBoard.Html => {
    const valueWithoutVisit: Omit<TraceApi.v2.TestCaseImplementationDescriptionBoard.Html, \\"_visit\\"> = {
      value: value,
      type: \\"html\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.TestCaseImplementationDescriptionBoard.Html, visitor: TraceApi.v2.TestCaseImplementationDescriptionBoard._Visitor<_Result>) {
      return TraceApi.v2.TestCaseImplementationDescriptionBoard._visit(this, visitor);
    });
  },

  paramId: (value: TraceApi.v2.ParameterId): TraceApi.v2.TestCaseImplementationDescriptionBoard.ParamId => {
    const valueWithoutVisit: Omit<TraceApi.v2.TestCaseImplementationDescriptionBoard.ParamId, \\"_visit\\"> = {
      value: value,
      type: \\"paramId\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.TestCaseImplementationDescriptionBoard.ParamId, visitor: TraceApi.v2.TestCaseImplementationDescriptionBoard._Visitor<_Result>) {
      return TraceApi.v2.TestCaseImplementationDescriptionBoard._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.TestCaseImplementationDescriptionBoard,
    visitor: TraceApi.v2.TestCaseImplementationDescriptionBoard._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"html\\":
        return visitor.html(value.value);
      case \\"paramId\\":
        return visitor.paramId(value.value);
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                            "name": "TestCaseImplementationDescriptionBoard.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export type TestCaseImplementationReference =
  | TraceApi.v2.TestCaseImplementationReference.TemplateId
  | TraceApi.v2.TestCaseImplementationReference.Implementation
  | TraceApi.v2.TestCaseImplementationReference._Unknown;

export declare namespace TestCaseImplementationReference {
  interface TemplateId extends _Utils {
    type: \\"templateId\\";
    value: TraceApi.v2.TestCaseTemplateId;
  }

  interface Implementation extends TraceApi.v2.TestCaseImplementation, _Utils {
    type: \\"implementation\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.TestCaseImplementationReference._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    templateId: (value: TraceApi.v2.TestCaseTemplateId) => _Result;
    implementation: (value: TraceApi.v2.TestCaseImplementation) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const TestCaseImplementationReference = {
  templateId: (value: TraceApi.v2.TestCaseTemplateId): TraceApi.v2.TestCaseImplementationReference.TemplateId => {
    const valueWithoutVisit: Omit<TraceApi.v2.TestCaseImplementationReference.TemplateId, \\"_visit\\"> = {
      value: value,
      type: \\"templateId\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.TestCaseImplementationReference.TemplateId, visitor: TraceApi.v2.TestCaseImplementationReference._Visitor<_Result>) {
      return TraceApi.v2.TestCaseImplementationReference._visit(this, visitor);
    });
  },

  implementation: (
    value: TraceApi.v2.TestCaseImplementation
  ): TraceApi.v2.TestCaseImplementationReference.Implementation => {
    const valueWithoutVisit: Omit<TraceApi.v2.TestCaseImplementationReference.Implementation, \\"_visit\\"> = {
      ...value,
      type: \\"implementation\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.TestCaseImplementationReference.Implementation, visitor: TraceApi.v2.TestCaseImplementationReference._Visitor<_Result>) {
      return TraceApi.v2.TestCaseImplementationReference._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.TestCaseImplementationReference,
    visitor: TraceApi.v2.TestCaseImplementationReference._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"templateId\\":
        return visitor.templateId(value.value);
      case \\"implementation\\":
        return visitor.implementation(value);
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                            "name": "TestCaseImplementationReference.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface TestCaseMetadata {
  id: TraceApi.v2.TestCaseId;
  name: string;
  hidden: boolean;
}
",
                            "name": "TestCaseMetadata.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface TestCaseTemplate {
  templateId: TraceApi.v2.TestCaseTemplateId;
  name: string;
  implementation: TraceApi.v2.TestCaseImplementation;
}
",
                            "name": "TestCaseTemplate.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export type TestCaseTemplateId = string & {
  v2_TestCaseTemplateId: void;
};

export const TestCaseTemplateId = {
  create: (value: string) => value as unknown as TraceApi.v2.TestCaseTemplateId,
} as const;
",
                            "name": "TestCaseTemplateId.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface TestCaseV2 {
  metadata: TraceApi.v2.TestCaseMetadata;
  implementation: TraceApi.v2.TestCaseImplementationReference;
  arguments: Record<TraceApi.v2.ParameterId, TraceApi.VariableValue>;
  expects?: TraceApi.v2.TestCaseExpects;
}
",
                            "name": "TestCaseV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface TestCaseWithActualResultImplementation {
  getActualResult: TraceApi.v2.NonVoidFunctionDefinition;
  assertCorrectnessCheck: TraceApi.v2.AssertCorrectnessCheck;
}
",
                            "name": "TestCaseWithActualResultImplementation.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface VoidFunctionDefinition {
  parameters: TraceApi.v2.Parameter[];
  code: TraceApi.v2.FunctionImplementationForMultipleLanguages;
}
",
                            "name": "VoidFunctionDefinition.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

/**
 * The generated signature will include an additional param, actualResult
 */
export interface VoidFunctionDefinitionThatTakesActualResult {
  additionalParameters: TraceApi.v2.Parameter[];
  code: TraceApi.v2.FunctionImplementationForMultipleLanguages;
}
",
                            "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface VoidFunctionSignature {
  parameters: TraceApi.v2.Parameter[];
}
",
                            "name": "VoidFunctionSignature.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";

export interface VoidFunctionSignatureThatTakesActualResult {
  parameters: TraceApi.v2.Parameter[];
  actualResultType: TraceApi.VariableType;
}
",
                            "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "types",
                        "type": "directory",
                      },
                    ],
                    "name": "problem",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../../environments\\";
import * as core from \\"../../../../../core\\";
import { Client as ProblemClient } from \\"../resources/problem/client/Client\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    auth?: {
      token?: core.Supplier<core.BearerToken>;
    };
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  #problem: ProblemClient | undefined;

  public get problem(): ProblemClient {
    return (this.#problem ??= new ProblemClient(this.options));
  }
}
",
                            "name": "Client.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export {};
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "client",
                        "type": "directory",
                      },
                      Object {
                        "contents": "export * from \\"./resources\\";
export * from \\"./client\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": Array [
                              Object {
                                "contents": Array [
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as environments from \\"../../../../../../../environments\\";
import * as core from \\"../../../../../../../core\\";
import { TraceApi } from \\"../../../../../../..\\";
import urlJoin from \\"url-join\\";
import * as serializers from \\"../../../../../../../serialization\\";

export declare namespace Client {
  interface Options {
    environment?: environments.Environment | string;
    auth?: {
      token?: core.Supplier<core.BearerToken>;
    };
  }
}

export class Client {
  constructor(private readonly options: Client.Options) {}

  public async getLightweightProblems(): Promise<TraceApi.v2.v3.problem.getLightweightProblems.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/problems-v2/lightweight-problem-info\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.v2.v3.problem.getLightweightProblems.Response.parse(
          response.body as serializers.v2.v3.LightweightProblemInfoV2.Raw[]
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getProblems(): Promise<TraceApi.v2.v3.problem.getProblems.Response> {
    const response = await core.fetcher({
      url: urlJoin(this.options.environment ?? environments.Environment.Prod, \\"/problems-v2/problem-info\\"),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.v2.v3.problem.getProblems.Response.parse(
          response.body as serializers.v2.v3.ProblemInfoV2.Raw[]
        ),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getLatestProblem(
    request: TraceApi.v2.v3.problem.getLatestProblem.Request
  ): Promise<TraceApi.v2.v3.problem.getLatestProblem.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/problems-v2/problem-info/\${request.problemId}\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.v2.v3.ProblemInfoV2.parse(response.body as serializers.v2.v3.ProblemInfoV2.Raw),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }

  public async getProblemVersion(
    request: TraceApi.v2.v3.problem.getProblemVersion.Request
  ): Promise<TraceApi.v2.v3.problem.getProblemVersion.Response> {
    const response = await core.fetcher({
      url: urlJoin(
        this.options.environment ?? environments.Environment.Prod,
        \`/problems-v2/problem-info/\${request.problemId}/version/\${request.problemVersion}\`
      ),
      method: \\"GET\\",
      headers: {
        Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.auth?.token)),
      },
    });
    if (response.ok) {
      return {
        ok: true,
        body: serializers.v2.v3.ProblemInfoV2.parse(response.body as serializers.v2.v3.ProblemInfoV2.Raw),
      };
    }

    return {
      ok: false,
      error: {
        errorName: undefined,
        content: response.error,
        _visit: (visitor) => visitor._other(response.error),
      },
    };
  }
}
",
                                    "name": "Client.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";

export interface Request {
  problemId: TraceApi.ProblemId;
}

export type Response = core.APIResponse<TraceApi.v2.v3.ProblemInfoV2, TraceApi.v2.v3.problem.getLatestProblem.Error>;
export type Error = TraceApi.v2.v3.problem.getLatestProblem.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.v3.problem.getLatestProblem.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                                    "name": "getLatestProblem.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";

export type Response = core.APIResponse<
  TraceApi.v2.v3.LightweightProblemInfoV2[],
  TraceApi.v2.v3.problem.getLightweightProblems.Error
>;
export type Error = TraceApi.v2.v3.problem.getLightweightProblems.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.v3.problem.getLightweightProblems.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                                    "name": "getLightweightProblems.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";

export interface Request {
  problemId: TraceApi.ProblemId;
  problemVersion: number;
}

export type Response = core.APIResponse<TraceApi.v2.v3.ProblemInfoV2, TraceApi.v2.v3.problem.getProblemVersion.Error>;
export type Error = TraceApi.v2.v3.problem.getProblemVersion.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.v3.problem.getProblemVersion.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                                    "name": "getProblemVersion.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";

export type Response = core.APIResponse<TraceApi.v2.v3.ProblemInfoV2[], TraceApi.v2.v3.problem.getProblems.Error>;
export type Error = TraceApi.v2.v3.problem.getProblems.Error._Unknown;

export declare namespace Error {
  interface _Unknown extends _Utils {
    errorName: void;
    content: core.Fetcher.Error;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.v3.problem.getProblems.Error._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    _other: (value: core.Fetcher.Error) => _Result;
  }
}
",
                                    "name": "getProblems.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
export * as getLatestProblem from \\"./getLatestProblem\\";
export * as getProblemVersion from \\"./getProblemVersion\\";
",
                                    "name": "index.ts",
                                    "type": "file",
                                  },
                                ],
                                "name": "client",
                                "type": "directory",
                              },
                              Object {
                                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                                "name": "index.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": Array [
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";

export type AssertCorrectnessCheck =
  | TraceApi.v2.v3.AssertCorrectnessCheck.DeepEquality
  | TraceApi.v2.v3.AssertCorrectnessCheck.Custom
  | TraceApi.v2.v3.AssertCorrectnessCheck._Unknown;

export declare namespace AssertCorrectnessCheck {
  interface DeepEquality extends TraceApi.v2.v3.DeepEqualityCorrectnessCheck, _Utils {
    type: \\"deepEquality\\";
  }

  interface Custom extends TraceApi.v2.v3.VoidFunctionDefinitionThatTakesActualResult, _Utils {
    type: \\"custom\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.v3.AssertCorrectnessCheck._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    deepEquality: (value: TraceApi.v2.v3.DeepEqualityCorrectnessCheck) => _Result;
    custom: (value: TraceApi.v2.v3.VoidFunctionDefinitionThatTakesActualResult) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const AssertCorrectnessCheck = {
  deepEquality: (
    value: TraceApi.v2.v3.DeepEqualityCorrectnessCheck
  ): TraceApi.v2.v3.AssertCorrectnessCheck.DeepEquality => {
    const valueWithoutVisit: Omit<TraceApi.v2.v3.AssertCorrectnessCheck.DeepEquality, \\"_visit\\"> = {
      ...value,
      type: \\"deepEquality\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.AssertCorrectnessCheck.DeepEquality, visitor: TraceApi.v2.v3.AssertCorrectnessCheck._Visitor<_Result>) {
      return TraceApi.v2.v3.AssertCorrectnessCheck._visit(this, visitor);
    });
  },

  custom: (
    value: TraceApi.v2.v3.VoidFunctionDefinitionThatTakesActualResult
  ): TraceApi.v2.v3.AssertCorrectnessCheck.Custom => {
    const valueWithoutVisit: Omit<TraceApi.v2.v3.AssertCorrectnessCheck.Custom, \\"_visit\\"> = {
      ...value,
      type: \\"custom\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.AssertCorrectnessCheck.Custom, visitor: TraceApi.v2.v3.AssertCorrectnessCheck._Visitor<_Result>) {
      return TraceApi.v2.v3.AssertCorrectnessCheck._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.v3.AssertCorrectnessCheck,
    visitor: TraceApi.v2.v3.AssertCorrectnessCheck._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"deepEquality\\":
        return visitor.deepEquality(value);
      case \\"custom\\":
        return visitor.custom(value);
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                                    "name": "AssertCorrectnessCheck.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export interface BasicCustomFiles {
  methodName: string;
  signature: TraceApi.v2.v3.NonVoidFunctionSignature;
  additionalFiles: Record<TraceApi.Language.RawValue, TraceApi.v2.v3.Files>;
  basicTestCaseTemplate: TraceApi.v2.v3.BasicTestCaseTemplate;
}
",
                                    "name": "BasicCustomFiles.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export interface BasicTestCaseTemplate {
  templateId: TraceApi.v2.v3.TestCaseTemplateId;
  name: string;
  description: TraceApi.v2.v3.TestCaseImplementationDescription;
  expectedValueParameterId: TraceApi.v2.v3.ParameterId;
}
",
                                    "name": "BasicTestCaseTemplate.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export interface CreateProblemRequestV2 {
  problemName: string;
  problemDescription: TraceApi.ProblemDescription;
  customFiles: TraceApi.v2.v3.CustomFiles;
  customTestCaseTemplates: TraceApi.v2.v3.TestCaseTemplate[];
  testcases: TraceApi.v2.v3.TestCaseV2[];
  supportedLanguages: TraceApi.Language[];
  isPublic: boolean;
}
",
                                    "name": "CreateProblemRequestV2.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";

export type CustomFiles =
  | TraceApi.v2.v3.CustomFiles.Basic
  | TraceApi.v2.v3.CustomFiles.Custom
  | TraceApi.v2.v3.CustomFiles._Unknown;

export declare namespace CustomFiles {
  interface Basic extends TraceApi.v2.v3.BasicCustomFiles, _Utils {
    type: \\"basic\\";
  }

  interface Custom extends _Utils {
    type: \\"custom\\";
    value: Record<TraceApi.Language.RawValue, TraceApi.v2.v3.Files>;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.v3.CustomFiles._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    basic: (value: TraceApi.v2.v3.BasicCustomFiles) => _Result;
    custom: (value: Record<TraceApi.Language.RawValue, TraceApi.v2.v3.Files>) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const CustomFiles = {
  basic: (value: TraceApi.v2.v3.BasicCustomFiles): TraceApi.v2.v3.CustomFiles.Basic => {
    const valueWithoutVisit: Omit<TraceApi.v2.v3.CustomFiles.Basic, \\"_visit\\"> = {
      ...value,
      type: \\"basic\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.CustomFiles.Basic, visitor: TraceApi.v2.v3.CustomFiles._Visitor<_Result>) {
      return TraceApi.v2.v3.CustomFiles._visit(this, visitor);
    });
  },

  custom: (value: Record<TraceApi.Language.RawValue, TraceApi.v2.v3.Files>): TraceApi.v2.v3.CustomFiles.Custom => {
    const valueWithoutVisit: Omit<TraceApi.v2.v3.CustomFiles.Custom, \\"_visit\\"> = {
      value: value,
      type: \\"custom\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.CustomFiles.Custom, visitor: TraceApi.v2.v3.CustomFiles._Visitor<_Result>) {
      return TraceApi.v2.v3.CustomFiles._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.v3.CustomFiles,
    visitor: TraceApi.v2.v3.CustomFiles._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"basic\\":
        return visitor.basic(value);
      case \\"custom\\":
        return visitor.custom(value.value);
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                                    "name": "CustomFiles.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export interface DeepEqualityCorrectnessCheck {
  expectedValueParameterId: TraceApi.v2.v3.ParameterId;
}
",
                                    "name": "DeepEqualityCorrectnessCheck.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export interface DefaultProvidedFile {
  file: TraceApi.v2.v3.FileInfoV2;
  relatedTypes: TraceApi.VariableType[];
}
",
                                    "name": "DefaultProvidedFile.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface FileInfoV2 {
  filename: string;
  directory: string;
  contents: string;
  editable: boolean;
}
",
                                    "name": "FileInfoV2.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export interface Files {
  files: TraceApi.v2.v3.FileInfoV2[];
}
",
                                    "name": "Files.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface FunctionImplementation {
  impl: string;
  imports?: string;
}
",
                                    "name": "FunctionImplementation.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export interface FunctionImplementationForMultipleLanguages {
  codeByLanguage: Record<TraceApi.Language.RawValue, TraceApi.v2.v3.FunctionImplementation>;
}
",
                                    "name": "FunctionImplementationForMultipleLanguages.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";

export type FunctionSignature =
  | TraceApi.v2.v3.FunctionSignature.Void
  | TraceApi.v2.v3.FunctionSignature.NonVoid
  /**
   * Useful when specifying custom grading for a testcase where actualResult is defined. */
  | TraceApi.v2.v3.FunctionSignature.VoidThatTakesActualResult
  | TraceApi.v2.v3.FunctionSignature._Unknown;

export declare namespace FunctionSignature {
  interface Void extends TraceApi.v2.v3.VoidFunctionSignature, _Utils {
    type: \\"void\\";
  }

  interface NonVoid extends TraceApi.v2.v3.NonVoidFunctionSignature, _Utils {
    type: \\"nonVoid\\";
  }

  interface VoidThatTakesActualResult extends TraceApi.v2.v3.VoidFunctionSignatureThatTakesActualResult, _Utils {
    type: \\"voidThatTakesActualResult\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.v3.FunctionSignature._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    void: (value: TraceApi.v2.v3.VoidFunctionSignature) => _Result;
    nonVoid: (value: TraceApi.v2.v3.NonVoidFunctionSignature) => _Result;
    voidThatTakesActualResult: (value: TraceApi.v2.v3.VoidFunctionSignatureThatTakesActualResult) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const FunctionSignature = {
  void: (value: TraceApi.v2.v3.VoidFunctionSignature): TraceApi.v2.v3.FunctionSignature.Void => {
    const valueWithoutVisit: Omit<TraceApi.v2.v3.FunctionSignature.Void, \\"_visit\\"> = {
      ...value,
      type: \\"void\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.FunctionSignature.Void, visitor: TraceApi.v2.v3.FunctionSignature._Visitor<_Result>) {
      return TraceApi.v2.v3.FunctionSignature._visit(this, visitor);
    });
  },

  nonVoid: (value: TraceApi.v2.v3.NonVoidFunctionSignature): TraceApi.v2.v3.FunctionSignature.NonVoid => {
    const valueWithoutVisit: Omit<TraceApi.v2.v3.FunctionSignature.NonVoid, \\"_visit\\"> = {
      ...value,
      type: \\"nonVoid\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.FunctionSignature.NonVoid, visitor: TraceApi.v2.v3.FunctionSignature._Visitor<_Result>) {
      return TraceApi.v2.v3.FunctionSignature._visit(this, visitor);
    });
  },

  voidThatTakesActualResult: (
    value: TraceApi.v2.v3.VoidFunctionSignatureThatTakesActualResult
  ): TraceApi.v2.v3.FunctionSignature.VoidThatTakesActualResult => {
    const valueWithoutVisit: Omit<TraceApi.v2.v3.FunctionSignature.VoidThatTakesActualResult, \\"_visit\\"> = {
      ...value,
      type: \\"voidThatTakesActualResult\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.FunctionSignature.VoidThatTakesActualResult, visitor: TraceApi.v2.v3.FunctionSignature._Visitor<_Result>) {
      return TraceApi.v2.v3.FunctionSignature._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.v3.FunctionSignature,
    visitor: TraceApi.v2.v3.FunctionSignature._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"void\\":
        return visitor.void(value);
      case \\"nonVoid\\":
        return visitor.nonVoid(value);
      case \\"voidThatTakesActualResult\\":
        return visitor.voidThatTakesActualResult(value);
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                                    "name": "FunctionSignature.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export interface GeneratedFiles {
  generatedTestCaseFiles: Record<TraceApi.Language.RawValue, TraceApi.v2.v3.Files>;
  generatedTemplateFiles: Record<TraceApi.Language.RawValue, TraceApi.v2.v3.Files>;
  other: Record<TraceApi.Language.RawValue, TraceApi.v2.v3.Files>;
}
",
                                    "name": "GeneratedFiles.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export interface GetBasicSolutionFileRequest {
  methodName: string;
  signature: TraceApi.v2.v3.NonVoidFunctionSignature;
}
",
                                    "name": "GetBasicSolutionFileRequest.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export interface GetBasicSolutionFileResponse {
  solutionFileByLanguage: Record<TraceApi.Language.RawValue, TraceApi.v2.v3.FileInfoV2>;
}
",
                                    "name": "GetBasicSolutionFileResponse.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export interface GetFunctionSignatureRequest {
  functionSignature: TraceApi.v2.v3.FunctionSignature;
}
",
                                    "name": "GetFunctionSignatureRequest.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export interface GetFunctionSignatureResponse {
  functionByLanguage: Record<TraceApi.Language.RawValue, string>;
}
",
                                    "name": "GetFunctionSignatureResponse.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export interface GetGeneratedTestCaseFileRequest {
  template?: TraceApi.v2.v3.TestCaseTemplate;
  testCase: TraceApi.v2.v3.TestCaseV2;
}
",
                                    "name": "GetGeneratedTestCaseFileRequest.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export interface GetGeneratedTestCaseTemplateFileRequest {
  template: TraceApi.v2.v3.TestCaseTemplate;
}
",
                                    "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export interface LightweightProblemInfoV2 {
  problemId: TraceApi.ProblemId;
  problemName: string;
  problemVersion: number;
  variableTypes: TraceApi.VariableType[];
}
",
                                    "name": "LightweightProblemInfoV2.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export interface NonVoidFunctionDefinition {
  signature: TraceApi.v2.v3.NonVoidFunctionSignature;
  code: TraceApi.v2.v3.FunctionImplementationForMultipleLanguages;
}
",
                                    "name": "NonVoidFunctionDefinition.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export interface NonVoidFunctionSignature {
  parameters: TraceApi.v2.v3.Parameter[];
  returnType: TraceApi.VariableType;
}
",
                                    "name": "NonVoidFunctionSignature.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export interface Parameter {
  parameterId: TraceApi.v2.v3.ParameterId;
  name: string;
  variableType: TraceApi.VariableType;
}
",
                                    "name": "Parameter.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export type ParameterId = string & {
  v2_v3_ParameterId: void;
};

export const ParameterId = {
  create: (value: string) => value as unknown as TraceApi.v2.v3.ParameterId,
} as const;
",
                                    "name": "ParameterId.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export interface ProblemInfoV2 {
  problemId: TraceApi.ProblemId;
  problemDescription: TraceApi.ProblemDescription;
  problemName: string;
  problemVersion: number;
  supportedLanguages: TraceApi.Language[];
  customFiles: TraceApi.v2.v3.CustomFiles;
  generatedFiles: TraceApi.v2.v3.GeneratedFiles;
  customTestCaseTemplates: TraceApi.v2.v3.TestCaseTemplate[];
  testcases: TraceApi.v2.v3.TestCaseV2[];
  isPublic: boolean;
}
",
                                    "name": "ProblemInfoV2.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

export interface TestCaseExpects {
  expectedStdout?: string;
}
",
                                    "name": "TestCaseExpects.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";

export type TestCaseFunction =
  | TraceApi.v2.v3.TestCaseFunction.WithActualResult
  | TraceApi.v2.v3.TestCaseFunction.Custom
  | TraceApi.v2.v3.TestCaseFunction._Unknown;

export declare namespace TestCaseFunction {
  interface WithActualResult extends TraceApi.v2.v3.TestCaseWithActualResultImplementation, _Utils {
    type: \\"withActualResult\\";
  }

  interface Custom extends TraceApi.v2.v3.VoidFunctionDefinition, _Utils {
    type: \\"custom\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.v3.TestCaseFunction._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    withActualResult: (value: TraceApi.v2.v3.TestCaseWithActualResultImplementation) => _Result;
    custom: (value: TraceApi.v2.v3.VoidFunctionDefinition) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const TestCaseFunction = {
  withActualResult: (
    value: TraceApi.v2.v3.TestCaseWithActualResultImplementation
  ): TraceApi.v2.v3.TestCaseFunction.WithActualResult => {
    const valueWithoutVisit: Omit<TraceApi.v2.v3.TestCaseFunction.WithActualResult, \\"_visit\\"> = {
      ...value,
      type: \\"withActualResult\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.TestCaseFunction.WithActualResult, visitor: TraceApi.v2.v3.TestCaseFunction._Visitor<_Result>) {
      return TraceApi.v2.v3.TestCaseFunction._visit(this, visitor);
    });
  },

  custom: (value: TraceApi.v2.v3.VoidFunctionDefinition): TraceApi.v2.v3.TestCaseFunction.Custom => {
    const valueWithoutVisit: Omit<TraceApi.v2.v3.TestCaseFunction.Custom, \\"_visit\\"> = {
      ...value,
      type: \\"custom\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.TestCaseFunction.Custom, visitor: TraceApi.v2.v3.TestCaseFunction._Visitor<_Result>) {
      return TraceApi.v2.v3.TestCaseFunction._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.v3.TestCaseFunction,
    visitor: TraceApi.v2.v3.TestCaseFunction._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"withActualResult\\":
        return visitor.withActualResult(value);
      case \\"custom\\":
        return visitor.custom(value);
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                                    "name": "TestCaseFunction.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export type TestCaseId = string & {
  v2_v3_TestCaseId: void;
};

export const TestCaseId = {
  create: (value: string) => value as unknown as TraceApi.v2.v3.TestCaseId,
} as const;
",
                                    "name": "TestCaseId.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export interface TestCaseImplementation {
  description: TraceApi.v2.v3.TestCaseImplementationDescription;
  function: TraceApi.v2.v3.TestCaseFunction;
}
",
                                    "name": "TestCaseImplementation.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export interface TestCaseImplementationDescription {
  boards: TraceApi.v2.v3.TestCaseImplementationDescriptionBoard[];
}
",
                                    "name": "TestCaseImplementationDescription.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";

export type TestCaseImplementationDescriptionBoard =
  | TraceApi.v2.v3.TestCaseImplementationDescriptionBoard.Html
  | TraceApi.v2.v3.TestCaseImplementationDescriptionBoard.ParamId
  | TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._Unknown;

export declare namespace TestCaseImplementationDescriptionBoard {
  interface Html extends _Utils {
    type: \\"html\\";
    value: string;
  }

  interface ParamId extends _Utils {
    type: \\"paramId\\";
    value: TraceApi.v2.v3.ParameterId;
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    html: (value: string) => _Result;
    paramId: (value: TraceApi.v2.v3.ParameterId) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const TestCaseImplementationDescriptionBoard = {
  html: (value: string): TraceApi.v2.v3.TestCaseImplementationDescriptionBoard.Html => {
    const valueWithoutVisit: Omit<TraceApi.v2.v3.TestCaseImplementationDescriptionBoard.Html, \\"_visit\\"> = {
      value: value,
      type: \\"html\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.TestCaseImplementationDescriptionBoard.Html, visitor: TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._Visitor<_Result>) {
      return TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._visit(this, visitor);
    });
  },

  paramId: (value: TraceApi.v2.v3.ParameterId): TraceApi.v2.v3.TestCaseImplementationDescriptionBoard.ParamId => {
    const valueWithoutVisit: Omit<TraceApi.v2.v3.TestCaseImplementationDescriptionBoard.ParamId, \\"_visit\\"> = {
      value: value,
      type: \\"paramId\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.TestCaseImplementationDescriptionBoard.ParamId, visitor: TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._Visitor<_Result>) {
      return TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.v3.TestCaseImplementationDescriptionBoard,
    visitor: TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"html\\":
        return visitor.html(value.value);
      case \\"paramId\\":
        return visitor.paramId(value.value);
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                                    "name": "TestCaseImplementationDescriptionBoard.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";

export type TestCaseImplementationReference =
  | TraceApi.v2.v3.TestCaseImplementationReference.TemplateId
  | TraceApi.v2.v3.TestCaseImplementationReference.Implementation
  | TraceApi.v2.v3.TestCaseImplementationReference._Unknown;

export declare namespace TestCaseImplementationReference {
  interface TemplateId extends _Utils {
    type: \\"templateId\\";
    value: TraceApi.v2.v3.TestCaseTemplateId;
  }

  interface Implementation extends TraceApi.v2.v3.TestCaseImplementation, _Utils {
    type: \\"implementation\\";
  }

  interface _Unknown extends _Utils {
    type: void;
  }

  interface _Utils {
    _visit: <_Result>(visitor: TraceApi.v2.v3.TestCaseImplementationReference._Visitor<_Result>) => _Result;
  }

  interface _Visitor<_Result> {
    templateId: (value: TraceApi.v2.v3.TestCaseTemplateId) => _Result;
    implementation: (value: TraceApi.v2.v3.TestCaseImplementation) => _Result;
    _other: (value: { type: string }) => _Result;
  }
}

export const TestCaseImplementationReference = {
  templateId: (value: TraceApi.v2.v3.TestCaseTemplateId): TraceApi.v2.v3.TestCaseImplementationReference.TemplateId => {
    const valueWithoutVisit: Omit<TraceApi.v2.v3.TestCaseImplementationReference.TemplateId, \\"_visit\\"> = {
      value: value,
      type: \\"templateId\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.TestCaseImplementationReference.TemplateId, visitor: TraceApi.v2.v3.TestCaseImplementationReference._Visitor<_Result>) {
      return TraceApi.v2.v3.TestCaseImplementationReference._visit(this, visitor);
    });
  },

  implementation: (
    value: TraceApi.v2.v3.TestCaseImplementation
  ): TraceApi.v2.v3.TestCaseImplementationReference.Implementation => {
    const valueWithoutVisit: Omit<TraceApi.v2.v3.TestCaseImplementationReference.Implementation, \\"_visit\\"> = {
      ...value,
      type: \\"implementation\\",
    };
    return core.addNonEnumerableProperty(valueWithoutVisit, \\"_visit\\", function <
      _Result
    >(this: TraceApi.v2.v3.TestCaseImplementationReference.Implementation, visitor: TraceApi.v2.v3.TestCaseImplementationReference._Visitor<_Result>) {
      return TraceApi.v2.v3.TestCaseImplementationReference._visit(this, visitor);
    });
  },

  _visit: <_Result>(
    value: TraceApi.v2.v3.TestCaseImplementationReference,
    visitor: TraceApi.v2.v3.TestCaseImplementationReference._Visitor<_Result>
  ): _Result => {
    switch (value.type) {
      case \\"templateId\\":
        return visitor.templateId(value.value);
      case \\"implementation\\":
        return visitor.implementation(value);
      default:
        return visitor._other(visitor as any);
    }
  },
} as const;
",
                                    "name": "TestCaseImplementationReference.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export interface TestCaseMetadata {
  id: TraceApi.v2.v3.TestCaseId;
  name: string;
  hidden: boolean;
}
",
                                    "name": "TestCaseMetadata.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export interface TestCaseTemplate {
  templateId: TraceApi.v2.v3.TestCaseTemplateId;
  name: string;
  implementation: TraceApi.v2.v3.TestCaseImplementation;
}
",
                                    "name": "TestCaseTemplate.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export type TestCaseTemplateId = string & {
  v2_v3_TestCaseTemplateId: void;
};

export const TestCaseTemplateId = {
  create: (value: string) => value as unknown as TraceApi.v2.v3.TestCaseTemplateId,
} as const;
",
                                    "name": "TestCaseTemplateId.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export interface TestCaseV2 {
  metadata: TraceApi.v2.v3.TestCaseMetadata;
  implementation: TraceApi.v2.v3.TestCaseImplementationReference;
  arguments: Record<TraceApi.v2.v3.ParameterId, TraceApi.VariableValue>;
  expects?: TraceApi.v2.v3.TestCaseExpects;
}
",
                                    "name": "TestCaseV2.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export interface TestCaseWithActualResultImplementation {
  getActualResult: TraceApi.v2.v3.NonVoidFunctionDefinition;
  assertCorrectnessCheck: TraceApi.v2.v3.AssertCorrectnessCheck;
}
",
                                    "name": "TestCaseWithActualResultImplementation.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export interface VoidFunctionDefinition {
  parameters: TraceApi.v2.v3.Parameter[];
  code: TraceApi.v2.v3.FunctionImplementationForMultipleLanguages;
}
",
                                    "name": "VoidFunctionDefinition.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

/**
 * The generated signature will include an additional param, actualResult
 */
export interface VoidFunctionDefinitionThatTakesActualResult {
  additionalParameters: TraceApi.v2.v3.Parameter[];
  code: TraceApi.v2.v3.FunctionImplementationForMultipleLanguages;
}
",
                                    "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export interface VoidFunctionSignature {
  parameters: TraceApi.v2.v3.Parameter[];
}
",
                                    "name": "VoidFunctionSignature.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";

export interface VoidFunctionSignatureThatTakesActualResult {
  parameters: TraceApi.v2.v3.Parameter[];
  actualResultType: TraceApi.VariableType;
}
",
                                    "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                                    "name": "index.ts",
                                    "type": "file",
                                  },
                                ],
                                "name": "types",
                                "type": "directory",
                              },
                            ],
                            "name": "problem",
                            "type": "directory",
                          },
                        ],
                        "name": "resources",
                        "type": "directory",
                      },
                    ],
                    "name": "v3",
                    "type": "directory",
                  },
                ],
                "name": "resources",
                "type": "directory",
              },
            ],
            "name": "v2",
            "type": "directory",
          },
        ],
        "name": "resources",
        "type": "directory",
      },
      Object {
        "contents": Array [
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "export * as storeTracedTestCaseV2 from \\"./storeTracedTestCaseV2\\";
export * as storeTracedWorkspaceV2 from \\"./storeTracedWorkspaceV2\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<serializers.TraceResponseV2.Raw[], TraceApi.TraceResponseV2[]> =
  core.schemas.list(core.schemas.lazyObject(() => serializers.TraceResponseV2));
",
                    "name": "storeTracedTestCaseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<serializers.TraceResponseV2.Raw[], TraceApi.TraceResponseV2[]> =
  core.schemas.list(core.schemas.lazyObject(() => serializers.TraceResponseV2));
",
                    "name": "storeTracedWorkspaceV2.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const StoreTracedTestCaseRequest: core.schemas.ObjectSchema<
  StoreTracedTestCaseRequest.Raw,
  TraceApi.StoreTracedTestCaseRequest
> = core.schemas.object({
  result: core.schemas.lazyObject(() => serializers.TestCaseResultWithStdout),
  traceResponses: core.schemas.list(core.schemas.lazyObject(() => serializers.TraceResponse)),
});

export declare namespace StoreTracedTestCaseRequest {
  interface Raw {
    result: serializers.TestCaseResultWithStdout.Raw;
    traceResponses: serializers.TraceResponse.Raw[];
  }
}
",
                    "name": "StoreTracedTestCaseRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const StoreTracedWorkspaceRequest: core.schemas.ObjectSchema<
  StoreTracedWorkspaceRequest.Raw,
  TraceApi.StoreTracedWorkspaceRequest
> = core.schemas.object({
  workspaceRunDetails: core.schemas.lazyObject(() => serializers.WorkspaceRunDetails),
  traceResponses: core.schemas.list(core.schemas.lazyObject(() => serializers.TraceResponse)),
});

export declare namespace StoreTracedWorkspaceRequest {
  interface Raw {
    workspaceRunDetails: serializers.WorkspaceRunDetails.Raw;
    traceResponses: serializers.TraceResponse.Raw[];
  }
}
",
                    "name": "StoreTracedWorkspaceRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./StoreTracedTestCaseRequest\\";
export * from \\"./StoreTracedWorkspaceRequest\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "admin",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const BinaryTreeNodeAndTreeValue: core.schemas.ObjectSchema<
  BinaryTreeNodeAndTreeValue.Raw,
  TraceApi.BinaryTreeNodeAndTreeValue
> = core.schemas.object({
  nodeId: core.schemas.lazy(() => serializers.NodeId),
  fullTree: core.schemas.lazyObject(() => serializers.BinaryTreeValue),
});

export declare namespace BinaryTreeNodeAndTreeValue {
  interface Raw {
    nodeId: serializers.NodeId.Raw;
    fullTree: serializers.BinaryTreeValue.Raw;
  }
}
",
                    "name": "BinaryTreeNodeAndTreeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const BinaryTreeNodeValue: core.schemas.ObjectSchema<BinaryTreeNodeValue.Raw, TraceApi.BinaryTreeNodeValue> =
  core.schemas.object({
    nodeId: core.schemas.lazy(() => serializers.NodeId),
    val: core.schemas.number(),
    right: core.schemas.lazy(() => serializers.NodeId).optional(),
    left: core.schemas.lazy(() => serializers.NodeId).optional(),
  });

export declare namespace BinaryTreeNodeValue {
  interface Raw {
    nodeId: serializers.NodeId.Raw;
    val: number;
    right?: serializers.NodeId.Raw | null;
    left?: serializers.NodeId.Raw | null;
  }
}
",
                    "name": "BinaryTreeNodeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const BinaryTreeValue: core.schemas.ObjectSchema<BinaryTreeValue.Raw, TraceApi.BinaryTreeValue> =
  core.schemas.object({
    root: core.schemas.lazy(() => serializers.NodeId).optional(),
    nodes: core.schemas.record(
      core.schemas.lazy(() => serializers.NodeId),
      core.schemas.lazyObject(() => serializers.BinaryTreeNodeValue)
    ),
  });

export declare namespace BinaryTreeValue {
  interface Raw {
    root?: serializers.NodeId.Raw | null;
    nodes: Record<serializers.NodeId.Raw, serializers.BinaryTreeNodeValue.Raw>;
  }
}
",
                    "name": "BinaryTreeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const DebugKeyValuePairs: core.schemas.ObjectSchema<DebugKeyValuePairs.Raw, TraceApi.DebugKeyValuePairs> =
  core.schemas.object({
    key: core.schemas.lazy(() => serializers.DebugVariableValue),
    value: core.schemas.lazy(() => serializers.DebugVariableValue),
  });

export declare namespace DebugKeyValuePairs {
  interface Raw {
    key: serializers.DebugVariableValue.Raw;
    value: serializers.DebugVariableValue.Raw;
  }
}
",
                    "name": "DebugKeyValuePairs.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const DebugMapValue: core.schemas.ObjectSchema<DebugMapValue.Raw, TraceApi.DebugMapValue> = core.schemas.object({
  keyValuePairs: core.schemas.list(core.schemas.lazyObject(() => serializers.DebugKeyValuePairs)),
});

export declare namespace DebugMapValue {
  interface Raw {
    keyValuePairs: serializers.DebugKeyValuePairs.Raw[];
  }
}
",
                    "name": "DebugMapValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const DebugVariableValue: core.schemas.Schema<DebugVariableValue.Raw, TraceApi.DebugVariableValue> = core.schemas
  .union(\\"type\\", {
    integerValue: core.schemas.object({
      value: core.schemas.number(),
    }),
    booleanValue: core.schemas.object({
      value: core.schemas.boolean(),
    }),
    doubleValue: core.schemas.object({
      value: core.schemas.number(),
    }),
    stringValue: core.schemas.object({
      value: core.schemas.string(),
    }),
    charValue: core.schemas.object({
      value: core.schemas.string(),
    }),
    mapValue: core.schemas.lazyObject(() => serializers.DebugMapValue),
    listValue: core.schemas.object({
      value: core.schemas.list(core.schemas.lazy(() => serializers.DebugVariableValue)),
    }),
    binaryTreeNodeValue: core.schemas.lazyObject(() => serializers.BinaryTreeNodeAndTreeValue),
    singlyLinkedListNodeValue: core.schemas.lazyObject(() => serializers.SinglyLinkedListNodeAndListValue),
    doublyLinkedListNodeValue: core.schemas.lazyObject(() => serializers.DoublyLinkedListNodeAndListValue),
    undefinedValue: core.schemas.object({}),
    nullValue: core.schemas.object({}),
    genericValue: core.schemas.lazyObject(() => serializers.GenericValue),
  })
  .transform<TraceApi.DebugVariableValue>({
    parse: (value) => {
      switch (value.type) {
        case \\"integerValue\\":
          return TraceApi.DebugVariableValue.integerValue(value.value);
        case \\"booleanValue\\":
          return TraceApi.DebugVariableValue.booleanValue(value.value);
        case \\"doubleValue\\":
          return TraceApi.DebugVariableValue.doubleValue(value.value);
        case \\"stringValue\\":
          return TraceApi.DebugVariableValue.stringValue(value.value);
        case \\"charValue\\":
          return TraceApi.DebugVariableValue.charValue(value.value);
        case \\"mapValue\\":
          return TraceApi.DebugVariableValue.mapValue(value);
        case \\"listValue\\":
          return TraceApi.DebugVariableValue.listValue(value.value);
        case \\"binaryTreeNodeValue\\":
          return TraceApi.DebugVariableValue.binaryTreeNodeValue(value);
        case \\"singlyLinkedListNodeValue\\":
          return TraceApi.DebugVariableValue.singlyLinkedListNodeValue(value);
        case \\"doublyLinkedListNodeValue\\":
          return TraceApi.DebugVariableValue.doublyLinkedListNodeValue(value);
        case \\"undefinedValue\\":
          return TraceApi.DebugVariableValue.undefinedValue();
        case \\"nullValue\\":
          return TraceApi.DebugVariableValue.nullValue();
        case \\"genericValue\\":
          return TraceApi.DebugVariableValue.genericValue(value);
        default:
          return core.addNonEnumerableProperty(value, \\"_visit\\", function <
            _Result
          >(this: TraceApi.DebugVariableValue, visitor: TraceApi.DebugVariableValue._Visitor<_Result>) {
            return visitor._other(value);
          });
      }
    },
    json: (value) => value as any,
  });

export declare namespace DebugVariableValue {
  type Raw =
    | DebugVariableValue.IntegerValue
    | DebugVariableValue.BooleanValue
    | DebugVariableValue.DoubleValue
    | DebugVariableValue.StringValue
    | DebugVariableValue.CharValue
    | DebugVariableValue.MapValue
    | DebugVariableValue.ListValue
    | DebugVariableValue.BinaryTreeNodeValue
    | DebugVariableValue.SinglyLinkedListNodeValue
    | DebugVariableValue.DoublyLinkedListNodeValue
    | DebugVariableValue.UndefinedValue
    | DebugVariableValue.NullValue
    | DebugVariableValue.GenericValue;

  interface IntegerValue {
    type: \\"integerValue\\";
    value: number;
  }

  interface BooleanValue {
    type: \\"booleanValue\\";
    value: boolean;
  }

  interface DoubleValue {
    type: \\"doubleValue\\";
    value: number;
  }

  interface StringValue {
    type: \\"stringValue\\";
    value: string;
  }

  interface CharValue {
    type: \\"charValue\\";
    value: string;
  }

  interface MapValue extends serializers.DebugMapValue.Raw {
    type: \\"mapValue\\";
  }

  interface ListValue {
    type: \\"listValue\\";
    value: serializers.DebugVariableValue.Raw[];
  }

  interface BinaryTreeNodeValue extends serializers.BinaryTreeNodeAndTreeValue.Raw {
    type: \\"binaryTreeNodeValue\\";
  }

  interface SinglyLinkedListNodeValue extends serializers.SinglyLinkedListNodeAndListValue.Raw {
    type: \\"singlyLinkedListNodeValue\\";
  }

  interface DoublyLinkedListNodeValue extends serializers.DoublyLinkedListNodeAndListValue.Raw {
    type: \\"doublyLinkedListNodeValue\\";
  }

  interface UndefinedValue {
    type: \\"undefinedValue\\";
  }

  interface NullValue {
    type: \\"nullValue\\";
  }

  interface GenericValue extends serializers.GenericValue.Raw {
    type: \\"genericValue\\";
  }
}
",
                    "name": "DebugVariableValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const DoublyLinkedListNodeAndListValue: core.schemas.ObjectSchema<
  DoublyLinkedListNodeAndListValue.Raw,
  TraceApi.DoublyLinkedListNodeAndListValue
> = core.schemas.object({
  nodeId: core.schemas.lazy(() => serializers.NodeId),
  fullList: core.schemas.lazyObject(() => serializers.DoublyLinkedListValue),
});

export declare namespace DoublyLinkedListNodeAndListValue {
  interface Raw {
    nodeId: serializers.NodeId.Raw;
    fullList: serializers.DoublyLinkedListValue.Raw;
  }
}
",
                    "name": "DoublyLinkedListNodeAndListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const DoublyLinkedListNodeValue: core.schemas.ObjectSchema<
  DoublyLinkedListNodeValue.Raw,
  TraceApi.DoublyLinkedListNodeValue
> = core.schemas.object({
  nodeId: core.schemas.lazy(() => serializers.NodeId),
  val: core.schemas.number(),
  next: core.schemas.lazy(() => serializers.NodeId).optional(),
  prev: core.schemas.lazy(() => serializers.NodeId).optional(),
});

export declare namespace DoublyLinkedListNodeValue {
  interface Raw {
    nodeId: serializers.NodeId.Raw;
    val: number;
    next?: serializers.NodeId.Raw | null;
    prev?: serializers.NodeId.Raw | null;
  }
}
",
                    "name": "DoublyLinkedListNodeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const DoublyLinkedListValue: core.schemas.ObjectSchema<
  DoublyLinkedListValue.Raw,
  TraceApi.DoublyLinkedListValue
> = core.schemas.object({
  head: core.schemas.lazy(() => serializers.NodeId).optional(),
  nodes: core.schemas.record(
    core.schemas.lazy(() => serializers.NodeId),
    core.schemas.lazyObject(() => serializers.DoublyLinkedListNodeValue)
  ),
});

export declare namespace DoublyLinkedListValue {
  interface Raw {
    head?: serializers.NodeId.Raw | null;
    nodes: Record<serializers.NodeId.Raw, serializers.DoublyLinkedListNodeValue.Raw>;
  }
}
",
                    "name": "DoublyLinkedListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const FileInfo: core.schemas.ObjectSchema<FileInfo.Raw, TraceApi.FileInfo> = core.schemas.object({
  filename: core.schemas.string(),
  contents: core.schemas.string(),
});

export declare namespace FileInfo {
  interface Raw {
    filename: string;
    contents: string;
  }
}
",
                    "name": "FileInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const GenericValue: core.schemas.ObjectSchema<GenericValue.Raw, TraceApi.GenericValue> = core.schemas.object({
  stringifiedType: core.schemas.string().optional(),
  stringifiedValue: core.schemas.string(),
});

export declare namespace GenericValue {
  interface Raw {
    stringifiedType?: string | null;
    stringifiedValue: string;
  }
}
",
                    "name": "GenericValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const KeyValuePair: core.schemas.ObjectSchema<KeyValuePair.Raw, TraceApi.KeyValuePair> = core.schemas.object({
  key: core.schemas.lazy(() => serializers.VariableValue),
  value: core.schemas.lazy(() => serializers.VariableValue),
});

export declare namespace KeyValuePair {
  interface Raw {
    key: serializers.VariableValue.Raw;
    value: serializers.VariableValue.Raw;
  }
}
",
                    "name": "KeyValuePair.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Language: core.schemas.Schema<Language.Raw, TraceApi.Language> = core.schemas
  .string()
  .transform<TraceApi.Language>({
    parse: (value) => TraceApi.Language._parse(value),
    json: ({ value }) => value,
  });

export declare namespace Language {
  type Raw = string;
}
",
                    "name": "Language.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const ListType: core.schemas.ObjectSchema<ListType.Raw, TraceApi.ListType> = core.schemas.object({
  valueType: core.schemas.lazy(() => serializers.VariableType),
  isFixedLength: core.schemas.boolean().optional(),
});

export declare namespace ListType {
  interface Raw {
    valueType: serializers.VariableType.Raw;
    isFixedLength?: boolean | null;
  }
}
",
                    "name": "ListType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const MapType: core.schemas.ObjectSchema<MapType.Raw, TraceApi.MapType> = core.schemas.object({
  keyType: core.schemas.lazy(() => serializers.VariableType),
  valueType: core.schemas.lazy(() => serializers.VariableType),
});

export declare namespace MapType {
  interface Raw {
    keyType: serializers.VariableType.Raw;
    valueType: serializers.VariableType.Raw;
  }
}
",
                    "name": "MapType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const MapValue: core.schemas.ObjectSchema<MapValue.Raw, TraceApi.MapValue> = core.schemas.object({
  keyValuePairs: core.schemas.list(core.schemas.lazyObject(() => serializers.KeyValuePair)),
});

export declare namespace MapValue {
  interface Raw {
    keyValuePairs: serializers.KeyValuePair.Raw[];
  }
}
",
                    "name": "MapValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const NodeId: core.schemas.Schema<NodeId.Raw, TraceApi.NodeId> = core.schemas.string().transform({
  parse: TraceApi.NodeId.create,
  json: (value) => value,
});

export declare namespace NodeId {
  type Raw = string;
}
",
                    "name": "NodeId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const ProblemId: core.schemas.Schema<ProblemId.Raw, TraceApi.ProblemId> = core.schemas.string().transform({
  parse: TraceApi.ProblemId.create,
  json: (value) => value,
});

export declare namespace ProblemId {
  type Raw = string;
}
",
                    "name": "ProblemId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const SinglyLinkedListNodeAndListValue: core.schemas.ObjectSchema<
  SinglyLinkedListNodeAndListValue.Raw,
  TraceApi.SinglyLinkedListNodeAndListValue
> = core.schemas.object({
  nodeId: core.schemas.lazy(() => serializers.NodeId),
  fullList: core.schemas.lazyObject(() => serializers.SinglyLinkedListValue),
});

export declare namespace SinglyLinkedListNodeAndListValue {
  interface Raw {
    nodeId: serializers.NodeId.Raw;
    fullList: serializers.SinglyLinkedListValue.Raw;
  }
}
",
                    "name": "SinglyLinkedListNodeAndListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const SinglyLinkedListNodeValue: core.schemas.ObjectSchema<
  SinglyLinkedListNodeValue.Raw,
  TraceApi.SinglyLinkedListNodeValue
> = core.schemas.object({
  nodeId: core.schemas.lazy(() => serializers.NodeId),
  val: core.schemas.number(),
  next: core.schemas.lazy(() => serializers.NodeId).optional(),
});

export declare namespace SinglyLinkedListNodeValue {
  interface Raw {
    nodeId: serializers.NodeId.Raw;
    val: number;
    next?: serializers.NodeId.Raw | null;
  }
}
",
                    "name": "SinglyLinkedListNodeValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const SinglyLinkedListValue: core.schemas.ObjectSchema<
  SinglyLinkedListValue.Raw,
  TraceApi.SinglyLinkedListValue
> = core.schemas.object({
  head: core.schemas.lazy(() => serializers.NodeId).optional(),
  nodes: core.schemas.record(
    core.schemas.lazy(() => serializers.NodeId),
    core.schemas.lazyObject(() => serializers.SinglyLinkedListNodeValue)
  ),
});

export declare namespace SinglyLinkedListValue {
  interface Raw {
    head?: serializers.NodeId.Raw | null;
    nodes: Record<serializers.NodeId.Raw, serializers.SinglyLinkedListNodeValue.Raw>;
  }
}
",
                    "name": "SinglyLinkedListValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TestCase: core.schemas.ObjectSchema<TestCase.Raw, TraceApi.TestCase> = core.schemas.object({
  id: core.schemas.string(),
  params: core.schemas.list(core.schemas.lazy(() => serializers.VariableValue)),
});

export declare namespace TestCase {
  interface Raw {
    id: string;
    params: serializers.VariableValue.Raw[];
  }
}
",
                    "name": "TestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TestCaseWithExpectedResult: core.schemas.ObjectSchema<
  TestCaseWithExpectedResult.Raw,
  TraceApi.TestCaseWithExpectedResult
> = core.schemas.object({
  testCase: core.schemas.lazyObject(() => serializers.TestCase),
  expectedResult: core.schemas.lazy(() => serializers.VariableValue),
});

export declare namespace TestCaseWithExpectedResult {
  interface Raw {
    testCase: serializers.TestCase.Raw;
    expectedResult: serializers.VariableValue.Raw;
  }
}
",
                    "name": "TestCaseWithExpectedResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const UserId: core.schemas.Schema<UserId.Raw, TraceApi.UserId> = core.schemas.string().transform({
  parse: TraceApi.UserId.create,
  json: (value) => value,
});

export declare namespace UserId {
  type Raw = string;
}
",
                    "name": "UserId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const VariableType: core.schemas.Schema<VariableType.Raw, TraceApi.VariableType> = core.schemas
  .union(\\"type\\", {
    integerType: core.schemas.object({}),
    doubleType: core.schemas.object({}),
    booleanType: core.schemas.object({}),
    stringType: core.schemas.object({}),
    charType: core.schemas.object({}),
    listType: core.schemas.lazyObject(() => serializers.ListType),
    mapType: core.schemas.lazyObject(() => serializers.MapType),
    binaryTreeType: core.schemas.object({}),
    singlyLinkedListType: core.schemas.object({}),
    doublyLinkedListType: core.schemas.object({}),
  })
  .transform<TraceApi.VariableType>({
    parse: (value) => {
      switch (value.type) {
        case \\"integerType\\":
          return TraceApi.VariableType.integerType();
        case \\"doubleType\\":
          return TraceApi.VariableType.doubleType();
        case \\"booleanType\\":
          return TraceApi.VariableType.booleanType();
        case \\"stringType\\":
          return TraceApi.VariableType.stringType();
        case \\"charType\\":
          return TraceApi.VariableType.charType();
        case \\"listType\\":
          return TraceApi.VariableType.listType(value);
        case \\"mapType\\":
          return TraceApi.VariableType.mapType(value);
        case \\"binaryTreeType\\":
          return TraceApi.VariableType.binaryTreeType();
        case \\"singlyLinkedListType\\":
          return TraceApi.VariableType.singlyLinkedListType();
        case \\"doublyLinkedListType\\":
          return TraceApi.VariableType.doublyLinkedListType();
        default:
          return core.addNonEnumerableProperty(value, \\"_visit\\", function <
            _Result
          >(this: TraceApi.VariableType, visitor: TraceApi.VariableType._Visitor<_Result>) {
            return visitor._other(value);
          });
      }
    },
    json: (value) => value as any,
  });

export declare namespace VariableType {
  type Raw =
    | VariableType.IntegerType
    | VariableType.DoubleType
    | VariableType.BooleanType
    | VariableType.StringType
    | VariableType.CharType
    | VariableType.ListType
    | VariableType.MapType
    | VariableType.BinaryTreeType
    | VariableType.SinglyLinkedListType
    | VariableType.DoublyLinkedListType;

  interface IntegerType {
    type: \\"integerType\\";
  }

  interface DoubleType {
    type: \\"doubleType\\";
  }

  interface BooleanType {
    type: \\"booleanType\\";
  }

  interface StringType {
    type: \\"stringType\\";
  }

  interface CharType {
    type: \\"charType\\";
  }

  interface ListType extends serializers.ListType.Raw {
    type: \\"listType\\";
  }

  interface MapType extends serializers.MapType.Raw {
    type: \\"mapType\\";
  }

  interface BinaryTreeType {
    type: \\"binaryTreeType\\";
  }

  interface SinglyLinkedListType {
    type: \\"singlyLinkedListType\\";
  }

  interface DoublyLinkedListType {
    type: \\"doublyLinkedListType\\";
  }
}
",
                    "name": "VariableType.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const VariableValue: core.schemas.Schema<VariableValue.Raw, TraceApi.VariableValue> = core.schemas
  .union(\\"type\\", {
    integerValue: core.schemas.object({
      value: core.schemas.number(),
    }),
    booleanValue: core.schemas.object({
      value: core.schemas.boolean(),
    }),
    doubleValue: core.schemas.object({
      value: core.schemas.number(),
    }),
    stringValue: core.schemas.object({
      value: core.schemas.string(),
    }),
    charValue: core.schemas.object({
      value: core.schemas.string(),
    }),
    mapValue: core.schemas.lazyObject(() => serializers.MapValue),
    listValue: core.schemas.object({
      value: core.schemas.list(core.schemas.lazy(() => serializers.VariableValue)),
    }),
    binaryTreeValue: core.schemas.lazyObject(() => serializers.BinaryTreeValue),
    singlyLinkedListValue: core.schemas.lazyObject(() => serializers.SinglyLinkedListValue),
    doublyLinkedListValue: core.schemas.lazyObject(() => serializers.DoublyLinkedListValue),
    nullValue: core.schemas.object({}),
  })
  .transform<TraceApi.VariableValue>({
    parse: (value) => {
      switch (value.type) {
        case \\"integerValue\\":
          return TraceApi.VariableValue.integerValue(value.value);
        case \\"booleanValue\\":
          return TraceApi.VariableValue.booleanValue(value.value);
        case \\"doubleValue\\":
          return TraceApi.VariableValue.doubleValue(value.value);
        case \\"stringValue\\":
          return TraceApi.VariableValue.stringValue(value.value);
        case \\"charValue\\":
          return TraceApi.VariableValue.charValue(value.value);
        case \\"mapValue\\":
          return TraceApi.VariableValue.mapValue(value);
        case \\"listValue\\":
          return TraceApi.VariableValue.listValue(value.value);
        case \\"binaryTreeValue\\":
          return TraceApi.VariableValue.binaryTreeValue(value);
        case \\"singlyLinkedListValue\\":
          return TraceApi.VariableValue.singlyLinkedListValue(value);
        case \\"doublyLinkedListValue\\":
          return TraceApi.VariableValue.doublyLinkedListValue(value);
        case \\"nullValue\\":
          return TraceApi.VariableValue.nullValue();
        default:
          return core.addNonEnumerableProperty(value, \\"_visit\\", function <
            _Result
          >(this: TraceApi.VariableValue, visitor: TraceApi.VariableValue._Visitor<_Result>) {
            return visitor._other(value);
          });
      }
    },
    json: (value) => value as any,
  });

export declare namespace VariableValue {
  type Raw =
    | VariableValue.IntegerValue
    | VariableValue.BooleanValue
    | VariableValue.DoubleValue
    | VariableValue.StringValue
    | VariableValue.CharValue
    | VariableValue.MapValue
    | VariableValue.ListValue
    | VariableValue.BinaryTreeValue
    | VariableValue.SinglyLinkedListValue
    | VariableValue.DoublyLinkedListValue
    | VariableValue.NullValue;

  interface IntegerValue {
    type: \\"integerValue\\";
    value: number;
  }

  interface BooleanValue {
    type: \\"booleanValue\\";
    value: boolean;
  }

  interface DoubleValue {
    type: \\"doubleValue\\";
    value: number;
  }

  interface StringValue {
    type: \\"stringValue\\";
    value: string;
  }

  interface CharValue {
    type: \\"charValue\\";
    value: string;
  }

  interface MapValue extends serializers.MapValue.Raw {
    type: \\"mapValue\\";
  }

  interface ListValue {
    type: \\"listValue\\";
    value: serializers.VariableValue.Raw[];
  }

  interface BinaryTreeValue extends serializers.BinaryTreeValue.Raw {
    type: \\"binaryTreeValue\\";
  }

  interface SinglyLinkedListValue extends serializers.SinglyLinkedListValue.Raw {
    type: \\"singlyLinkedListValue\\";
  }

  interface DoublyLinkedListValue extends serializers.DoublyLinkedListValue.Raw {
    type: \\"doublyLinkedListValue\\";
  }

  interface NullValue {
    type: \\"nullValue\\";
  }
}
",
                    "name": "VariableValue.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./UserId\\";
export * from \\"./ProblemId\\";
export * from \\"./NodeId\\";
export * from \\"./VariableType\\";
export * from \\"./ListType\\";
export * from \\"./MapType\\";
export * from \\"./VariableValue\\";
export * from \\"./DebugVariableValue\\";
export * from \\"./GenericValue\\";
export * from \\"./MapValue\\";
export * from \\"./KeyValuePair\\";
export * from \\"./BinaryTreeValue\\";
export * from \\"./BinaryTreeNodeValue\\";
export * from \\"./BinaryTreeNodeAndTreeValue\\";
export * from \\"./SinglyLinkedListValue\\";
export * from \\"./SinglyLinkedListNodeValue\\";
export * from \\"./SinglyLinkedListNodeAndListValue\\";
export * from \\"./DoublyLinkedListValue\\";
export * from \\"./DoublyLinkedListNodeValue\\";
export * from \\"./DoublyLinkedListNodeAndListValue\\";
export * from \\"./DebugMapValue\\";
export * from \\"./DebugKeyValuePairs\\";
export * from \\"./TestCase\\";
export * from \\"./TestCaseWithExpectedResult\\";
export * from \\"./FileInfo\\";
export * from \\"./Language\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "commons",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<serializers.ProblemId.Raw[], TraceApi.ProblemId[]> = core.schemas.list(
  core.schemas.lazy(() => serializers.ProblemId)
);
",
                    "name": "getHomepageProblems.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getHomepageProblems from \\"./getHomepageProblems\\";
export * as setHomepageProblems from \\"./setHomepageProblems\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<serializers.ProblemId.Raw[], TraceApi.ProblemId[]> = core.schemas.list(
  core.schemas.lazy(() => serializers.ProblemId)
);
",
                    "name": "setHomepageProblems.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "homepage",
            "type": "directory",
          },
          Object {
            "contents": "export * as admin from \\"./admin\\";
export * from \\"./admin/types\\";
export * as commons from \\"./commons\\";
export * from \\"./commons/types\\";
export * as langServer from \\"./langServer\\";
export * from \\"./langServer/types\\";
export * as migration from \\"./migration\\";
export * from \\"./migration/types\\";
export * as playlist from \\"./playlist\\";
export * from \\"./playlist/types\\";
export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as submission from \\"./submission\\";
export * from \\"./submission/types\\";
export * as v2 from \\"./v2\\";
export * from \\"./playlist/errors\\";
export * as homepage from \\"./homepage\\";
export * as sysprop from \\"./sysprop\\";
",
            "name": "index.ts",
            "type": "file",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const LangServerRequest: core.schemas.ObjectSchema<LangServerRequest.Raw, TraceApi.LangServerRequest> =
  core.schemas.object({
    request: core.schemas.unknown(),
  });

export declare namespace LangServerRequest {
  interface Raw {
    request?: unknown;
  }
}
",
                    "name": "LangServerRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const LangServerResponse: core.schemas.ObjectSchema<LangServerResponse.Raw, TraceApi.LangServerResponse> =
  core.schemas.object({
    response: core.schemas.unknown(),
  });

export declare namespace LangServerResponse {
  interface Raw {
    response?: unknown;
  }
}
",
                    "name": "LangServerResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./LangServerRequest\\";
export * from \\"./LangServerResponse\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "langServer",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<serializers.Migration.Raw[], TraceApi.Migration[]> = core.schemas.list(
  core.schemas.lazyObject(() => serializers.Migration)
);
",
                    "name": "getAttemptedMigrations.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getAttemptedMigrations from \\"./getAttemptedMigrations\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const Migration: core.schemas.ObjectSchema<Migration.Raw, TraceApi.Migration> = core.schemas.object({
  name: core.schemas.string(),
  status: core.schemas.lazy(() => serializers.MigrationStatus),
});

export declare namespace Migration {
  interface Raw {
    name: string;
    status: serializers.MigrationStatus.Raw;
  }
}
",
                    "name": "Migration.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const MigrationStatus: core.schemas.Schema<MigrationStatus.Raw, TraceApi.MigrationStatus> = core.schemas
  .string()
  .transform<TraceApi.MigrationStatus>({
    parse: (value) => TraceApi.MigrationStatus._parse(value),
    json: ({ value }) => value,
  });

export declare namespace MigrationStatus {
  type Raw = string;
}
",
                    "name": "MigrationStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./MigrationStatus\\";
export * from \\"./Migration\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "migration",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const Error: core.schemas.Schema<Error.Raw, TraceApi.playlist.getPlaylist.Error> = core.schemas
  .union(\\"errorName\\", {
    PlaylistIdNotFoundError: core.schemas.object({
      content: core.schemas.lazy(() => serializers.PlaylistIdNotFoundError),
    }),
    UnauthorizedError: core.schemas.object({}),
  })
  .transform<TraceApi.playlist.getPlaylist.Error>({
    parse: (value) => {
      switch (value.errorName) {
        case \\"PlaylistIdNotFoundError\\":
          return TraceApi.playlist.getPlaylist.Error.playlistIdNotFoundError(value.content);
        case \\"UnauthorizedError\\":
          return TraceApi.playlist.getPlaylist.Error.unauthorizedError();
      }
    },
    json: (value) => value as any,
  });

export declare namespace Error {
  type Raw = Error.PlaylistIdNotFoundError | Error.UnauthorizedError;

  interface PlaylistIdNotFoundError {
    errorName: \\"PlaylistIdNotFoundError\\";
    content: serializers.PlaylistIdNotFoundError.Raw;
  }

  interface UnauthorizedError {
    errorName: \\"UnauthorizedError\\";
  }
}
",
                    "name": "getPlaylist.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<serializers.Playlist.Raw[], TraceApi.Playlist[]> = core.schemas.list(
  core.schemas.lazyObject(() => serializers.Playlist)
);
",
                    "name": "getPlaylists.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getPlaylists from \\"./getPlaylists\\";
export * as getPlaylist from \\"./getPlaylist\\";
export * as updatePlaylist from \\"./updatePlaylist\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Request: core.schemas.Schema<
  serializers.UpdatePlaylistRequest.Raw | null | undefined,
  TraceApi.UpdatePlaylistRequest | undefined
> = core.schemas.lazyObject(() => serializers.UpdatePlaylistRequest).optional();
export const Response: core.schemas.Schema<serializers.Playlist.Raw | null | undefined, TraceApi.Playlist | undefined> =
  core.schemas.lazyObject(() => serializers.Playlist).optional();
export const Error: core.schemas.Schema<Error.Raw, TraceApi.playlist.updatePlaylist.Error> = core.schemas
  .union(\\"errorName\\", {
    PlaylistIdNotFoundError: core.schemas.object({
      content: core.schemas.lazy(() => serializers.PlaylistIdNotFoundError),
    }),
  })
  .transform<TraceApi.playlist.updatePlaylist.Error>({
    parse: (value) => {
      switch (value.errorName) {
        case \\"PlaylistIdNotFoundError\\":
          return TraceApi.playlist.updatePlaylist.Error.playlistIdNotFoundError(value.content);
      }
    },
    json: (value) => value as any,
  });

export declare namespace Error {
  type Raw = Error.PlaylistIdNotFoundError;

  interface PlaylistIdNotFoundError {
    errorName: \\"PlaylistIdNotFoundError\\";
    content: serializers.PlaylistIdNotFoundError.Raw;
  }
}
",
                    "name": "updatePlaylist.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const PlaylistIdNotFoundError: core.schemas.Schema<
  PlaylistIdNotFoundError.Raw,
  TraceApi.PlaylistIdNotFoundError
> = core.schemas.lazy(() => serializers.PlaylistIdNotFoundErrorBody);

export declare namespace PlaylistIdNotFoundError {
  type Raw = serializers.PlaylistIdNotFoundErrorBody.Raw;
}
",
                    "name": "PlaylistIdNotFoundError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./PlaylistIdNotFoundError\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "errors",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./errors\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const Playlist: core.schemas.ObjectSchema<Playlist.Raw, TraceApi.Playlist> = core.schemas
  .object({
    playlistId: core.schemas.property(
      \\"playlist_id\\",
      core.schemas.lazy(() => serializers.PlaylistId)
    ),
    ownerId: core.schemas.property(
      \\"owner-id\\",
      core.schemas.lazy(() => serializers.UserId)
    ),
  })
  .extend(core.schemas.lazyObject(() => serializers.PlaylistCreateRequest));

export declare namespace Playlist {
  interface Raw extends serializers.PlaylistCreateRequest.Raw {
    playlist_id: serializers.PlaylistId.Raw;
    \\"owner-id\\": serializers.UserId.Raw;
  }
}
",
                    "name": "Playlist.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const PlaylistCreateRequest: core.schemas.ObjectSchema<
  PlaylistCreateRequest.Raw,
  TraceApi.PlaylistCreateRequest
> = core.schemas.object({
  name: core.schemas.string(),
  problems: core.schemas.list(core.schemas.lazy(() => serializers.ProblemId)),
});

export declare namespace PlaylistCreateRequest {
  interface Raw {
    name: string;
    problems: serializers.ProblemId.Raw[];
  }
}
",
                    "name": "PlaylistCreateRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const PlaylistId: core.schemas.Schema<PlaylistId.Raw, TraceApi.PlaylistId> = core.schemas.string().transform({
  parse: TraceApi.PlaylistId.create,
  json: (value) => value,
});

export declare namespace PlaylistId {
  type Raw = string;
}
",
                    "name": "PlaylistId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const PlaylistIdNotFoundErrorBody: core.schemas.Schema<
  PlaylistIdNotFoundErrorBody.Raw,
  TraceApi.PlaylistIdNotFoundErrorBody
> = core.schemas
  .union(\\"type\\", {
    playlistId: core.schemas.object({
      value: core.schemas.lazy(() => serializers.PlaylistId),
    }),
  })
  .transform<TraceApi.PlaylistIdNotFoundErrorBody>({
    parse: (value) => {
      switch (value.type) {
        case \\"playlistId\\":
          return TraceApi.PlaylistIdNotFoundErrorBody.playlistId(value.value);
        default:
          return core.addNonEnumerableProperty(value, \\"_visit\\", function <
            _Result
          >(this: TraceApi.PlaylistIdNotFoundErrorBody, visitor: TraceApi.PlaylistIdNotFoundErrorBody._Visitor<_Result>) {
            return visitor._other(value);
          });
      }
    },
    json: (value) => value as any,
  });

export declare namespace PlaylistIdNotFoundErrorBody {
  type Raw = PlaylistIdNotFoundErrorBody.PlaylistId;

  interface PlaylistId {
    type: \\"playlistId\\";
    value: serializers.PlaylistId.Raw;
  }
}
",
                    "name": "PlaylistIdNotFoundErrorBody.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const ReservedKeywordEnum: core.schemas.Schema<ReservedKeywordEnum.Raw, TraceApi.ReservedKeywordEnum> =
  core.schemas.string().transform<TraceApi.ReservedKeywordEnum>({
    parse: (value) => TraceApi.ReservedKeywordEnum._parse(value),
    json: ({ value }) => value,
  });

export declare namespace ReservedKeywordEnum {
  type Raw = string;
}
",
                    "name": "ReservedKeywordEnum.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const UpdatePlaylistRequest: core.schemas.ObjectSchema<
  UpdatePlaylistRequest.Raw,
  TraceApi.UpdatePlaylistRequest
> = core.schemas.object({
  name: core.schemas.string(),
  problems: core.schemas.list(core.schemas.lazy(() => serializers.ProblemId)),
});

export declare namespace UpdatePlaylistRequest {
  interface Raw {
    name: string;
    problems: serializers.ProblemId.Raw[];
  }
}
",
                    "name": "UpdatePlaylistRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./PlaylistId\\";
export * from \\"./Playlist\\";
export * from \\"./PlaylistCreateRequest\\";
export * from \\"./UpdatePlaylistRequest\\";
export * from \\"./PlaylistIdNotFoundErrorBody\\";
export * from \\"./ReservedKeywordEnum\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "playlist",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./types\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const CreateProblemError: core.schemas.Schema<CreateProblemError.Raw, TraceApi.CreateProblemError> = core.schemas
  .union(core.schemas.discriminant(\\"errorType\\", \\"_type\\"), {
    generic: core.schemas.lazyObject(() => serializers.GenericCreateProblemError),
  })
  .transform<TraceApi.CreateProblemError>({
    parse: (value) => {
      switch (value.errorType) {
        case \\"generic\\":
          return TraceApi.CreateProblemError.generic(value);
        default:
          return core.addNonEnumerableProperty(value, \\"_visit\\", function <
            _Result
          >(this: TraceApi.CreateProblemError, visitor: TraceApi.CreateProblemError._Visitor<_Result>) {
            return visitor._other(value);
          });
      }
    },
    json: (value) => value as any,
  });

export declare namespace CreateProblemError {
  type Raw = CreateProblemError.Generic;

  interface Generic extends serializers.GenericCreateProblemError.Raw {
    _type: \\"generic\\";
  }
}
",
                    "name": "CreateProblemError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const CreateProblemRequest: core.schemas.ObjectSchema<CreateProblemRequest.Raw, TraceApi.CreateProblemRequest> =
  core.schemas.object({
    problemName: core.schemas.string(),
    problemDescription: core.schemas.lazyObject(() => serializers.ProblemDescription),
    files: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(() => serializers.ProblemFiles)
    ),
    inputParams: core.schemas.list(core.schemas.lazyObject(() => serializers.VariableTypeAndName)),
    outputType: core.schemas.lazy(() => serializers.VariableType),
    testcases: core.schemas.list(core.schemas.lazyObject(() => serializers.TestCaseWithExpectedResult)),
    methodName: core.schemas.string(),
  });

export declare namespace CreateProblemRequest {
  interface Raw {
    problemName: string;
    problemDescription: serializers.ProblemDescription.Raw;
    files: Record<serializers.Language.Raw, serializers.ProblemFiles.Raw>;
    inputParams: serializers.VariableTypeAndName.Raw[];
    outputType: serializers.VariableType.Raw;
    testcases: serializers.TestCaseWithExpectedResult.Raw[];
    methodName: string;
  }
}
",
                    "name": "CreateProblemRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const CreateProblemResponse: core.schemas.Schema<CreateProblemResponse.Raw, TraceApi.CreateProblemResponse> =
  core.schemas
    .union(\\"type\\", {
      success: core.schemas.object({
        value: core.schemas.lazy(() => serializers.ProblemId),
      }),
      error: core.schemas.object({
        value: core.schemas.lazy(() => serializers.CreateProblemError),
      }),
    })
    .transform<TraceApi.CreateProblemResponse>({
      parse: (value) => {
        switch (value.type) {
          case \\"success\\":
            return TraceApi.CreateProblemResponse.success(value.value);
          case \\"error\\":
            return TraceApi.CreateProblemResponse.error(value.value);
          default:
            return core.addNonEnumerableProperty(value, \\"_visit\\", function <
              _Result
            >(this: TraceApi.CreateProblemResponse, visitor: TraceApi.CreateProblemResponse._Visitor<_Result>) {
              return visitor._other(value);
            });
        }
      },
      json: (value) => value as any,
    });

export declare namespace CreateProblemResponse {
  type Raw = CreateProblemResponse.Success | CreateProblemResponse.Error;

  interface Success {
    type: \\"success\\";
    value: serializers.ProblemId.Raw;
  }

  interface Error {
    type: \\"error\\";
    value: serializers.CreateProblemError.Raw;
  }
}
",
                    "name": "CreateProblemResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const GenericCreateProblemError: core.schemas.ObjectSchema<
  GenericCreateProblemError.Raw,
  TraceApi.GenericCreateProblemError
> = core.schemas.object({
  message: core.schemas.string(),
  type: core.schemas.string(),
  stacktrace: core.schemas.string(),
});

export declare namespace GenericCreateProblemError {
  interface Raw {
    message: string;
    type: string;
    stacktrace: string;
  }
}
",
                    "name": "GenericCreateProblemError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const GetDefaultStarterFilesRequest: core.schemas.ObjectSchema<
  GetDefaultStarterFilesRequest.Raw,
  TraceApi.GetDefaultStarterFilesRequest
> = core.schemas.object({
  inputParams: core.schemas.list(core.schemas.lazyObject(() => serializers.VariableTypeAndName)),
  outputType: core.schemas.lazy(() => serializers.VariableType),
  methodName: core.schemas.string(),
});

export declare namespace GetDefaultStarterFilesRequest {
  interface Raw {
    inputParams: serializers.VariableTypeAndName.Raw[];
    outputType: serializers.VariableType.Raw;
    methodName: string;
  }
}
",
                    "name": "GetDefaultStarterFilesRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const GetDefaultStarterFilesResponse: core.schemas.ObjectSchema<
  GetDefaultStarterFilesResponse.Raw,
  TraceApi.GetDefaultStarterFilesResponse
> = core.schemas.object({
  files: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => serializers.ProblemFiles)
  ),
});

export declare namespace GetDefaultStarterFilesResponse {
  interface Raw {
    files: Record<serializers.Language.Raw, serializers.ProblemFiles.Raw>;
  }
}
",
                    "name": "GetDefaultStarterFilesResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const ProblemDescription: core.schemas.ObjectSchema<ProblemDescription.Raw, TraceApi.ProblemDescription> =
  core.schemas.object({
    boards: core.schemas.list(core.schemas.lazy(() => serializers.ProblemDescriptionBoard)),
  });

export declare namespace ProblemDescription {
  interface Raw {
    boards: serializers.ProblemDescriptionBoard.Raw[];
  }
}
",
                    "name": "ProblemDescription.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const ProblemDescriptionBoard: core.schemas.Schema<
  ProblemDescriptionBoard.Raw,
  TraceApi.ProblemDescriptionBoard
> = core.schemas
  .union(\\"type\\", {
    html: core.schemas.object({
      value: core.schemas.string(),
    }),
    variable: core.schemas.object({
      value: core.schemas.lazy(() => serializers.VariableValue),
    }),
    testCaseId: core.schemas.object({
      value: core.schemas.string(),
    }),
  })
  .transform<TraceApi.ProblemDescriptionBoard>({
    parse: (value) => {
      switch (value.type) {
        case \\"html\\":
          return TraceApi.ProblemDescriptionBoard.html(value.value);
        case \\"variable\\":
          return TraceApi.ProblemDescriptionBoard.variable(value.value);
        case \\"testCaseId\\":
          return TraceApi.ProblemDescriptionBoard.testCaseId(value.value);
        default:
          return core.addNonEnumerableProperty(value, \\"_visit\\", function <
            _Result
          >(this: TraceApi.ProblemDescriptionBoard, visitor: TraceApi.ProblemDescriptionBoard._Visitor<_Result>) {
            return visitor._other(value);
          });
      }
    },
    json: (value) => value as any,
  });

export declare namespace ProblemDescriptionBoard {
  type Raw = ProblemDescriptionBoard.Html | ProblemDescriptionBoard.Variable | ProblemDescriptionBoard.TestCaseId;

  interface Html {
    type: \\"html\\";
    value: string;
  }

  interface Variable {
    type: \\"variable\\";
    value: serializers.VariableValue.Raw;
  }

  interface TestCaseId {
    type: \\"testCaseId\\";
    value: string;
  }
}
",
                    "name": "ProblemDescriptionBoard.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const ProblemFiles: core.schemas.ObjectSchema<ProblemFiles.Raw, TraceApi.ProblemFiles> = core.schemas.object({
  solutionFile: core.schemas.lazyObject(() => serializers.FileInfo),
  readOnlyFiles: core.schemas.list(core.schemas.lazyObject(() => serializers.FileInfo)),
});

export declare namespace ProblemFiles {
  interface Raw {
    solutionFile: serializers.FileInfo.Raw;
    readOnlyFiles: serializers.FileInfo.Raw[];
  }
}
",
                    "name": "ProblemFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const ProblemInfo: core.schemas.ObjectSchema<ProblemInfo.Raw, TraceApi.ProblemInfo> = core.schemas.object({
  problemId: core.schemas.lazy(() => serializers.ProblemId),
  problemDescription: core.schemas.lazyObject(() => serializers.ProblemDescription),
  problemName: core.schemas.string(),
  problemVersion: core.schemas.number(),
  files: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => serializers.ProblemFiles)
  ),
  inputParams: core.schemas.list(core.schemas.lazyObject(() => serializers.VariableTypeAndName)),
  outputType: core.schemas.lazy(() => serializers.VariableType),
  testcases: core.schemas.list(core.schemas.lazyObject(() => serializers.TestCaseWithExpectedResult)),
  methodName: core.schemas.string(),
  supportsCustomTestCases: core.schemas.boolean(),
});

export declare namespace ProblemInfo {
  interface Raw {
    problemId: serializers.ProblemId.Raw;
    problemDescription: serializers.ProblemDescription.Raw;
    problemName: string;
    problemVersion: number;
    files: Record<serializers.Language.Raw, serializers.ProblemFiles.Raw>;
    inputParams: serializers.VariableTypeAndName.Raw[];
    outputType: serializers.VariableType.Raw;
    testcases: serializers.TestCaseWithExpectedResult.Raw[];
    methodName: string;
    supportsCustomTestCases: boolean;
  }
}
",
                    "name": "ProblemInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const ProblemsMap: core.schemas.ObjectSchema<ProblemsMap.Raw, TraceApi.ProblemsMap> = core.schemas.object({
  problemsById: core.schemas.record(
    core.schemas.lazy(() => serializers.ProblemId),
    core.schemas.lazyObject(() => serializers.ProblemInfo)
  ),
});

export declare namespace ProblemsMap {
  interface Raw {
    problemsById: Record<serializers.ProblemId.Raw, serializers.ProblemInfo.Raw>;
  }
}
",
                    "name": "ProblemsMap.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const UpdateProblemResponse: core.schemas.ObjectSchema<
  UpdateProblemResponse.Raw,
  TraceApi.UpdateProblemResponse
> = core.schemas.object({
  problemVersion: core.schemas.number(),
});

export declare namespace UpdateProblemResponse {
  interface Raw {
    problemVersion: number;
  }
}
",
                    "name": "UpdateProblemResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const VariableTypeAndName: core.schemas.ObjectSchema<VariableTypeAndName.Raw, TraceApi.VariableTypeAndName> =
  core.schemas.object({
    variableType: core.schemas.lazy(() => serializers.VariableType),
    name: core.schemas.string(),
  });

export declare namespace VariableTypeAndName {
  interface Raw {
    variableType: serializers.VariableType.Raw;
    name: string;
  }
}
",
                    "name": "VariableTypeAndName.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./ProblemInfo\\";
export * from \\"./ProblemsMap\\";
export * from \\"./ProblemDescription\\";
export * from \\"./ProblemDescriptionBoard\\";
export * from \\"./ProblemFiles\\";
export * from \\"./VariableTypeAndName\\";
export * from \\"./CreateProblemRequest\\";
export * from \\"./CreateProblemResponse\\";
export * from \\"./UpdateProblemResponse\\";
export * from \\"./CreateProblemError\\";
export * from \\"./GenericCreateProblemError\\";
export * from \\"./GetDefaultStarterFilesRequest\\";
export * from \\"./GetDefaultStarterFilesResponse\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "problem",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  serializers.ExecutionSessionResponse.Raw | null | undefined,
  TraceApi.ExecutionSessionResponse | undefined
> = core.schemas.lazyObject(() => serializers.ExecutionSessionResponse).optional();
",
                    "name": "getExecutionSession.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getExecutionSession from \\"./getExecutionSession\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const ActualResult: core.schemas.Schema<ActualResult.Raw, TraceApi.ActualResult> = core.schemas
  .union(\\"type\\", {
    value: core.schemas.object({
      value: core.schemas.lazy(() => serializers.VariableValue),
    }),
    exception: core.schemas.lazyObject(() => serializers.ExceptionInfo),
    exceptionV2: core.schemas.object({
      value: core.schemas.lazy(() => serializers.ExceptionV2),
    }),
  })
  .transform<TraceApi.ActualResult>({
    parse: (value) => {
      switch (value.type) {
        case \\"value\\":
          return TraceApi.ActualResult.value(value.value);
        case \\"exception\\":
          return TraceApi.ActualResult.exception(value);
        case \\"exceptionV2\\":
          return TraceApi.ActualResult.exceptionV2(value.value);
        default:
          return core.addNonEnumerableProperty(value, \\"_visit\\", function <
            _Result
          >(this: TraceApi.ActualResult, visitor: TraceApi.ActualResult._Visitor<_Result>) {
            return visitor._other(value);
          });
      }
    },
    json: (value) => value as any,
  });

export declare namespace ActualResult {
  type Raw = ActualResult.Value | ActualResult.Exception | ActualResult.ExceptionV2;

  interface Value {
    type: \\"value\\";
    value: serializers.VariableValue.Raw;
  }

  interface Exception extends serializers.ExceptionInfo.Raw {
    type: \\"exception\\";
  }

  interface ExceptionV2 {
    type: \\"exceptionV2\\";
    value: serializers.ExceptionV2.Raw;
  }
}
",
                    "name": "ActualResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const BuildingExecutorResponse: core.schemas.ObjectSchema<
  BuildingExecutorResponse.Raw,
  TraceApi.BuildingExecutorResponse
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => serializers.SubmissionId),
  status: core.schemas.lazy(() => serializers.ExecutionSessionStatus),
});

export declare namespace BuildingExecutorResponse {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
    status: serializers.ExecutionSessionStatus.Raw;
  }
}
",
                    "name": "BuildingExecutorResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const CodeExecutionUpdate: core.schemas.Schema<CodeExecutionUpdate.Raw, TraceApi.CodeExecutionUpdate> =
  core.schemas
    .union(\\"type\\", {
      buildingExecutor: core.schemas.lazyObject(() => serializers.BuildingExecutorResponse),
      running: core.schemas.lazyObject(() => serializers.RunningResponse),
      errored: core.schemas.lazyObject(() => serializers.ErroredResponse),
      stopped: core.schemas.lazyObject(() => serializers.StoppedResponse),
      graded: core.schemas.lazyObject(() => serializers.GradedResponse),
      gradedV2: core.schemas.lazyObject(() => serializers.GradedResponseV2),
      workspaceRan: core.schemas.lazyObject(() => serializers.WorkspaceRanResponse),
      recording: core.schemas.lazyObject(() => serializers.RecordingResponseNotification),
      recorded: core.schemas.lazyObject(() => serializers.RecordedResponseNotification),
      invalidRequest: core.schemas.lazyObject(() => serializers.InvalidRequestResponse),
      finished: core.schemas.lazyObject(() => serializers.FinishedResponse),
    })
    .transform<TraceApi.CodeExecutionUpdate>({
      parse: (value) => {
        switch (value.type) {
          case \\"buildingExecutor\\":
            return TraceApi.CodeExecutionUpdate.buildingExecutor(value);
          case \\"running\\":
            return TraceApi.CodeExecutionUpdate.running(value);
          case \\"errored\\":
            return TraceApi.CodeExecutionUpdate.errored(value);
          case \\"stopped\\":
            return TraceApi.CodeExecutionUpdate.stopped(value);
          case \\"graded\\":
            return TraceApi.CodeExecutionUpdate.graded(value);
          case \\"gradedV2\\":
            return TraceApi.CodeExecutionUpdate.gradedV2(value);
          case \\"workspaceRan\\":
            return TraceApi.CodeExecutionUpdate.workspaceRan(value);
          case \\"recording\\":
            return TraceApi.CodeExecutionUpdate.recording(value);
          case \\"recorded\\":
            return TraceApi.CodeExecutionUpdate.recorded(value);
          case \\"invalidRequest\\":
            return TraceApi.CodeExecutionUpdate.invalidRequest(value);
          case \\"finished\\":
            return TraceApi.CodeExecutionUpdate.finished(value);
          default:
            return core.addNonEnumerableProperty(value, \\"_visit\\", function <
              _Result
            >(this: TraceApi.CodeExecutionUpdate, visitor: TraceApi.CodeExecutionUpdate._Visitor<_Result>) {
              return visitor._other(value);
            });
        }
      },
      json: (value) => value as any,
    });

export declare namespace CodeExecutionUpdate {
  type Raw =
    | CodeExecutionUpdate.BuildingExecutor
    | CodeExecutionUpdate.Running
    | CodeExecutionUpdate.Errored
    | CodeExecutionUpdate.Stopped
    | CodeExecutionUpdate.Graded
    | CodeExecutionUpdate.GradedV2
    | CodeExecutionUpdate.WorkspaceRan
    | CodeExecutionUpdate.Recording
    | CodeExecutionUpdate.Recorded
    | CodeExecutionUpdate.InvalidRequest
    | CodeExecutionUpdate.Finished;

  interface BuildingExecutor extends serializers.BuildingExecutorResponse.Raw {
    type: \\"buildingExecutor\\";
  }

  interface Running extends serializers.RunningResponse.Raw {
    type: \\"running\\";
  }

  interface Errored extends serializers.ErroredResponse.Raw {
    type: \\"errored\\";
  }

  interface Stopped extends serializers.StoppedResponse.Raw {
    type: \\"stopped\\";
  }

  interface Graded extends serializers.GradedResponse.Raw {
    type: \\"graded\\";
  }

  interface GradedV2 extends serializers.GradedResponseV2.Raw {
    type: \\"gradedV2\\";
  }

  interface WorkspaceRan extends serializers.WorkspaceRanResponse.Raw {
    type: \\"workspaceRan\\";
  }

  interface Recording extends serializers.RecordingResponseNotification.Raw {
    type: \\"recording\\";
  }

  interface Recorded extends serializers.RecordedResponseNotification.Raw {
    type: \\"recorded\\";
  }

  interface InvalidRequest extends serializers.InvalidRequestResponse.Raw {
    type: \\"invalidRequest\\";
  }

  interface Finished extends serializers.FinishedResponse.Raw {
    type: \\"finished\\";
  }
}
",
                    "name": "CodeExecutionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const CompileError: core.schemas.ObjectSchema<CompileError.Raw, TraceApi.CompileError> = core.schemas.object({
  message: core.schemas.string(),
});

export declare namespace CompileError {
  interface Raw {
    message: string;
  }
}
",
                    "name": "CompileError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const CustomTestCasesUnsupported: core.schemas.ObjectSchema<
  CustomTestCasesUnsupported.Raw,
  TraceApi.CustomTestCasesUnsupported
> = core.schemas.object({
  problemId: core.schemas.lazy(() => serializers.ProblemId),
  submissionId: core.schemas.lazy(() => serializers.SubmissionId),
});

export declare namespace CustomTestCasesUnsupported {
  interface Raw {
    problemId: serializers.ProblemId.Raw;
    submissionId: serializers.SubmissionId.Raw;
  }
}
",
                    "name": "CustomTestCasesUnsupported.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const ErrorInfo: core.schemas.Schema<ErrorInfo.Raw, TraceApi.ErrorInfo> = core.schemas
  .union(\\"type\\", {
    compileError: core.schemas.lazyObject(() => serializers.CompileError),
    runtimeError: core.schemas.lazyObject(() => serializers.RuntimeError),
    internalError: core.schemas.lazyObject(() => serializers.InternalError),
  })
  .transform<TraceApi.ErrorInfo>({
    parse: (value) => {
      switch (value.type) {
        case \\"compileError\\":
          return TraceApi.ErrorInfo.compileError(value);
        case \\"runtimeError\\":
          return TraceApi.ErrorInfo.runtimeError(value);
        case \\"internalError\\":
          return TraceApi.ErrorInfo.internalError(value);
        default:
          return core.addNonEnumerableProperty(value, \\"_visit\\", function <
            _Result
          >(this: TraceApi.ErrorInfo, visitor: TraceApi.ErrorInfo._Visitor<_Result>) {
            return visitor._other(value);
          });
      }
    },
    json: (value) => value as any,
  });

export declare namespace ErrorInfo {
  type Raw = ErrorInfo.CompileError | ErrorInfo.RuntimeError | ErrorInfo.InternalError;

  interface CompileError extends serializers.CompileError.Raw {
    type: \\"compileError\\";
  }

  interface RuntimeError extends serializers.RuntimeError.Raw {
    type: \\"runtimeError\\";
  }

  interface InternalError extends serializers.InternalError.Raw {
    type: \\"internalError\\";
  }
}
",
                    "name": "ErrorInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const ErroredResponse: core.schemas.ObjectSchema<ErroredResponse.Raw, TraceApi.ErroredResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => serializers.SubmissionId),
    errorInfo: core.schemas.lazy(() => serializers.ErrorInfo),
  });

export declare namespace ErroredResponse {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
    errorInfo: serializers.ErrorInfo.Raw;
  }
}
",
                    "name": "ErroredResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const ExceptionInfo: core.schemas.ObjectSchema<ExceptionInfo.Raw, TraceApi.ExceptionInfo> = core.schemas.object({
  exceptionType: core.schemas.string(),
  exceptionMessage: core.schemas.string(),
  exceptionStacktrace: core.schemas.string(),
});

export declare namespace ExceptionInfo {
  interface Raw {
    exceptionType: string;
    exceptionMessage: string;
    exceptionStacktrace: string;
  }
}
",
                    "name": "ExceptionInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const ExceptionV2: core.schemas.Schema<ExceptionV2.Raw, TraceApi.ExceptionV2> = core.schemas
  .union(\\"type\\", {
    generic: core.schemas.lazyObject(() => serializers.ExceptionInfo),
    timeout: core.schemas.object({}),
  })
  .transform<TraceApi.ExceptionV2>({
    parse: (value) => {
      switch (value.type) {
        case \\"generic\\":
          return TraceApi.ExceptionV2.generic(value);
        case \\"timeout\\":
          return TraceApi.ExceptionV2.timeout();
        default:
          return core.addNonEnumerableProperty(value, \\"_visit\\", function <
            _Result
          >(this: TraceApi.ExceptionV2, visitor: TraceApi.ExceptionV2._Visitor<_Result>) {
            return visitor._other(value);
          });
      }
    },
    json: (value) => value as any,
  });

export declare namespace ExceptionV2 {
  type Raw = ExceptionV2.Generic | ExceptionV2.Timeout;

  interface Generic extends serializers.ExceptionInfo.Raw {
    type: \\"generic\\";
  }

  interface Timeout {
    type: \\"timeout\\";
  }
}
",
                    "name": "ExceptionV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const ExecutionSessionResponse: core.schemas.ObjectSchema<
  ExecutionSessionResponse.Raw,
  TraceApi.ExecutionSessionResponse
> = core.schemas.object({
  sessionId: core.schemas.string(),
  executionSessionUrl: core.schemas.string().optional(),
  language: core.schemas.lazy(() => serializers.Language),
  status: core.schemas.lazy(() => serializers.ExecutionSessionStatus),
});

export declare namespace ExecutionSessionResponse {
  interface Raw {
    sessionId: string;
    executionSessionUrl?: string | null;
    language: serializers.Language.Raw;
    status: serializers.ExecutionSessionStatus.Raw;
  }
}
",
                    "name": "ExecutionSessionResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const ExecutionSessionState: core.schemas.ObjectSchema<
  ExecutionSessionState.Raw,
  TraceApi.ExecutionSessionState
> = core.schemas.object({
  lastTimeContacted: core.schemas.string().optional(),
  sessionId: core.schemas.string(),
  isWarmInstance: core.schemas.boolean(),
  awsTaskId: core.schemas.string().optional(),
  language: core.schemas.lazy(() => serializers.Language),
  status: core.schemas.lazy(() => serializers.ExecutionSessionStatus),
});

export declare namespace ExecutionSessionState {
  interface Raw {
    lastTimeContacted?: string | null;
    sessionId: string;
    isWarmInstance: boolean;
    awsTaskId?: string | null;
    language: serializers.Language.Raw;
    status: serializers.ExecutionSessionStatus.Raw;
  }
}
",
                    "name": "ExecutionSessionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const ExecutionSessionStatus: core.schemas.Schema<ExecutionSessionStatus.Raw, TraceApi.ExecutionSessionStatus> =
  core.schemas.string().transform<TraceApi.ExecutionSessionStatus>({
    parse: (value) => TraceApi.ExecutionSessionStatus._parse(value),
    json: ({ value }) => value,
  });

export declare namespace ExecutionSessionStatus {
  type Raw = string;
}
",
                    "name": "ExecutionSessionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const ExistingSubmissionExecuting: core.schemas.ObjectSchema<
  ExistingSubmissionExecuting.Raw,
  TraceApi.ExistingSubmissionExecuting
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => serializers.SubmissionId),
});

export declare namespace ExistingSubmissionExecuting {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
  }
}
",
                    "name": "ExistingSubmissionExecuting.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const ExpressionLocation: core.schemas.ObjectSchema<ExpressionLocation.Raw, TraceApi.ExpressionLocation> =
  core.schemas.object({
    start: core.schemas.number(),
    offset: core.schemas.number(),
  });

export declare namespace ExpressionLocation {
  interface Raw {
    start: number;
    offset: number;
  }
}
",
                    "name": "ExpressionLocation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const FinishedResponse: core.schemas.ObjectSchema<FinishedResponse.Raw, TraceApi.FinishedResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => serializers.SubmissionId),
  });

export declare namespace FinishedResponse {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
  }
}
",
                    "name": "FinishedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const GetExecutionSessionStateResponse: core.schemas.ObjectSchema<
  GetExecutionSessionStateResponse.Raw,
  TraceApi.GetExecutionSessionStateResponse
> = core.schemas.object({
  states: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => serializers.ExecutionSessionState)
  ),
  numWarmingInstances: core.schemas.number().optional(),
  warmingSessionIds: core.schemas.list(core.schemas.string()),
});

export declare namespace GetExecutionSessionStateResponse {
  interface Raw {
    states: Record<string, serializers.ExecutionSessionState.Raw>;
    numWarmingInstances?: number | null;
    warmingSessionIds: string[];
  }
}
",
                    "name": "GetExecutionSessionStateResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const GetSubmissionStateResponse: core.schemas.ObjectSchema<
  GetSubmissionStateResponse.Raw,
  TraceApi.GetSubmissionStateResponse
> = core.schemas.object({
  timeSubmitted: core.schemas.date().optional(),
  submission: core.schemas.string(),
  language: core.schemas.lazy(() => serializers.Language),
  submissionTypeState: core.schemas.lazy(() => serializers.SubmissionTypeState),
});

export declare namespace GetSubmissionStateResponse {
  interface Raw {
    timeSubmitted?: string | null;
    submission: string;
    language: serializers.Language.Raw;
    submissionTypeState: serializers.SubmissionTypeState.Raw;
  }
}
",
                    "name": "GetSubmissionStateResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const GetTraceResponsesPageRequest: core.schemas.ObjectSchema<
  GetTraceResponsesPageRequest.Raw,
  TraceApi.GetTraceResponsesPageRequest
> = core.schemas.object({
  offset: core.schemas.number().optional(),
});

export declare namespace GetTraceResponsesPageRequest {
  interface Raw {
    offset?: number | null;
  }
}
",
                    "name": "GetTraceResponsesPageRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const GradedResponse: core.schemas.ObjectSchema<GradedResponse.Raw, TraceApi.GradedResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => serializers.SubmissionId),
    testCases: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(() => serializers.TestCaseResultWithStdout)
    ),
  });

export declare namespace GradedResponse {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
    testCases: Record<string, serializers.TestCaseResultWithStdout.Raw>;
  }
}
",
                    "name": "GradedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const GradedResponseV2: core.schemas.ObjectSchema<GradedResponseV2.Raw, TraceApi.GradedResponseV2> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => serializers.SubmissionId),
    testCases: core.schemas.record(
      core.schemas.lazy(() => serializers.v2.TestCaseId),
      core.schemas.lazy(() => serializers.TestCaseGrade)
    ),
  });

export declare namespace GradedResponseV2 {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
    testCases: Record<serializers.v2.TestCaseId.Raw, serializers.TestCaseGrade.Raw>;
  }
}
",
                    "name": "GradedResponseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const GradedTestCaseUpdate: core.schemas.ObjectSchema<GradedTestCaseUpdate.Raw, TraceApi.GradedTestCaseUpdate> =
  core.schemas.object({
    testCaseId: core.schemas.lazy(() => serializers.v2.TestCaseId),
    grade: core.schemas.lazy(() => serializers.TestCaseGrade),
  });

export declare namespace GradedTestCaseUpdate {
  interface Raw {
    testCaseId: serializers.v2.TestCaseId.Raw;
    grade: serializers.TestCaseGrade.Raw;
  }
}
",
                    "name": "GradedTestCaseUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const InitializeProblemRequest: core.schemas.ObjectSchema<
  InitializeProblemRequest.Raw,
  TraceApi.InitializeProblemRequest
> = core.schemas.object({
  problemId: core.schemas.lazy(() => serializers.ProblemId),
  problemVersion: core.schemas.number().optional(),
});

export declare namespace InitializeProblemRequest {
  interface Raw {
    problemId: serializers.ProblemId.Raw;
    problemVersion?: number | null;
  }
}
",
                    "name": "InitializeProblemRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const InternalError: core.schemas.ObjectSchema<InternalError.Raw, TraceApi.InternalError> = core.schemas.object({
  exceptionInfo: core.schemas.lazyObject(() => serializers.ExceptionInfo),
});

export declare namespace InternalError {
  interface Raw {
    exceptionInfo: serializers.ExceptionInfo.Raw;
  }
}
",
                    "name": "InternalError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const InvalidRequestCause: core.schemas.Schema<InvalidRequestCause.Raw, TraceApi.InvalidRequestCause> =
  core.schemas
    .union(\\"type\\", {
      submissionIdNotFound: core.schemas.lazyObject(() => serializers.SubmissionIdNotFound),
      customTestCasesUnsupported: core.schemas.lazyObject(() => serializers.CustomTestCasesUnsupported),
      unexpectedLanguage: core.schemas.lazyObject(() => serializers.UnexpectedLanguageError),
    })
    .transform<TraceApi.InvalidRequestCause>({
      parse: (value) => {
        switch (value.type) {
          case \\"submissionIdNotFound\\":
            return TraceApi.InvalidRequestCause.submissionIdNotFound(value);
          case \\"customTestCasesUnsupported\\":
            return TraceApi.InvalidRequestCause.customTestCasesUnsupported(value);
          case \\"unexpectedLanguage\\":
            return TraceApi.InvalidRequestCause.unexpectedLanguage(value);
          default:
            return core.addNonEnumerableProperty(value, \\"_visit\\", function <
              _Result
            >(this: TraceApi.InvalidRequestCause, visitor: TraceApi.InvalidRequestCause._Visitor<_Result>) {
              return visitor._other(value);
            });
        }
      },
      json: (value) => value as any,
    });

export declare namespace InvalidRequestCause {
  type Raw =
    | InvalidRequestCause.SubmissionIdNotFound
    | InvalidRequestCause.CustomTestCasesUnsupported
    | InvalidRequestCause.UnexpectedLanguage;

  interface SubmissionIdNotFound extends serializers.SubmissionIdNotFound.Raw {
    type: \\"submissionIdNotFound\\";
  }

  interface CustomTestCasesUnsupported extends serializers.CustomTestCasesUnsupported.Raw {
    type: \\"customTestCasesUnsupported\\";
  }

  interface UnexpectedLanguage extends serializers.UnexpectedLanguageError.Raw {
    type: \\"unexpectedLanguage\\";
  }
}
",
                    "name": "InvalidRequestCause.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const InvalidRequestResponse: core.schemas.ObjectSchema<
  InvalidRequestResponse.Raw,
  TraceApi.InvalidRequestResponse
> = core.schemas.object({
  request: core.schemas.lazy(() => serializers.SubmissionRequest),
  cause: core.schemas.lazy(() => serializers.InvalidRequestCause),
});

export declare namespace InvalidRequestResponse {
  interface Raw {
    request: serializers.SubmissionRequest.Raw;
    cause: serializers.InvalidRequestCause.Raw;
  }
}
",
                    "name": "InvalidRequestResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const LightweightStackframeInformation: core.schemas.ObjectSchema<
  LightweightStackframeInformation.Raw,
  TraceApi.LightweightStackframeInformation
> = core.schemas.object({
  numStackFrames: core.schemas.number(),
  topStackFrameMethodName: core.schemas.string(),
});

export declare namespace LightweightStackframeInformation {
  interface Raw {
    numStackFrames: number;
    topStackFrameMethodName: string;
  }
}
",
                    "name": "LightweightStackframeInformation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const RecordedResponseNotification: core.schemas.ObjectSchema<
  RecordedResponseNotification.Raw,
  TraceApi.RecordedResponseNotification
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => serializers.SubmissionId),
  traceResponsesSize: core.schemas.number(),
  testCaseId: core.schemas.string().optional(),
});

export declare namespace RecordedResponseNotification {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
    traceResponsesSize: number;
    testCaseId?: string | null;
  }
}
",
                    "name": "RecordedResponseNotification.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const RecordedTestCaseUpdate: core.schemas.ObjectSchema<
  RecordedTestCaseUpdate.Raw,
  TraceApi.RecordedTestCaseUpdate
> = core.schemas.object({
  testCaseId: core.schemas.lazy(() => serializers.v2.TestCaseId),
  traceResponsesSize: core.schemas.number(),
});

export declare namespace RecordedTestCaseUpdate {
  interface Raw {
    testCaseId: serializers.v2.TestCaseId.Raw;
    traceResponsesSize: number;
  }
}
",
                    "name": "RecordedTestCaseUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const RecordingResponseNotification: core.schemas.ObjectSchema<
  RecordingResponseNotification.Raw,
  TraceApi.RecordingResponseNotification
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => serializers.SubmissionId),
  testCaseId: core.schemas.string().optional(),
  lineNumber: core.schemas.number(),
  lightweightStackInfo: core.schemas.lazyObject(() => serializers.LightweightStackframeInformation),
  tracedFile: core.schemas.lazyObject(() => serializers.TracedFile).optional(),
});

export declare namespace RecordingResponseNotification {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
    testCaseId?: string | null;
    lineNumber: number;
    lightweightStackInfo: serializers.LightweightStackframeInformation.Raw;
    tracedFile?: serializers.TracedFile.Raw | null;
  }
}
",
                    "name": "RecordingResponseNotification.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const RunningResponse: core.schemas.ObjectSchema<RunningResponse.Raw, TraceApi.RunningResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => serializers.SubmissionId),
    state: core.schemas.lazy(() => serializers.RunningSubmissionState),
  });

export declare namespace RunningResponse {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
    state: serializers.RunningSubmissionState.Raw;
  }
}
",
                    "name": "RunningResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const RunningSubmissionState: core.schemas.Schema<RunningSubmissionState.Raw, TraceApi.RunningSubmissionState> =
  core.schemas.string().transform<TraceApi.RunningSubmissionState>({
    parse: (value) => TraceApi.RunningSubmissionState._parse(value),
    json: ({ value }) => value,
  });

export declare namespace RunningSubmissionState {
  type Raw = string;
}
",
                    "name": "RunningSubmissionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const RuntimeError: core.schemas.ObjectSchema<RuntimeError.Raw, TraceApi.RuntimeError> = core.schemas.object({
  message: core.schemas.string(),
});

export declare namespace RuntimeError {
  interface Raw {
    message: string;
  }
}
",
                    "name": "RuntimeError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const Scope: core.schemas.ObjectSchema<Scope.Raw, TraceApi.Scope> = core.schemas.object({
  variables: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazy(() => serializers.DebugVariableValue)
  ),
});

export declare namespace Scope {
  interface Raw {
    variables: Record<string, serializers.DebugVariableValue.Raw>;
  }
}
",
                    "name": "Scope.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const ShareId: core.schemas.Schema<ShareId.Raw, TraceApi.ShareId> = core.schemas.string().transform({
  parse: TraceApi.ShareId.create,
  json: (value) => value,
});

export declare namespace ShareId {
  type Raw = string;
}
",
                    "name": "ShareId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const StackFrame: core.schemas.ObjectSchema<StackFrame.Raw, TraceApi.StackFrame> = core.schemas.object({
  methodName: core.schemas.string(),
  lineNumber: core.schemas.number(),
  scopes: core.schemas.list(core.schemas.lazyObject(() => serializers.Scope)),
});

export declare namespace StackFrame {
  interface Raw {
    methodName: string;
    lineNumber: number;
    scopes: serializers.Scope.Raw[];
  }
}
",
                    "name": "StackFrame.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const StackInformation: core.schemas.ObjectSchema<StackInformation.Raw, TraceApi.StackInformation> =
  core.schemas.object({
    numStackFrames: core.schemas.number(),
    topStackFrame: core.schemas.lazyObject(() => serializers.StackFrame).optional(),
  });

export declare namespace StackInformation {
  interface Raw {
    numStackFrames: number;
    topStackFrame?: serializers.StackFrame.Raw | null;
  }
}
",
                    "name": "StackInformation.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const StderrResponse: core.schemas.ObjectSchema<StderrResponse.Raw, TraceApi.StderrResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => serializers.SubmissionId),
    stderr: core.schemas.string(),
  });

export declare namespace StderrResponse {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
    stderr: string;
  }
}
",
                    "name": "StderrResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const StdoutResponse: core.schemas.ObjectSchema<StdoutResponse.Raw, TraceApi.StdoutResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => serializers.SubmissionId),
    stdout: core.schemas.string(),
  });

export declare namespace StdoutResponse {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
    stdout: string;
  }
}
",
                    "name": "StdoutResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const StopRequest: core.schemas.ObjectSchema<StopRequest.Raw, TraceApi.StopRequest> = core.schemas.object({
  submissionId: core.schemas.lazy(() => serializers.SubmissionId),
});

export declare namespace StopRequest {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
  }
}
",
                    "name": "StopRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const StoppedResponse: core.schemas.ObjectSchema<StoppedResponse.Raw, TraceApi.StoppedResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => serializers.SubmissionId),
  });

export declare namespace StoppedResponse {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
  }
}
",
                    "name": "StoppedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const SubmissionFileInfo: core.schemas.ObjectSchema<SubmissionFileInfo.Raw, TraceApi.SubmissionFileInfo> =
  core.schemas.object({
    directory: core.schemas.string(),
    filename: core.schemas.string(),
    contents: core.schemas.string(),
  });

export declare namespace SubmissionFileInfo {
  interface Raw {
    directory: string;
    filename: string;
    contents: string;
  }
}
",
                    "name": "SubmissionFileInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const SubmissionId: core.schemas.Schema<SubmissionId.Raw, TraceApi.SubmissionId> = core.schemas
  .string()
  .transform({
    parse: TraceApi.SubmissionId.create,
    json: (value) => value,
  });

export declare namespace SubmissionId {
  type Raw = string;
}
",
                    "name": "SubmissionId.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const SubmissionIdNotFound: core.schemas.ObjectSchema<SubmissionIdNotFound.Raw, TraceApi.SubmissionIdNotFound> =
  core.schemas.object({
    missingSubmissionId: core.schemas.lazy(() => serializers.SubmissionId),
  });

export declare namespace SubmissionIdNotFound {
  interface Raw {
    missingSubmissionId: serializers.SubmissionId.Raw;
  }
}
",
                    "name": "SubmissionIdNotFound.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const SubmissionRequest: core.schemas.Schema<SubmissionRequest.Raw, TraceApi.SubmissionRequest> = core.schemas
  .union(\\"type\\", {
    initializeProblemRequest: core.schemas.lazyObject(() => serializers.InitializeProblemRequest),
    initializeWorkspaceRequest: core.schemas.object({}),
    submitV2: core.schemas.lazyObject(() => serializers.SubmitRequestV2),
    workspaceSubmit: core.schemas.lazyObject(() => serializers.WorkspaceSubmitRequest),
    stop: core.schemas.lazyObject(() => serializers.StopRequest),
  })
  .transform<TraceApi.SubmissionRequest>({
    parse: (value) => {
      switch (value.type) {
        case \\"initializeProblemRequest\\":
          return TraceApi.SubmissionRequest.initializeProblemRequest(value);
        case \\"initializeWorkspaceRequest\\":
          return TraceApi.SubmissionRequest.initializeWorkspaceRequest();
        case \\"submitV2\\":
          return TraceApi.SubmissionRequest.submitV2(value);
        case \\"workspaceSubmit\\":
          return TraceApi.SubmissionRequest.workspaceSubmit(value);
        case \\"stop\\":
          return TraceApi.SubmissionRequest.stop(value);
        default:
          return core.addNonEnumerableProperty(value, \\"_visit\\", function <
            _Result
          >(this: TraceApi.SubmissionRequest, visitor: TraceApi.SubmissionRequest._Visitor<_Result>) {
            return visitor._other(value);
          });
      }
    },
    json: (value) => value as any,
  });

export declare namespace SubmissionRequest {
  type Raw =
    | SubmissionRequest.InitializeProblemRequest
    | SubmissionRequest.InitializeWorkspaceRequest
    | SubmissionRequest.SubmitV2
    | SubmissionRequest.WorkspaceSubmit
    | SubmissionRequest.Stop;

  interface InitializeProblemRequest extends serializers.InitializeProblemRequest.Raw {
    type: \\"initializeProblemRequest\\";
  }

  interface InitializeWorkspaceRequest {
    type: \\"initializeWorkspaceRequest\\";
  }

  interface SubmitV2 extends serializers.SubmitRequestV2.Raw {
    type: \\"submitV2\\";
  }

  interface WorkspaceSubmit extends serializers.WorkspaceSubmitRequest.Raw {
    type: \\"workspaceSubmit\\";
  }

  interface Stop extends serializers.StopRequest.Raw {
    type: \\"stop\\";
  }
}
",
                    "name": "SubmissionRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const SubmissionResponse: core.schemas.Schema<SubmissionResponse.Raw, TraceApi.SubmissionResponse> = core.schemas
  .union(\\"type\\", {
    serverInitialized: core.schemas.object({}),
    problemInitialized: core.schemas.object({
      value: core.schemas.lazy(() => serializers.ProblemId),
    }),
    workspaceInitialized: core.schemas.object({}),
    serverErrored: core.schemas.lazyObject(() => serializers.ExceptionInfo),
    codeExecutionUpdate: core.schemas.object({
      value: core.schemas.lazy(() => serializers.CodeExecutionUpdate),
    }),
    terminated: core.schemas.lazyObject(() => serializers.TerminatedResponse),
  })
  .transform<TraceApi.SubmissionResponse>({
    parse: (value) => {
      switch (value.type) {
        case \\"serverInitialized\\":
          return TraceApi.SubmissionResponse.serverInitialized();
        case \\"problemInitialized\\":
          return TraceApi.SubmissionResponse.problemInitialized(value.value);
        case \\"workspaceInitialized\\":
          return TraceApi.SubmissionResponse.workspaceInitialized();
        case \\"serverErrored\\":
          return TraceApi.SubmissionResponse.serverErrored(value);
        case \\"codeExecutionUpdate\\":
          return TraceApi.SubmissionResponse.codeExecutionUpdate(value.value);
        case \\"terminated\\":
          return TraceApi.SubmissionResponse.terminated(value);
        default:
          return core.addNonEnumerableProperty(value, \\"_visit\\", function <
            _Result
          >(this: TraceApi.SubmissionResponse, visitor: TraceApi.SubmissionResponse._Visitor<_Result>) {
            return visitor._other(value);
          });
      }
    },
    json: (value) => value as any,
  });

export declare namespace SubmissionResponse {
  type Raw =
    | SubmissionResponse.ServerInitialized
    | SubmissionResponse.ProblemInitialized
    | SubmissionResponse.WorkspaceInitialized
    | SubmissionResponse.ServerErrored
    | SubmissionResponse.CodeExecutionUpdate
    | SubmissionResponse.Terminated;

  interface ServerInitialized {
    type: \\"serverInitialized\\";
  }

  interface ProblemInitialized {
    type: \\"problemInitialized\\";
    value: serializers.ProblemId.Raw;
  }

  interface WorkspaceInitialized {
    type: \\"workspaceInitialized\\";
  }

  interface ServerErrored extends serializers.ExceptionInfo.Raw {
    type: \\"serverErrored\\";
  }

  interface CodeExecutionUpdate {
    type: \\"codeExecutionUpdate\\";
    value: serializers.CodeExecutionUpdate.Raw;
  }

  interface Terminated extends serializers.TerminatedResponse.Raw {
    type: \\"terminated\\";
  }
}
",
                    "name": "SubmissionResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const SubmissionStatusForTestCase: core.schemas.Schema<
  SubmissionStatusForTestCase.Raw,
  TraceApi.SubmissionStatusForTestCase
> = core.schemas
  .union(\\"type\\", {
    graded: core.schemas.lazyObject(() => serializers.TestCaseResultWithStdout),
    gradedV2: core.schemas.object({
      value: core.schemas.lazy(() => serializers.TestCaseGrade),
    }),
    traced: core.schemas.lazyObject(() => serializers.TracedTestCase),
  })
  .transform<TraceApi.SubmissionStatusForTestCase>({
    parse: (value) => {
      switch (value.type) {
        case \\"graded\\":
          return TraceApi.SubmissionStatusForTestCase.graded(value);
        case \\"gradedV2\\":
          return TraceApi.SubmissionStatusForTestCase.gradedV2(value.value);
        case \\"traced\\":
          return TraceApi.SubmissionStatusForTestCase.traced(value);
        default:
          return core.addNonEnumerableProperty(value, \\"_visit\\", function <
            _Result
          >(this: TraceApi.SubmissionStatusForTestCase, visitor: TraceApi.SubmissionStatusForTestCase._Visitor<_Result>) {
            return visitor._other(value);
          });
      }
    },
    json: (value) => value as any,
  });

export declare namespace SubmissionStatusForTestCase {
  type Raw =
    | SubmissionStatusForTestCase.Graded
    | SubmissionStatusForTestCase.GradedV2
    | SubmissionStatusForTestCase.Traced;

  interface Graded extends serializers.TestCaseResultWithStdout.Raw {
    type: \\"graded\\";
  }

  interface GradedV2 {
    type: \\"gradedV2\\";
    value: serializers.TestCaseGrade.Raw;
  }

  interface Traced extends serializers.TracedTestCase.Raw {
    type: \\"traced\\";
  }
}
",
                    "name": "SubmissionStatusForTestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const SubmissionStatusV2: core.schemas.Schema<SubmissionStatusV2.Raw, TraceApi.SubmissionStatusV2> = core.schemas
  .union(\\"type\\", {
    test: core.schemas.lazyObject(() => serializers.TestSubmissionStatusV2),
    workspace: core.schemas.lazyObject(() => serializers.WorkspaceSubmissionStatusV2),
  })
  .transform<TraceApi.SubmissionStatusV2>({
    parse: (value) => {
      switch (value.type) {
        case \\"test\\":
          return TraceApi.SubmissionStatusV2.test(value);
        case \\"workspace\\":
          return TraceApi.SubmissionStatusV2.workspace(value);
        default:
          return core.addNonEnumerableProperty(value, \\"_visit\\", function <
            _Result
          >(this: TraceApi.SubmissionStatusV2, visitor: TraceApi.SubmissionStatusV2._Visitor<_Result>) {
            return visitor._other(value);
          });
      }
    },
    json: (value) => value as any,
  });

export declare namespace SubmissionStatusV2 {
  type Raw = SubmissionStatusV2.Test | SubmissionStatusV2.Workspace;

  interface Test extends serializers.TestSubmissionStatusV2.Raw {
    type: \\"test\\";
  }

  interface Workspace extends serializers.WorkspaceSubmissionStatusV2.Raw {
    type: \\"workspace\\";
  }
}
",
                    "name": "SubmissionStatusV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const SubmissionTypeEnum: core.schemas.Schema<SubmissionTypeEnum.Raw, TraceApi.SubmissionTypeEnum> = core.schemas
  .string()
  .transform<TraceApi.SubmissionTypeEnum>({
    parse: (value) => TraceApi.SubmissionTypeEnum._parse(value),
    json: ({ value }) => value,
  });

export declare namespace SubmissionTypeEnum {
  type Raw = string;
}
",
                    "name": "SubmissionTypeEnum.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const SubmissionTypeState: core.schemas.Schema<SubmissionTypeState.Raw, TraceApi.SubmissionTypeState> =
  core.schemas
    .union(\\"type\\", {
      test: core.schemas.lazyObject(() => serializers.TestSubmissionState),
      workspace: core.schemas.lazyObject(() => serializers.WorkspaceSubmissionState),
    })
    .transform<TraceApi.SubmissionTypeState>({
      parse: (value) => {
        switch (value.type) {
          case \\"test\\":
            return TraceApi.SubmissionTypeState.test(value);
          case \\"workspace\\":
            return TraceApi.SubmissionTypeState.workspace(value);
          default:
            return core.addNonEnumerableProperty(value, \\"_visit\\", function <
              _Result
            >(this: TraceApi.SubmissionTypeState, visitor: TraceApi.SubmissionTypeState._Visitor<_Result>) {
              return visitor._other(value);
            });
        }
      },
      json: (value) => value as any,
    });

export declare namespace SubmissionTypeState {
  type Raw = SubmissionTypeState.Test | SubmissionTypeState.Workspace;

  interface Test extends serializers.TestSubmissionState.Raw {
    type: \\"test\\";
  }

  interface Workspace extends serializers.WorkspaceSubmissionState.Raw {
    type: \\"workspace\\";
  }
}
",
                    "name": "SubmissionTypeState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const SubmitRequestV2: core.schemas.ObjectSchema<SubmitRequestV2.Raw, TraceApi.SubmitRequestV2> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => serializers.SubmissionId),
    language: core.schemas.lazy(() => serializers.Language),
    submissionFiles: core.schemas.list(core.schemas.lazyObject(() => serializers.SubmissionFileInfo)),
    problemId: core.schemas.lazy(() => serializers.ProblemId),
    problemVersion: core.schemas.number().optional(),
    userId: core.schemas.string().optional(),
  });

export declare namespace SubmitRequestV2 {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
    language: serializers.Language.Raw;
    submissionFiles: serializers.SubmissionFileInfo.Raw[];
    problemId: serializers.ProblemId.Raw;
    problemVersion?: number | null;
    userId?: string | null;
  }
}
",
                    "name": "SubmitRequestV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const TerminatedResponse: core.schemas.ObjectSchema<TerminatedResponse.Raw, TraceApi.TerminatedResponse> =
  core.schemas.object({});

export declare namespace TerminatedResponse {
  interface Raw {}
}
",
                    "name": "TerminatedResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TestCaseGrade: core.schemas.Schema<TestCaseGrade.Raw, TraceApi.TestCaseGrade> = core.schemas
  .union(\\"type\\", {
    hidden: core.schemas.lazyObject(() => serializers.TestCaseHiddenGrade),
    nonHidden: core.schemas.lazyObject(() => serializers.TestCaseNonHiddenGrade),
  })
  .transform<TraceApi.TestCaseGrade>({
    parse: (value) => {
      switch (value.type) {
        case \\"hidden\\":
          return TraceApi.TestCaseGrade.hidden(value);
        case \\"nonHidden\\":
          return TraceApi.TestCaseGrade.nonHidden(value);
        default:
          return core.addNonEnumerableProperty(value, \\"_visit\\", function <
            _Result
          >(this: TraceApi.TestCaseGrade, visitor: TraceApi.TestCaseGrade._Visitor<_Result>) {
            return visitor._other(value);
          });
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestCaseGrade {
  type Raw = TestCaseGrade.Hidden | TestCaseGrade.NonHidden;

  interface Hidden extends serializers.TestCaseHiddenGrade.Raw {
    type: \\"hidden\\";
  }

  interface NonHidden extends serializers.TestCaseNonHiddenGrade.Raw {
    type: \\"nonHidden\\";
  }
}
",
                    "name": "TestCaseGrade.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const TestCaseHiddenGrade: core.schemas.ObjectSchema<TestCaseHiddenGrade.Raw, TraceApi.TestCaseHiddenGrade> =
  core.schemas.object({
    passed: core.schemas.boolean(),
  });

export declare namespace TestCaseHiddenGrade {
  interface Raw {
    passed: boolean;
  }
}
",
                    "name": "TestCaseHiddenGrade.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TestCaseNonHiddenGrade: core.schemas.ObjectSchema<
  TestCaseNonHiddenGrade.Raw,
  TraceApi.TestCaseNonHiddenGrade
> = core.schemas.object({
  passed: core.schemas.boolean(),
  actualResult: core.schemas.lazy(() => serializers.VariableValue).optional(),
  exception: core.schemas.lazy(() => serializers.ExceptionV2).optional(),
  stdout: core.schemas.string(),
});

export declare namespace TestCaseNonHiddenGrade {
  interface Raw {
    passed: boolean;
    actualResult?: serializers.VariableValue.Raw | null;
    exception?: serializers.ExceptionV2.Raw | null;
    stdout: string;
  }
}
",
                    "name": "TestCaseNonHiddenGrade.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TestCaseResult: core.schemas.ObjectSchema<TestCaseResult.Raw, TraceApi.TestCaseResult> =
  core.schemas.object({
    expectedResult: core.schemas.lazy(() => serializers.VariableValue),
    actualResult: core.schemas.lazy(() => serializers.ActualResult),
    passed: core.schemas.boolean(),
  });

export declare namespace TestCaseResult {
  interface Raw {
    expectedResult: serializers.VariableValue.Raw;
    actualResult: serializers.ActualResult.Raw;
    passed: boolean;
  }
}
",
                    "name": "TestCaseResult.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TestCaseResultWithStdout: core.schemas.ObjectSchema<
  TestCaseResultWithStdout.Raw,
  TraceApi.TestCaseResultWithStdout
> = core.schemas.object({
  result: core.schemas.lazyObject(() => serializers.TestCaseResult),
  stdout: core.schemas.string(),
});

export declare namespace TestCaseResultWithStdout {
  interface Raw {
    result: serializers.TestCaseResult.Raw;
    stdout: string;
  }
}
",
                    "name": "TestCaseResultWithStdout.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TestSubmissionState: core.schemas.ObjectSchema<TestSubmissionState.Raw, TraceApi.TestSubmissionState> =
  core.schemas.object({
    problemId: core.schemas.lazy(() => serializers.ProblemId),
    defaultTestCases: core.schemas.list(core.schemas.lazyObject(() => serializers.TestCase)),
    customTestCases: core.schemas.list(core.schemas.lazyObject(() => serializers.TestCase)),
    status: core.schemas.lazy(() => serializers.TestSubmissionStatus),
  });

export declare namespace TestSubmissionState {
  interface Raw {
    problemId: serializers.ProblemId.Raw;
    defaultTestCases: serializers.TestCase.Raw[];
    customTestCases: serializers.TestCase.Raw[];
    status: serializers.TestSubmissionStatus.Raw;
  }
}
",
                    "name": "TestSubmissionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TestSubmissionStatus: core.schemas.Schema<TestSubmissionStatus.Raw, TraceApi.TestSubmissionStatus> =
  core.schemas
    .union(\\"type\\", {
      stopped: core.schemas.object({}),
      errored: core.schemas.object({
        value: core.schemas.lazy(() => serializers.ErrorInfo),
      }),
      running: core.schemas.object({
        value: core.schemas.lazy(() => serializers.RunningSubmissionState),
      }),
      testCaseIdToState: core.schemas.object({
        value: core.schemas.record(
          core.schemas.string(),
          core.schemas.lazy(() => serializers.SubmissionStatusForTestCase)
        ),
      }),
    })
    .transform<TraceApi.TestSubmissionStatus>({
      parse: (value) => {
        switch (value.type) {
          case \\"stopped\\":
            return TraceApi.TestSubmissionStatus.stopped();
          case \\"errored\\":
            return TraceApi.TestSubmissionStatus.errored(value.value);
          case \\"running\\":
            return TraceApi.TestSubmissionStatus.running(value.value);
          case \\"testCaseIdToState\\":
            return TraceApi.TestSubmissionStatus.testCaseIdToState(value.value);
          default:
            return core.addNonEnumerableProperty(value, \\"_visit\\", function <
              _Result
            >(this: TraceApi.TestSubmissionStatus, visitor: TraceApi.TestSubmissionStatus._Visitor<_Result>) {
              return visitor._other(value);
            });
        }
      },
      json: (value) => value as any,
    });

export declare namespace TestSubmissionStatus {
  type Raw =
    | TestSubmissionStatus.Stopped
    | TestSubmissionStatus.Errored
    | TestSubmissionStatus.Running
    | TestSubmissionStatus.TestCaseIdToState;

  interface Stopped {
    type: \\"stopped\\";
  }

  interface Errored {
    type: \\"errored\\";
    value: serializers.ErrorInfo.Raw;
  }

  interface Running {
    type: \\"running\\";
    value: serializers.RunningSubmissionState.Raw;
  }

  interface TestCaseIdToState {
    type: \\"testCaseIdToState\\";
    value: Record<string, serializers.SubmissionStatusForTestCase.Raw>;
  }
}
",
                    "name": "TestSubmissionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TestSubmissionStatusV2: core.schemas.ObjectSchema<
  TestSubmissionStatusV2.Raw,
  TraceApi.TestSubmissionStatusV2
> = core.schemas.object({
  updates: core.schemas.list(core.schemas.lazyObject(() => serializers.TestSubmissionUpdate)),
  problemId: core.schemas.lazy(() => serializers.ProblemId),
  problemVersion: core.schemas.number(),
  problemInfo: core.schemas.lazyObject(() => serializers.v2.ProblemInfoV2),
});

export declare namespace TestSubmissionStatusV2 {
  interface Raw {
    updates: serializers.TestSubmissionUpdate.Raw[];
    problemId: serializers.ProblemId.Raw;
    problemVersion: number;
    problemInfo: serializers.v2.ProblemInfoV2.Raw;
  }
}
",
                    "name": "TestSubmissionStatusV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TestSubmissionUpdate: core.schemas.ObjectSchema<TestSubmissionUpdate.Raw, TraceApi.TestSubmissionUpdate> =
  core.schemas.object({
    updateTime: core.schemas.date(),
    updateInfo: core.schemas.lazy(() => serializers.TestSubmissionUpdateInfo),
  });

export declare namespace TestSubmissionUpdate {
  interface Raw {
    updateTime: string;
    updateInfo: serializers.TestSubmissionUpdateInfo.Raw;
  }
}
",
                    "name": "TestSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TestSubmissionUpdateInfo: core.schemas.Schema<
  TestSubmissionUpdateInfo.Raw,
  TraceApi.TestSubmissionUpdateInfo
> = core.schemas
  .union(\\"type\\", {
    running: core.schemas.object({
      value: core.schemas.lazy(() => serializers.RunningSubmissionState),
    }),
    stopped: core.schemas.object({}),
    errored: core.schemas.object({
      value: core.schemas.lazy(() => serializers.ErrorInfo),
    }),
    gradedTestCase: core.schemas.lazyObject(() => serializers.GradedTestCaseUpdate),
    recordedTestCase: core.schemas.lazyObject(() => serializers.RecordedTestCaseUpdate),
    finished: core.schemas.object({}),
  })
  .transform<TraceApi.TestSubmissionUpdateInfo>({
    parse: (value) => {
      switch (value.type) {
        case \\"running\\":
          return TraceApi.TestSubmissionUpdateInfo.running(value.value);
        case \\"stopped\\":
          return TraceApi.TestSubmissionUpdateInfo.stopped();
        case \\"errored\\":
          return TraceApi.TestSubmissionUpdateInfo.errored(value.value);
        case \\"gradedTestCase\\":
          return TraceApi.TestSubmissionUpdateInfo.gradedTestCase(value);
        case \\"recordedTestCase\\":
          return TraceApi.TestSubmissionUpdateInfo.recordedTestCase(value);
        case \\"finished\\":
          return TraceApi.TestSubmissionUpdateInfo.finished();
        default:
          return core.addNonEnumerableProperty(value, \\"_visit\\", function <
            _Result
          >(this: TraceApi.TestSubmissionUpdateInfo, visitor: TraceApi.TestSubmissionUpdateInfo._Visitor<_Result>) {
            return visitor._other(value);
          });
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestSubmissionUpdateInfo {
  type Raw =
    | TestSubmissionUpdateInfo.Running
    | TestSubmissionUpdateInfo.Stopped
    | TestSubmissionUpdateInfo.Errored
    | TestSubmissionUpdateInfo.GradedTestCase
    | TestSubmissionUpdateInfo.RecordedTestCase
    | TestSubmissionUpdateInfo.Finished;

  interface Running {
    type: \\"running\\";
    value: serializers.RunningSubmissionState.Raw;
  }

  interface Stopped {
    type: \\"stopped\\";
  }

  interface Errored {
    type: \\"errored\\";
    value: serializers.ErrorInfo.Raw;
  }

  interface GradedTestCase extends serializers.GradedTestCaseUpdate.Raw {
    type: \\"gradedTestCase\\";
  }

  interface RecordedTestCase extends serializers.RecordedTestCaseUpdate.Raw {
    type: \\"recordedTestCase\\";
  }

  interface Finished {
    type: \\"finished\\";
  }
}
",
                    "name": "TestSubmissionUpdateInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TraceResponse: core.schemas.ObjectSchema<TraceResponse.Raw, TraceApi.TraceResponse> = core.schemas.object({
  submissionId: core.schemas.lazy(() => serializers.SubmissionId),
  lineNumber: core.schemas.number(),
  returnValue: core.schemas.lazy(() => serializers.DebugVariableValue).optional(),
  expressionLocation: core.schemas.lazyObject(() => serializers.ExpressionLocation).optional(),
  stack: core.schemas.lazyObject(() => serializers.StackInformation),
  stdout: core.schemas.string().optional(),
});

export declare namespace TraceResponse {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
    lineNumber: number;
    returnValue?: serializers.DebugVariableValue.Raw | null;
    expressionLocation?: serializers.ExpressionLocation.Raw | null;
    stack: serializers.StackInformation.Raw;
    stdout?: string | null;
  }
}
",
                    "name": "TraceResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TraceResponseV2: core.schemas.ObjectSchema<TraceResponseV2.Raw, TraceApi.TraceResponseV2> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => serializers.SubmissionId),
    lineNumber: core.schemas.number(),
    file: core.schemas.lazyObject(() => serializers.TracedFile),
    returnValue: core.schemas.lazy(() => serializers.DebugVariableValue).optional(),
    expressionLocation: core.schemas.lazyObject(() => serializers.ExpressionLocation).optional(),
    stack: core.schemas.lazyObject(() => serializers.StackInformation),
    stdout: core.schemas.string().optional(),
  });

export declare namespace TraceResponseV2 {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
    lineNumber: number;
    file: serializers.TracedFile.Raw;
    returnValue?: serializers.DebugVariableValue.Raw | null;
    expressionLocation?: serializers.ExpressionLocation.Raw | null;
    stack: serializers.StackInformation.Raw;
    stdout?: string | null;
  }
}
",
                    "name": "TraceResponseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TraceResponsesPage: core.schemas.ObjectSchema<TraceResponsesPage.Raw, TraceApi.TraceResponsesPage> =
  core.schemas.object({
    offset: core.schemas.number().optional(),
    traceResponses: core.schemas.list(core.schemas.lazyObject(() => serializers.TraceResponse)),
  });

export declare namespace TraceResponsesPage {
  interface Raw {
    offset?: number | null;
    traceResponses: serializers.TraceResponse.Raw[];
  }
}
",
                    "name": "TraceResponsesPage.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TraceResponsesPageV2: core.schemas.ObjectSchema<TraceResponsesPageV2.Raw, TraceApi.TraceResponsesPageV2> =
  core.schemas.object({
    offset: core.schemas.number().optional(),
    traceResponses: core.schemas.list(core.schemas.lazyObject(() => serializers.TraceResponseV2)),
  });

export declare namespace TraceResponsesPageV2 {
  interface Raw {
    offset?: number | null;
    traceResponses: serializers.TraceResponseV2.Raw[];
  }
}
",
                    "name": "TraceResponsesPageV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const TracedFile: core.schemas.ObjectSchema<TracedFile.Raw, TraceApi.TracedFile> = core.schemas.object({
  filename: core.schemas.string(),
  directory: core.schemas.string(),
});

export declare namespace TracedFile {
  interface Raw {
    filename: string;
    directory: string;
  }
}
",
                    "name": "TracedFile.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const TracedTestCase: core.schemas.ObjectSchema<TracedTestCase.Raw, TraceApi.TracedTestCase> =
  core.schemas.object({
    result: core.schemas.lazyObject(() => serializers.TestCaseResultWithStdout),
    traceResponsesSize: core.schemas.number(),
  });

export declare namespace TracedTestCase {
  interface Raw {
    result: serializers.TestCaseResultWithStdout.Raw;
    traceResponsesSize: number;
  }
}
",
                    "name": "TracedTestCase.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const UnexpectedLanguageError: core.schemas.ObjectSchema<
  UnexpectedLanguageError.Raw,
  TraceApi.UnexpectedLanguageError
> = core.schemas.object({
  expectedLanguage: core.schemas.lazy(() => serializers.Language),
  actualLanguage: core.schemas.lazy(() => serializers.Language),
});

export declare namespace UnexpectedLanguageError {
  interface Raw {
    expectedLanguage: serializers.Language.Raw;
    actualLanguage: serializers.Language.Raw;
  }
}
",
                    "name": "UnexpectedLanguageError.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const WorkspaceFiles: core.schemas.ObjectSchema<WorkspaceFiles.Raw, TraceApi.WorkspaceFiles> =
  core.schemas.object({
    mainFile: core.schemas.lazyObject(() => serializers.FileInfo),
    readOnlyFiles: core.schemas.list(core.schemas.lazyObject(() => serializers.FileInfo)),
  });

export declare namespace WorkspaceFiles {
  interface Raw {
    mainFile: serializers.FileInfo.Raw;
    readOnlyFiles: serializers.FileInfo.Raw[];
  }
}
",
                    "name": "WorkspaceFiles.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const WorkspaceRanResponse: core.schemas.ObjectSchema<WorkspaceRanResponse.Raw, TraceApi.WorkspaceRanResponse> =
  core.schemas.object({
    submissionId: core.schemas.lazy(() => serializers.SubmissionId),
    runDetails: core.schemas.lazyObject(() => serializers.WorkspaceRunDetails),
  });

export declare namespace WorkspaceRanResponse {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
    runDetails: serializers.WorkspaceRunDetails.Raw;
  }
}
",
                    "name": "WorkspaceRanResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const WorkspaceRunDetails: core.schemas.ObjectSchema<WorkspaceRunDetails.Raw, TraceApi.WorkspaceRunDetails> =
  core.schemas.object({
    exceptionV2: core.schemas.lazy(() => serializers.ExceptionV2).optional(),
    exception: core.schemas.lazyObject(() => serializers.ExceptionInfo).optional(),
    stdout: core.schemas.string(),
  });

export declare namespace WorkspaceRunDetails {
  interface Raw {
    exceptionV2?: serializers.ExceptionV2.Raw | null;
    exception?: serializers.ExceptionInfo.Raw | null;
    stdout: string;
  }
}
",
                    "name": "WorkspaceRunDetails.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const WorkspaceStarterFilesResponse: core.schemas.ObjectSchema<
  WorkspaceStarterFilesResponse.Raw,
  TraceApi.WorkspaceStarterFilesResponse
> = core.schemas.object({
  files: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => serializers.WorkspaceFiles)
  ),
});

export declare namespace WorkspaceStarterFilesResponse {
  interface Raw {
    files: Record<serializers.Language.Raw, serializers.WorkspaceFiles.Raw>;
  }
}
",
                    "name": "WorkspaceStarterFilesResponse.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const WorkspaceStarterFilesResponseV2: core.schemas.ObjectSchema<
  WorkspaceStarterFilesResponseV2.Raw,
  TraceApi.WorkspaceStarterFilesResponseV2
> = core.schemas.object({
  filesByLanguage: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => serializers.v2.Files)
  ),
});

export declare namespace WorkspaceStarterFilesResponseV2 {
  interface Raw {
    filesByLanguage: Record<serializers.Language.Raw, serializers.v2.Files.Raw>;
  }
}
",
                    "name": "WorkspaceStarterFilesResponseV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const WorkspaceSubmissionState: core.schemas.ObjectSchema<
  WorkspaceSubmissionState.Raw,
  TraceApi.WorkspaceSubmissionState
> = core.schemas.object({
  status: core.schemas.lazy(() => serializers.WorkspaceSubmissionStatus),
});

export declare namespace WorkspaceSubmissionState {
  interface Raw {
    status: serializers.WorkspaceSubmissionStatus.Raw;
  }
}
",
                    "name": "WorkspaceSubmissionState.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const WorkspaceSubmissionStatus: core.schemas.Schema<
  WorkspaceSubmissionStatus.Raw,
  TraceApi.WorkspaceSubmissionStatus
> = core.schemas
  .union(\\"type\\", {
    stopped: core.schemas.object({}),
    errored: core.schemas.object({
      value: core.schemas.lazy(() => serializers.ErrorInfo),
    }),
    running: core.schemas.object({
      value: core.schemas.lazy(() => serializers.RunningSubmissionState),
    }),
    ran: core.schemas.lazyObject(() => serializers.WorkspaceRunDetails),
    traced: core.schemas.lazyObject(() => serializers.WorkspaceRunDetails),
  })
  .transform<TraceApi.WorkspaceSubmissionStatus>({
    parse: (value) => {
      switch (value.type) {
        case \\"stopped\\":
          return TraceApi.WorkspaceSubmissionStatus.stopped();
        case \\"errored\\":
          return TraceApi.WorkspaceSubmissionStatus.errored(value.value);
        case \\"running\\":
          return TraceApi.WorkspaceSubmissionStatus.running(value.value);
        case \\"ran\\":
          return TraceApi.WorkspaceSubmissionStatus.ran(value);
        case \\"traced\\":
          return TraceApi.WorkspaceSubmissionStatus.traced(value);
        default:
          return core.addNonEnumerableProperty(value, \\"_visit\\", function <
            _Result
          >(this: TraceApi.WorkspaceSubmissionStatus, visitor: TraceApi.WorkspaceSubmissionStatus._Visitor<_Result>) {
            return visitor._other(value);
          });
      }
    },
    json: (value) => value as any,
  });

export declare namespace WorkspaceSubmissionStatus {
  type Raw =
    | WorkspaceSubmissionStatus.Stopped
    | WorkspaceSubmissionStatus.Errored
    | WorkspaceSubmissionStatus.Running
    | WorkspaceSubmissionStatus.Ran
    | WorkspaceSubmissionStatus.Traced;

  interface Stopped {
    type: \\"stopped\\";
  }

  interface Errored {
    type: \\"errored\\";
    value: serializers.ErrorInfo.Raw;
  }

  interface Running {
    type: \\"running\\";
    value: serializers.RunningSubmissionState.Raw;
  }

  interface Ran extends serializers.WorkspaceRunDetails.Raw {
    type: \\"ran\\";
  }

  interface Traced extends serializers.WorkspaceRunDetails.Raw {
    type: \\"traced\\";
  }
}
",
                    "name": "WorkspaceSubmissionStatus.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const WorkspaceSubmissionStatusV2: core.schemas.ObjectSchema<
  WorkspaceSubmissionStatusV2.Raw,
  TraceApi.WorkspaceSubmissionStatusV2
> = core.schemas.object({
  updates: core.schemas.list(core.schemas.lazyObject(() => serializers.WorkspaceSubmissionUpdate)),
});

export declare namespace WorkspaceSubmissionStatusV2 {
  interface Raw {
    updates: serializers.WorkspaceSubmissionUpdate.Raw[];
  }
}
",
                    "name": "WorkspaceSubmissionStatusV2.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const WorkspaceSubmissionUpdate: core.schemas.ObjectSchema<
  WorkspaceSubmissionUpdate.Raw,
  TraceApi.WorkspaceSubmissionUpdate
> = core.schemas.object({
  updateTime: core.schemas.date(),
  updateInfo: core.schemas.lazy(() => serializers.WorkspaceSubmissionUpdateInfo),
});

export declare namespace WorkspaceSubmissionUpdate {
  interface Raw {
    updateTime: string;
    updateInfo: serializers.WorkspaceSubmissionUpdateInfo.Raw;
  }
}
",
                    "name": "WorkspaceSubmissionUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const WorkspaceSubmissionUpdateInfo: core.schemas.Schema<
  WorkspaceSubmissionUpdateInfo.Raw,
  TraceApi.WorkspaceSubmissionUpdateInfo
> = core.schemas
  .union(\\"type\\", {
    running: core.schemas.object({
      value: core.schemas.lazy(() => serializers.RunningSubmissionState),
    }),
    ran: core.schemas.lazyObject(() => serializers.WorkspaceRunDetails),
    stopped: core.schemas.object({}),
    traced: core.schemas.object({}),
    tracedV2: core.schemas.lazyObject(() => serializers.WorkspaceTracedUpdate),
    errored: core.schemas.object({
      value: core.schemas.lazy(() => serializers.ErrorInfo),
    }),
    finished: core.schemas.object({}),
  })
  .transform<TraceApi.WorkspaceSubmissionUpdateInfo>({
    parse: (value) => {
      switch (value.type) {
        case \\"running\\":
          return TraceApi.WorkspaceSubmissionUpdateInfo.running(value.value);
        case \\"ran\\":
          return TraceApi.WorkspaceSubmissionUpdateInfo.ran(value);
        case \\"stopped\\":
          return TraceApi.WorkspaceSubmissionUpdateInfo.stopped();
        case \\"traced\\":
          return TraceApi.WorkspaceSubmissionUpdateInfo.traced();
        case \\"tracedV2\\":
          return TraceApi.WorkspaceSubmissionUpdateInfo.tracedV2(value);
        case \\"errored\\":
          return TraceApi.WorkspaceSubmissionUpdateInfo.errored(value.value);
        case \\"finished\\":
          return TraceApi.WorkspaceSubmissionUpdateInfo.finished();
        default:
          return core.addNonEnumerableProperty(value, \\"_visit\\", function <
            _Result
          >(this: TraceApi.WorkspaceSubmissionUpdateInfo, visitor: TraceApi.WorkspaceSubmissionUpdateInfo._Visitor<_Result>) {
            return visitor._other(value);
          });
      }
    },
    json: (value) => value as any,
  });

export declare namespace WorkspaceSubmissionUpdateInfo {
  type Raw =
    | WorkspaceSubmissionUpdateInfo.Running
    | WorkspaceSubmissionUpdateInfo.Ran
    | WorkspaceSubmissionUpdateInfo.Stopped
    | WorkspaceSubmissionUpdateInfo.Traced
    | WorkspaceSubmissionUpdateInfo.TracedV2
    | WorkspaceSubmissionUpdateInfo.Errored
    | WorkspaceSubmissionUpdateInfo.Finished;

  interface Running {
    type: \\"running\\";
    value: serializers.RunningSubmissionState.Raw;
  }

  interface Ran extends serializers.WorkspaceRunDetails.Raw {
    type: \\"ran\\";
  }

  interface Stopped {
    type: \\"stopped\\";
  }

  interface Traced {
    type: \\"traced\\";
  }

  interface TracedV2 extends serializers.WorkspaceTracedUpdate.Raw {
    type: \\"tracedV2\\";
  }

  interface Errored {
    type: \\"errored\\";
    value: serializers.ErrorInfo.Raw;
  }

  interface Finished {
    type: \\"finished\\";
  }
}
",
                    "name": "WorkspaceSubmissionUpdateInfo.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";
import * as serializers from \\"../..\\";

export const WorkspaceSubmitRequest: core.schemas.ObjectSchema<
  WorkspaceSubmitRequest.Raw,
  TraceApi.WorkspaceSubmitRequest
> = core.schemas.object({
  submissionId: core.schemas.lazy(() => serializers.SubmissionId),
  language: core.schemas.lazy(() => serializers.Language),
  submissionFiles: core.schemas.list(core.schemas.lazyObject(() => serializers.SubmissionFileInfo)),
  userId: core.schemas.string().optional(),
});

export declare namespace WorkspaceSubmitRequest {
  interface Raw {
    submissionId: serializers.SubmissionId.Raw;
    language: serializers.Language.Raw;
    submissionFiles: serializers.SubmissionFileInfo.Raw[];
    userId?: string | null;
  }
}
",
                    "name": "WorkspaceSubmitRequest.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const WorkspaceTracedUpdate: core.schemas.ObjectSchema<
  WorkspaceTracedUpdate.Raw,
  TraceApi.WorkspaceTracedUpdate
> = core.schemas.object({
  traceResponsesSize: core.schemas.number(),
});

export declare namespace WorkspaceTracedUpdate {
  interface Raw {
    traceResponsesSize: number;
  }
}
",
                    "name": "WorkspaceTracedUpdate.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * from \\"./SubmissionId\\";
export * from \\"./ShareId\\";
export * from \\"./SubmissionRequest\\";
export * from \\"./InitializeProblemRequest\\";
export * from \\"./SubmitRequestV2\\";
export * from \\"./WorkspaceSubmitRequest\\";
export * from \\"./SubmissionFileInfo\\";
export * from \\"./SubmissionTypeEnum\\";
export * from \\"./StopRequest\\";
export * from \\"./SubmissionResponse\\";
export * from \\"./CodeExecutionUpdate\\";
export * from \\"./BuildingExecutorResponse\\";
export * from \\"./RunningResponse\\";
export * from \\"./RunningSubmissionState\\";
export * from \\"./ErroredResponse\\";
export * from \\"./ErrorInfo\\";
export * from \\"./CompileError\\";
export * from \\"./RuntimeError\\";
export * from \\"./InternalError\\";
export * from \\"./StoppedResponse\\";
export * from \\"./WorkspaceRanResponse\\";
export * from \\"./WorkspaceRunDetails\\";
export * from \\"./GradedResponse\\";
export * from \\"./GradedResponseV2\\";
export * from \\"./TestCaseGrade\\";
export * from \\"./TestCaseHiddenGrade\\";
export * from \\"./TestCaseNonHiddenGrade\\";
export * from \\"./RecordedResponseNotification\\";
export * from \\"./RecordingResponseNotification\\";
export * from \\"./LightweightStackframeInformation\\";
export * from \\"./TestCaseResultWithStdout\\";
export * from \\"./TestCaseResult\\";
export * from \\"./ActualResult\\";
export * from \\"./ExceptionV2\\";
export * from \\"./ExceptionInfo\\";
export * from \\"./InvalidRequestResponse\\";
export * from \\"./InvalidRequestCause\\";
export * from \\"./ExistingSubmissionExecuting\\";
export * from \\"./SubmissionIdNotFound\\";
export * from \\"./CustomTestCasesUnsupported\\";
export * from \\"./UnexpectedLanguageError\\";
export * from \\"./TerminatedResponse\\";
export * from \\"./FinishedResponse\\";
export * from \\"./StdoutResponse\\";
export * from \\"./StderrResponse\\";
export * from \\"./TraceResponse\\";
export * from \\"./TraceResponseV2\\";
export * from \\"./TracedFile\\";
export * from \\"./ExpressionLocation\\";
export * from \\"./StackInformation\\";
export * from \\"./StackFrame\\";
export * from \\"./Scope\\";
export * from \\"./ExecutionSessionResponse\\";
export * from \\"./ExecutionSessionStatus\\";
export * from \\"./SubmissionStatusV2\\";
export * from \\"./TestSubmissionStatusV2\\";
export * from \\"./WorkspaceSubmissionStatusV2\\";
export * from \\"./TestSubmissionUpdate\\";
export * from \\"./TestSubmissionUpdateInfo\\";
export * from \\"./WorkspaceSubmissionUpdate\\";
export * from \\"./WorkspaceSubmissionUpdateInfo\\";
export * from \\"./GradedTestCaseUpdate\\";
export * from \\"./RecordedTestCaseUpdate\\";
export * from \\"./WorkspaceTracedUpdate\\";
export * from \\"./SubmissionTypeState\\";
export * from \\"./WorkspaceSubmissionState\\";
export * from \\"./WorkspaceSubmissionStatus\\";
export * from \\"./TestSubmissionState\\";
export * from \\"./TestSubmissionStatus\\";
export * from \\"./SubmissionStatusForTestCase\\";
export * from \\"./TracedTestCase\\";
export * from \\"./TraceResponsesPage\\";
export * from \\"./TraceResponsesPageV2\\";
export * from \\"./GetTraceResponsesPageRequest\\";
export * from \\"./WorkspaceStarterFilesResponse\\";
export * from \\"./WorkspaceStarterFilesResponseV2\\";
export * from \\"./WorkspaceFiles\\";
export * from \\"./ExecutionSessionState\\";
export * from \\"./GetExecutionSessionStateResponse\\";
export * from \\"./GetSubmissionStateResponse\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "types",
                "type": "directory",
              },
            ],
            "name": "submission",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": Array [
                  Object {
                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../..\\";
import { TraceApi } from \\"../../..\\";
import * as core from \\"../../../core\\";

export const Response: core.schemas.Schema<
  Record<serializers.Language.Raw, number>,
  Record<TraceApi.Language.RawValue, number>
> = core.schemas.record(core.schemas.string(), core.schemas.number());
",
                    "name": "getNumWarmInstances.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": "export * as getNumWarmInstances from \\"./getNumWarmInstances\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                ],
                "name": "client",
                "type": "directory",
              },
              Object {
                "contents": "export * from \\"./client\\";
",
                "name": "index.ts",
                "type": "file",
              },
            ],
            "name": "sysprop",
            "type": "directory",
          },
          Object {
            "contents": Array [
              Object {
                "contents": "export * from \\"./resources\\";
",
                "name": "index.ts",
                "type": "file",
              },
              Object {
                "contents": Array [
                  Object {
                    "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
export * as v3 from \\"./v3\\";
",
                    "name": "index.ts",
                    "type": "file",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const Response: core.schemas.Schema<
  serializers.v2.LightweightProblemInfoV2.Raw[],
  TraceApi.v2.LightweightProblemInfoV2[]
> = core.schemas.list(core.schemas.lazyObject(() => serializers.v2.LightweightProblemInfoV2));
",
                            "name": "getLightweightProblems.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../..\\";
import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const Response: core.schemas.Schema<serializers.v2.ProblemInfoV2.Raw[], TraceApi.v2.ProblemInfoV2[]> =
  core.schemas.list(core.schemas.lazyObject(() => serializers.v2.ProblemInfoV2));
",
                            "name": "getProblems.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "client",
                        "type": "directory",
                      },
                      Object {
                        "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const AssertCorrectnessCheck: core.schemas.Schema<
  AssertCorrectnessCheck.Raw,
  TraceApi.v2.AssertCorrectnessCheck
> = core.schemas
  .union(\\"type\\", {
    deepEquality: core.schemas.lazyObject(() => serializers.v2.DeepEqualityCorrectnessCheck),
    custom: core.schemas.lazyObject(() => serializers.v2.VoidFunctionDefinitionThatTakesActualResult),
  })
  .transform<TraceApi.v2.AssertCorrectnessCheck>({
    parse: (value) => {
      switch (value.type) {
        case \\"deepEquality\\":
          return TraceApi.v2.AssertCorrectnessCheck.deepEquality(value);
        case \\"custom\\":
          return TraceApi.v2.AssertCorrectnessCheck.custom(value);
        default:
          return core.addNonEnumerableProperty(value, \\"_visit\\", function <
            _Result
          >(this: TraceApi.v2.AssertCorrectnessCheck, visitor: TraceApi.v2.AssertCorrectnessCheck._Visitor<_Result>) {
            return visitor._other(value);
          });
      }
    },
    json: (value) => value as any,
  });

export declare namespace AssertCorrectnessCheck {
  type Raw = AssertCorrectnessCheck.DeepEquality | AssertCorrectnessCheck.Custom;

  interface DeepEquality extends serializers.v2.DeepEqualityCorrectnessCheck.Raw {
    type: \\"deepEquality\\";
  }

  interface Custom extends serializers.v2.VoidFunctionDefinitionThatTakesActualResult.Raw {
    type: \\"custom\\";
  }
}
",
                            "name": "AssertCorrectnessCheck.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const BasicCustomFiles: core.schemas.ObjectSchema<BasicCustomFiles.Raw, TraceApi.v2.BasicCustomFiles> =
  core.schemas.object({
    methodName: core.schemas.string(),
    signature: core.schemas.lazyObject(() => serializers.v2.NonVoidFunctionSignature),
    additionalFiles: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(() => serializers.v2.Files)
    ),
    basicTestCaseTemplate: core.schemas.lazyObject(() => serializers.v2.BasicTestCaseTemplate),
  });

export declare namespace BasicCustomFiles {
  interface Raw {
    methodName: string;
    signature: serializers.v2.NonVoidFunctionSignature.Raw;
    additionalFiles: Record<serializers.Language.Raw, serializers.v2.Files.Raw>;
    basicTestCaseTemplate: serializers.v2.BasicTestCaseTemplate.Raw;
  }
}
",
                            "name": "BasicCustomFiles.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const BasicTestCaseTemplate: core.schemas.ObjectSchema<
  BasicTestCaseTemplate.Raw,
  TraceApi.v2.BasicTestCaseTemplate
> = core.schemas.object({
  templateId: core.schemas.lazy(() => serializers.v2.TestCaseTemplateId),
  name: core.schemas.string(),
  description: core.schemas.lazyObject(() => serializers.v2.TestCaseImplementationDescription),
  expectedValueParameterId: core.schemas.lazy(() => serializers.v2.ParameterId),
});

export declare namespace BasicTestCaseTemplate {
  interface Raw {
    templateId: serializers.v2.TestCaseTemplateId.Raw;
    name: string;
    description: serializers.v2.TestCaseImplementationDescription.Raw;
    expectedValueParameterId: serializers.v2.ParameterId.Raw;
  }
}
",
                            "name": "BasicTestCaseTemplate.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const CreateProblemRequestV2: core.schemas.ObjectSchema<
  CreateProblemRequestV2.Raw,
  TraceApi.v2.CreateProblemRequestV2
> = core.schemas.object({
  problemName: core.schemas.string(),
  problemDescription: core.schemas.lazyObject(() => serializers.ProblemDescription),
  customFiles: core.schemas.lazy(() => serializers.v2.CustomFiles),
  customTestCaseTemplates: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.TestCaseTemplate)),
  testcases: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.TestCaseV2)),
  supportedLanguages: core.schemas.list(core.schemas.lazy(() => serializers.Language)),
  isPublic: core.schemas.boolean(),
});

export declare namespace CreateProblemRequestV2 {
  interface Raw {
    problemName: string;
    problemDescription: serializers.ProblemDescription.Raw;
    customFiles: serializers.v2.CustomFiles.Raw;
    customTestCaseTemplates: serializers.v2.TestCaseTemplate.Raw[];
    testcases: serializers.v2.TestCaseV2.Raw[];
    supportedLanguages: serializers.Language.Raw[];
    isPublic: boolean;
  }
}
",
                            "name": "CreateProblemRequestV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const CustomFiles: core.schemas.Schema<CustomFiles.Raw, TraceApi.v2.CustomFiles> = core.schemas
  .union(\\"type\\", {
    basic: core.schemas.lazyObject(() => serializers.v2.BasicCustomFiles),
    custom: core.schemas.object({
      value: core.schemas.record(
        core.schemas.string(),
        core.schemas.lazyObject(() => serializers.v2.Files)
      ),
    }),
  })
  .transform<TraceApi.v2.CustomFiles>({
    parse: (value) => {
      switch (value.type) {
        case \\"basic\\":
          return TraceApi.v2.CustomFiles.basic(value);
        case \\"custom\\":
          return TraceApi.v2.CustomFiles.custom(value.value);
        default:
          return core.addNonEnumerableProperty(value, \\"_visit\\", function <
            _Result
          >(this: TraceApi.v2.CustomFiles, visitor: TraceApi.v2.CustomFiles._Visitor<_Result>) {
            return visitor._other(value);
          });
      }
    },
    json: (value) => value as any,
  });

export declare namespace CustomFiles {
  type Raw = CustomFiles.Basic | CustomFiles.Custom;

  interface Basic extends serializers.v2.BasicCustomFiles.Raw {
    type: \\"basic\\";
  }

  interface Custom {
    type: \\"custom\\";
    value: Record<serializers.Language.Raw, serializers.v2.Files.Raw>;
  }
}
",
                            "name": "CustomFiles.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const DeepEqualityCorrectnessCheck: core.schemas.ObjectSchema<
  DeepEqualityCorrectnessCheck.Raw,
  TraceApi.v2.DeepEqualityCorrectnessCheck
> = core.schemas.object({
  expectedValueParameterId: core.schemas.lazy(() => serializers.v2.ParameterId),
});

export declare namespace DeepEqualityCorrectnessCheck {
  interface Raw {
    expectedValueParameterId: serializers.v2.ParameterId.Raw;
  }
}
",
                            "name": "DeepEqualityCorrectnessCheck.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const DefaultProvidedFile: core.schemas.ObjectSchema<DefaultProvidedFile.Raw, TraceApi.v2.DefaultProvidedFile> =
  core.schemas.object({
    file: core.schemas.lazyObject(() => serializers.v2.FileInfoV2),
    relatedTypes: core.schemas.list(core.schemas.lazy(() => serializers.VariableType)),
  });

export declare namespace DefaultProvidedFile {
  interface Raw {
    file: serializers.v2.FileInfoV2.Raw;
    relatedTypes: serializers.VariableType.Raw[];
  }
}
",
                            "name": "DefaultProvidedFile.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const FileInfoV2: core.schemas.ObjectSchema<FileInfoV2.Raw, TraceApi.v2.FileInfoV2> = core.schemas.object({
  filename: core.schemas.string(),
  directory: core.schemas.string(),
  contents: core.schemas.string(),
  editable: core.schemas.boolean(),
});

export declare namespace FileInfoV2 {
  interface Raw {
    filename: string;
    directory: string;
    contents: string;
    editable: boolean;
  }
}
",
                            "name": "FileInfoV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const Files: core.schemas.ObjectSchema<Files.Raw, TraceApi.v2.Files> = core.schemas.object({
  files: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.FileInfoV2)),
});

export declare namespace Files {
  interface Raw {
    files: serializers.v2.FileInfoV2.Raw[];
  }
}
",
                            "name": "Files.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const FunctionImplementation: core.schemas.ObjectSchema<
  FunctionImplementation.Raw,
  TraceApi.v2.FunctionImplementation
> = core.schemas.object({
  impl: core.schemas.string(),
  imports: core.schemas.string().optional(),
});

export declare namespace FunctionImplementation {
  interface Raw {
    impl: string;
    imports?: string | null;
  }
}
",
                            "name": "FunctionImplementation.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const FunctionImplementationForMultipleLanguages: core.schemas.ObjectSchema<
  FunctionImplementationForMultipleLanguages.Raw,
  TraceApi.v2.FunctionImplementationForMultipleLanguages
> = core.schemas.object({
  codeByLanguage: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => serializers.v2.FunctionImplementation)
  ),
});

export declare namespace FunctionImplementationForMultipleLanguages {
  interface Raw {
    codeByLanguage: Record<serializers.Language.Raw, serializers.v2.FunctionImplementation.Raw>;
  }
}
",
                            "name": "FunctionImplementationForMultipleLanguages.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const FunctionSignature: core.schemas.Schema<FunctionSignature.Raw, TraceApi.v2.FunctionSignature> = core.schemas
  .union(\\"type\\", {
    void: core.schemas.lazyObject(() => serializers.v2.VoidFunctionSignature),
    nonVoid: core.schemas.lazyObject(() => serializers.v2.NonVoidFunctionSignature),
    voidThatTakesActualResult: core.schemas.lazyObject(() => serializers.v2.VoidFunctionSignatureThatTakesActualResult),
  })
  .transform<TraceApi.v2.FunctionSignature>({
    parse: (value) => {
      switch (value.type) {
        case \\"void\\":
          return TraceApi.v2.FunctionSignature.void(value);
        case \\"nonVoid\\":
          return TraceApi.v2.FunctionSignature.nonVoid(value);
        case \\"voidThatTakesActualResult\\":
          return TraceApi.v2.FunctionSignature.voidThatTakesActualResult(value);
        default:
          return core.addNonEnumerableProperty(value, \\"_visit\\", function <
            _Result
          >(this: TraceApi.v2.FunctionSignature, visitor: TraceApi.v2.FunctionSignature._Visitor<_Result>) {
            return visitor._other(value);
          });
      }
    },
    json: (value) => value as any,
  });

export declare namespace FunctionSignature {
  type Raw = FunctionSignature.Void | FunctionSignature.NonVoid | FunctionSignature.VoidThatTakesActualResult;

  interface Void extends serializers.v2.VoidFunctionSignature.Raw {
    type: \\"void\\";
  }

  interface NonVoid extends serializers.v2.NonVoidFunctionSignature.Raw {
    type: \\"nonVoid\\";
  }

  interface VoidThatTakesActualResult extends serializers.v2.VoidFunctionSignatureThatTakesActualResult.Raw {
    type: \\"voidThatTakesActualResult\\";
  }
}
",
                            "name": "FunctionSignature.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const GeneratedFiles: core.schemas.ObjectSchema<GeneratedFiles.Raw, TraceApi.v2.GeneratedFiles> =
  core.schemas.object({
    generatedTestCaseFiles: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(() => serializers.v2.Files)
    ),
    generatedTemplateFiles: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(() => serializers.v2.Files)
    ),
    other: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(() => serializers.v2.Files)
    ),
  });

export declare namespace GeneratedFiles {
  interface Raw {
    generatedTestCaseFiles: Record<serializers.Language.Raw, serializers.v2.Files.Raw>;
    generatedTemplateFiles: Record<serializers.Language.Raw, serializers.v2.Files.Raw>;
    other: Record<serializers.Language.Raw, serializers.v2.Files.Raw>;
  }
}
",
                            "name": "GeneratedFiles.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const GetBasicSolutionFileRequest: core.schemas.ObjectSchema<
  GetBasicSolutionFileRequest.Raw,
  TraceApi.v2.GetBasicSolutionFileRequest
> = core.schemas.object({
  methodName: core.schemas.string(),
  signature: core.schemas.lazyObject(() => serializers.v2.NonVoidFunctionSignature),
});

export declare namespace GetBasicSolutionFileRequest {
  interface Raw {
    methodName: string;
    signature: serializers.v2.NonVoidFunctionSignature.Raw;
  }
}
",
                            "name": "GetBasicSolutionFileRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const GetBasicSolutionFileResponse: core.schemas.ObjectSchema<
  GetBasicSolutionFileResponse.Raw,
  TraceApi.v2.GetBasicSolutionFileResponse
> = core.schemas.object({
  solutionFileByLanguage: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => serializers.v2.FileInfoV2)
  ),
});

export declare namespace GetBasicSolutionFileResponse {
  interface Raw {
    solutionFileByLanguage: Record<serializers.Language.Raw, serializers.v2.FileInfoV2.Raw>;
  }
}
",
                            "name": "GetBasicSolutionFileResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const GetFunctionSignatureRequest: core.schemas.ObjectSchema<
  GetFunctionSignatureRequest.Raw,
  TraceApi.v2.GetFunctionSignatureRequest
> = core.schemas.object({
  functionSignature: core.schemas.lazy(() => serializers.v2.FunctionSignature),
});

export declare namespace GetFunctionSignatureRequest {
  interface Raw {
    functionSignature: serializers.v2.FunctionSignature.Raw;
  }
}
",
                            "name": "GetFunctionSignatureRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const GetFunctionSignatureResponse: core.schemas.ObjectSchema<
  GetFunctionSignatureResponse.Raw,
  TraceApi.v2.GetFunctionSignatureResponse
> = core.schemas.object({
  functionByLanguage: core.schemas.record(core.schemas.string(), core.schemas.string()),
});

export declare namespace GetFunctionSignatureResponse {
  interface Raw {
    functionByLanguage: Record<serializers.Language.Raw, string>;
  }
}
",
                            "name": "GetFunctionSignatureResponse.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const GetGeneratedTestCaseFileRequest: core.schemas.ObjectSchema<
  GetGeneratedTestCaseFileRequest.Raw,
  TraceApi.v2.GetGeneratedTestCaseFileRequest
> = core.schemas.object({
  template: core.schemas.lazyObject(() => serializers.v2.TestCaseTemplate).optional(),
  testCase: core.schemas.lazyObject(() => serializers.v2.TestCaseV2),
});

export declare namespace GetGeneratedTestCaseFileRequest {
  interface Raw {
    template?: serializers.v2.TestCaseTemplate.Raw | null;
    testCase: serializers.v2.TestCaseV2.Raw;
  }
}
",
                            "name": "GetGeneratedTestCaseFileRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const GetGeneratedTestCaseTemplateFileRequest: core.schemas.ObjectSchema<
  GetGeneratedTestCaseTemplateFileRequest.Raw,
  TraceApi.v2.GetGeneratedTestCaseTemplateFileRequest
> = core.schemas.object({
  template: core.schemas.lazyObject(() => serializers.v2.TestCaseTemplate),
});

export declare namespace GetGeneratedTestCaseTemplateFileRequest {
  interface Raw {
    template: serializers.v2.TestCaseTemplate.Raw;
  }
}
",
                            "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const LightweightProblemInfoV2: core.schemas.ObjectSchema<
  LightweightProblemInfoV2.Raw,
  TraceApi.v2.LightweightProblemInfoV2
> = core.schemas.object({
  problemId: core.schemas.lazy(() => serializers.ProblemId),
  problemName: core.schemas.string(),
  problemVersion: core.schemas.number(),
  variableTypes: core.schemas.list(core.schemas.lazy(() => serializers.VariableType)),
});

export declare namespace LightweightProblemInfoV2 {
  interface Raw {
    problemId: serializers.ProblemId.Raw;
    problemName: string;
    problemVersion: number;
    variableTypes: serializers.VariableType.Raw[];
  }
}
",
                            "name": "LightweightProblemInfoV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const NonVoidFunctionDefinition: core.schemas.ObjectSchema<
  NonVoidFunctionDefinition.Raw,
  TraceApi.v2.NonVoidFunctionDefinition
> = core.schemas.object({
  signature: core.schemas.lazyObject(() => serializers.v2.NonVoidFunctionSignature),
  code: core.schemas.lazyObject(() => serializers.v2.FunctionImplementationForMultipleLanguages),
});

export declare namespace NonVoidFunctionDefinition {
  interface Raw {
    signature: serializers.v2.NonVoidFunctionSignature.Raw;
    code: serializers.v2.FunctionImplementationForMultipleLanguages.Raw;
  }
}
",
                            "name": "NonVoidFunctionDefinition.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const NonVoidFunctionSignature: core.schemas.ObjectSchema<
  NonVoidFunctionSignature.Raw,
  TraceApi.v2.NonVoidFunctionSignature
> = core.schemas.object({
  parameters: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.Parameter)),
  returnType: core.schemas.lazy(() => serializers.VariableType),
});

export declare namespace NonVoidFunctionSignature {
  interface Raw {
    parameters: serializers.v2.Parameter.Raw[];
    returnType: serializers.VariableType.Raw;
  }
}
",
                            "name": "NonVoidFunctionSignature.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const Parameter: core.schemas.ObjectSchema<Parameter.Raw, TraceApi.v2.Parameter> = core.schemas.object({
  parameterId: core.schemas.lazy(() => serializers.v2.ParameterId),
  name: core.schemas.string(),
  variableType: core.schemas.lazy(() => serializers.VariableType),
});

export declare namespace Parameter {
  interface Raw {
    parameterId: serializers.v2.ParameterId.Raw;
    name: string;
    variableType: serializers.VariableType.Raw;
  }
}
",
                            "name": "Parameter.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const ParameterId: core.schemas.Schema<ParameterId.Raw, TraceApi.v2.ParameterId> = core.schemas
  .string()
  .transform({
    parse: TraceApi.v2.ParameterId.create,
    json: (value) => value,
  });

export declare namespace ParameterId {
  type Raw = string;
}
",
                            "name": "ParameterId.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const ProblemInfoV2: core.schemas.ObjectSchema<ProblemInfoV2.Raw, TraceApi.v2.ProblemInfoV2> =
  core.schemas.object({
    problemId: core.schemas.lazy(() => serializers.ProblemId),
    problemDescription: core.schemas.lazyObject(() => serializers.ProblemDescription),
    problemName: core.schemas.string(),
    problemVersion: core.schemas.number(),
    supportedLanguages: core.schemas.list(core.schemas.lazy(() => serializers.Language)),
    customFiles: core.schemas.lazy(() => serializers.v2.CustomFiles),
    generatedFiles: core.schemas.lazyObject(() => serializers.v2.GeneratedFiles),
    customTestCaseTemplates: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.TestCaseTemplate)),
    testcases: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.TestCaseV2)),
    isPublic: core.schemas.boolean(),
  });

export declare namespace ProblemInfoV2 {
  interface Raw {
    problemId: serializers.ProblemId.Raw;
    problemDescription: serializers.ProblemDescription.Raw;
    problemName: string;
    problemVersion: number;
    supportedLanguages: serializers.Language.Raw[];
    customFiles: serializers.v2.CustomFiles.Raw;
    generatedFiles: serializers.v2.GeneratedFiles.Raw;
    customTestCaseTemplates: serializers.v2.TestCaseTemplate.Raw[];
    testcases: serializers.v2.TestCaseV2.Raw[];
    isPublic: boolean;
  }
}
",
                            "name": "ProblemInfoV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const TestCaseExpects: core.schemas.ObjectSchema<TestCaseExpects.Raw, TraceApi.v2.TestCaseExpects> =
  core.schemas.object({
    expectedStdout: core.schemas.string().optional(),
  });

export declare namespace TestCaseExpects {
  interface Raw {
    expectedStdout?: string | null;
  }
}
",
                            "name": "TestCaseExpects.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const TestCaseFunction: core.schemas.Schema<TestCaseFunction.Raw, TraceApi.v2.TestCaseFunction> = core.schemas
  .union(\\"type\\", {
    withActualResult: core.schemas.lazyObject(() => serializers.v2.TestCaseWithActualResultImplementation),
    custom: core.schemas.lazyObject(() => serializers.v2.VoidFunctionDefinition),
  })
  .transform<TraceApi.v2.TestCaseFunction>({
    parse: (value) => {
      switch (value.type) {
        case \\"withActualResult\\":
          return TraceApi.v2.TestCaseFunction.withActualResult(value);
        case \\"custom\\":
          return TraceApi.v2.TestCaseFunction.custom(value);
        default:
          return core.addNonEnumerableProperty(value, \\"_visit\\", function <
            _Result
          >(this: TraceApi.v2.TestCaseFunction, visitor: TraceApi.v2.TestCaseFunction._Visitor<_Result>) {
            return visitor._other(value);
          });
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestCaseFunction {
  type Raw = TestCaseFunction.WithActualResult | TestCaseFunction.Custom;

  interface WithActualResult extends serializers.v2.TestCaseWithActualResultImplementation.Raw {
    type: \\"withActualResult\\";
  }

  interface Custom extends serializers.v2.VoidFunctionDefinition.Raw {
    type: \\"custom\\";
  }
}
",
                            "name": "TestCaseFunction.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const TestCaseId: core.schemas.Schema<TestCaseId.Raw, TraceApi.v2.TestCaseId> = core.schemas.string().transform({
  parse: TraceApi.v2.TestCaseId.create,
  json: (value) => value,
});

export declare namespace TestCaseId {
  type Raw = string;
}
",
                            "name": "TestCaseId.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const TestCaseImplementation: core.schemas.ObjectSchema<
  TestCaseImplementation.Raw,
  TraceApi.v2.TestCaseImplementation
> = core.schemas.object({
  description: core.schemas.lazyObject(() => serializers.v2.TestCaseImplementationDescription),
  function: core.schemas.lazy(() => serializers.v2.TestCaseFunction),
});

export declare namespace TestCaseImplementation {
  interface Raw {
    description: serializers.v2.TestCaseImplementationDescription.Raw;
    function: serializers.v2.TestCaseFunction.Raw;
  }
}
",
                            "name": "TestCaseImplementation.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const TestCaseImplementationDescription: core.schemas.ObjectSchema<
  TestCaseImplementationDescription.Raw,
  TraceApi.v2.TestCaseImplementationDescription
> = core.schemas.object({
  boards: core.schemas.list(core.schemas.lazy(() => serializers.v2.TestCaseImplementationDescriptionBoard)),
});

export declare namespace TestCaseImplementationDescription {
  interface Raw {
    boards: serializers.v2.TestCaseImplementationDescriptionBoard.Raw[];
  }
}
",
                            "name": "TestCaseImplementationDescription.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const TestCaseImplementationDescriptionBoard: core.schemas.Schema<
  TestCaseImplementationDescriptionBoard.Raw,
  TraceApi.v2.TestCaseImplementationDescriptionBoard
> = core.schemas
  .union(\\"type\\", {
    html: core.schemas.object({
      value: core.schemas.string(),
    }),
    paramId: core.schemas.object({
      value: core.schemas.lazy(() => serializers.v2.ParameterId),
    }),
  })
  .transform<TraceApi.v2.TestCaseImplementationDescriptionBoard>({
    parse: (value) => {
      switch (value.type) {
        case \\"html\\":
          return TraceApi.v2.TestCaseImplementationDescriptionBoard.html(value.value);
        case \\"paramId\\":
          return TraceApi.v2.TestCaseImplementationDescriptionBoard.paramId(value.value);
        default:
          return core.addNonEnumerableProperty(value, \\"_visit\\", function <
            _Result
          >(this: TraceApi.v2.TestCaseImplementationDescriptionBoard, visitor: TraceApi.v2.TestCaseImplementationDescriptionBoard._Visitor<_Result>) {
            return visitor._other(value);
          });
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestCaseImplementationDescriptionBoard {
  type Raw = TestCaseImplementationDescriptionBoard.Html | TestCaseImplementationDescriptionBoard.ParamId;

  interface Html {
    type: \\"html\\";
    value: string;
  }

  interface ParamId {
    type: \\"paramId\\";
    value: serializers.v2.ParameterId.Raw;
  }
}
",
                            "name": "TestCaseImplementationDescriptionBoard.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const TestCaseImplementationReference: core.schemas.Schema<
  TestCaseImplementationReference.Raw,
  TraceApi.v2.TestCaseImplementationReference
> = core.schemas
  .union(\\"type\\", {
    templateId: core.schemas.object({
      value: core.schemas.lazy(() => serializers.v2.TestCaseTemplateId),
    }),
    implementation: core.schemas.lazyObject(() => serializers.v2.TestCaseImplementation),
  })
  .transform<TraceApi.v2.TestCaseImplementationReference>({
    parse: (value) => {
      switch (value.type) {
        case \\"templateId\\":
          return TraceApi.v2.TestCaseImplementationReference.templateId(value.value);
        case \\"implementation\\":
          return TraceApi.v2.TestCaseImplementationReference.implementation(value);
        default:
          return core.addNonEnumerableProperty(value, \\"_visit\\", function <
            _Result
          >(this: TraceApi.v2.TestCaseImplementationReference, visitor: TraceApi.v2.TestCaseImplementationReference._Visitor<_Result>) {
            return visitor._other(value);
          });
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestCaseImplementationReference {
  type Raw = TestCaseImplementationReference.TemplateId | TestCaseImplementationReference.Implementation;

  interface TemplateId {
    type: \\"templateId\\";
    value: serializers.v2.TestCaseTemplateId.Raw;
  }

  interface Implementation extends serializers.v2.TestCaseImplementation.Raw {
    type: \\"implementation\\";
  }
}
",
                            "name": "TestCaseImplementationReference.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const TestCaseMetadata: core.schemas.ObjectSchema<TestCaseMetadata.Raw, TraceApi.v2.TestCaseMetadata> =
  core.schemas.object({
    id: core.schemas.lazy(() => serializers.v2.TestCaseId),
    name: core.schemas.string(),
    hidden: core.schemas.boolean(),
  });

export declare namespace TestCaseMetadata {
  interface Raw {
    id: serializers.v2.TestCaseId.Raw;
    name: string;
    hidden: boolean;
  }
}
",
                            "name": "TestCaseMetadata.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const TestCaseTemplate: core.schemas.ObjectSchema<TestCaseTemplate.Raw, TraceApi.v2.TestCaseTemplate> =
  core.schemas.object({
    templateId: core.schemas.lazy(() => serializers.v2.TestCaseTemplateId),
    name: core.schemas.string(),
    implementation: core.schemas.lazyObject(() => serializers.v2.TestCaseImplementation),
  });

export declare namespace TestCaseTemplate {
  interface Raw {
    templateId: serializers.v2.TestCaseTemplateId.Raw;
    name: string;
    implementation: serializers.v2.TestCaseImplementation.Raw;
  }
}
",
                            "name": "TestCaseTemplate.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";

export const TestCaseTemplateId: core.schemas.Schema<TestCaseTemplateId.Raw, TraceApi.v2.TestCaseTemplateId> =
  core.schemas.string().transform({
    parse: TraceApi.v2.TestCaseTemplateId.create,
    json: (value) => value,
  });

export declare namespace TestCaseTemplateId {
  type Raw = string;
}
",
                            "name": "TestCaseTemplateId.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const TestCaseV2: core.schemas.ObjectSchema<TestCaseV2.Raw, TraceApi.v2.TestCaseV2> = core.schemas.object({
  metadata: core.schemas.lazyObject(() => serializers.v2.TestCaseMetadata),
  implementation: core.schemas.lazy(() => serializers.v2.TestCaseImplementationReference),
  arguments: core.schemas.record(
    core.schemas.lazy(() => serializers.v2.ParameterId),
    core.schemas.lazy(() => serializers.VariableValue)
  ),
  expects: core.schemas.lazyObject(() => serializers.v2.TestCaseExpects).optional(),
});

export declare namespace TestCaseV2 {
  interface Raw {
    metadata: serializers.v2.TestCaseMetadata.Raw;
    implementation: serializers.v2.TestCaseImplementationReference.Raw;
    arguments: Record<serializers.v2.ParameterId.Raw, serializers.VariableValue.Raw>;
    expects?: serializers.v2.TestCaseExpects.Raw | null;
  }
}
",
                            "name": "TestCaseV2.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const TestCaseWithActualResultImplementation: core.schemas.ObjectSchema<
  TestCaseWithActualResultImplementation.Raw,
  TraceApi.v2.TestCaseWithActualResultImplementation
> = core.schemas.object({
  getActualResult: core.schemas.lazyObject(() => serializers.v2.NonVoidFunctionDefinition),
  assertCorrectnessCheck: core.schemas.lazy(() => serializers.v2.AssertCorrectnessCheck),
});

export declare namespace TestCaseWithActualResultImplementation {
  interface Raw {
    getActualResult: serializers.v2.NonVoidFunctionDefinition.Raw;
    assertCorrectnessCheck: serializers.v2.AssertCorrectnessCheck.Raw;
  }
}
",
                            "name": "TestCaseWithActualResultImplementation.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const VoidFunctionDefinition: core.schemas.ObjectSchema<
  VoidFunctionDefinition.Raw,
  TraceApi.v2.VoidFunctionDefinition
> = core.schemas.object({
  parameters: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.Parameter)),
  code: core.schemas.lazyObject(() => serializers.v2.FunctionImplementationForMultipleLanguages),
});

export declare namespace VoidFunctionDefinition {
  interface Raw {
    parameters: serializers.v2.Parameter.Raw[];
    code: serializers.v2.FunctionImplementationForMultipleLanguages.Raw;
  }
}
",
                            "name": "VoidFunctionDefinition.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const VoidFunctionDefinitionThatTakesActualResult: core.schemas.ObjectSchema<
  VoidFunctionDefinitionThatTakesActualResult.Raw,
  TraceApi.v2.VoidFunctionDefinitionThatTakesActualResult
> = core.schemas.object({
  additionalParameters: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.Parameter)),
  code: core.schemas.lazyObject(() => serializers.v2.FunctionImplementationForMultipleLanguages),
});

export declare namespace VoidFunctionDefinitionThatTakesActualResult {
  interface Raw {
    additionalParameters: serializers.v2.Parameter.Raw[];
    code: serializers.v2.FunctionImplementationForMultipleLanguages.Raw;
  }
}
",
                            "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const VoidFunctionSignature: core.schemas.ObjectSchema<
  VoidFunctionSignature.Raw,
  TraceApi.v2.VoidFunctionSignature
> = core.schemas.object({
  parameters: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.Parameter)),
});

export declare namespace VoidFunctionSignature {
  interface Raw {
    parameters: serializers.v2.Parameter.Raw[];
  }
}
",
                            "name": "VoidFunctionSignature.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../..\\";
import * as core from \\"../../../../../core\\";
import * as serializers from \\"../../../..\\";

export const VoidFunctionSignatureThatTakesActualResult: core.schemas.ObjectSchema<
  VoidFunctionSignatureThatTakesActualResult.Raw,
  TraceApi.v2.VoidFunctionSignatureThatTakesActualResult
> = core.schemas.object({
  parameters: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.Parameter)),
  actualResultType: core.schemas.lazy(() => serializers.VariableType),
});

export declare namespace VoidFunctionSignatureThatTakesActualResult {
  interface Raw {
    parameters: serializers.v2.Parameter.Raw[];
    actualResultType: serializers.VariableType.Raw;
  }
}
",
                            "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                        ],
                        "name": "types",
                        "type": "directory",
                      },
                    ],
                    "name": "problem",
                    "type": "directory",
                  },
                  Object {
                    "contents": Array [
                      Object {
                        "contents": "export * from \\"./resources\\";
",
                        "name": "index.ts",
                        "type": "file",
                      },
                      Object {
                        "contents": Array [
                          Object {
                            "contents": "export * as problem from \\"./problem\\";
export * from \\"./problem/types\\";
",
                            "name": "index.ts",
                            "type": "file",
                          },
                          Object {
                            "contents": Array [
                              Object {
                                "contents": Array [
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";

export const Response: core.schemas.Schema<
  serializers.v2.v3.LightweightProblemInfoV2.Raw[],
  TraceApi.v2.v3.LightweightProblemInfoV2[]
> = core.schemas.list(core.schemas.lazyObject(() => serializers.v2.v3.LightweightProblemInfoV2));
",
                                    "name": "getLightweightProblems.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import * as serializers from \\"../../../../../..\\";
import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";

export const Response: core.schemas.Schema<serializers.v2.v3.ProblemInfoV2.Raw[], TraceApi.v2.v3.ProblemInfoV2[]> =
  core.schemas.list(core.schemas.lazyObject(() => serializers.v2.v3.ProblemInfoV2));
",
                                    "name": "getProblems.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "export * as getLightweightProblems from \\"./getLightweightProblems\\";
export * as getProblems from \\"./getProblems\\";
",
                                    "name": "index.ts",
                                    "type": "file",
                                  },
                                ],
                                "name": "client",
                                "type": "directory",
                              },
                              Object {
                                "contents": "export * from \\"./types\\";
export * from \\"./client\\";
",
                                "name": "index.ts",
                                "type": "file",
                              },
                              Object {
                                "contents": Array [
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const AssertCorrectnessCheck: core.schemas.Schema<
  AssertCorrectnessCheck.Raw,
  TraceApi.v2.v3.AssertCorrectnessCheck
> = core.schemas
  .union(\\"type\\", {
    deepEquality: core.schemas.lazyObject(() => serializers.v2.v3.DeepEqualityCorrectnessCheck),
    custom: core.schemas.lazyObject(() => serializers.v2.v3.VoidFunctionDefinitionThatTakesActualResult),
  })
  .transform<TraceApi.v2.v3.AssertCorrectnessCheck>({
    parse: (value) => {
      switch (value.type) {
        case \\"deepEquality\\":
          return TraceApi.v2.v3.AssertCorrectnessCheck.deepEquality(value);
        case \\"custom\\":
          return TraceApi.v2.v3.AssertCorrectnessCheck.custom(value);
        default:
          return core.addNonEnumerableProperty(value, \\"_visit\\", function <
            _Result
          >(this: TraceApi.v2.v3.AssertCorrectnessCheck, visitor: TraceApi.v2.v3.AssertCorrectnessCheck._Visitor<_Result>) {
            return visitor._other(value);
          });
      }
    },
    json: (value) => value as any,
  });

export declare namespace AssertCorrectnessCheck {
  type Raw = AssertCorrectnessCheck.DeepEquality | AssertCorrectnessCheck.Custom;

  interface DeepEquality extends serializers.v2.v3.DeepEqualityCorrectnessCheck.Raw {
    type: \\"deepEquality\\";
  }

  interface Custom extends serializers.v2.v3.VoidFunctionDefinitionThatTakesActualResult.Raw {
    type: \\"custom\\";
  }
}
",
                                    "name": "AssertCorrectnessCheck.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const BasicCustomFiles: core.schemas.ObjectSchema<BasicCustomFiles.Raw, TraceApi.v2.v3.BasicCustomFiles> =
  core.schemas.object({
    methodName: core.schemas.string(),
    signature: core.schemas.lazyObject(() => serializers.v2.v3.NonVoidFunctionSignature),
    additionalFiles: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(() => serializers.v2.v3.Files)
    ),
    basicTestCaseTemplate: core.schemas.lazyObject(() => serializers.v2.v3.BasicTestCaseTemplate),
  });

export declare namespace BasicCustomFiles {
  interface Raw {
    methodName: string;
    signature: serializers.v2.v3.NonVoidFunctionSignature.Raw;
    additionalFiles: Record<serializers.Language.Raw, serializers.v2.v3.Files.Raw>;
    basicTestCaseTemplate: serializers.v2.v3.BasicTestCaseTemplate.Raw;
  }
}
",
                                    "name": "BasicCustomFiles.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const BasicTestCaseTemplate: core.schemas.ObjectSchema<
  BasicTestCaseTemplate.Raw,
  TraceApi.v2.v3.BasicTestCaseTemplate
> = core.schemas.object({
  templateId: core.schemas.lazy(() => serializers.v2.v3.TestCaseTemplateId),
  name: core.schemas.string(),
  description: core.schemas.lazyObject(() => serializers.v2.v3.TestCaseImplementationDescription),
  expectedValueParameterId: core.schemas.lazy(() => serializers.v2.v3.ParameterId),
});

export declare namespace BasicTestCaseTemplate {
  interface Raw {
    templateId: serializers.v2.v3.TestCaseTemplateId.Raw;
    name: string;
    description: serializers.v2.v3.TestCaseImplementationDescription.Raw;
    expectedValueParameterId: serializers.v2.v3.ParameterId.Raw;
  }
}
",
                                    "name": "BasicTestCaseTemplate.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const CreateProblemRequestV2: core.schemas.ObjectSchema<
  CreateProblemRequestV2.Raw,
  TraceApi.v2.v3.CreateProblemRequestV2
> = core.schemas.object({
  problemName: core.schemas.string(),
  problemDescription: core.schemas.lazyObject(() => serializers.ProblemDescription),
  customFiles: core.schemas.lazy(() => serializers.v2.v3.CustomFiles),
  customTestCaseTemplates: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.v3.TestCaseTemplate)),
  testcases: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.v3.TestCaseV2)),
  supportedLanguages: core.schemas.list(core.schemas.lazy(() => serializers.Language)),
  isPublic: core.schemas.boolean(),
});

export declare namespace CreateProblemRequestV2 {
  interface Raw {
    problemName: string;
    problemDescription: serializers.ProblemDescription.Raw;
    customFiles: serializers.v2.v3.CustomFiles.Raw;
    customTestCaseTemplates: serializers.v2.v3.TestCaseTemplate.Raw[];
    testcases: serializers.v2.v3.TestCaseV2.Raw[];
    supportedLanguages: serializers.Language.Raw[];
    isPublic: boolean;
  }
}
",
                                    "name": "CreateProblemRequestV2.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const CustomFiles: core.schemas.Schema<CustomFiles.Raw, TraceApi.v2.v3.CustomFiles> = core.schemas
  .union(\\"type\\", {
    basic: core.schemas.lazyObject(() => serializers.v2.v3.BasicCustomFiles),
    custom: core.schemas.object({
      value: core.schemas.record(
        core.schemas.string(),
        core.schemas.lazyObject(() => serializers.v2.v3.Files)
      ),
    }),
  })
  .transform<TraceApi.v2.v3.CustomFiles>({
    parse: (value) => {
      switch (value.type) {
        case \\"basic\\":
          return TraceApi.v2.v3.CustomFiles.basic(value);
        case \\"custom\\":
          return TraceApi.v2.v3.CustomFiles.custom(value.value);
        default:
          return core.addNonEnumerableProperty(value, \\"_visit\\", function <
            _Result
          >(this: TraceApi.v2.v3.CustomFiles, visitor: TraceApi.v2.v3.CustomFiles._Visitor<_Result>) {
            return visitor._other(value);
          });
      }
    },
    json: (value) => value as any,
  });

export declare namespace CustomFiles {
  type Raw = CustomFiles.Basic | CustomFiles.Custom;

  interface Basic extends serializers.v2.v3.BasicCustomFiles.Raw {
    type: \\"basic\\";
  }

  interface Custom {
    type: \\"custom\\";
    value: Record<serializers.Language.Raw, serializers.v2.v3.Files.Raw>;
  }
}
",
                                    "name": "CustomFiles.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const DeepEqualityCorrectnessCheck: core.schemas.ObjectSchema<
  DeepEqualityCorrectnessCheck.Raw,
  TraceApi.v2.v3.DeepEqualityCorrectnessCheck
> = core.schemas.object({
  expectedValueParameterId: core.schemas.lazy(() => serializers.v2.v3.ParameterId),
});

export declare namespace DeepEqualityCorrectnessCheck {
  interface Raw {
    expectedValueParameterId: serializers.v2.v3.ParameterId.Raw;
  }
}
",
                                    "name": "DeepEqualityCorrectnessCheck.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const DefaultProvidedFile: core.schemas.ObjectSchema<
  DefaultProvidedFile.Raw,
  TraceApi.v2.v3.DefaultProvidedFile
> = core.schemas.object({
  file: core.schemas.lazyObject(() => serializers.v2.v3.FileInfoV2),
  relatedTypes: core.schemas.list(core.schemas.lazy(() => serializers.VariableType)),
});

export declare namespace DefaultProvidedFile {
  interface Raw {
    file: serializers.v2.v3.FileInfoV2.Raw;
    relatedTypes: serializers.VariableType.Raw[];
  }
}
",
                                    "name": "DefaultProvidedFile.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";

export const FileInfoV2: core.schemas.ObjectSchema<FileInfoV2.Raw, TraceApi.v2.v3.FileInfoV2> = core.schemas.object({
  filename: core.schemas.string(),
  directory: core.schemas.string(),
  contents: core.schemas.string(),
  editable: core.schemas.boolean(),
});

export declare namespace FileInfoV2 {
  interface Raw {
    filename: string;
    directory: string;
    contents: string;
    editable: boolean;
  }
}
",
                                    "name": "FileInfoV2.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const Files: core.schemas.ObjectSchema<Files.Raw, TraceApi.v2.v3.Files> = core.schemas.object({
  files: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.v3.FileInfoV2)),
});

export declare namespace Files {
  interface Raw {
    files: serializers.v2.v3.FileInfoV2.Raw[];
  }
}
",
                                    "name": "Files.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";

export const FunctionImplementation: core.schemas.ObjectSchema<
  FunctionImplementation.Raw,
  TraceApi.v2.v3.FunctionImplementation
> = core.schemas.object({
  impl: core.schemas.string(),
  imports: core.schemas.string().optional(),
});

export declare namespace FunctionImplementation {
  interface Raw {
    impl: string;
    imports?: string | null;
  }
}
",
                                    "name": "FunctionImplementation.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const FunctionImplementationForMultipleLanguages: core.schemas.ObjectSchema<
  FunctionImplementationForMultipleLanguages.Raw,
  TraceApi.v2.v3.FunctionImplementationForMultipleLanguages
> = core.schemas.object({
  codeByLanguage: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => serializers.v2.v3.FunctionImplementation)
  ),
});

export declare namespace FunctionImplementationForMultipleLanguages {
  interface Raw {
    codeByLanguage: Record<serializers.Language.Raw, serializers.v2.v3.FunctionImplementation.Raw>;
  }
}
",
                                    "name": "FunctionImplementationForMultipleLanguages.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const FunctionSignature: core.schemas.Schema<FunctionSignature.Raw, TraceApi.v2.v3.FunctionSignature> =
  core.schemas
    .union(\\"type\\", {
      void: core.schemas.lazyObject(() => serializers.v2.v3.VoidFunctionSignature),
      nonVoid: core.schemas.lazyObject(() => serializers.v2.v3.NonVoidFunctionSignature),
      voidThatTakesActualResult: core.schemas.lazyObject(
        () => serializers.v2.v3.VoidFunctionSignatureThatTakesActualResult
      ),
    })
    .transform<TraceApi.v2.v3.FunctionSignature>({
      parse: (value) => {
        switch (value.type) {
          case \\"void\\":
            return TraceApi.v2.v3.FunctionSignature.void(value);
          case \\"nonVoid\\":
            return TraceApi.v2.v3.FunctionSignature.nonVoid(value);
          case \\"voidThatTakesActualResult\\":
            return TraceApi.v2.v3.FunctionSignature.voidThatTakesActualResult(value);
          default:
            return core.addNonEnumerableProperty(value, \\"_visit\\", function <
              _Result
            >(this: TraceApi.v2.v3.FunctionSignature, visitor: TraceApi.v2.v3.FunctionSignature._Visitor<_Result>) {
              return visitor._other(value);
            });
        }
      },
      json: (value) => value as any,
    });

export declare namespace FunctionSignature {
  type Raw = FunctionSignature.Void | FunctionSignature.NonVoid | FunctionSignature.VoidThatTakesActualResult;

  interface Void extends serializers.v2.v3.VoidFunctionSignature.Raw {
    type: \\"void\\";
  }

  interface NonVoid extends serializers.v2.v3.NonVoidFunctionSignature.Raw {
    type: \\"nonVoid\\";
  }

  interface VoidThatTakesActualResult extends serializers.v2.v3.VoidFunctionSignatureThatTakesActualResult.Raw {
    type: \\"voidThatTakesActualResult\\";
  }
}
",
                                    "name": "FunctionSignature.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const GeneratedFiles: core.schemas.ObjectSchema<GeneratedFiles.Raw, TraceApi.v2.v3.GeneratedFiles> =
  core.schemas.object({
    generatedTestCaseFiles: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(() => serializers.v2.v3.Files)
    ),
    generatedTemplateFiles: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(() => serializers.v2.v3.Files)
    ),
    other: core.schemas.record(
      core.schemas.string(),
      core.schemas.lazyObject(() => serializers.v2.v3.Files)
    ),
  });

export declare namespace GeneratedFiles {
  interface Raw {
    generatedTestCaseFiles: Record<serializers.Language.Raw, serializers.v2.v3.Files.Raw>;
    generatedTemplateFiles: Record<serializers.Language.Raw, serializers.v2.v3.Files.Raw>;
    other: Record<serializers.Language.Raw, serializers.v2.v3.Files.Raw>;
  }
}
",
                                    "name": "GeneratedFiles.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const GetBasicSolutionFileRequest: core.schemas.ObjectSchema<
  GetBasicSolutionFileRequest.Raw,
  TraceApi.v2.v3.GetBasicSolutionFileRequest
> = core.schemas.object({
  methodName: core.schemas.string(),
  signature: core.schemas.lazyObject(() => serializers.v2.v3.NonVoidFunctionSignature),
});

export declare namespace GetBasicSolutionFileRequest {
  interface Raw {
    methodName: string;
    signature: serializers.v2.v3.NonVoidFunctionSignature.Raw;
  }
}
",
                                    "name": "GetBasicSolutionFileRequest.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const GetBasicSolutionFileResponse: core.schemas.ObjectSchema<
  GetBasicSolutionFileResponse.Raw,
  TraceApi.v2.v3.GetBasicSolutionFileResponse
> = core.schemas.object({
  solutionFileByLanguage: core.schemas.record(
    core.schemas.string(),
    core.schemas.lazyObject(() => serializers.v2.v3.FileInfoV2)
  ),
});

export declare namespace GetBasicSolutionFileResponse {
  interface Raw {
    solutionFileByLanguage: Record<serializers.Language.Raw, serializers.v2.v3.FileInfoV2.Raw>;
  }
}
",
                                    "name": "GetBasicSolutionFileResponse.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const GetFunctionSignatureRequest: core.schemas.ObjectSchema<
  GetFunctionSignatureRequest.Raw,
  TraceApi.v2.v3.GetFunctionSignatureRequest
> = core.schemas.object({
  functionSignature: core.schemas.lazy(() => serializers.v2.v3.FunctionSignature),
});

export declare namespace GetFunctionSignatureRequest {
  interface Raw {
    functionSignature: serializers.v2.v3.FunctionSignature.Raw;
  }
}
",
                                    "name": "GetFunctionSignatureRequest.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const GetFunctionSignatureResponse: core.schemas.ObjectSchema<
  GetFunctionSignatureResponse.Raw,
  TraceApi.v2.v3.GetFunctionSignatureResponse
> = core.schemas.object({
  functionByLanguage: core.schemas.record(core.schemas.string(), core.schemas.string()),
});

export declare namespace GetFunctionSignatureResponse {
  interface Raw {
    functionByLanguage: Record<serializers.Language.Raw, string>;
  }
}
",
                                    "name": "GetFunctionSignatureResponse.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const GetGeneratedTestCaseFileRequest: core.schemas.ObjectSchema<
  GetGeneratedTestCaseFileRequest.Raw,
  TraceApi.v2.v3.GetGeneratedTestCaseFileRequest
> = core.schemas.object({
  template: core.schemas.lazyObject(() => serializers.v2.v3.TestCaseTemplate).optional(),
  testCase: core.schemas.lazyObject(() => serializers.v2.v3.TestCaseV2),
});

export declare namespace GetGeneratedTestCaseFileRequest {
  interface Raw {
    template?: serializers.v2.v3.TestCaseTemplate.Raw | null;
    testCase: serializers.v2.v3.TestCaseV2.Raw;
  }
}
",
                                    "name": "GetGeneratedTestCaseFileRequest.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const GetGeneratedTestCaseTemplateFileRequest: core.schemas.ObjectSchema<
  GetGeneratedTestCaseTemplateFileRequest.Raw,
  TraceApi.v2.v3.GetGeneratedTestCaseTemplateFileRequest
> = core.schemas.object({
  template: core.schemas.lazyObject(() => serializers.v2.v3.TestCaseTemplate),
});

export declare namespace GetGeneratedTestCaseTemplateFileRequest {
  interface Raw {
    template: serializers.v2.v3.TestCaseTemplate.Raw;
  }
}
",
                                    "name": "GetGeneratedTestCaseTemplateFileRequest.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const LightweightProblemInfoV2: core.schemas.ObjectSchema<
  LightweightProblemInfoV2.Raw,
  TraceApi.v2.v3.LightweightProblemInfoV2
> = core.schemas.object({
  problemId: core.schemas.lazy(() => serializers.ProblemId),
  problemName: core.schemas.string(),
  problemVersion: core.schemas.number(),
  variableTypes: core.schemas.list(core.schemas.lazy(() => serializers.VariableType)),
});

export declare namespace LightweightProblemInfoV2 {
  interface Raw {
    problemId: serializers.ProblemId.Raw;
    problemName: string;
    problemVersion: number;
    variableTypes: serializers.VariableType.Raw[];
  }
}
",
                                    "name": "LightweightProblemInfoV2.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const NonVoidFunctionDefinition: core.schemas.ObjectSchema<
  NonVoidFunctionDefinition.Raw,
  TraceApi.v2.v3.NonVoidFunctionDefinition
> = core.schemas.object({
  signature: core.schemas.lazyObject(() => serializers.v2.v3.NonVoidFunctionSignature),
  code: core.schemas.lazyObject(() => serializers.v2.v3.FunctionImplementationForMultipleLanguages),
});

export declare namespace NonVoidFunctionDefinition {
  interface Raw {
    signature: serializers.v2.v3.NonVoidFunctionSignature.Raw;
    code: serializers.v2.v3.FunctionImplementationForMultipleLanguages.Raw;
  }
}
",
                                    "name": "NonVoidFunctionDefinition.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const NonVoidFunctionSignature: core.schemas.ObjectSchema<
  NonVoidFunctionSignature.Raw,
  TraceApi.v2.v3.NonVoidFunctionSignature
> = core.schemas.object({
  parameters: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.v3.Parameter)),
  returnType: core.schemas.lazy(() => serializers.VariableType),
});

export declare namespace NonVoidFunctionSignature {
  interface Raw {
    parameters: serializers.v2.v3.Parameter.Raw[];
    returnType: serializers.VariableType.Raw;
  }
}
",
                                    "name": "NonVoidFunctionSignature.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const Parameter: core.schemas.ObjectSchema<Parameter.Raw, TraceApi.v2.v3.Parameter> = core.schemas.object({
  parameterId: core.schemas.lazy(() => serializers.v2.v3.ParameterId),
  name: core.schemas.string(),
  variableType: core.schemas.lazy(() => serializers.VariableType),
});

export declare namespace Parameter {
  interface Raw {
    parameterId: serializers.v2.v3.ParameterId.Raw;
    name: string;
    variableType: serializers.VariableType.Raw;
  }
}
",
                                    "name": "Parameter.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";

export const ParameterId: core.schemas.Schema<ParameterId.Raw, TraceApi.v2.v3.ParameterId> = core.schemas
  .string()
  .transform({
    parse: TraceApi.v2.v3.ParameterId.create,
    json: (value) => value,
  });

export declare namespace ParameterId {
  type Raw = string;
}
",
                                    "name": "ParameterId.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const ProblemInfoV2: core.schemas.ObjectSchema<ProblemInfoV2.Raw, TraceApi.v2.v3.ProblemInfoV2> =
  core.schemas.object({
    problemId: core.schemas.lazy(() => serializers.ProblemId),
    problemDescription: core.schemas.lazyObject(() => serializers.ProblemDescription),
    problemName: core.schemas.string(),
    problemVersion: core.schemas.number(),
    supportedLanguages: core.schemas.list(core.schemas.lazy(() => serializers.Language)),
    customFiles: core.schemas.lazy(() => serializers.v2.v3.CustomFiles),
    generatedFiles: core.schemas.lazyObject(() => serializers.v2.v3.GeneratedFiles),
    customTestCaseTemplates: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.v3.TestCaseTemplate)),
    testcases: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.v3.TestCaseV2)),
    isPublic: core.schemas.boolean(),
  });

export declare namespace ProblemInfoV2 {
  interface Raw {
    problemId: serializers.ProblemId.Raw;
    problemDescription: serializers.ProblemDescription.Raw;
    problemName: string;
    problemVersion: number;
    supportedLanguages: serializers.Language.Raw[];
    customFiles: serializers.v2.v3.CustomFiles.Raw;
    generatedFiles: serializers.v2.v3.GeneratedFiles.Raw;
    customTestCaseTemplates: serializers.v2.v3.TestCaseTemplate.Raw[];
    testcases: serializers.v2.v3.TestCaseV2.Raw[];
    isPublic: boolean;
  }
}
",
                                    "name": "ProblemInfoV2.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";

export const TestCaseExpects: core.schemas.ObjectSchema<TestCaseExpects.Raw, TraceApi.v2.v3.TestCaseExpects> =
  core.schemas.object({
    expectedStdout: core.schemas.string().optional(),
  });

export declare namespace TestCaseExpects {
  interface Raw {
    expectedStdout?: string | null;
  }
}
",
                                    "name": "TestCaseExpects.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const TestCaseFunction: core.schemas.Schema<TestCaseFunction.Raw, TraceApi.v2.v3.TestCaseFunction> = core.schemas
  .union(\\"type\\", {
    withActualResult: core.schemas.lazyObject(() => serializers.v2.v3.TestCaseWithActualResultImplementation),
    custom: core.schemas.lazyObject(() => serializers.v2.v3.VoidFunctionDefinition),
  })
  .transform<TraceApi.v2.v3.TestCaseFunction>({
    parse: (value) => {
      switch (value.type) {
        case \\"withActualResult\\":
          return TraceApi.v2.v3.TestCaseFunction.withActualResult(value);
        case \\"custom\\":
          return TraceApi.v2.v3.TestCaseFunction.custom(value);
        default:
          return core.addNonEnumerableProperty(value, \\"_visit\\", function <
            _Result
          >(this: TraceApi.v2.v3.TestCaseFunction, visitor: TraceApi.v2.v3.TestCaseFunction._Visitor<_Result>) {
            return visitor._other(value);
          });
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestCaseFunction {
  type Raw = TestCaseFunction.WithActualResult | TestCaseFunction.Custom;

  interface WithActualResult extends serializers.v2.v3.TestCaseWithActualResultImplementation.Raw {
    type: \\"withActualResult\\";
  }

  interface Custom extends serializers.v2.v3.VoidFunctionDefinition.Raw {
    type: \\"custom\\";
  }
}
",
                                    "name": "TestCaseFunction.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";

export const TestCaseId: core.schemas.Schema<TestCaseId.Raw, TraceApi.v2.v3.TestCaseId> = core.schemas
  .string()
  .transform({
    parse: TraceApi.v2.v3.TestCaseId.create,
    json: (value) => value,
  });

export declare namespace TestCaseId {
  type Raw = string;
}
",
                                    "name": "TestCaseId.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const TestCaseImplementation: core.schemas.ObjectSchema<
  TestCaseImplementation.Raw,
  TraceApi.v2.v3.TestCaseImplementation
> = core.schemas.object({
  description: core.schemas.lazyObject(() => serializers.v2.v3.TestCaseImplementationDescription),
  function: core.schemas.lazy(() => serializers.v2.v3.TestCaseFunction),
});

export declare namespace TestCaseImplementation {
  interface Raw {
    description: serializers.v2.v3.TestCaseImplementationDescription.Raw;
    function: serializers.v2.v3.TestCaseFunction.Raw;
  }
}
",
                                    "name": "TestCaseImplementation.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const TestCaseImplementationDescription: core.schemas.ObjectSchema<
  TestCaseImplementationDescription.Raw,
  TraceApi.v2.v3.TestCaseImplementationDescription
> = core.schemas.object({
  boards: core.schemas.list(core.schemas.lazy(() => serializers.v2.v3.TestCaseImplementationDescriptionBoard)),
});

export declare namespace TestCaseImplementationDescription {
  interface Raw {
    boards: serializers.v2.v3.TestCaseImplementationDescriptionBoard.Raw[];
  }
}
",
                                    "name": "TestCaseImplementationDescription.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const TestCaseImplementationDescriptionBoard: core.schemas.Schema<
  TestCaseImplementationDescriptionBoard.Raw,
  TraceApi.v2.v3.TestCaseImplementationDescriptionBoard
> = core.schemas
  .union(\\"type\\", {
    html: core.schemas.object({
      value: core.schemas.string(),
    }),
    paramId: core.schemas.object({
      value: core.schemas.lazy(() => serializers.v2.v3.ParameterId),
    }),
  })
  .transform<TraceApi.v2.v3.TestCaseImplementationDescriptionBoard>({
    parse: (value) => {
      switch (value.type) {
        case \\"html\\":
          return TraceApi.v2.v3.TestCaseImplementationDescriptionBoard.html(value.value);
        case \\"paramId\\":
          return TraceApi.v2.v3.TestCaseImplementationDescriptionBoard.paramId(value.value);
        default:
          return core.addNonEnumerableProperty(value, \\"_visit\\", function <
            _Result
          >(this: TraceApi.v2.v3.TestCaseImplementationDescriptionBoard, visitor: TraceApi.v2.v3.TestCaseImplementationDescriptionBoard._Visitor<_Result>) {
            return visitor._other(value);
          });
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestCaseImplementationDescriptionBoard {
  type Raw = TestCaseImplementationDescriptionBoard.Html | TestCaseImplementationDescriptionBoard.ParamId;

  interface Html {
    type: \\"html\\";
    value: string;
  }

  interface ParamId {
    type: \\"paramId\\";
    value: serializers.v2.v3.ParameterId.Raw;
  }
}
",
                                    "name": "TestCaseImplementationDescriptionBoard.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const TestCaseImplementationReference: core.schemas.Schema<
  TestCaseImplementationReference.Raw,
  TraceApi.v2.v3.TestCaseImplementationReference
> = core.schemas
  .union(\\"type\\", {
    templateId: core.schemas.object({
      value: core.schemas.lazy(() => serializers.v2.v3.TestCaseTemplateId),
    }),
    implementation: core.schemas.lazyObject(() => serializers.v2.v3.TestCaseImplementation),
  })
  .transform<TraceApi.v2.v3.TestCaseImplementationReference>({
    parse: (value) => {
      switch (value.type) {
        case \\"templateId\\":
          return TraceApi.v2.v3.TestCaseImplementationReference.templateId(value.value);
        case \\"implementation\\":
          return TraceApi.v2.v3.TestCaseImplementationReference.implementation(value);
        default:
          return core.addNonEnumerableProperty(value, \\"_visit\\", function <
            _Result
          >(this: TraceApi.v2.v3.TestCaseImplementationReference, visitor: TraceApi.v2.v3.TestCaseImplementationReference._Visitor<_Result>) {
            return visitor._other(value);
          });
      }
    },
    json: (value) => value as any,
  });

export declare namespace TestCaseImplementationReference {
  type Raw = TestCaseImplementationReference.TemplateId | TestCaseImplementationReference.Implementation;

  interface TemplateId {
    type: \\"templateId\\";
    value: serializers.v2.v3.TestCaseTemplateId.Raw;
  }

  interface Implementation extends serializers.v2.v3.TestCaseImplementation.Raw {
    type: \\"implementation\\";
  }
}
",
                                    "name": "TestCaseImplementationReference.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const TestCaseMetadata: core.schemas.ObjectSchema<TestCaseMetadata.Raw, TraceApi.v2.v3.TestCaseMetadata> =
  core.schemas.object({
    id: core.schemas.lazy(() => serializers.v2.v3.TestCaseId),
    name: core.schemas.string(),
    hidden: core.schemas.boolean(),
  });

export declare namespace TestCaseMetadata {
  interface Raw {
    id: serializers.v2.v3.TestCaseId.Raw;
    name: string;
    hidden: boolean;
  }
}
",
                                    "name": "TestCaseMetadata.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const TestCaseTemplate: core.schemas.ObjectSchema<TestCaseTemplate.Raw, TraceApi.v2.v3.TestCaseTemplate> =
  core.schemas.object({
    templateId: core.schemas.lazy(() => serializers.v2.v3.TestCaseTemplateId),
    name: core.schemas.string(),
    implementation: core.schemas.lazyObject(() => serializers.v2.v3.TestCaseImplementation),
  });

export declare namespace TestCaseTemplate {
  interface Raw {
    templateId: serializers.v2.v3.TestCaseTemplateId.Raw;
    name: string;
    implementation: serializers.v2.v3.TestCaseImplementation.Raw;
  }
}
",
                                    "name": "TestCaseTemplate.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";

export const TestCaseTemplateId: core.schemas.Schema<TestCaseTemplateId.Raw, TraceApi.v2.v3.TestCaseTemplateId> =
  core.schemas.string().transform({
    parse: TraceApi.v2.v3.TestCaseTemplateId.create,
    json: (value) => value,
  });

export declare namespace TestCaseTemplateId {
  type Raw = string;
}
",
                                    "name": "TestCaseTemplateId.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const TestCaseV2: core.schemas.ObjectSchema<TestCaseV2.Raw, TraceApi.v2.v3.TestCaseV2> = core.schemas.object({
  metadata: core.schemas.lazyObject(() => serializers.v2.v3.TestCaseMetadata),
  implementation: core.schemas.lazy(() => serializers.v2.v3.TestCaseImplementationReference),
  arguments: core.schemas.record(
    core.schemas.lazy(() => serializers.v2.v3.ParameterId),
    core.schemas.lazy(() => serializers.VariableValue)
  ),
  expects: core.schemas.lazyObject(() => serializers.v2.v3.TestCaseExpects).optional(),
});

export declare namespace TestCaseV2 {
  interface Raw {
    metadata: serializers.v2.v3.TestCaseMetadata.Raw;
    implementation: serializers.v2.v3.TestCaseImplementationReference.Raw;
    arguments: Record<serializers.v2.v3.ParameterId.Raw, serializers.VariableValue.Raw>;
    expects?: serializers.v2.v3.TestCaseExpects.Raw | null;
  }
}
",
                                    "name": "TestCaseV2.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const TestCaseWithActualResultImplementation: core.schemas.ObjectSchema<
  TestCaseWithActualResultImplementation.Raw,
  TraceApi.v2.v3.TestCaseWithActualResultImplementation
> = core.schemas.object({
  getActualResult: core.schemas.lazyObject(() => serializers.v2.v3.NonVoidFunctionDefinition),
  assertCorrectnessCheck: core.schemas.lazy(() => serializers.v2.v3.AssertCorrectnessCheck),
});

export declare namespace TestCaseWithActualResultImplementation {
  interface Raw {
    getActualResult: serializers.v2.v3.NonVoidFunctionDefinition.Raw;
    assertCorrectnessCheck: serializers.v2.v3.AssertCorrectnessCheck.Raw;
  }
}
",
                                    "name": "TestCaseWithActualResultImplementation.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const VoidFunctionDefinition: core.schemas.ObjectSchema<
  VoidFunctionDefinition.Raw,
  TraceApi.v2.v3.VoidFunctionDefinition
> = core.schemas.object({
  parameters: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.v3.Parameter)),
  code: core.schemas.lazyObject(() => serializers.v2.v3.FunctionImplementationForMultipleLanguages),
});

export declare namespace VoidFunctionDefinition {
  interface Raw {
    parameters: serializers.v2.v3.Parameter.Raw[];
    code: serializers.v2.v3.FunctionImplementationForMultipleLanguages.Raw;
  }
}
",
                                    "name": "VoidFunctionDefinition.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const VoidFunctionDefinitionThatTakesActualResult: core.schemas.ObjectSchema<
  VoidFunctionDefinitionThatTakesActualResult.Raw,
  TraceApi.v2.v3.VoidFunctionDefinitionThatTakesActualResult
> = core.schemas.object({
  additionalParameters: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.v3.Parameter)),
  code: core.schemas.lazyObject(() => serializers.v2.v3.FunctionImplementationForMultipleLanguages),
});

export declare namespace VoidFunctionDefinitionThatTakesActualResult {
  interface Raw {
    additionalParameters: serializers.v2.v3.Parameter.Raw[];
    code: serializers.v2.v3.FunctionImplementationForMultipleLanguages.Raw;
  }
}
",
                                    "name": "VoidFunctionDefinitionThatTakesActualResult.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const VoidFunctionSignature: core.schemas.ObjectSchema<
  VoidFunctionSignature.Raw,
  TraceApi.v2.v3.VoidFunctionSignature
> = core.schemas.object({
  parameters: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.v3.Parameter)),
});

export declare namespace VoidFunctionSignature {
  interface Raw {
    parameters: serializers.v2.v3.Parameter.Raw[];
  }
}
",
                                    "name": "VoidFunctionSignature.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "/**
 * This file auto-generated by Fern from our API Definition.
 */

import { TraceApi } from \\"../../../../../../..\\";
import * as core from \\"../../../../../../../core\\";
import * as serializers from \\"../../../../../..\\";

export const VoidFunctionSignatureThatTakesActualResult: core.schemas.ObjectSchema<
  VoidFunctionSignatureThatTakesActualResult.Raw,
  TraceApi.v2.v3.VoidFunctionSignatureThatTakesActualResult
> = core.schemas.object({
  parameters: core.schemas.list(core.schemas.lazyObject(() => serializers.v2.v3.Parameter)),
  actualResultType: core.schemas.lazy(() => serializers.VariableType),
});

export declare namespace VoidFunctionSignatureThatTakesActualResult {
  interface Raw {
    parameters: serializers.v2.v3.Parameter.Raw[];
    actualResultType: serializers.VariableType.Raw;
  }
}
",
                                    "name": "VoidFunctionSignatureThatTakesActualResult.ts",
                                    "type": "file",
                                  },
                                  Object {
                                    "contents": "export * from \\"./TestCaseTemplateId\\";
export * from \\"./TestCaseId\\";
export * from \\"./ParameterId\\";
export * from \\"./ProblemInfoV2\\";
export * from \\"./LightweightProblemInfoV2\\";
export * from \\"./CreateProblemRequestV2\\";
export * from \\"./TestCaseV2\\";
export * from \\"./TestCaseExpects\\";
export * from \\"./TestCaseImplementationReference\\";
export * from \\"./BasicTestCaseTemplate\\";
export * from \\"./TestCaseTemplate\\";
export * from \\"./TestCaseImplementation\\";
export * from \\"./TestCaseFunction\\";
export * from \\"./TestCaseWithActualResultImplementation\\";
export * from \\"./VoidFunctionDefinition\\";
export * from \\"./Parameter\\";
export * from \\"./NonVoidFunctionDefinition\\";
export * from \\"./VoidFunctionSignature\\";
export * from \\"./NonVoidFunctionSignature\\";
export * from \\"./VoidFunctionSignatureThatTakesActualResult\\";
export * from \\"./AssertCorrectnessCheck\\";
export * from \\"./DeepEqualityCorrectnessCheck\\";
export * from \\"./VoidFunctionDefinitionThatTakesActualResult\\";
export * from \\"./TestCaseImplementationDescription\\";
export * from \\"./TestCaseImplementationDescriptionBoard\\";
export * from \\"./TestCaseMetadata\\";
export * from \\"./FunctionImplementationForMultipleLanguages\\";
export * from \\"./FunctionImplementation\\";
export * from \\"./GeneratedFiles\\";
export * from \\"./CustomFiles\\";
export * from \\"./BasicCustomFiles\\";
export * from \\"./Files\\";
export * from \\"./FileInfoV2\\";
export * from \\"./DefaultProvidedFile\\";
export * from \\"./FunctionSignature\\";
export * from \\"./GetFunctionSignatureRequest\\";
export * from \\"./GetFunctionSignatureResponse\\";
export * from \\"./GetBasicSolutionFileRequest\\";
export * from \\"./GetBasicSolutionFileResponse\\";
export * from \\"./GetGeneratedTestCaseFileRequest\\";
export * from \\"./GetGeneratedTestCaseTemplateFileRequest\\";
",
                                    "name": "index.ts",
                                    "type": "file",
                                  },
                                ],
                                "name": "types",
                                "type": "directory",
                              },
                            ],
                            "name": "problem",
                            "type": "directory",
                          },
                        ],
                        "name": "resources",
                        "type": "directory",
                      },
                    ],
                    "name": "v3",
                    "type": "directory",
                  },
                ],
                "name": "resources",
                "type": "directory",
              },
            ],
            "name": "v2",
            "type": "directory",
          },
        ],
        "name": "serialization",
        "type": "directory",
      },
    ],
    "name": "src",
    "type": "directory",
  },
  Object {
    "contents": "{
    \\"compilerOptions\\": {
        \\"strict\\": true,
        \\"target\\": \\"esnext\\",
        \\"moduleResolution\\": \\"node\\",
        \\"skipLibCheck\\": true,
        \\"declaration\\": true,
        \\"sourceMap\\": true,
        \\"emitDeclarationOnly\\": true,
        \\"esModuleInterop\\": true,
        \\"noUncheckedIndexedAccess\\": true,
        \\"noUnusedLocals\\": true,
        \\"noUnusedParameters\\": true,
        \\"declarationDir\\": \\".\\",
        \\"rootDir\\": \\"src\\"
    },
    \\"include\\": [
        \\"src\\"
    ],
    \\"exclude\\": []
}",
    "name": "tsconfig.json",
    "type": "file",
  },
]
`;
