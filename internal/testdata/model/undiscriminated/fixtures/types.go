// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
)

type AnotherUnion struct {
	typeName      string
	String        string
	stringLiteral string
	Foo           *Foo
}

func NewAnotherUnionFromString(value string) *AnotherUnion {
	return &AnotherUnion{typeName: "string", String: value}
}

func NewAnotherUnionWithStringLiteral() *AnotherUnion {
	return &AnotherUnion{typeName: "stringLiteral", stringLiteral: "fern"}
}

func NewAnotherUnionFromFoo(value *Foo) *AnotherUnion {
	return &AnotherUnion{typeName: "foo", Foo: value}
}

func (a *AnotherUnion) StringLiteral() string {
	return a.stringLiteral
}

func (a *AnotherUnion) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		a.typeName = "string"
		a.String = valueString
		return nil
	}
	var valueStringLiteral string
	if err := json.Unmarshal(data, &valueStringLiteral); err == nil {
		if valueStringLiteral == "fern" {
			a.typeName = "stringLiteral"
			a.stringLiteral = valueStringLiteral
			return nil
		}
	}
	valueFoo := new(Foo)
	if err := json.Unmarshal(data, &valueFoo); err == nil {
		a.typeName = "foo"
		a.Foo = valueFoo
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AnotherUnion) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return json.Marshal(a.String)
	case "stringLiteral":
		return json.Marshal("fern")
	case "foo":
		return json.Marshal(a.Foo)
	}
}

type AnotherUnionVisitor interface {
	VisitString(string) error
	VisitStringLiteral(string) error
	VisitFoo(*Foo) error
}

func (a *AnotherUnion) Accept(visitor AnotherUnionVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "string":
		return visitor.VisitString(a.String)
	case "stringLiteral":
		return visitor.VisitStringLiteral(a.stringLiteral)
	case "foo":
		return visitor.VisitFoo(a.Foo)
	}
}

type Bar struct {
	Name string `json:"name"`
}

type Baz struct {
	Id string `json:"id"`
}

type Foo struct {
	Name string `json:"name"`
}

type Union struct {
	typeName         string
	Foo              *Foo
	Bar              *Bar
	Baz              *Baz
	String           string
	IntegerOptional  *int
	StringBooleanMap map[string]bool
	StringList       []string
	StringListList   [][]string
	DoubleSet        []float64
	stringLiteral    string
}

func NewUnionFromFoo(value *Foo) *Union {
	return &Union{typeName: "foo", Foo: value}
}

func NewUnionFromBar(value *Bar) *Union {
	return &Union{typeName: "bar", Bar: value}
}

func NewUnionFromBaz(value *Baz) *Union {
	return &Union{typeName: "baz", Baz: value}
}

func NewUnionFromString(value string) *Union {
	return &Union{typeName: "string", String: value}
}

func NewUnionFromIntegerOptional(value *int) *Union {
	return &Union{typeName: "integerOptional", IntegerOptional: value}
}

func NewUnionFromStringBooleanMap(value map[string]bool) *Union {
	return &Union{typeName: "stringBooleanMap", StringBooleanMap: value}
}

func NewUnionFromStringList(value []string) *Union {
	return &Union{typeName: "stringList", StringList: value}
}

func NewUnionFromStringListList(value [][]string) *Union {
	return &Union{typeName: "stringListList", StringListList: value}
}

func NewUnionFromDoubleSet(value []float64) *Union {
	return &Union{typeName: "doubleSet", DoubleSet: value}
}

func NewUnionWithStringLiteral() *Union {
	return &Union{typeName: "stringLiteral", stringLiteral: "fern"}
}

func (u *Union) StringLiteral() string {
	return u.stringLiteral
}

func (u *Union) UnmarshalJSON(data []byte) error {
	valueFoo := new(Foo)
	if err := json.Unmarshal(data, &valueFoo); err == nil {
		u.typeName = "foo"
		u.Foo = valueFoo
		return nil
	}
	valueBar := new(Bar)
	if err := json.Unmarshal(data, &valueBar); err == nil {
		u.typeName = "bar"
		u.Bar = valueBar
		return nil
	}
	valueBaz := new(Baz)
	if err := json.Unmarshal(data, &valueBaz); err == nil {
		u.typeName = "baz"
		u.Baz = valueBaz
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		u.typeName = "string"
		u.String = valueString
		return nil
	}
	var valueIntegerOptional *int
	if err := json.Unmarshal(data, &valueIntegerOptional); err == nil {
		u.typeName = "integerOptional"
		u.IntegerOptional = valueIntegerOptional
		return nil
	}
	var valueStringBooleanMap map[string]bool
	if err := json.Unmarshal(data, &valueStringBooleanMap); err == nil {
		u.typeName = "stringBooleanMap"
		u.StringBooleanMap = valueStringBooleanMap
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		u.typeName = "stringList"
		u.StringList = valueStringList
		return nil
	}
	var valueStringListList [][]string
	if err := json.Unmarshal(data, &valueStringListList); err == nil {
		u.typeName = "stringListList"
		u.StringListList = valueStringListList
		return nil
	}
	var valueDoubleSet []float64
	if err := json.Unmarshal(data, &valueDoubleSet); err == nil {
		u.typeName = "doubleSet"
		u.DoubleSet = valueDoubleSet
		return nil
	}
	var valueStringLiteral string
	if err := json.Unmarshal(data, &valueStringLiteral); err == nil {
		if valueStringLiteral == "fern" {
			u.typeName = "stringLiteral"
			u.stringLiteral = valueStringLiteral
			return nil
		}
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u Union) MarshalJSON() ([]byte, error) {
	switch u.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "foo":
		return json.Marshal(u.Foo)
	case "bar":
		return json.Marshal(u.Bar)
	case "baz":
		return json.Marshal(u.Baz)
	case "string":
		return json.Marshal(u.String)
	case "integerOptional":
		return json.Marshal(u.IntegerOptional)
	case "stringBooleanMap":
		return json.Marshal(u.StringBooleanMap)
	case "stringList":
		return json.Marshal(u.StringList)
	case "stringListList":
		return json.Marshal(u.StringListList)
	case "doubleSet":
		return json.Marshal(u.DoubleSet)
	case "stringLiteral":
		return json.Marshal("fern")
	}
}

type UnionVisitor interface {
	VisitFoo(*Foo) error
	VisitBar(*Bar) error
	VisitBaz(*Baz) error
	VisitString(string) error
	VisitIntegerOptional(*int) error
	VisitStringBooleanMap(map[string]bool) error
	VisitStringList([]string) error
	VisitStringListList([][]string) error
	VisitDoubleSet([]float64) error
	VisitStringLiteral(string) error
}

func (u *Union) Accept(visitor UnionVisitor) error {
	switch u.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "foo":
		return visitor.VisitFoo(u.Foo)
	case "bar":
		return visitor.VisitBar(u.Bar)
	case "baz":
		return visitor.VisitBaz(u.Baz)
	case "string":
		return visitor.VisitString(u.String)
	case "integerOptional":
		return visitor.VisitIntegerOptional(u.IntegerOptional)
	case "stringBooleanMap":
		return visitor.VisitStringBooleanMap(u.StringBooleanMap)
	case "stringList":
		return visitor.VisitStringList(u.StringList)
	case "stringListList":
		return visitor.VisitStringListList(u.StringListList)
	case "doubleSet":
		return visitor.VisitDoubleSet(u.DoubleSet)
	case "stringLiteral":
		return visitor.VisitStringLiteral(u.stringLiteral)
	}
}

type UnionWithLiteral struct {
	typeName      string
	stringLiteral string
	String        string
}

func NewUnionWithLiteralWithStringLiteral() *UnionWithLiteral {
	return &UnionWithLiteral{typeName: "stringLiteral", stringLiteral: "fern"}
}

func NewUnionWithLiteralFromString(value string) *UnionWithLiteral {
	return &UnionWithLiteral{typeName: "string", String: value}
}

func (u *UnionWithLiteral) StringLiteral() string {
	return u.stringLiteral
}

func (u *UnionWithLiteral) UnmarshalJSON(data []byte) error {
	var valueStringLiteral string
	if err := json.Unmarshal(data, &valueStringLiteral); err == nil {
		if valueStringLiteral == "fern" {
			u.typeName = "stringLiteral"
			u.stringLiteral = valueStringLiteral
			return nil
		}
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		u.typeName = "string"
		u.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UnionWithLiteral) MarshalJSON() ([]byte, error) {
	switch u.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "stringLiteral":
		return json.Marshal("fern")
	case "string":
		return json.Marshal(u.String)
	}
}

type UnionWithLiteralVisitor interface {
	VisitStringLiteral(string) error
	VisitString(string) error
}

func (u *UnionWithLiteral) Accept(visitor UnionWithLiteralVisitor) error {
	switch u.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "stringLiteral":
		return visitor.VisitStringLiteral(u.stringLiteral)
	case "string":
		return visitor.VisitString(u.String)
	}
}
