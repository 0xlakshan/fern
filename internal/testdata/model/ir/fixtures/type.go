// Generated by Fern. Do not edit.

package ir

import (
	json "encoding/json"
	fmt "fmt"
)

type Type struct {
	Type                 string
	Alias                *AliasTypeDeclaration
	Enum                 *EnumTypeDeclaration
	Object               *ObjectTypeDeclaration
	Union                *UnionTypeDeclaration
	UndiscriminatedUnion *UndiscriminatedUnionTypeDeclaration
}

func NewTypeFromAlias(value *AliasTypeDeclaration) *Type {
	return &Type{Type: "alias", Alias: value}
}

func NewTypeFromEnum(value *EnumTypeDeclaration) *Type {
	return &Type{Type: "enum", Enum: value}
}

func NewTypeFromObject(value *ObjectTypeDeclaration) *Type {
	return &Type{Type: "object", Object: value}
}

func NewTypeFromUnion(value *UnionTypeDeclaration) *Type {
	return &Type{Type: "union", Union: value}
}

func NewTypeFromUndiscriminatedUnion(value *UndiscriminatedUnionTypeDeclaration) *Type {
	return &Type{Type: "undiscriminatedUnion", UndiscriminatedUnion: value}
}

func (t *Type) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"_type,omitempty"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "alias":
		value := new(AliasTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Alias = value
	case "enum":
		value := new(EnumTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Enum = value
	case "object":
		value := new(ObjectTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Object = value
	case "union":
		value := new(UnionTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Union = value
	case "undiscriminatedUnion":
		value := new(UndiscriminatedUnionTypeDeclaration)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.UndiscriminatedUnion = value
	}
	return nil
}

func (t Type) MarshalJSON() ([]byte, error) {
	switch t.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.Type, t)
	case "alias":
		var marshaler = struct {
			Type string `json:"_type,omitempty"`
			*AliasTypeDeclaration
		}{
			Type:                 t.Type,
			AliasTypeDeclaration: t.Alias,
		}
		return json.Marshal(marshaler)
	case "enum":
		var marshaler = struct {
			Type string `json:"_type,omitempty"`
			*EnumTypeDeclaration
		}{
			Type:                t.Type,
			EnumTypeDeclaration: t.Enum,
		}
		return json.Marshal(marshaler)
	case "object":
		var marshaler = struct {
			Type string `json:"_type,omitempty"`
			*ObjectTypeDeclaration
		}{
			Type:                  t.Type,
			ObjectTypeDeclaration: t.Object,
		}
		return json.Marshal(marshaler)
	case "union":
		var marshaler = struct {
			Type string `json:"_type,omitempty"`
			*UnionTypeDeclaration
		}{
			Type:                 t.Type,
			UnionTypeDeclaration: t.Union,
		}
		return json.Marshal(marshaler)
	case "undiscriminatedUnion":
		var marshaler = struct {
			Type string `json:"_type,omitempty"`
			*UndiscriminatedUnionTypeDeclaration
		}{
			Type:                                t.Type,
			UndiscriminatedUnionTypeDeclaration: t.UndiscriminatedUnion,
		}
		return json.Marshal(marshaler)
	}
}

type TypeVisitor interface {
	VisitAlias(*AliasTypeDeclaration) error
	VisitEnum(*EnumTypeDeclaration) error
	VisitObject(*ObjectTypeDeclaration) error
	VisitUnion(*UnionTypeDeclaration) error
	VisitUndiscriminatedUnion(*UndiscriminatedUnionTypeDeclaration) error
}

func (t *Type) Accept(v TypeVisitor) error {
	switch t.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", t.Type, t)
	case "alias":
		return v.VisitAlias(t.Alias)
	case "enum":
		return v.VisitEnum(t.Enum)
	case "object":
		return v.VisitObject(t.Object)
	case "union":
		return v.VisitUnion(t.Union)
	case "undiscriminatedUnion":
		return v.VisitUndiscriminatedUnion(t.UndiscriminatedUnion)
	}
}
