// Generated by Fern. Do not edit.

package api

import (
	context "context"
	json "encoding/json"
	errors "errors"
	fmt "fmt"
	core "github.com/fern-api/fern-go/internal/testdata/sdk/post-with-path-params/fixtures/core"
	io "io"
	http "net/http"
)

type getFooEndpoint struct {
	url        string
	httpClient core.HTTPClient
	header     http.Header
}

func newGetFooEndpoint(url string, httpClient core.HTTPClient, clientOptions *core.ClientOptions) *getFooEndpoint {
	return &getFooEndpoint{
		url:        url,
		httpClient: httpClient,
		header:     clientOptions.ToHeader(),
	}
}

func (g *getFooEndpoint) decodeError(statusCode int, body io.Reader) error {
	bytes, err := io.ReadAll(body)
	if err != nil {
		return err
	}
	return errors.New(string(bytes))
}

func (g *getFooEndpoint) Call(ctx context.Context) ([]*Foo, error) {
	endpointURL := g.url
	var response []*Foo
	if err := core.DoRequest(
		ctx,
		g.httpClient,
		endpointURL,
		http.MethodGet,
		nil,
		response,
		g.header,
		g.decodeError,
	); err != nil {
		return response, err
	}
	return response, nil
}

type postFooEndpoint struct {
	url        string
	httpClient core.HTTPClient
	header     http.Header
}

func newPostFooEndpoint(url string, httpClient core.HTTPClient, clientOptions *core.ClientOptions) *postFooEndpoint {
	return &postFooEndpoint{
		url:        url,
		httpClient: httpClient,
		header:     clientOptions.ToHeader(),
	}
}

func (p *postFooEndpoint) decodeError(statusCode int, body io.Reader) error {
	decoder := json.NewDecoder(body)
	switch statusCode {
	case 409:
		value := new(ConflictError)
		if err := decoder.Decode(value); err != nil {
			return err
		}
		value.StatusCode = statusCode
		return value
	case 422:
		value := new(UnprocessableEntityError)
		if err := decoder.Decode(value); err != nil {
			return err
		}
		value.StatusCode = statusCode
		return value
	}
	bytes, err := io.ReadAll(body)
	if err != nil {
		return err
	}
	return errors.New(string(bytes))
}

func (p *postFooEndpoint) Call(ctx context.Context, request *Bar) (*Foo, error) {
	endpointURL := p.url
	response := new(Foo)
	if err := core.DoRequest(
		ctx,
		p.httpClient,
		endpointURL,
		http.MethodPost,
		request,
		response,
		p.header,
		p.decodeError,
	); err != nil {
		return response, err
	}
	return response, nil
}

type getFooFooIdEndpoint struct {
	url        string
	httpClient core.HTTPClient
	header     http.Header
}

func newGetFooFooIdEndpoint(url string, httpClient core.HTTPClient, clientOptions *core.ClientOptions) *getFooFooIdEndpoint {
	return &getFooFooIdEndpoint{
		url:        url,
		httpClient: httpClient,
		header:     clientOptions.ToHeader(),
	}
}

func (g *getFooFooIdEndpoint) decodeError(statusCode int, body io.Reader) error {
	decoder := json.NewDecoder(body)
	switch statusCode {
	case 404:
		value := new(NotFoundError)
		if err := decoder.Decode(value); err != nil {
			return err
		}
		value.StatusCode = statusCode
		return value
	}
	bytes, err := io.ReadAll(body)
	if err != nil {
		return err
	}
	return errors.New(string(bytes))
}

func (g *getFooFooIdEndpoint) Call(ctx context.Context, fooId Id) (*Foo, error) {
	endpointURL := fmt.Sprintf(g.url, fooId)
	response := new(Foo)
	if err := core.DoRequest(
		ctx,
		g.httpClient,
		endpointURL,
		http.MethodGet,
		nil,
		response,
		g.header,
		g.decodeError,
	); err != nil {
		return response, err
	}
	return response, nil
}

type patchFooFooIdEndpoint struct {
	url        string
	httpClient core.HTTPClient
	header     http.Header
}

func newPatchFooFooIdEndpoint(url string, httpClient core.HTTPClient, clientOptions *core.ClientOptions) *patchFooFooIdEndpoint {
	return &patchFooFooIdEndpoint{
		url:        url,
		httpClient: httpClient,
		header:     clientOptions.ToHeader(),
	}
}

func (p *patchFooFooIdEndpoint) decodeError(statusCode int, body io.Reader) error {
	decoder := json.NewDecoder(body)
	switch statusCode {
	case 404:
		value := new(NotFoundError)
		if err := decoder.Decode(value); err != nil {
			return err
		}
		value.StatusCode = statusCode
		return value
	case 409:
		value := new(ConflictError)
		if err := decoder.Decode(value); err != nil {
			return err
		}
		value.StatusCode = statusCode
		return value
	case 422:
		value := new(UnprocessableEntityError)
		if err := decoder.Decode(value); err != nil {
			return err
		}
		value.StatusCode = statusCode
		return value
	}
	bytes, err := io.ReadAll(body)
	if err != nil {
		return err
	}
	return errors.New(string(bytes))
}

func (p *patchFooFooIdEndpoint) Call(ctx context.Context, fooId Id, request *Foo) (*Foo, error) {
	endpointURL := fmt.Sprintf(p.url, fooId)
	response := new(Foo)
	if err := core.DoRequest(
		ctx,
		p.httpClient,
		endpointURL,
		http.MethodPatch,
		request,
		response,
		p.header,
		p.decodeError,
	); err != nil {
		return response, err
	}
	return response, nil
}

type deleteFooFooIdEndpoint struct {
	url        string
	httpClient core.HTTPClient
	header     http.Header
}

func newDeleteFooFooIdEndpoint(url string, httpClient core.HTTPClient, clientOptions *core.ClientOptions) *deleteFooFooIdEndpoint {
	return &deleteFooFooIdEndpoint{
		url:        url,
		httpClient: httpClient,
		header:     clientOptions.ToHeader(),
	}
}

func (d *deleteFooFooIdEndpoint) decodeError(statusCode int, body io.Reader) error {
	decoder := json.NewDecoder(body)
	switch statusCode {
	case 404:
		value := new(NotFoundError)
		if err := decoder.Decode(value); err != nil {
			return err
		}
		value.StatusCode = statusCode
		return value
	}
	bytes, err := io.ReadAll(body)
	if err != nil {
		return err
	}
	return errors.New(string(bytes))
}

func (d *deleteFooFooIdEndpoint) Call(ctx context.Context, fooId Id) error {
	endpointURL := fmt.Sprintf(d.url, fooId)
	if err := core.DoRequest(
		ctx,
		d.httpClient,
		endpointURL,
		http.MethodDelete,
		nil,
		nil,
		d.header,
		d.decodeError,
	); err != nil {
		return err
	}
	return nil
}

type postFooFooIdRunEndpoint struct {
	url        string
	httpClient core.HTTPClient
	header     http.Header
}

func newPostFooFooIdRunEndpoint(url string, httpClient core.HTTPClient, clientOptions *core.ClientOptions) *postFooFooIdRunEndpoint {
	return &postFooFooIdRunEndpoint{
		url:        url,
		httpClient: httpClient,
		header:     clientOptions.ToHeader(),
	}
}

func (p *postFooFooIdRunEndpoint) decodeError(statusCode int, body io.Reader) error {
	decoder := json.NewDecoder(body)
	switch statusCode {
	case 404:
		value := new(NotFoundError)
		if err := decoder.Decode(value); err != nil {
			return err
		}
		value.StatusCode = statusCode
		return value
	case 409:
		value := new(ConflictError)
		if err := decoder.Decode(value); err != nil {
			return err
		}
		value.StatusCode = statusCode
		return value
	}
	bytes, err := io.ReadAll(body)
	if err != nil {
		return err
	}
	return errors.New(string(bytes))
}

func (p *postFooFooIdRunEndpoint) Call(ctx context.Context, fooId Id) (*Foo, error) {
	endpointURL := fmt.Sprintf(p.url, fooId)
	response := new(Foo)
	if err := core.DoRequest(
		ctx,
		p.httpClient,
		endpointURL,
		http.MethodPost,
		nil,
		response,
		p.header,
		p.decodeError,
	); err != nil {
		return response, err
	}
	return response, nil
}

type postFooBatchCreateEndpoint struct {
	url        string
	httpClient core.HTTPClient
	header     http.Header
}

func newPostFooBatchCreateEndpoint(url string, httpClient core.HTTPClient, clientOptions *core.ClientOptions) *postFooBatchCreateEndpoint {
	return &postFooBatchCreateEndpoint{
		url:        url,
		httpClient: httpClient,
		header:     clientOptions.ToHeader(),
	}
}

func (p *postFooBatchCreateEndpoint) decodeError(statusCode int, body io.Reader) error {
	decoder := json.NewDecoder(body)
	switch statusCode {
	case 404:
		value := new(NotFoundError)
		if err := decoder.Decode(value); err != nil {
			return err
		}
		value.StatusCode = statusCode
		return value
	case 409:
		value := new(ConflictError)
		if err := decoder.Decode(value); err != nil {
			return err
		}
		value.StatusCode = statusCode
		return value
	case 413:
		value := new(ContentTooLargeError)
		if err := decoder.Decode(value); err != nil {
			return err
		}
		value.StatusCode = statusCode
		return value
	case 422:
		value := new(UnprocessableEntityError)
		if err := decoder.Decode(value); err != nil {
			return err
		}
		value.StatusCode = statusCode
		return value
	}
	bytes, err := io.ReadAll(body)
	if err != nil {
		return err
	}
	return errors.New(string(bytes))
}

func (p *postFooBatchCreateEndpoint) Call(ctx context.Context, request []*Bar) ([]*Foo, error) {
	endpointURL := p.url
	var response []*Foo
	if err := core.DoRequest(
		ctx,
		p.httpClient,
		endpointURL,
		http.MethodPost,
		request,
		response,
		p.header,
		p.decodeError,
	); err != nil {
		return response, err
	}
	return response, nil
}

type postFooBatchDeleteEndpoint struct {
	url        string
	httpClient core.HTTPClient
	header     http.Header
}

func newPostFooBatchDeleteEndpoint(url string, httpClient core.HTTPClient, clientOptions *core.ClientOptions) *postFooBatchDeleteEndpoint {
	return &postFooBatchDeleteEndpoint{
		url:        url,
		httpClient: httpClient,
		header:     clientOptions.ToHeader(),
	}
}

func (p *postFooBatchDeleteEndpoint) decodeError(statusCode int, body io.Reader) error {
	decoder := json.NewDecoder(body)
	switch statusCode {
	case 404:
		value := new(NotFoundError)
		if err := decoder.Decode(value); err != nil {
			return err
		}
		value.StatusCode = statusCode
		return value
	case 413:
		value := new(ContentTooLargeError)
		if err := decoder.Decode(value); err != nil {
			return err
		}
		value.StatusCode = statusCode
		return value
	}
	bytes, err := io.ReadAll(body)
	if err != nil {
		return err
	}
	return errors.New(string(bytes))
}

func (p *postFooBatchDeleteEndpoint) Call(ctx context.Context, request []Id) error {
	endpointURL := p.url
	if err := core.DoRequest(
		ctx,
		p.httpClient,
		endpointURL,
		http.MethodPost,
		request,
		nil,
		p.header,
		p.decodeError,
	); err != nil {
		return err
	}
	return nil
}

type Service interface {
	GetFoo(ctx context.Context) ([]*Foo, error)
	PostFoo(ctx context.Context, request *Bar) (*Foo, error)
	GetFooFooId(ctx context.Context, fooId Id) (*Foo, error)
	PatchFooFooId(ctx context.Context, fooId Id, request *Foo) (*Foo, error)
	DeleteFooFooId(ctx context.Context, fooId Id) error
	PostFooFooIdRun(ctx context.Context, fooId Id) (*Foo, error)
	PostFooBatchCreate(ctx context.Context, request []*Bar) ([]*Foo, error)
	PostFooBatchDelete(ctx context.Context, request []Id) error
}

func NewClient(baseURL string, httpClient core.HTTPClient, opts ...core.ClientOption) (Service, error) {
	options := new(core.ClientOptions)
	for _, opt := range opts {
		opt(options)
	}
	return &client{
		getFoo:             newGetFooEndpoint(baseURL, httpClient, options).Call,
		postFoo:            newPostFooEndpoint(baseURL, httpClient, options).Call,
		getFooFooId:        newGetFooFooIdEndpoint(baseURL, httpClient, options).Call,
		patchFooFooId:      newPatchFooFooIdEndpoint(baseURL, httpClient, options).Call,
		deleteFooFooId:     newDeleteFooFooIdEndpoint(baseURL, httpClient, options).Call,
		postFooFooIdRun:    newPostFooFooIdRunEndpoint(baseURL, httpClient, options).Call,
		postFooBatchCreate: newPostFooBatchCreateEndpoint(baseURL, httpClient, options).Call,
		postFooBatchDelete: newPostFooBatchDeleteEndpoint(baseURL, httpClient, options).Call,
	}, nil
}

type client struct {
	getFoo             func(ctx context.Context) ([]*Foo, error)
	postFoo            func(ctx context.Context, request *Bar) (*Foo, error)
	getFooFooId        func(ctx context.Context, fooId Id) (*Foo, error)
	patchFooFooId      func(ctx context.Context, fooId Id, request *Foo) (*Foo, error)
	deleteFooFooId     func(ctx context.Context, fooId Id) error
	postFooFooIdRun    func(ctx context.Context, fooId Id) (*Foo, error)
	postFooBatchCreate func(ctx context.Context, request []*Bar) ([]*Foo, error)
	postFooBatchDelete func(ctx context.Context, request []Id) error
}

func (g *client) GetFoo(ctx context.Context) ([]*Foo, error) {
	return g.getFoo(ctx)
}

func (p *client) PostFoo(ctx context.Context, request *Bar) (*Foo, error) {
	return p.postFoo(ctx, request)
}

func (g *client) GetFooFooId(ctx context.Context, fooId Id) (*Foo, error) {
	return g.getFooFooId(ctx, fooId)
}

func (p *client) PatchFooFooId(ctx context.Context, fooId Id, request *Foo) (*Foo, error) {
	return p.patchFooFooId(ctx, fooId, request)
}

func (d *client) DeleteFooFooId(ctx context.Context, fooId Id) error {
	return d.deleteFooFooId(ctx, fooId)
}

func (p *client) PostFooFooIdRun(ctx context.Context, fooId Id) (*Foo, error) {
	return p.postFooFooIdRun(ctx, fooId)
}

func (p *client) PostFooBatchCreate(ctx context.Context, request []*Bar) ([]*Foo, error) {
	return p.postFooBatchCreate(ctx, request)
}

func (p *client) PostFooBatchDelete(ctx context.Context, request []Id) error {
	return p.postFooBatchDelete(ctx, request)
}
