// Generated by Fern. Do not edit.

package api

import (
	json "encoding/json"
	fmt "fmt"
)

type Union struct {
	typeName         string
	Foo              *Foo
	Bar              *Bar
	Baz              *Baz
	String           string
	IntegerOptional  *int
	StringBooleanMap map[string]bool
	StringList       []string
	StringListList   [][]string
	DoubleSet        []float64
	stringLiteral    string
}

func (x *Union) StringLiteral() string {
	return x.stringLiteral
}

func (x *Union) UnmarshalJSON(data []byte) error {
	valueFoo := new(Foo)
	if err := json.Unmarshal(data, &valueFoo); err == nil {
		x.typeName = "foo"
		x.Foo = valueFoo
		return nil
	}
	valueBar := new(Bar)
	if err := json.Unmarshal(data, &valueBar); err == nil {
		x.typeName = "bar"
		x.Bar = valueBar
		return nil
	}
	valueBaz := new(Baz)
	if err := json.Unmarshal(data, &valueBaz); err == nil {
		x.typeName = "baz"
		x.Baz = valueBaz
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		x.typeName = "string"
		x.String = valueString
		return nil
	}
	var valueIntegerOptional *int
	if err := json.Unmarshal(data, &valueIntegerOptional); err == nil {
		x.typeName = "integerOptional"
		x.IntegerOptional = valueIntegerOptional
		return nil
	}
	var valueStringBooleanMap map[string]bool
	if err := json.Unmarshal(data, &valueStringBooleanMap); err == nil {
		x.typeName = "stringBooleanMap"
		x.StringBooleanMap = valueStringBooleanMap
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		x.typeName = "stringList"
		x.StringList = valueStringList
		return nil
	}
	var valueStringListList [][]string
	if err := json.Unmarshal(data, &valueStringListList); err == nil {
		x.typeName = "stringListList"
		x.StringListList = valueStringListList
		return nil
	}
	var valueDoubleSet []float64
	if err := json.Unmarshal(data, &valueDoubleSet); err == nil {
		x.typeName = "doubleSet"
		x.DoubleSet = valueDoubleSet
		return nil
	}
	var valueStringLiteral string
	if err := json.Unmarshal(data, &valueStringLiteral); err == nil {
		if valueStringLiteral == "fern" {
			x.typeName = "stringLiteral"
			x.stringLiteral = valueStringLiteral
			return nil
		}
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, x)
}

func (x Union) MarshalJSON() ([]byte, error) {
	switch x.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", x.typeName, x)
	case "foo":
		return json.Marshal(x.Foo)
	case "bar":
		return json.Marshal(x.Bar)
	case "baz":
		return json.Marshal(x.Baz)
	case "string":
		return json.Marshal(x.String)
	case "integerOptional":
		return json.Marshal(x.IntegerOptional)
	case "stringBooleanMap":
		return json.Marshal(x.StringBooleanMap)
	case "stringList":
		return json.Marshal(x.StringList)
	case "stringListList":
		return json.Marshal(x.StringListList)
	case "doubleSet":
		return json.Marshal(x.DoubleSet)
	case "stringLiteral":
		return json.Marshal("fern")
	}
}

type UnionVisitor interface {
	VisitFoo(*Foo) error
	VisitBar(*Bar) error
	VisitBaz(*Baz) error
	VisitString(string) error
	VisitIntegerOptional(*int) error
	VisitStringBooleanMap(map[string]bool) error
	VisitStringList([]string) error
	VisitStringListList([][]string) error
	VisitDoubleSet([]float64) error
	VisitStringLiteral(string) error
}

func (x *Union) Accept(v UnionVisitor) error {
	switch x.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", x.typeName, x)
	case "foo":
		return v.VisitFoo(x.Foo)
	case "bar":
		return v.VisitBar(x.Bar)
	case "baz":
		return v.VisitBaz(x.Baz)
	case "string":
		return v.VisitString(x.String)
	case "integerOptional":
		return v.VisitIntegerOptional(x.IntegerOptional)
	case "stringBooleanMap":
		return v.VisitStringBooleanMap(x.StringBooleanMap)
	case "stringList":
		return v.VisitStringList(x.StringList)
	case "stringListList":
		return v.VisitStringListList(x.StringListList)
	case "doubleSet":
		return v.VisitDoubleSet(x.DoubleSet)
	case "stringLiteral":
		return v.VisitStringLiteral(x.stringLiteral)
	}
}
