// Generated by Fern. Do not edit.

package api

import (
	json "encoding/json"
	fmt "fmt"
)

type AnotherUnion struct {
	typeName      string
	String        string
	stringLiteral string
	Foo           *Foo
}

func (x *AnotherUnion) StringLiteral() string {
	return x.stringLiteral
}

func (x *AnotherUnion) UnmarshalJSON(data []byte) error {
	var String string
	if err := json.Unmarshal(data, &String); err == nil {
		x.typeName = "String"
		x.String = String
		return nil
	}
	// A literal value will always succeed, so we don't bother
	// to unmarshal the remaining undiscriminated union values.
	x.typeName = "stringLiteral"
	x.stringLiteral = "fern"
	return nil
}

func (x AnotherUnion) MarshalJSON() ([]byte, error) {
	switch x.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", x.typeName, x)
	case "String":
		return json.Marshal(x.String)
	case "stringLiteral":
		return json.Marshal("fern")
	case "Foo":
		return json.Marshal(x.Foo)
	}
}

type AnotherUnionVisitor interface {
	VisitString(string) error
	VisitStringLiteral(string) error
	VisitFoo(*Foo) error
}

func (x *AnotherUnion) Accept(v AnotherUnionVisitor) error {
	switch x.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", x.typeName, x)
	case "String":
		return v.VisitString(x.String)
	case "stringLiteral":
		return v.VisitStringLiteral(x.stringLiteral)
	case "Foo":
		return v.VisitFoo(x.Foo)
	}
}
