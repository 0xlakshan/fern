// This file was auto-generated by Fern from our API Definition.

package ir

import (
	json "encoding/json"
	fmt "fmt"
)

type HttpResponse struct {
	Type         string
	Json         *JsonResponse
	FileDownload *FileDownloadResponse
	Streaming    *StreamingResponse
}

func NewHttpResponseFromJson(value *JsonResponse) *HttpResponse {
	return &HttpResponse{Type: "json", Json: value}
}

func NewHttpResponseFromFileDownload(value *FileDownloadResponse) *HttpResponse {
	return &HttpResponse{Type: "fileDownload", FileDownload: value}
}

func NewHttpResponseFromStreaming(value *StreamingResponse) *HttpResponse {
	return &HttpResponse{Type: "streaming", Streaming: value}
}

func (h *HttpResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	h.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "json":
		value := new(JsonResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.Json = value
	case "fileDownload":
		value := new(FileDownloadResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.FileDownload = value
	case "streaming":
		value := new(StreamingResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.Streaming = value
	}
	return nil
}

func (h HttpResponse) MarshalJSON() ([]byte, error) {
	switch h.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", h.Type, h)
	case "json":
		var marshaler = struct {
			Type string `json:"type"`
			*JsonResponse
		}{
			Type:         h.Type,
			JsonResponse: h.Json,
		}
		return json.Marshal(marshaler)
	case "fileDownload":
		var marshaler = struct {
			Type string `json:"type"`
			*FileDownloadResponse
		}{
			Type:                 h.Type,
			FileDownloadResponse: h.FileDownload,
		}
		return json.Marshal(marshaler)
	case "streaming":
		var marshaler = struct {
			Type string `json:"type"`
			*StreamingResponse
		}{
			Type:              h.Type,
			StreamingResponse: h.Streaming,
		}
		return json.Marshal(marshaler)
	}
}

type HttpResponseVisitor interface {
	VisitJson(*JsonResponse) error
	VisitFileDownload(*FileDownloadResponse) error
	VisitStreaming(*StreamingResponse) error
}

func (h *HttpResponse) Accept(v HttpResponseVisitor) error {
	switch h.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", h.Type, h)
	case "json":
		return v.VisitJson(h.Json)
	case "fileDownload":
		return v.VisitFileDownload(h.FileDownload)
	case "streaming":
		return v.VisitStreaming(h.Streaming)
	}
}
