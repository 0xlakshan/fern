package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"go/parser"
	"go/token"
	"path"
	"strconv"
	"strings"

	"github.com/fern-api/fern-go/internal/coordinator"
	"github.com/fern-api/fern-go/internal/fern/ir"
	"golang.org/x/tools/go/ast/astutil"
)

// fileHeader is the comment included in every generated Go file.
const fileHeader = `// This file was auto-generated by Fern from our API Definition.

`

// fileWriter wries and formats Go files.
type fileWriter struct {
	filename       string
	packageName    string
	baseImportPath string
	imports        imports
	types          map[ir.TypeId]*ir.TypeDeclaration
	errors         map[ir.ErrorId]*ir.ErrorDeclaration
	buffer         *bytes.Buffer

	coordinator *coordinator.Client
}

func newFileWriter(
	filename string,
	packageName string,
	baseImportPath string,
	types map[ir.TypeId]*ir.TypeDeclaration,
	errors map[ir.ErrorId]*ir.ErrorDeclaration,
	coordinator *coordinator.Client,
) *fileWriter {
	// The default set of imports used in the generated output.
	// These imports are removed from the generated output if
	// they aren't used.
	imports := make(imports)
	imports.Add("bytes")
	imports.Add("context")
	imports.Add("encoding/base64")
	imports.Add("encoding/json")
	imports.Add("errors")
	imports.Add("fmt")
	imports.Add("io")
	imports.Add("mime/multipart")
	imports.Add("net/http")
	imports.Add("net/url")
	imports.Add("strconv")
	imports.Add("strings")
	imports.Add("time")

	// Add an import to the core utilities package generated for
	// the SDK.
	imports.Add(path.Join(baseImportPath, "core"))

	// Manually specify the UUID path so that we can use
	// the uuid alias.
	imports["github.com/gofrs/uuid/v5"] = "uuid"

	return &fileWriter{
		filename:       filename,
		packageName:    packageName,
		baseImportPath: baseImportPath,
		imports:        imports,
		types:          types,
		errors:         errors,
		buffer:         new(bytes.Buffer),
		coordinator:    coordinator,
	}
}

// P writes the given element into a single line, concluding with a newline.
func (f *fileWriter) P(elements ...any) {
	for _, element := range elements {
		fmt.Fprint(f.buffer, element)
	}
	fmt.Fprintln(f.buffer)
}

// File formats and writes the content stored in the writer's buffer into a *File.
func (f *fileWriter) File() (*File, error) {
	// Start with the package declaration and import statements.
	header := newFileWriter(f.filename, f.packageName, f.baseImportPath, f.types, f.errors, f.coordinator)
	header.P(fileHeader)
	header.P("package ", f.packageName)
	header.P("import (")
	for importDecl, importAlias := range f.imports {
		header.P(fmt.Sprintf("%s %q", importAlias, importDecl))
	}
	header.P(")")

	formatted, err := removeUnusedImports(f.filename, append(header.buffer.Bytes(), f.buffer.Bytes()...))
	if err != nil {
		return nil, err
	}

	return NewFile(f.coordinator, f.filename, formatted), nil
}

// DocsFile acts like File, but is tailored to write docs.go files.
func (f *fileWriter) DocsFile() *File {
	f.P("package ", f.packageName)
	return NewFile(f.coordinator, f.filename, append([]byte(fileHeader), f.buffer.Bytes()...))
}

// WriteDocs is a convenience function to writes the given documentation, if any.
// This prevents us from having to perform a nil check and length check at every
// call site.
func (f *fileWriter) WriteDocs(docs *string) {
	if docs == nil || len(*docs) == 0 {
		return
	}
	split := strings.Split(*docs, "\n")
	for _, line := range split {
		f.P("// " + line)
	}
}

// removeUnusedImports parses the buffer, interpreting it as Go code,
// and removes all unused imports. If successful, the result is then
// formatted.
func removeUnusedImports(filename string, buf []byte) ([]byte, error) {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, filename, buf, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("failed to parse Go code: %v", err)
	}

	imports := make(map[string]string)
	for _, route := range f.Imports {
		importPath, err := strconv.Unquote(route.Path.Value)
		if err != nil {
			// Unreachable. If the file parsed successfully,
			// the unquote will never fail.
			return nil, err
		}
		imports[route.Name.Name] = importPath
	}

	for name, path := range imports {
		if !astutil.UsesImport(f, path) {
			astutil.DeleteNamedImport(fset, f, name, path)
		}
	}

	var buffer bytes.Buffer
	if err := format.Node(&buffer, fset, f); err != nil {
		return nil, fmt.Errorf("failed to format Go code: %v", err)
	}

	return buffer.Bytes(), nil
}
